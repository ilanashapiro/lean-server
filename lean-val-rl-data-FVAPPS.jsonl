{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a permutation $p=[p_1, p_2, \\ldots, p_n]$ of integers from $1$ to $n$. Let's call the number $m$ ($1 \\le m \\le n$) beautiful, if there exists two indices $l, r$ ($1 \\le l \\le r \\le n$), such that the numbers $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$.\n\nFor example, let $p = [4, 5, 1, 3, 2, 6]$. In this case, the numbers $1, 3, 5, 6$ are beautiful and $2, 4$ are not. It is because:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 5$ we will have a permutation $[1, 3, 2]$ for $m = 3$;  if $l = 1$ and $r = 5$ we will have a permutation $[4, 5, 1, 3, 2]$ for $m = 5$;  if $l = 1$ and $r = 6$ we will have a permutation $[4, 5, 1, 3, 2, 6]$ for $m = 6$;  it is impossible to take some $l$ and $r$, such that $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$ for $m = 2$ and for $m = 4$. \n\nYou are given a permutation $p=[p_1, p_2, \\ldots, p_n]$. For all $m$ ($1 \\le m \\le n$) determine if it is a beautiful number or not.\n\n\n-----Input-----\n\nThe first line contains the only integer $t$ ($1 \\le t \\le 1000$)  — the number of test cases in the input. The next lines contain the description of test cases.\n\nThe first line of a test case contains a number $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the given permutation $p$. The next line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le n$, all $p_i$ are different) — the given permutation $p$.\n\nIt is guaranteed, that the sum of $n$ from all test cases in the input doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $t$ lines — the answers to test cases in the order they are given in the input. \n\nThe answer to a test case is the string of length $n$, there the $i$-th character is equal to $1$ if $i$ is a beautiful number and is equal to $0$ if $i$ is not a beautiful number.\n\n\n-----Example-----\nInput\n3\n6\n4 5 1 3 2 6\n5\n5 3 1 2 4\n4\n1 4 3 2\n\nOutput\n101011\n11111\n1001\n\n\n\n-----Note-----\n\nThe first test case is described in the problem statement.\n\nIn the second test case all numbers from $1$ to $5$ are beautiful:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 4$ we will have a permutation $[1, 2]$ for $m = 2$;  if $l = 2$ and $r = 4$ we will have a permutation $[3, 1, 2]$ for $m = 3$;  if $l = 2$ and $r = 5$ we will have a permutation $[3, 1, 2, 4]$ for $m = 4$;  if $l = 1$ and $r = 5$ we will have a permutation $[5, 3, 1, 2, 4]$ for $m = 5$.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_beautiful_permutation (nums : List Nat) : List Nat := sorry\n\ntheorem solve_first_pos_beautiful (nums : List Nat) \n  (h : nums.length = 5) \n  (h2 : nums.Perm [1,2,3,4,5]) : \n  (solve_beautiful_permutation nums).get! 0 = 1 := sorry\n\ntheorem solve_preserves_length (nums : List Nat)  \n  (h : nums.length = 5)\n  (h2 : nums.Perm [1,2,3,4,5]) :\n  (solve_beautiful_permutation nums).length = nums.length := sorry \n\ntheorem solve_returns_binary (nums : List Nat)\n  (h : nums.length = 5)\n  (h2 : nums.Perm [1,2,3,4,5]) :\n  ∀ x ∈ solve_beautiful_permutation nums, x = 0 ∨ x = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0004", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a permutation $p=[p_1, p_2, \\ldots, p_n]$ of integers from $1$ to $n$. Let's call the number $m$ ($1 \\le m \\le n$) beautiful, if there exists two indices $l, r$ ($1 \\le l \\le r \\le n$), such that the numbers $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$.\n\nFor example, let $p = [4, 5, 1, 3, 2, 6]$. In this case, the numbers $1, 3, 5, 6$ are beautiful and $2, 4$ are not. It is because:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 5$ we will have a permutation $[1, 3, 2]$ for $m = 3$;  if $l = 1$ and $r = 5$ we will have a permutation $[4, 5, 1, 3, 2]$ for $m = 5$;  if $l = 1$ and $r = 6$ we will have a permutation $[4, 5, 1, 3, 2, 6]$ for $m = 6$;  it is impossible to take some $l$ and $r$, such that $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$ for $m = 2$ and for $m = 4$. \n\nYou are given a permutation $p=[p_1, p_2, \\ldots, p_n]$. For all $m$ ($1 \\le m \\le n$) determine if it is a beautiful number or not.\n\n\n-----Input-----\n\nThe first line contains the only integer $t$ ($1 \\le t \\le 1000$)  — the number of test cases in the input. The next lines contain the description of test cases.\n\nThe first line of a test case contains a number $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the given permutation $p$. The next line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le n$, all $p_i$ are different) — the given permutation $p$.\n\nIt is guaranteed, that the sum of $n$ from all test cases in the input doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $t$ lines — the answers to test cases in the order they are given in the input. \n\nThe answer to a test case is the string of length $n$, there the $i$-th character is equal to $1$ if $i$ is a beautiful number and is equal to $0$ if $i$ is not a beautiful number.\n\n\n-----Example-----\nInput\n3\n6\n4 5 1 3 2 6\n5\n5 3 1 2 4\n4\n1 4 3 2\n\nOutput\n101011\n11111\n1001\n\n\n\n-----Note-----\n\nThe first test case is described in the problem statement.\n\nIn the second test case all numbers from $1$ to $5$ are beautiful:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 4$ we will have a permutation $[1, 2]$ for $m = 2$;  if $l = 2$ and $r = 4$ we will have a permutation $[3, 1, 2]$ for $m = 3$;  if $l = 2$ and $r = 5$ we will have a permutation $[3, 1, 2, 4]$ for $m = 4$;  if $l = 1$ and $r = 5$ we will have a permutation $[5, 3, 1, 2, 4]$ for $m = 5$.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_beautiful_permutation (nums : List Nat) : List Nat := sorry\n\ntheorem solve_first_pos_beautiful (nums : List Nat) \n  (h : nums.length = 5) \n  (h2 : nums.Perm [1,2,3,4,5]) : \n  (solve_beautiful_permutation nums).get! 0 = 1 := sorry\n\ntheorem solve_preserves_length (nums : List Nat)  \n  (h : nums.length = 5)\n  (h2 : nums.Perm [1,2,3,4,5]) :\n  (solve_beautiful_permutation nums).length = nums.length := sorry \n\ntheorem solve_returns_binary (nums : List Nat)\n  (h : nums.length = 5)\n  (h2 : nums.Perm [1,2,3,4,5]) :\n  ∀ x ∈ solve_beautiful_permutation nums, x = 0 ∨ x = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0004"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a special jigsaw puzzle consisting of $n\\cdot m$ identical pieces. Every piece has three tabs and one blank, as pictured below. $\\{3$ \n\nThe jigsaw puzzle is considered solved if the following conditions hold:  The pieces are arranged into a grid with $n$ rows and $m$ columns.  For any two pieces that share an edge in the grid, a tab of one piece fits perfectly into a blank of the other piece. \n\nThrough rotation and translation of the pieces, determine if it is possible to solve the jigsaw puzzle.\n\n\n-----Input-----\n\nThe test consists of multiple test cases. The first line contains a single integer $t$ ($1\\le t\\le 1000$) — the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nEach test case contains two integers $n$ and $m$ ($1 \\le n,m \\le 10^5$).\n\n\n-----Output-----\n\nFor each test case output a single line containing \"YES\" if it is possible to solve the jigsaw puzzle, or \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n3\n1 3\n100000 100000\n2 2\n\nOutput\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nFor the first test case, this is an example solution:  [Image] \n\nFor the second test case, we can show that no solution exists.\n\nFor the third test case, this is an example solution: $\\left\\{\\begin{array}{l}{3} \\\\{3} \\end{array} \\right\\}$\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_jigsaw (n m : Nat) : Bool := sorry\n\ntheorem solve_jigsaw_symmetry (n m : Nat) :\n  solve_jigsaw n m = solve_jigsaw m n := sorry\n\ntheorem solve_jigsaw_one_row (n : Nat) : \n  solve_jigsaw 1 n = true := sorry\n\ntheorem solve_jigsaw_2x2 :\n  solve_jigsaw 2 2 = true := sorry\n\ntheorem solve_jigsaw_large_grids (n m : Nat) :\n  n ≥ 3 → m ≥ 3 → solve_jigsaw n m = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0026", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a special jigsaw puzzle consisting of $n\\cdot m$ identical pieces. Every piece has three tabs and one blank, as pictured below. $\\{3$ \n\nThe jigsaw puzzle is considered solved if the following conditions hold:  The pieces are arranged into a grid with $n$ rows and $m$ columns.  For any two pieces that share an edge in the grid, a tab of one piece fits perfectly into a blank of the other piece. \n\nThrough rotation and translation of the pieces, determine if it is possible to solve the jigsaw puzzle.\n\n\n-----Input-----\n\nThe test consists of multiple test cases. The first line contains a single integer $t$ ($1\\le t\\le 1000$) — the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nEach test case contains two integers $n$ and $m$ ($1 \\le n,m \\le 10^5$).\n\n\n-----Output-----\n\nFor each test case output a single line containing \"YES\" if it is possible to solve the jigsaw puzzle, or \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n3\n1 3\n100000 100000\n2 2\n\nOutput\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nFor the first test case, this is an example solution:  [Image] \n\nFor the second test case, we can show that no solution exists.\n\nFor the third test case, this is an example solution: $\\left\\{\\begin{array}{l}{3} \\\\{3} \\end{array} \\right\\}$\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_jigsaw (n m : Nat) : Bool := sorry\n\ntheorem solve_jigsaw_symmetry (n m : Nat) :\n  solve_jigsaw n m = solve_jigsaw m n := sorry\n\ntheorem solve_jigsaw_one_row (n : Nat) : \n  solve_jigsaw 1 n = true := sorry\n\ntheorem solve_jigsaw_2x2 :\n  solve_jigsaw 2 2 = true := sorry\n\ntheorem solve_jigsaw_large_grids (n m : Nat) :\n  n ≥ 3 → m ≥ 3 → solve_jigsaw n m = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0026"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGildong recently learned how to find the longest increasing subsequence (LIS) in $O(n\\log{n})$ time for a sequence of length $n$. He wants to test himself if he can implement it correctly, but he couldn't find any online judges that would do it (even though there are actually many of them). So instead he's going to make a quiz for you about making permutations of $n$ distinct integers between $1$ and $n$, inclusive, to test his code with your output.\n\nThe quiz is as follows.\n\nGildong provides a string of length $n-1$, consisting of characters '<' and '>' only. The $i$-th (1-indexed) character is the comparison result between the $i$-th element and the $i+1$-st element of the sequence. If the $i$-th character of the string is '<', then the $i$-th element of the sequence is less than the $i+1$-st element. If the $i$-th character of the string is '>', then the $i$-th element of the sequence is greater than the $i+1$-st element.\n\nHe wants you to find two possible sequences (not necessarily distinct) consisting of $n$ distinct integers between $1$ and $n$, inclusive, each satisfying the comparison results, where the length of the LIS of the first sequence is minimum possible, and the length of the LIS of the second sequence is maximum possible.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nEach test case contains exactly one line, consisting of an integer and a string consisting of characters '<' and '>' only. The integer is $n$ ($2 \\le n \\le 2 \\cdot 10^5$), the length of the permutation you need to find. The string is the comparison results explained in the description. The length of the string is $n-1$.\n\nIt is guaranteed that the sum of all $n$ in all test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print two lines with $n$ integers each. The first line is the sequence with the minimum length of the LIS, and the second line is the sequence with the maximum length of the LIS. If there are multiple answers, print any one of them. Each sequence should contain all integers between $1$ and $n$, inclusive, and should satisfy the comparison results.\n\nIt can be shown that at least one answer always exists.\n\n\n-----Example-----\nInput\n3\n3 <<\n7 >><>><\n5 >>><\n\nOutput\n1 2 3\n1 2 3\n5 4 3 7 2 1 6\n4 3 1 7 5 2 6\n4 3 2 1 5\n5 4 2 1 3\n\n\n\n-----Note-----\n\nIn the first case, $1$ $2$ $3$ is the only possible answer.\n\nIn the second case, the shortest length of the LIS is $2$, and the longest length of the LIS is $3$. In the example of the maximum LIS sequence, $4$ '$3$' $1$ $7$ '$5$' $2$ '$6$' can be one of the possible LIS.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_sequence (n : Nat) (comp_str : String) : (List Nat × List Nat) :=\n  sorry\n\ndef verifySequenceMatchesComparisons (seq : List Nat) (comps : List Char) : Bool :=\n  sorry\n\ntheorem sequence_length_matches_comparisons \n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  min_seq.length = n ∧ max_seq.length = n :=\nsorry\n\ntheorem sequences_follow_comparisons \n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  verifySequenceMatchesComparisons min_seq (comp_str.data) ∧\n  verifySequenceMatchesComparisons max_seq (comp_str.data) :=\nsorry\n\ntheorem sequences_use_consecutive_integers\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  ∀ k, k ≤ n → (k ∈ min_seq ↔ k ≤ n ∧ k > 0) ∧\n               (k ∈ max_seq ↔ k ≤ n ∧ k > 0) :=\nsorry\n\ntheorem single_value_edge_case \n  {n : Nat} :\n  n = 1 →\n  solve_sequence n \"\" = ([1], [1]) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0053", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGildong recently learned how to find the longest increasing subsequence (LIS) in $O(n\\log{n})$ time for a sequence of length $n$. He wants to test himself if he can implement it correctly, but he couldn't find any online judges that would do it (even though there are actually many of them). So instead he's going to make a quiz for you about making permutations of $n$ distinct integers between $1$ and $n$, inclusive, to test his code with your output.\n\nThe quiz is as follows.\n\nGildong provides a string of length $n-1$, consisting of characters '<' and '>' only. The $i$-th (1-indexed) character is the comparison result between the $i$-th element and the $i+1$-st element of the sequence. If the $i$-th character of the string is '<', then the $i$-th element of the sequence is less than the $i+1$-st element. If the $i$-th character of the string is '>', then the $i$-th element of the sequence is greater than the $i+1$-st element.\n\nHe wants you to find two possible sequences (not necessarily distinct) consisting of $n$ distinct integers between $1$ and $n$, inclusive, each satisfying the comparison results, where the length of the LIS of the first sequence is minimum possible, and the length of the LIS of the second sequence is maximum possible.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nEach test case contains exactly one line, consisting of an integer and a string consisting of characters '<' and '>' only. The integer is $n$ ($2 \\le n \\le 2 \\cdot 10^5$), the length of the permutation you need to find. The string is the comparison results explained in the description. The length of the string is $n-1$.\n\nIt is guaranteed that the sum of all $n$ in all test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print two lines with $n$ integers each. The first line is the sequence with the minimum length of the LIS, and the second line is the sequence with the maximum length of the LIS. If there are multiple answers, print any one of them. Each sequence should contain all integers between $1$ and $n$, inclusive, and should satisfy the comparison results.\n\nIt can be shown that at least one answer always exists.\n\n\n-----Example-----\nInput\n3\n3 <<\n7 >><>><\n5 >>><\n\nOutput\n1 2 3\n1 2 3\n5 4 3 7 2 1 6\n4 3 1 7 5 2 6\n4 3 2 1 5\n5 4 2 1 3\n\n\n\n-----Note-----\n\nIn the first case, $1$ $2$ $3$ is the only possible answer.\n\nIn the second case, the shortest length of the LIS is $2$, and the longest length of the LIS is $3$. In the example of the maximum LIS sequence, $4$ '$3$' $1$ $7$ '$5$' $2$ '$6$' can be one of the possible LIS.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_sequence (n : Nat) (comp_str : String) : (List Nat × List Nat) :=\n  sorry\n\ndef verifySequenceMatchesComparisons (seq : List Nat) (comps : List Char) : Bool :=\n  sorry\n\ntheorem sequence_length_matches_comparisons \n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  min_seq.length = n ∧ max_seq.length = n :=\nsorry\n\ntheorem sequences_follow_comparisons \n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  verifySequenceMatchesComparisons min_seq (comp_str.data) ∧\n  verifySequenceMatchesComparisons max_seq (comp_str.data) :=\nsorry\n\ntheorem sequences_use_consecutive_integers\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  ∀ k, k ≤ n → (k ∈ min_seq ↔ k ≤ n ∧ k > 0) ∧\n               (k ∈ max_seq ↔ k ≤ n ∧ k > 0) :=\nsorry\n\ntheorem single_value_edge_case \n  {n : Nat} :\n  n = 1 →\n  solve_sequence n \"\" = ([1], [1]) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0053"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou have a rectangular chocolate bar consisting of n × m single squares. You want to eat exactly k squares, so you may need to break the chocolate bar. \n\nIn one move you can break any single rectangular piece of chocolate in two rectangular pieces. You can break only by lines between squares: horizontally or vertically. The cost of breaking is equal to square of the break length.\n\nFor example, if you have a chocolate bar consisting of 2 × 3 unit squares then you can break it horizontally and get two 1 × 3 pieces (the cost of such breaking is 3^2 = 9), or you can break it vertically in two ways and get two pieces: 2 × 1 and 2 × 2 (the cost of such breaking is 2^2 = 4).\n\nFor several given values n, m and k find the minimum total cost of breaking. You can eat exactly k squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to k squares. The remaining n·m - k squares are not necessarily form a single rectangular piece.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer t (1 ≤ t ≤ 40910) — the number of values n, m and k to process.\n\nEach of the next t lines contains three integers n, m and k (1 ≤ n, m ≤ 30, 1 ≤ k ≤ min(n·m, 50)) — the dimensions of the chocolate bar and the number of squares you want to eat respectively.\n\n\n-----Output-----\n\nFor each n, m and k print the minimum total cost needed to break the chocolate bar, in order to make it possible to eat exactly k squares.\n\n\n-----Examples-----\nInput\n4\n2 2 1\n2 2 3\n2 2 2\n2 2 4\n\nOutput\n5\n5\n4\n0\n\n\n\n-----Note-----\n\nIn the first query of the sample one needs to perform two breaks:  to split 2 × 2 bar into two pieces of 2 × 1 (cost is 2^2 = 4),  to split the resulting 2 × 1 into two 1 × 1 pieces (cost is 1^2 = 1). \n\nIn the second query of the sample one wants to eat 3 unit squares. One can use exactly the same strategy as in the first query of the sample.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_min_chocolate_break_cost (n m k : Nat) : Nat :=\n  sorry\n\n\n\ntheorem zero_cost_for_exact_pieces (n m k : Nat)\n  (hn : n > 0) (hm : m > 0) (hk : k ≤ 25)\n  (h_exact : n * m = k) :\n  find_min_chocolate_break_cost n m k = 0 :=\nsorry \n\ntheorem zero_pieces_cost_nothing (n m k : Nat)\n  (hn : n > 0) (hm : m > 0)\n  (hk_zero : k = 0) :\n  find_min_chocolate_break_cost n m k = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0058", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou have a rectangular chocolate bar consisting of n × m single squares. You want to eat exactly k squares, so you may need to break the chocolate bar. \n\nIn one move you can break any single rectangular piece of chocolate in two rectangular pieces. You can break only by lines between squares: horizontally or vertically. The cost of breaking is equal to square of the break length.\n\nFor example, if you have a chocolate bar consisting of 2 × 3 unit squares then you can break it horizontally and get two 1 × 3 pieces (the cost of such breaking is 3^2 = 9), or you can break it vertically in two ways and get two pieces: 2 × 1 and 2 × 2 (the cost of such breaking is 2^2 = 4).\n\nFor several given values n, m and k find the minimum total cost of breaking. You can eat exactly k squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to k squares. The remaining n·m - k squares are not necessarily form a single rectangular piece.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer t (1 ≤ t ≤ 40910) — the number of values n, m and k to process.\n\nEach of the next t lines contains three integers n, m and k (1 ≤ n, m ≤ 30, 1 ≤ k ≤ min(n·m, 50)) — the dimensions of the chocolate bar and the number of squares you want to eat respectively.\n\n\n-----Output-----\n\nFor each n, m and k print the minimum total cost needed to break the chocolate bar, in order to make it possible to eat exactly k squares.\n\n\n-----Examples-----\nInput\n4\n2 2 1\n2 2 3\n2 2 2\n2 2 4\n\nOutput\n5\n5\n4\n0\n\n\n\n-----Note-----\n\nIn the first query of the sample one needs to perform two breaks:  to split 2 × 2 bar into two pieces of 2 × 1 (cost is 2^2 = 4),  to split the resulting 2 × 1 into two 1 × 1 pieces (cost is 1^2 = 1). \n\nIn the second query of the sample one wants to eat 3 unit squares. One can use exactly the same strategy as in the first query of the sample.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_min_chocolate_break_cost (n m k : Nat) : Nat :=\n  sorry\n\n\n\ntheorem zero_cost_for_exact_pieces (n m k : Nat)\n  (hn : n > 0) (hm : m > 0) (hk : k ≤ 25)\n  (h_exact : n * m = k) :\n  find_min_chocolate_break_cost n m k = 0 :=\nsorry \n\ntheorem zero_pieces_cost_nothing (n m k : Nat)\n  (hn : n > 0) (hm : m > 0)\n  (hk_zero : k = 0) :\n  find_min_chocolate_break_cost n m k = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0058"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a integer $n$ ($n > 0$). Find any integer $s$ which satisfies these conditions, or report that there are no such numbers:\n\nIn the decimal representation of $s$:   $s > 0$,  $s$ consists of $n$ digits,  no digit in $s$ equals $0$,  $s$ is not divisible by any of it's digits. \n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line of the input contains a single integer $t$ ($1 \\leq t \\leq 400$), the number of test cases. The next $t$ lines each describe a test case.\n\nEach test case contains one positive integer $n$ ($1 \\leq n \\leq 10^5$).\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print an integer $s$ which satisfies the conditions described above, or \"-1\" (without quotes), if no such number exists. If there are multiple possible solutions for $s$, print any solution.\n\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n-1\n57\n239\n6789\n\n\n\n-----Note-----\n\nIn the first test case, there are no possible solutions for $s$ consisting of one digit, because any such solution is divisible by itself.\n\nFor the second test case, the possible solutions are: $23$, $27$, $29$, $34$, $37$, $38$, $43$, $46$, $47$, $49$, $53$, $54$, $56$, $57$, $58$, $59$, $67$, $68$, $69$, $73$, $74$, $76$, $78$, $79$, $83$, $86$, $87$, $89$, $94$, $97$, and $98$.\n\nFor the third test case, one possible solution is $239$ because $239$ is not divisible by $2$, $3$ or $9$ and has three digits (none of which equals zero).\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_uneven_digit (n: Nat) : Int :=\nsorry\n\ntheorem solve_uneven_digit_one :\n  solve_uneven_digit 1 = -1 := by\n  sorry\n\ntheorem solve_uneven_digit_two :\n  solve_uneven_digit 2 = 23 := by\n  sorry\n\ntheorem solve_uneven_digit_positive (n: Nat) (h: n > 1) :\n  solve_uneven_digit n > 0 := by\n  sorry\n\ntheorem solve_uneven_digit_length (n: Nat) (h: n > 1) :\n  (toString (solve_uneven_digit n).natAbs).length = n := by\n  sorry\n\ntheorem solve_uneven_digit_no_zeros (n: Nat) (h: n > 1) :\n  ¬((toString (solve_uneven_digit n).natAbs).contains '0') := by\n  sorry\n\ntheorem solve_uneven_digit_not_divisible (n: Nat) (h: n > 1) (d: Char) :\n  d ∈ (toString (solve_uneven_digit n).natAbs).data →\n  ¬((solve_uneven_digit n).natAbs % (d.toNat - 48) = 0) := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0095", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a integer $n$ ($n > 0$). Find any integer $s$ which satisfies these conditions, or report that there are no such numbers:\n\nIn the decimal representation of $s$:   $s > 0$,  $s$ consists of $n$ digits,  no digit in $s$ equals $0$,  $s$ is not divisible by any of it's digits. \n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line of the input contains a single integer $t$ ($1 \\leq t \\leq 400$), the number of test cases. The next $t$ lines each describe a test case.\n\nEach test case contains one positive integer $n$ ($1 \\leq n \\leq 10^5$).\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print an integer $s$ which satisfies the conditions described above, or \"-1\" (without quotes), if no such number exists. If there are multiple possible solutions for $s$, print any solution.\n\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n-1\n57\n239\n6789\n\n\n\n-----Note-----\n\nIn the first test case, there are no possible solutions for $s$ consisting of one digit, because any such solution is divisible by itself.\n\nFor the second test case, the possible solutions are: $23$, $27$, $29$, $34$, $37$, $38$, $43$, $46$, $47$, $49$, $53$, $54$, $56$, $57$, $58$, $59$, $67$, $68$, $69$, $73$, $74$, $76$, $78$, $79$, $83$, $86$, $87$, $89$, $94$, $97$, and $98$.\n\nFor the third test case, one possible solution is $239$ because $239$ is not divisible by $2$, $3$ or $9$ and has three digits (none of which equals zero).\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_uneven_digit (n: Nat) : Int :=\nsorry\n\ntheorem solve_uneven_digit_one :\n  solve_uneven_digit 1 = -1 := by\n  sorry\n\ntheorem solve_uneven_digit_two :\n  solve_uneven_digit 2 = 23 := by\n  sorry\n\ntheorem solve_uneven_digit_positive (n: Nat) (h: n > 1) :\n  solve_uneven_digit n > 0 := by\n  sorry\n\ntheorem solve_uneven_digit_length (n: Nat) (h: n > 1) :\n  (toString (solve_uneven_digit n).natAbs).length = n := by\n  sorry\n\ntheorem solve_uneven_digit_no_zeros (n: Nat) (h: n > 1) :\n  ¬((toString (solve_uneven_digit n).natAbs).contains '0') := by\n  sorry\n\ntheorem solve_uneven_digit_not_divisible (n: Nat) (h: n > 1) (d: Char) :\n  d ∈ (toString (solve_uneven_digit n).natAbs).data →\n  ¬((solve_uneven_digit n).natAbs % (d.toNat - 48) = 0) := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0095"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two strings text1 and text2, return the length of their longest common subsequence.\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). A common subsequence of two strings is a subsequence that is common to both strings.\n \nIf there is no common subsequence, return 0.\n \nExample 1:\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n\nExample 2:\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n\nExample 3:\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n\n \nConstraints:\n\n1 <= text1.length <= 1000\n1 <= text2.length <= 1000\nThe input strings consist of lowercase English characters only.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef longest_common_subsequence (s1 s2 : String) : Nat :=\n  sorry\n\ntheorem lcs_length_bounded (s1 s2 : String) :\n  longest_common_subsequence s1 s2 ≤ s1.length ∧ \n  longest_common_subsequence s1 s2 ≤ s2.length :=\n  sorry\n\ntheorem lcs_empty (s : String) :\n  longest_common_subsequence s \"\" = 0 ∧\n  longest_common_subsequence \"\" s = 0 :=\n  sorry\n\ntheorem lcs_identical (s : String) :\n  longest_common_subsequence s s = s.length :=\n  sorry\n\ntheorem lcs_symmetric (s1 s2 : String) :\n  longest_common_subsequence s1 s2 = longest_common_subsequence s2 s1 :=\n  sorry\n\ntheorem lcs_substring (s1 s2 s3 : String) :\n  longest_common_subsequence (s1 ++ s2) s3 ≥ longest_common_subsequence s1 s3 ∧\n  longest_common_subsequence (s1 ++ s2) s3 ≥ longest_common_subsequence s2 s3 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0162", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two strings text1 and text2, return the length of their longest common subsequence.\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). A common subsequence of two strings is a subsequence that is common to both strings.\n \nIf there is no common subsequence, return 0.\n \nExample 1:\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n\nExample 2:\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n\nExample 3:\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n\n \nConstraints:\n\n1 <= text1.length <= 1000\n1 <= text2.length <= 1000\nThe input strings consist of lowercase English characters only.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef longest_common_subsequence (s1 s2 : String) : Nat :=\n  sorry\n\ntheorem lcs_length_bounded (s1 s2 : String) :\n  longest_common_subsequence s1 s2 ≤ s1.length ∧ \n  longest_common_subsequence s1 s2 ≤ s2.length :=\n  sorry\n\ntheorem lcs_empty (s : String) :\n  longest_common_subsequence s \"\" = 0 ∧\n  longest_common_subsequence \"\" s = 0 :=\n  sorry\n\ntheorem lcs_identical (s : String) :\n  longest_common_subsequence s s = s.length :=\n  sorry\n\ntheorem lcs_symmetric (s1 s2 : String) :\n  longest_common_subsequence s1 s2 = longest_common_subsequence s2 s1 :=\n  sorry\n\ntheorem lcs_substring (s1 s2 s3 : String) :\n  longest_common_subsequence (s1 ++ s2) s3 ≥ longest_common_subsequence s1 s3 ∧\n  longest_common_subsequence (s1 ++ s2) s3 ≥ longest_common_subsequence s2 s3 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0162"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.\n\nExample 1:\n\nInput: 5\nOutput: 5\nExplanation: \nHere are the non-negative integers \n\n\nNote:\n1 9\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_integers_without_consecutive_ones (n : Nat) : Nat := sorry\n\ntheorem output_properties (x : Nat) : \n  let result := find_integers_without_consecutive_ones x\n  result ≥ 2 ∧ result > 0 := sorry\n\ntheorem monotonic_relation (x y : Nat) :\n  x < y → find_integers_without_consecutive_ones x ≤ find_integers_without_consecutive_ones y := sorry \n\ntheorem known_values :\n  (find_integers_without_consecutive_ones 1 = 2) ∧\n  (find_integers_without_consecutive_ones 2 = 3) ∧  \n  (find_integers_without_consecutive_ones 5 = 5) ∧\n  (find_integers_without_consecutive_ones 10 = 8) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0175", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.\n\nExample 1:\n\nInput: 5\nOutput: 5\nExplanation: \nHere are the non-negative integers \n\n\nNote:\n1 9\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_integers_without_consecutive_ones (n : Nat) : Nat := sorry\n\ntheorem output_properties (x : Nat) : \n  let result := find_integers_without_consecutive_ones x\n  result ≥ 2 ∧ result > 0 := sorry\n\ntheorem monotonic_relation (x y : Nat) :\n  x < y → find_integers_without_consecutive_ones x ≤ find_integers_without_consecutive_ones y := sorry \n\ntheorem known_values :\n  (find_integers_without_consecutive_ones 1 = 2) ∧\n  (find_integers_without_consecutive_ones 2 = 3) ∧  \n  (find_integers_without_consecutive_ones 5 = 5) ∧\n  (find_integers_without_consecutive_ones 10 = 8) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0175"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn the world of Dota2, there are two parties: the Radiant and the Dire.\n\n\n\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\nBan one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.\n\n\n\n\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.\n\n\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\n\n\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.\n\n\nExample 1:\n\nInput: \"RD\"\nOutput: \"Radiant\"\nExplanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\n\n\nExample 2:\n\nInput: \"RDD\"\nOutput: \"Dire\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\n\nNote:\n\nThe length of the given string will in the range [1, 10,000].\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef predict_party_victory (senate : String) : String := sorry\n\ntheorem predict_party_victory_valid_output (senate : String) :\n  senate.length > 0 → \n  (predict_party_victory senate = \"Radiant\" ∨ predict_party_victory senate = \"Dire\") := sorry\n\ntheorem predict_party_victory_all_radiant (senate : String) :\n  senate.length > 0 → \n  (∀ c, c ∈ senate.data → c = 'R') →\n  predict_party_victory senate = \"Radiant\" := sorry\n\ntheorem predict_party_victory_all_dire (senate : String) :\n  senate.length > 0 → \n  (∀ c, c ∈ senate.data → c = 'D') →\n  predict_party_victory senate = \"Dire\" := sorry\n\ntheorem predict_party_victory_deterministic (senate : String) :\n  senate.length > 0 →\n  predict_party_victory senate = predict_party_victory senate := sorry\n\ntheorem predict_party_victory_repeating_pattern (n : Nat) :\n  n > 0 →\n  predict_party_victory (String.join (List.replicate n \"RD\")) = predict_party_victory \"RD\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0208", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn the world of Dota2, there are two parties: the Radiant and the Dire.\n\n\n\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\nBan one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.\n\n\n\n\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.\n\n\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\n\n\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.\n\n\nExample 1:\n\nInput: \"RD\"\nOutput: \"Radiant\"\nExplanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\n\n\nExample 2:\n\nInput: \"RDD\"\nOutput: \"Dire\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\n\nNote:\n\nThe length of the given string will in the range [1, 10,000].\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef predict_party_victory (senate : String) : String := sorry\n\ntheorem predict_party_victory_valid_output (senate : String) :\n  senate.length > 0 → \n  (predict_party_victory senate = \"Radiant\" ∨ predict_party_victory senate = \"Dire\") := sorry\n\ntheorem predict_party_victory_all_radiant (senate : String) :\n  senate.length > 0 → \n  (∀ c, c ∈ senate.data → c = 'R') →\n  predict_party_victory senate = \"Radiant\" := sorry\n\ntheorem predict_party_victory_all_dire (senate : String) :\n  senate.length > 0 → \n  (∀ c, c ∈ senate.data → c = 'D') →\n  predict_party_victory senate = \"Dire\" := sorry\n\ntheorem predict_party_victory_deterministic (senate : String) :\n  senate.length > 0 →\n  predict_party_victory senate = predict_party_victory senate := sorry\n\ntheorem predict_party_victory_repeating_pattern (n : Nat) :\n  n > 0 →\n  predict_party_victory (String.join (List.replicate n \"RD\")) = predict_party_victory \"RD\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0208"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)\nReturn any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is \"\".)\n \nExample 1:\nInput: \"banana\"\nOutput: \"ana\"\n\nExample 2:\nInput: \"abcd\"\nOutput: \"\"\n\n \nNote:\n\n2 <= S.length <= 10^5\nS consists of lowercase English letters.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef longest_dup_substring (s : String) : String := sorry\n\ndef isSubstringOf (sub str : String) : Bool := sorry\n\ntheorem longest_dup_is_substring {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  isSubstringOf result s = true := sorry\n\ndef countOccurrences (needle haystack : String) (start : Nat) : Nat := sorry\n\ntheorem longest_dup_occurs_twice {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  if result.length > 0 then\n    countOccurrences result s 0 ≥ 2\n  else True := sorry\n\ndef hasLongerDuplicate (s : String) (len : Nat) : Bool := sorry\n\ntheorem no_longer_duplicate_exists {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  ∀ len, len > result.length → \n  hasLongerDuplicate s len = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0221", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)\nReturn any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is \"\".)\n \nExample 1:\nInput: \"banana\"\nOutput: \"ana\"\n\nExample 2:\nInput: \"abcd\"\nOutput: \"\"\n\n \nNote:\n\n2 <= S.length <= 10^5\nS consists of lowercase English letters.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef longest_dup_substring (s : String) : String := sorry\n\ndef isSubstringOf (sub str : String) : Bool := sorry\n\ntheorem longest_dup_is_substring {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  isSubstringOf result s = true := sorry\n\ndef countOccurrences (needle haystack : String) (start : Nat) : Nat := sorry\n\ntheorem longest_dup_occurs_twice {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  if result.length > 0 then\n    countOccurrences result s 0 ≥ 2\n  else True := sorry\n\ndef hasLongerDuplicate (s : String) (len : Nat) : Bool := sorry\n\ntheorem no_longer_duplicate_exists {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  ∀ len, len > result.length → \n  hasLongerDuplicate s len = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0221"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n \nExample 1:\n\nInput: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:\n\n\nExample 2:\n\nInput: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:\n\n\nExample 3:\n\nInput: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 500\n1 <= n <= 500\ngrid consists only of lowercase English letters.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.rectangular (grid : List (List α)) : Bool :=\n  sorry\n\ndef contains_cycle (grid : List (List Char)) : Bool :=\n  sorry\n\ntheorem contains_cycle_empty_raises : ∀ (grid : List (List Char)),\n  grid = [] ∨ grid.head?.map (λ row => row = []) = some true →\n  contains_cycle grid = false :=\n  sorry\n\ntheorem contains_cycle_returns_bool : ∀ (grid : List (List Char)),\n  grid ≠ [] →\n  grid.head?.map (λ row => row ≠ []) = some true →\n  grid.rectangular = true →\n  (contains_cycle grid = true ∨ contains_cycle grid = false) :=\n  sorry\n\ntheorem contains_cycle_all_same_char : ∀ (c : Char) (n : Nat),\n  n > 0 →\n  let grid := List.replicate n (List.replicate n c);\n  contains_cycle grid = (n > 1) :=\n  sorry\n\ntheorem contains_cycle_checkerboard : ∀ (n : Nat),\n  n ≥ 2 →\n  let grid := List.map (λ i => List.map (λ j => if (i+j)%2 = 0 then 'a' else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = false :=\n  sorry\n\ntheorem contains_cycle_border : ∀ (n : Nat),\n  n ≥ 3 →\n  let grid := List.map (λ i => List.map (λ j => \n    if i = 0 ∨ i = n-1 ∨ j = 0 ∨ j = n-1 \n    then 'a' \n    else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = true :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0248", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n \nExample 1:\n\nInput: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:\n\n\nExample 2:\n\nInput: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:\n\n\nExample 3:\n\nInput: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 500\n1 <= n <= 500\ngrid consists only of lowercase English letters.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.rectangular (grid : List (List α)) : Bool :=\n  sorry\n\ndef contains_cycle (grid : List (List Char)) : Bool :=\n  sorry\n\ntheorem contains_cycle_empty_raises : ∀ (grid : List (List Char)),\n  grid = [] ∨ grid.head?.map (λ row => row = []) = some true →\n  contains_cycle grid = false :=\n  sorry\n\ntheorem contains_cycle_returns_bool : ∀ (grid : List (List Char)),\n  grid ≠ [] →\n  grid.head?.map (λ row => row ≠ []) = some true →\n  grid.rectangular = true →\n  (contains_cycle grid = true ∨ contains_cycle grid = false) :=\n  sorry\n\ntheorem contains_cycle_all_same_char : ∀ (c : Char) (n : Nat),\n  n > 0 →\n  let grid := List.replicate n (List.replicate n c);\n  contains_cycle grid = (n > 1) :=\n  sorry\n\ntheorem contains_cycle_checkerboard : ∀ (n : Nat),\n  n ≥ 2 →\n  let grid := List.map (λ i => List.map (λ j => if (i+j)%2 = 0 then 'a' else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = false :=\n  sorry\n\ntheorem contains_cycle_border : ∀ (n : Nat),\n  n ≥ 3 →\n  let grid := List.map (λ i => List.map (λ j => \n    if i = 0 ∨ i = n-1 ∨ j = 0 ∨ j = n-1 \n    then 'a' \n    else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = true :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0248"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an equation, represented by words on left side and the result on right side.\nYou need to check if the equation is solvable under the following rules:\n\nEach character is decoded as one digit (0 - 9).\nEvery pair of different characters they must map to different digits.\nEach words[i] and result are decoded as one number without leading zeros.\nSum of numbers on left side (words) will equal to the number on right side (result). \n\nReturn True if the equation is solvable otherwise return False.\n \nExample 1:\nInput: words = [\"SEND\",\"MORE\"], result = \"MONEY\"\nOutput: true\nExplanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\nSuch that: \"SEND\" + \"MORE\" = \"MONEY\" ,  9567 + 1085 = 10652\nExample 2:\nInput: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\"\nOutput: true\nExplanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\nSuch that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" ,  650 + 68782 + 68782 = 138214\nExample 3:\nInput: words = [\"THIS\",\"IS\",\"TOO\"], result = \"FUNNY\"\nOutput: true\n\nExample 4:\nInput: words = [\"LEET\",\"CODE\"], result = \"POINT\"\nOutput: false\n\n \nConstraints:\n\n2 <= words.length <= 5\n1 <= words[i].length, result.length <= 7\nwords[i], result contains only upper case English letters.\nNumber of different characters used on the expression is at most 10.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Solution := String\n\ndef isSolvable (words : List String) (result : String) : Bool :=\n  sorry\n\ndef isAlpha (s : String) : Bool :=\n  sorry\n\ndef isUpper (s : String) : Bool :=\n  sorry \n\ntheorem valid_solution_constraints {words : List String} {result : String}\n  (h1 : ∀ w ∈ words, isAlpha w ∧ isUpper w)\n  (h2 : isAlpha result ∧ isUpper result) \n  (h3 : words.length > 0)\n  (h4 : ∀ w ∈ words, w.length > 0)\n  (h5 : result.length ≥ words.foldr (fun w acc => max w.length acc) 0) :\n  ∃ solution : Bool, isSolvable words result = solution :=\n  sorry\n\ntheorem known_valid_cases_work \n  (h1 : isSolvable [\"SEND\", \"MORE\"] \"MONEY\" = true)\n  (h2 : isSolvable [\"SIX\", \"SEVEN\", \"SEVEN\"] \"TWENTY\" = true) :\n  ∀ words result, \n    (words = [\"SEND\", \"MORE\"] ∧ result = \"MONEY\") ∨\n    (words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ result = \"TWENTY\") →\n    isSolvable words result = true :=\n  sorry\n\ntheorem modified_valid_case_exists_solution\n  {words result : String} \n  (h1 : words.length > 0)\n  (h2 : result.length > 0)\n  (h3 : ∃ (orig_words : List String) (orig_result : String),\n        ((orig_words = [\"SEND\", \"MORE\"] ∧ orig_result = \"MONEY\") ∨\n         (orig_words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ orig_result = \"TWENTY\")) ∧\n        words.length = orig_result.length) :\n  ∃ solution : Bool, isSolvable [words] result = solution :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0262", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an equation, represented by words on left side and the result on right side.\nYou need to check if the equation is solvable under the following rules:\n\nEach character is decoded as one digit (0 - 9).\nEvery pair of different characters they must map to different digits.\nEach words[i] and result are decoded as one number without leading zeros.\nSum of numbers on left side (words) will equal to the number on right side (result). \n\nReturn True if the equation is solvable otherwise return False.\n \nExample 1:\nInput: words = [\"SEND\",\"MORE\"], result = \"MONEY\"\nOutput: true\nExplanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\nSuch that: \"SEND\" + \"MORE\" = \"MONEY\" ,  9567 + 1085 = 10652\nExample 2:\nInput: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\"\nOutput: true\nExplanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\nSuch that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" ,  650 + 68782 + 68782 = 138214\nExample 3:\nInput: words = [\"THIS\",\"IS\",\"TOO\"], result = \"FUNNY\"\nOutput: true\n\nExample 4:\nInput: words = [\"LEET\",\"CODE\"], result = \"POINT\"\nOutput: false\n\n \nConstraints:\n\n2 <= words.length <= 5\n1 <= words[i].length, result.length <= 7\nwords[i], result contains only upper case English letters.\nNumber of different characters used on the expression is at most 10.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Solution := String\n\ndef isSolvable (words : List String) (result : String) : Bool :=\n  sorry\n\ndef isAlpha (s : String) : Bool :=\n  sorry\n\ndef isUpper (s : String) : Bool :=\n  sorry \n\ntheorem valid_solution_constraints {words : List String} {result : String}\n  (h1 : ∀ w ∈ words, isAlpha w ∧ isUpper w)\n  (h2 : isAlpha result ∧ isUpper result) \n  (h3 : words.length > 0)\n  (h4 : ∀ w ∈ words, w.length > 0)\n  (h5 : result.length ≥ words.foldr (fun w acc => max w.length acc) 0) :\n  ∃ solution : Bool, isSolvable words result = solution :=\n  sorry\n\ntheorem known_valid_cases_work \n  (h1 : isSolvable [\"SEND\", \"MORE\"] \"MONEY\" = true)\n  (h2 : isSolvable [\"SIX\", \"SEVEN\", \"SEVEN\"] \"TWENTY\" = true) :\n  ∀ words result, \n    (words = [\"SEND\", \"MORE\"] ∧ result = \"MONEY\") ∨\n    (words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ result = \"TWENTY\") →\n    isSolvable words result = true :=\n  sorry\n\ntheorem modified_valid_case_exists_solution\n  {words result : String} \n  (h1 : words.length > 0)\n  (h2 : result.length > 0)\n  (h3 : ∃ (orig_words : List String) (orig_result : String),\n        ((orig_words = [\"SEND\", \"MORE\"] ∧ orig_result = \"MONEY\") ∨\n         (orig_words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ orig_result = \"TWENTY\")) ∧\n        words.length = orig_result.length) :\n  ∃ solution : Bool, isSolvable [words] result = solution :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0262"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nEvaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\n\nNote:\n\n\n       Division between two integers should truncate toward zero.\n       The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.\n\n\nExample 1:\n\n\nInput: [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\n\nExample 2:\n\n\nInput: [\"4\", \"13\", \"5\", \"/\", \"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\n\nExample 3:\n\n\nInput: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\nOutput: 22\nExplanation: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n```\n#####\n\nTo answer this question, you need to replace the 14 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef eval_rpn : List String → Int\n  | _ => sorry\n\ntheorem eval_rpn_empty :\n  eval_rpn [] = 0 := by sorry\n\ntheorem eval_rpn_single_positive :\n  eval_rpn [\"5\"] = 5 := by sorry\n\ntheorem eval_rpn_single_negative : \n  eval_rpn [\"-5\"] = -5 := by sorry\n\ntheorem eval_rpn_addition :\n  eval_rpn [\"3\", \"2\", \"+\"] = 5 := by sorry\n\ntheorem eval_rpn_subtraction :\n  eval_rpn [\"3\", \"2\", \"-\"] = 1 := by sorry\n\ntheorem eval_rpn_multiplication :\n  eval_rpn [\"3\", \"2\", \"*\"] = 6 := by sorry\n\ntheorem eval_rpn_division :\n  eval_rpn [\"6\", \"2\", \"/\"] = 3 := by sorry\n\ntheorem eval_rpn_negative_division_1 :\n  eval_rpn [\"6\", \"-2\", \"/\"] = -3 := by sorry\n\ntheorem eval_rpn_negative_division_2 :\n  eval_rpn [\"-6\", \"2\", \"/\"] = -3 := by sorry\n\ntheorem eval_rpn_negative_multiplication :\n  eval_rpn [\"-2\", \"-3\", \"*\"] = 6 := by sorry\n\ntheorem eval_rpn_negative_addition :\n  eval_rpn [\"-1\", \"1\", \"+\"] = 0 := by sorry\n\ntheorem eval_rpn_complex_1 :\n  eval_rpn [\"2\", \"1\", \"+\", \"3\", \"*\"] = 9 := by sorry\n\ntheorem eval_rpn_complex_2 :\n  eval_rpn [\"4\", \"13\", \"5\", \"/\", \"+\"] = 6 := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0267", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nEvaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\n\nNote:\n\n\n       Division between two integers should truncate toward zero.\n       The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.\n\n\nExample 1:\n\n\nInput: [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\n\nExample 2:\n\n\nInput: [\"4\", \"13\", \"5\", \"/\", \"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\n\nExample 3:\n\n\nInput: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\nOutput: 22\nExplanation: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n```\n#####\n\nTo answer this question, you need to replace the 14 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef eval_rpn : List String → Int\n  | _ => sorry\n\ntheorem eval_rpn_empty :\n  eval_rpn [] = 0 := by sorry\n\ntheorem eval_rpn_single_positive :\n  eval_rpn [\"5\"] = 5 := by sorry\n\ntheorem eval_rpn_single_negative : \n  eval_rpn [\"-5\"] = -5 := by sorry\n\ntheorem eval_rpn_addition :\n  eval_rpn [\"3\", \"2\", \"+\"] = 5 := by sorry\n\ntheorem eval_rpn_subtraction :\n  eval_rpn [\"3\", \"2\", \"-\"] = 1 := by sorry\n\ntheorem eval_rpn_multiplication :\n  eval_rpn [\"3\", \"2\", \"*\"] = 6 := by sorry\n\ntheorem eval_rpn_division :\n  eval_rpn [\"6\", \"2\", \"/\"] = 3 := by sorry\n\ntheorem eval_rpn_negative_division_1 :\n  eval_rpn [\"6\", \"-2\", \"/\"] = -3 := by sorry\n\ntheorem eval_rpn_negative_division_2 :\n  eval_rpn [\"-6\", \"2\", \"/\"] = -3 := by sorry\n\ntheorem eval_rpn_negative_multiplication :\n  eval_rpn [\"-2\", \"-3\", \"*\"] = 6 := by sorry\n\ntheorem eval_rpn_negative_addition :\n  eval_rpn [\"-1\", \"1\", \"+\"] = 0 := by sorry\n\ntheorem eval_rpn_complex_1 :\n  eval_rpn [\"2\", \"1\", \"+\", \"3\", \"*\"] = 9 := by sorry\n\ntheorem eval_rpn_complex_2 :\n  eval_rpn [\"4\", \"13\", \"5\", \"/\", \"+\"] = 6 := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0267"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.\n \nExample 1:\n\nInput: nums = [1,0,0,0,1,0,0,1], k = 2\nOutput: true\nExplanation: Each of the 1s are at least 2 places away from each other.\n\nExample 2:\n\nInput: nums = [1,0,0,1,0,1], k = 2\nOutput: false\nExplanation: The second 1 and third 1 are only one apart from each other.\nExample 3:\nInput: nums = [1,1,1,1,1], k = 0\nOutput: true\n\nExample 4:\nInput: nums = [0,1,0,1], k = 1\nOutput: true\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= k <= nums.length\nnums[i] is 0 or 1\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef k_length_apart (nums : List Nat) (k : Nat) : Bool :=\n  sorry\n\ntheorem k_distance_property {nums : List Nat} {k : Nat} \n  (h1 : ∀ x ∈ nums, x ≤ 1)\n  (h2 : k > 0)\n  (h3 : k_length_apart nums k = true) :\n  ∀ i j, i < nums.length → j < nums.length → \n    (nums.get ⟨i, sorry⟩ = 1 ∧ nums.get ⟨j, sorry⟩ = 1 ∧ i < j) → \n    j - i > k :=\nsorry\n\ntheorem no_ones_property {nums : List Nat} {k : Nat}\n  (h1 : ∀ x ∈ nums, x ≤ 1)\n  (h2 : 1 ∉ nums) :\n  k_length_apart nums k = true :=\nsorry\n\ntheorem consecutive_ones_property {nums : List Nat} {k : Nat} {i : Nat}\n  (h1 : ∀ x ∈ nums, x ≤ 1)\n  (h2 : k > 0)\n  (h3 : i < nums.length - 1)\n  (h4 : nums.get ⟨i, sorry⟩ = 1)\n  (h5 : nums.get ⟨i+1, sorry⟩ = 1) :\n  k_length_apart nums k = false :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0269", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.\n \nExample 1:\n\nInput: nums = [1,0,0,0,1,0,0,1], k = 2\nOutput: true\nExplanation: Each of the 1s are at least 2 places away from each other.\n\nExample 2:\n\nInput: nums = [1,0,0,1,0,1], k = 2\nOutput: false\nExplanation: The second 1 and third 1 are only one apart from each other.\nExample 3:\nInput: nums = [1,1,1,1,1], k = 0\nOutput: true\n\nExample 4:\nInput: nums = [0,1,0,1], k = 1\nOutput: true\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= k <= nums.length\nnums[i] is 0 or 1\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef k_length_apart (nums : List Nat) (k : Nat) : Bool :=\n  sorry\n\ntheorem k_distance_property {nums : List Nat} {k : Nat} \n  (h1 : ∀ x ∈ nums, x ≤ 1)\n  (h2 : k > 0)\n  (h3 : k_length_apart nums k = true) :\n  ∀ i j, i < nums.length → j < nums.length → \n    (nums.get ⟨i, sorry⟩ = 1 ∧ nums.get ⟨j, sorry⟩ = 1 ∧ i < j) → \n    j - i > k :=\nsorry\n\ntheorem no_ones_property {nums : List Nat} {k : Nat}\n  (h1 : ∀ x ∈ nums, x ≤ 1)\n  (h2 : 1 ∉ nums) :\n  k_length_apart nums k = true :=\nsorry\n\ntheorem consecutive_ones_property {nums : List Nat} {k : Nat} {i : Nat}\n  (h1 : ∀ x ∈ nums, x ≤ 1)\n  (h2 : k > 0)\n  (h3 : i < nums.length - 1)\n  (h4 : nums.get ⟨i, sorry⟩ = 1)\n  (h5 : nums.get ⟨i+1, sorry⟩ = 1) :\n  k_length_apart nums k = false :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0269"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.\nYou need to determine whether it is possible to measure exactly z litres using these two jugs.\n\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\n\n\nOperations allowed:\n\nFill any of the jugs completely with water.\nEmpty any of the jugs.\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\n\n\n\nExample 1: (From the famous \"Die Hard\" example)\n\nInput: x = 3, y = 5, z = 4\nOutput: True\n\n\n\nExample 2:\n\nInput: x = 2, y = 6, z = 5\nOutput: False\n\n\n\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_measure_water (x y z : Nat) : Bool := sorry\n\ndef gcd (a b : Nat) : Nat := sorry\n\ntheorem measurement_bounds {x y z : Nat} :\n  can_measure_water x y z → z ≤ x + y ∧ z ≥ 0 := sorry\n\ntheorem zero_target_always_possible {x y : Nat} :\n  can_measure_water x y 0 = true := sorry\n\ntheorem single_jug_measurements {cap : Nat} (h : cap > 0) :\n  can_measure_water cap 0 cap = true ∧\n  can_measure_water cap 0 (cap + 1) = false := sorry\n\ntheorem commutative {x y z : Nat} :\n  can_measure_water x y z = can_measure_water y x z := sorry\n\ntheorem gcd_property {x y z : Nat} (hx : x > 0) (hy : y > 0) :\n  can_measure_water x y z → z % gcd x y = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0364", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.\nYou need to determine whether it is possible to measure exactly z litres using these two jugs.\n\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\n\n\nOperations allowed:\n\nFill any of the jugs completely with water.\nEmpty any of the jugs.\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\n\n\n\nExample 1: (From the famous \"Die Hard\" example)\n\nInput: x = 3, y = 5, z = 4\nOutput: True\n\n\n\nExample 2:\n\nInput: x = 2, y = 6, z = 5\nOutput: False\n\n\n\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_measure_water (x y z : Nat) : Bool := sorry\n\ndef gcd (a b : Nat) : Nat := sorry\n\ntheorem measurement_bounds {x y z : Nat} :\n  can_measure_water x y z → z ≤ x + y ∧ z ≥ 0 := sorry\n\ntheorem zero_target_always_possible {x y : Nat} :\n  can_measure_water x y 0 = true := sorry\n\ntheorem single_jug_measurements {cap : Nat} (h : cap > 0) :\n  can_measure_water cap 0 cap = true ∧\n  can_measure_water cap 0 (cap + 1) = false := sorry\n\ntheorem commutative {x y z : Nat} :\n  can_measure_water x y z = can_measure_water y x z := sorry\n\ntheorem gcd_property {x y z : Nat} (hx : x > 0) (hy : y > 0) :\n  can_measure_water x y z → z % gcd x y = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0364"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two positive integers n and k.\nA factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n \nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\n\nExample 4:\nInput: n = 1, k = 1\nOutput: 1\nExplanation: Factors list is [1], the 1st factor is 1.\n\nExample 5:\nInput: n = 1000, k = 3\nOutput: 4\nExplanation: Factors list is [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000].\n\n \nConstraints:\n\n1 <= k <= n <= 1000\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef kthFactor (n : Nat) (k : Nat) : Int :=\n  sorry\n\ntheorem first_factor_always_one (n : Nat) (h : n > 0) :\n  kthFactor n 1 = 1 := sorry\n\ntheorem k_greater_than_total_factors_negative_one (n k : Nat) (h₁ : n > 0) (h₂ : k > 0) :\n  let numFactors := (List.range n).filter (fun i => n % (i+1) = 0) |>.length\n  k > numFactors → kthFactor n k = -1 := sorry\n\ntheorem valid_factor_divides_evenly (n k : Nat) (h₁ : n > 0) (h₂ : k > 0) :\n  kthFactor n k ≠ -1 → n % (kthFactor n k).toNat = 0 := sorry\n\ntheorem factors_are_ordered (n k : Nat) (h₁ : n > 0) (h₂ : k > 0) :\n  kthFactor n k ≠ -1 →\n  ((List.range (kthFactor n k).toNat).filter (fun i => n % (i+1) = 0)).length = k - 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0385", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two positive integers n and k.\nA factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n \nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\n\nExample 4:\nInput: n = 1, k = 1\nOutput: 1\nExplanation: Factors list is [1], the 1st factor is 1.\n\nExample 5:\nInput: n = 1000, k = 3\nOutput: 4\nExplanation: Factors list is [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000].\n\n \nConstraints:\n\n1 <= k <= n <= 1000\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef kthFactor (n : Nat) (k : Nat) : Int :=\n  sorry\n\ntheorem first_factor_always_one (n : Nat) (h : n > 0) :\n  kthFactor n 1 = 1 := sorry\n\ntheorem k_greater_than_total_factors_negative_one (n k : Nat) (h₁ : n > 0) (h₂ : k > 0) :\n  let numFactors := (List.range n).filter (fun i => n % (i+1) = 0) |>.length\n  k > numFactors → kthFactor n k = -1 := sorry\n\ntheorem valid_factor_divides_evenly (n k : Nat) (h₁ : n > 0) (h₂ : k > 0) :\n  kthFactor n k ≠ -1 → n % (kthFactor n k).toNat = 0 := sorry\n\ntheorem factors_are_ordered (n k : Nat) (h₁ : n > 0) (h₂ : k > 0) :\n  kthFactor n k ≠ -1 →\n  ((List.range (kthFactor n k).toNat).filter (fun i => n % (i+1) = 0)).length = k - 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0385"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an integer array A.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.\nYou may from index i jump forward to index j (with i < j) in the following way:\n\nDuring odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j.\nDuring even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j.\n(It may be the case that for some index i, there are no legal jumps.)\n\nA starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.)\nReturn the number of good starting indexes.\n \nExample 1:\nInput: [10,13,12,14,15]\nOutput: 2\nExplanation: \nFrom starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more.\nFrom starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more.\nFrom starting index i = 3, we can jump to i = 4, so we've reached the end.\nFrom starting index i = 4, we've reached the end already.\nIn total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.\n\n\nExample 2:\nInput: [2,3,1,1,4]\nOutput: 3\nExplanation: \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\n\nDuring our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].\n\nDuring our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.\n\nDuring our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].\n\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\n\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.\n\n\nExample 3:\nInput: [5,1,3,4,2]\nOutput: 3\nExplanation: \nWe can reach the end from starting indexes 1, 2, and 4.\n\n\n\n \nNote:\n\n1 <= A.length <= 20000\n0 <= A[i] < 100000\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef oddEvenJumps (arr : List Int) : Nat :=\n  sorry\n\ntheorem oddEvenJumps_output_range (arr : List Int) (h : arr ≠ []) : \n  let result := oddEvenJumps arr\n  1 ≤ result ∧ result ≤ arr.length := sorry\n\ntheorem oddEvenJumps_single_element (x : Int) :\n  oddEvenJumps [x] = 1 := sorry\n\ntheorem oddEvenJumps_decreasing {arr : List Int} (h₁ : arr ≠ [])\n  (h₂ : ∀ (i j : Fin arr.length), i.val < j.val → arr[i] > arr[j]) :\n  oddEvenJumps arr ≥ 1 := sorry\n\ntheorem oddEvenJumps_all_equal (x : Int) (n : Nat) (h : n > 0) :\n  oddEvenJumps (List.replicate n x) = n := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0395", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an integer array A.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.\nYou may from index i jump forward to index j (with i < j) in the following way:\n\nDuring odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j.\nDuring even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j.\n(It may be the case that for some index i, there are no legal jumps.)\n\nA starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.)\nReturn the number of good starting indexes.\n \nExample 1:\nInput: [10,13,12,14,15]\nOutput: 2\nExplanation: \nFrom starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more.\nFrom starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more.\nFrom starting index i = 3, we can jump to i = 4, so we've reached the end.\nFrom starting index i = 4, we've reached the end already.\nIn total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.\n\n\nExample 2:\nInput: [2,3,1,1,4]\nOutput: 3\nExplanation: \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\n\nDuring our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].\n\nDuring our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.\n\nDuring our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].\n\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\n\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.\n\n\nExample 3:\nInput: [5,1,3,4,2]\nOutput: 3\nExplanation: \nWe can reach the end from starting indexes 1, 2, and 4.\n\n\n\n \nNote:\n\n1 <= A.length <= 20000\n0 <= A[i] < 100000\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef oddEvenJumps (arr : List Int) : Nat :=\n  sorry\n\ntheorem oddEvenJumps_output_range (arr : List Int) (h : arr ≠ []) : \n  let result := oddEvenJumps arr\n  1 ≤ result ∧ result ≤ arr.length := sorry\n\ntheorem oddEvenJumps_single_element (x : Int) :\n  oddEvenJumps [x] = 1 := sorry\n\ntheorem oddEvenJumps_decreasing {arr : List Int} (h₁ : arr ≠ [])\n  (h₂ : ∀ (i j : Fin arr.length), i.val < j.val → arr[i] > arr[j]) :\n  oddEvenJumps arr ≥ 1 := sorry\n\ntheorem oddEvenJumps_all_equal (x : Int) (n : Nat) (h : n > 0) :\n  oddEvenJumps (List.replicate n x) = n := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0395"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nExample 1:\n\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\n\n\nExample 2:\n\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\n\nExample 3:\n\n\nInput: numerator = 2, denominator = 3\nOutput: \"0.(6)\"\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure DecimalRepr where\n  value: String\n  isValid: Bool\n\ndef toFloat (s: String) : Float :=\n  sorry\n\ndef intToFloat (n: Int) : Float :=\n  sorry\n\ndef fraction_to_decimal (n: Int) (d: Int) : DecimalRepr :=\n  sorry\n\ntheorem positive_fraction_valid_format (n d: Int)\n  (hn: 0 < n) (hd: 0 < d) (hdn: n ≤ 10^6 ∧ d ≤ 10^6) :\n  (fraction_to_decimal n d).isValid = true :=\n  sorry\n\ntheorem positive_fraction_matches_value (n d: Int)\n  (hn: 0 < n) (hd: 0 < d) (hdn: n ≤ 10^6 ∧ d ≤ 10^6) :\n  (((toFloat (fraction_to_decimal n d).value) - ((intToFloat n) / (intToFloat d))).abs < 1e-10) :=\n  sorry\n\ntheorem whole_numbers_no_decimals (n: Int)\n  (hn: -10^6 ≤ n ∧ n ≤ 10^6) (hnz: n ≠ 0) :\n  let res := (fraction_to_decimal n 1).value\n  ¬res.contains '.' ∧ ¬res.contains '(' ∧ res.toInt! = n :=\n  sorry\n\ntheorem zero_numerator (d: Int)\n  (hd: 0 < d) (hdb: d ≤ 10^6) :\n  (fraction_to_decimal 0 d).value = \"0\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0468", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nExample 1:\n\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\n\n\nExample 2:\n\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\n\nExample 3:\n\n\nInput: numerator = 2, denominator = 3\nOutput: \"0.(6)\"\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure DecimalRepr where\n  value: String\n  isValid: Bool\n\ndef toFloat (s: String) : Float :=\n  sorry\n\ndef intToFloat (n: Int) : Float :=\n  sorry\n\ndef fraction_to_decimal (n: Int) (d: Int) : DecimalRepr :=\n  sorry\n\ntheorem positive_fraction_valid_format (n d: Int)\n  (hn: 0 < n) (hd: 0 < d) (hdn: n ≤ 10^6 ∧ d ≤ 10^6) :\n  (fraction_to_decimal n d).isValid = true :=\n  sorry\n\ntheorem positive_fraction_matches_value (n d: Int)\n  (hn: 0 < n) (hd: 0 < d) (hdn: n ≤ 10^6 ∧ d ≤ 10^6) :\n  (((toFloat (fraction_to_decimal n d).value) - ((intToFloat n) / (intToFloat d))).abs < 1e-10) :=\n  sorry\n\ntheorem whole_numbers_no_decimals (n: Int)\n  (hn: -10^6 ≤ n ∧ n ≤ 10^6) (hnz: n ≠ 0) :\n  let res := (fraction_to_decimal n 1).value\n  ¬res.contains '.' ∧ ¬res.contains '(' ∧ res.toInt! = n :=\n  sorry\n\ntheorem zero_numerator (d: Int)\n  (hd: 0 < d) (hdb: d ≤ 10^6) :\n  (fraction_to_decimal 0 d).value = \"0\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0468"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nFind the smallest prime palindrome greater than or equal to N.\nRecall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1. \nFor example, 2,3,5,7,11 and 13 are primes.\nRecall that a number is a palindrome if it reads the same from left to right as it does from right to left. \nFor example, 12321 is a palindrome.\n \n\nExample 1:\nInput: 6\nOutput: 7\n\n\nExample 2:\nInput: 8\nOutput: 11\n\n\nExample 3:\nInput: 13\nOutput: 101\n\n\n\n \nNote:\n\n1 <= N <= 10^8\nThe answer is guaranteed to exist and be less than 2 * 10^8.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef primePalindrome (n : Nat) : Nat :=\n  sorry\n\ndef isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry\n\n\n\n\n\ntheorem primePalindrome_geq_input\n  (n : Nat)\n  (h1 : n ≥ 2)\n  (h2 : n ≤ 19990) :\n  primePalindrome n ≥ n :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0484", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nFind the smallest prime palindrome greater than or equal to N.\nRecall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1. \nFor example, 2,3,5,7,11 and 13 are primes.\nRecall that a number is a palindrome if it reads the same from left to right as it does from right to left. \nFor example, 12321 is a palindrome.\n \n\nExample 1:\nInput: 6\nOutput: 7\n\n\nExample 2:\nInput: 8\nOutput: 11\n\n\nExample 3:\nInput: 13\nOutput: 101\n\n\n\n \nNote:\n\n1 <= N <= 10^8\nThe answer is guaranteed to exist and be less than 2 * 10^8.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef primePalindrome (n : Nat) : Nat :=\n  sorry\n\ndef isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry\n\n\n\n\n\ntheorem primePalindrome_geq_input\n  (n : Nat)\n  (h1 : n ≥ 2)\n  (h2 : n ≤ 19990) :\n  primePalindrome n ≥ n :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0484"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n \n\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \n\n\nExample 1:\n\nInput: nums is [1, 1, 1, 1, 1], S is 3. \nOutput: 5\nExplanation: \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\n\n\n\nNote:\n\nThe length of the given array is positive and will not exceed 20. \nThe sum of elements in the given array will not exceed 1000.\nYour output answer is guaranteed to be fitted in a 32-bit integer.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + List.sum t\n\ndef Int.abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef List.sort (xs : List Nat) : List Nat :=\n  sorry\n\ndef find_target_sum_ways (nums : List Nat) (target : Int) : Nat :=\n  sorry\n\ntheorem output_bounds_nonnegative {nums : List Nat} {target : Int} :\n  find_target_sum_ways nums target ≥ 0 := sorry\n\ntheorem output_bounds_impossible {nums : List Nat} {target : Int} :\n  ((nums.sum : Int) < target.abs) → find_target_sum_ways nums target = 0 := sorry\n\ntheorem invariant_permutation {nums : List Nat} {target : Int} :\n  find_target_sum_ways nums target = find_target_sum_ways (List.sort nums) target := sorry\n\ntheorem invariant_odd_sum {nums : List Nat} {target : Int} :\n  ((nums.sum : Int) + target) % 2 = 1 → find_target_sum_ways nums target = 0 := sorry\n\ntheorem all_ones_symmetric {n : Nat} {nums : List Nat} :\n  (∀ x ∈ nums, x = 1) →\n  find_target_sum_ways nums (n / 2) = find_target_sum_ways nums (-n / 2) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0493", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n \n\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \n\n\nExample 1:\n\nInput: nums is [1, 1, 1, 1, 1], S is 3. \nOutput: 5\nExplanation: \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\n\n\n\nNote:\n\nThe length of the given array is positive and will not exceed 20. \nThe sum of elements in the given array will not exceed 1000.\nYour output answer is guaranteed to be fitted in a 32-bit integer.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + List.sum t\n\ndef Int.abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef List.sort (xs : List Nat) : List Nat :=\n  sorry\n\ndef find_target_sum_ways (nums : List Nat) (target : Int) : Nat :=\n  sorry\n\ntheorem output_bounds_nonnegative {nums : List Nat} {target : Int} :\n  find_target_sum_ways nums target ≥ 0 := sorry\n\ntheorem output_bounds_impossible {nums : List Nat} {target : Int} :\n  ((nums.sum : Int) < target.abs) → find_target_sum_ways nums target = 0 := sorry\n\ntheorem invariant_permutation {nums : List Nat} {target : Int} :\n  find_target_sum_ways nums target = find_target_sum_ways (List.sort nums) target := sorry\n\ntheorem invariant_odd_sum {nums : List Nat} {target : Int} :\n  ((nums.sum : Int) + target) % 2 = 1 → find_target_sum_ways nums target = 0 := sorry\n\ntheorem all_ones_symmetric {n : Nat} {nums : List Nat} :\n  (∀ x ∈ nums, x = 1) →\n  find_target_sum_ways nums (n / 2) = find_target_sum_ways nums (-n / 2) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0493"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nVasya's older brother, Petya, attends an algorithm course in his school. Today he learned about matchings in graphs. Formally, a set of edges in a graph is called a matching if no pair of distinct edges in the set shares a common endpoint.\nPetya instantly came up with an inverse concept, an antimatching. In an antimatching, any pair of distinct edges should have a common endpoint.\nPetya knows that finding a largest matching in a graph is a somewhat formidable task. He wonders if finding the largest antimatching is any easier. Help him find the number of edges in a largest antimatching in a given graph.\n\n-----Input:-----\nThe first line contains T$T$, number of test cases per file.\nThe first line of each test case contains two integers n$n$ and m−$m-$ the number of vertices and edges of the graph respectively (1≤n≤104$1 \\leq n \\leq 10^4$, 0≤m≤104$0 \\leq m \\leq 10^4$).\nThe next m$m$ lines describe the edges. The i$i$-th of these lines contains two integers ui$u_i$ and vi−$v_i-$ the indices of endpoints of the i$i$-th edge (1≤ui,vi≤n$1 \\leq u_i, v_i \\leq n$, ui≠vi$u_i \\neq v_i$).\nIt is guaranteed that the graph does not contain self-loops nor multiple edges. It is not guaranteed that the graph is connected.\n\n-----Output:-----\nPrint a single number per test case −$-$ the maximum size of an antichain in the graph.\n\n-----Constraints-----\n- 1≤T≤10$1 \\leq T \\leq 10$\n- 1≤n≤104$1 \\leq n \\leq 10^4$\n- 0≤m≤104$0 \\leq m \\leq 10^4$\n- 1≤ui,vi≤n$1 \\leq u_i, v_i \\leq n$\n- ui≠vi$u_i \\neq v_i$\n\n-----Sample Input:-----\n3\n3 3\n1 2\n1 3\n2 3\n4 2\n1 2\n3 4\n5 0\n\n-----Sample Output:-----\n3\n1\n0\n\n-----EXPLANATION:-----\nIn the first sample all three edges form an antimatching.\nIn the second sample at most one of the two edges can be included in an antimatching since they do not share common endpoints.\nIn the third sample there are no edges, hence the answer is 0$0$.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_antimatching (n m : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ntheorem antimatching_nonnegative (n m : Nat) (edges : List (Nat × Nat)) :\n  solve_antimatching n m edges ≥ 0 := sorry\n\n\n\ntheorem antimatching_empty_graph (n : Nat) : \n  solve_antimatching n 0 [] = 0 := sorry\n\ndef vertex_degree (v : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\n\n\ntheorem antimatching_single_vertex :\n  solve_antimatching 1 0 [] = 0 := sorry\n\ntheorem antimatching_single_edge :\n  solve_antimatching 2 1 [(1,2)] = 1 := sorry\n\ntheorem antimatching_triangle :\n  solve_antimatching 3 3 [(1,2), (2,3), (1,3)] = 3 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0534", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nVasya's older brother, Petya, attends an algorithm course in his school. Today he learned about matchings in graphs. Formally, a set of edges in a graph is called a matching if no pair of distinct edges in the set shares a common endpoint.\nPetya instantly came up with an inverse concept, an antimatching. In an antimatching, any pair of distinct edges should have a common endpoint.\nPetya knows that finding a largest matching in a graph is a somewhat formidable task. He wonders if finding the largest antimatching is any easier. Help him find the number of edges in a largest antimatching in a given graph.\n\n-----Input:-----\nThe first line contains T$T$, number of test cases per file.\nThe first line of each test case contains two integers n$n$ and m−$m-$ the number of vertices and edges of the graph respectively (1≤n≤104$1 \\leq n \\leq 10^4$, 0≤m≤104$0 \\leq m \\leq 10^4$).\nThe next m$m$ lines describe the edges. The i$i$-th of these lines contains two integers ui$u_i$ and vi−$v_i-$ the indices of endpoints of the i$i$-th edge (1≤ui,vi≤n$1 \\leq u_i, v_i \\leq n$, ui≠vi$u_i \\neq v_i$).\nIt is guaranteed that the graph does not contain self-loops nor multiple edges. It is not guaranteed that the graph is connected.\n\n-----Output:-----\nPrint a single number per test case −$-$ the maximum size of an antichain in the graph.\n\n-----Constraints-----\n- 1≤T≤10$1 \\leq T \\leq 10$\n- 1≤n≤104$1 \\leq n \\leq 10^4$\n- 0≤m≤104$0 \\leq m \\leq 10^4$\n- 1≤ui,vi≤n$1 \\leq u_i, v_i \\leq n$\n- ui≠vi$u_i \\neq v_i$\n\n-----Sample Input:-----\n3\n3 3\n1 2\n1 3\n2 3\n4 2\n1 2\n3 4\n5 0\n\n-----Sample Output:-----\n3\n1\n0\n\n-----EXPLANATION:-----\nIn the first sample all three edges form an antimatching.\nIn the second sample at most one of the two edges can be included in an antimatching since they do not share common endpoints.\nIn the third sample there are no edges, hence the answer is 0$0$.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_antimatching (n m : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ntheorem antimatching_nonnegative (n m : Nat) (edges : List (Nat × Nat)) :\n  solve_antimatching n m edges ≥ 0 := sorry\n\n\n\ntheorem antimatching_empty_graph (n : Nat) : \n  solve_antimatching n 0 [] = 0 := sorry\n\ndef vertex_degree (v : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\n\n\ntheorem antimatching_single_vertex :\n  solve_antimatching 1 0 [] = 0 := sorry\n\ntheorem antimatching_single_edge :\n  solve_antimatching 2 1 [(1,2)] = 1 := sorry\n\ntheorem antimatching_triangle :\n  solve_antimatching 3 3 [(1,2), (2,3), (1,3)] = 3 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0534"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nSebi goes to school daily with his father. They cross a big highway in the car to reach to the school. Sebi sits in front seat beside his father at driving seat. To kill boredom, they play a game of guessing speed of other cars on the highway. Sebi makes a guess of other car's speed being SG kph, his father FG kph. \n\nThe highway is usually empty, so the drivers use cruise control, i.e. vehicles run at a constant speed. There are markers on the highway at a gap of 50 meters. Both father-son duo wants to check the accuracy of their guesses. For that, they start a timer at the instant at which their car and the other car (which speed they are guessing) are parallel to each other (they need not to be against some marker, they can be in between the markers too). After some T seconds, they observe that both the cars are next to some markers and the number of markers in between the markers of their car and the other car is D - 1 (excluding the markers next to both the cars). Also, they can observe these markers easily because the other car is faster than their. Speed of Sebi's father's car is S. Using this information, one can find the speed of the other car accurately.\n\nAn example situation when Sebi's father starts the timer. Notice that both the car's are parallel to each other.\n\nExample situation after T seconds. The cars are next to the markers. Here the value of D is 1. The green car is Sebi's and the other car is of blue color.\n\nSebi's a child, he does not know how to find the check whose guess is close to the real speed of the car. He does not trust his father as he thinks that he might cheat. Can you help to resolve this issue between them by telling whose guess is closer. If Sebi's guess is better, output \"SEBI\". If his father's guess is better, output \"FATHER\". If both the guess are equally close, then output \"DRAW\".\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. \nEach of the next T lines contain five space separated integers S, SG, FG, D, T corresponding to the Sebi's car speed, Sebi's guess, his father's guess, D as defined in the statement and the time at which both the cars at against the markers (in seconds), respectively.\n\n-----Output-----\nOutput description.\nFor each test case, output a single line containing \"SEBI\", \"FATHER\" or \"DRAW\" (without quotes) denoting whose guess is better.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10000\n- 0 ≤ S ≤ 130\n- 0 ≤ SG, FG ≤ 300\n- 1 ≤ D ≤ 30\n- 1 ≤ T ≤ 300\n-  The other car speed doesn't exceed 300 kph.\n\n-----Example-----\nInput:\n2\n100 180 200 20 60\n130 131 132 1 72\n\nOutput:\nSEBI\nFATHER\n\n-----Explanation-----\nExample case 1.\nThere are total 20 - 1 = 19 markers in between the Sebi's car and the other car. So, the distance between those cars at time T is 20 * 50 = 1000 meters = 1 km.\nAs T = 60 seconds, i.e. 1 minutes. So, the other car goes 1 km more than Sebi's car in 1 minute. So, the other car will go 60 km more than Sebi's car in 1 hour. So, its speed is 60 kmph more than Sebi's car, i.e. 160 kmph.\nSebi had made a guess of 180 kmph, while his father of 200 kmph. Other car's real speed is 160 kmph. So, Sebi's guess is better than his father. Hence he wins the game.\nExample case 2.\n\nThe situation of this example is depicted in the image provided in the statement. You can find the speed of other car and see that Father's guess is more accurate.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Winner where\n  | SEBI : Winner\n  | FATHER : Winner\n  | DRAW : Winner\n\ndef determine_winner (S : Nat) (SG : Nat) (FG : Nat) (D : Nat) (T : Nat) : Winner :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry\n\ndef nat_minus (a b : Nat) : Nat :=\n  sorry\n\ntheorem determine_winner_valid (S SG FG D T : Nat) :\n  ∃ w : Winner, determine_winner S SG FG D T = w\n  := sorry\n\ntheorem determine_winner_draw_when_equidistant (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) = 0 →\n  determine_winner S SG FG D T = Winner.DRAW\n  := sorry\n\ntheorem determine_winner_father_when_further (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) > 0 →\n  determine_winner S SG FG D T = Winner.FATHER\n  := sorry\n\ntheorem determine_winner_sebi_when_closer (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) < 0 →\n  determine_winner S SG FG D T = Winner.SEBI\n  := sorry\n\ntheorem determine_winner_same_guess_draw (S G D T : Nat) :\n  determine_winner S G G D T = Winner.DRAW\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0538", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nSebi goes to school daily with his father. They cross a big highway in the car to reach to the school. Sebi sits in front seat beside his father at driving seat. To kill boredom, they play a game of guessing speed of other cars on the highway. Sebi makes a guess of other car's speed being SG kph, his father FG kph. \n\nThe highway is usually empty, so the drivers use cruise control, i.e. vehicles run at a constant speed. There are markers on the highway at a gap of 50 meters. Both father-son duo wants to check the accuracy of their guesses. For that, they start a timer at the instant at which their car and the other car (which speed they are guessing) are parallel to each other (they need not to be against some marker, they can be in between the markers too). After some T seconds, they observe that both the cars are next to some markers and the number of markers in between the markers of their car and the other car is D - 1 (excluding the markers next to both the cars). Also, they can observe these markers easily because the other car is faster than their. Speed of Sebi's father's car is S. Using this information, one can find the speed of the other car accurately.\n\nAn example situation when Sebi's father starts the timer. Notice that both the car's are parallel to each other.\n\nExample situation after T seconds. The cars are next to the markers. Here the value of D is 1. The green car is Sebi's and the other car is of blue color.\n\nSebi's a child, he does not know how to find the check whose guess is close to the real speed of the car. He does not trust his father as he thinks that he might cheat. Can you help to resolve this issue between them by telling whose guess is closer. If Sebi's guess is better, output \"SEBI\". If his father's guess is better, output \"FATHER\". If both the guess are equally close, then output \"DRAW\".\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. \nEach of the next T lines contain five space separated integers S, SG, FG, D, T corresponding to the Sebi's car speed, Sebi's guess, his father's guess, D as defined in the statement and the time at which both the cars at against the markers (in seconds), respectively.\n\n-----Output-----\nOutput description.\nFor each test case, output a single line containing \"SEBI\", \"FATHER\" or \"DRAW\" (without quotes) denoting whose guess is better.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10000\n- 0 ≤ S ≤ 130\n- 0 ≤ SG, FG ≤ 300\n- 1 ≤ D ≤ 30\n- 1 ≤ T ≤ 300\n-  The other car speed doesn't exceed 300 kph.\n\n-----Example-----\nInput:\n2\n100 180 200 20 60\n130 131 132 1 72\n\nOutput:\nSEBI\nFATHER\n\n-----Explanation-----\nExample case 1.\nThere are total 20 - 1 = 19 markers in between the Sebi's car and the other car. So, the distance between those cars at time T is 20 * 50 = 1000 meters = 1 km.\nAs T = 60 seconds, i.e. 1 minutes. So, the other car goes 1 km more than Sebi's car in 1 minute. So, the other car will go 60 km more than Sebi's car in 1 hour. So, its speed is 60 kmph more than Sebi's car, i.e. 160 kmph.\nSebi had made a guess of 180 kmph, while his father of 200 kmph. Other car's real speed is 160 kmph. So, Sebi's guess is better than his father. Hence he wins the game.\nExample case 2.\n\nThe situation of this example is depicted in the image provided in the statement. You can find the speed of other car and see that Father's guess is more accurate.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Winner where\n  | SEBI : Winner\n  | FATHER : Winner\n  | DRAW : Winner\n\ndef determine_winner (S : Nat) (SG : Nat) (FG : Nat) (D : Nat) (T : Nat) : Winner :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry\n\ndef nat_minus (a b : Nat) : Nat :=\n  sorry\n\ntheorem determine_winner_valid (S SG FG D T : Nat) :\n  ∃ w : Winner, determine_winner S SG FG D T = w\n  := sorry\n\ntheorem determine_winner_draw_when_equidistant (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) = 0 →\n  determine_winner S SG FG D T = Winner.DRAW\n  := sorry\n\ntheorem determine_winner_father_when_further (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) > 0 →\n  determine_winner S SG FG D T = Winner.FATHER\n  := sorry\n\ntheorem determine_winner_sebi_when_closer (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) < 0 →\n  determine_winner S SG FG D T = Winner.SEBI\n  := sorry\n\ntheorem determine_winner_same_guess_draw (S G D T : Nat) :\n  determine_winner S G G D T = Winner.DRAW\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0538"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nProf. Sergio Marquina is a mathematics teacher at the University of Spain. Whenever he comes across any good question(with complexity k), he gives that question to students within roll number range i and j.\nAt the start of the semester he assigns a score of 10 to every student in his class if a student submits a question of complexity k, his score gets multiplied by k.\nThis month he gave M questions and he is wondering what will be mean of maximum scores of all the students. He is busy planning a tour of the Bank of Spain for his students, can you help him?\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains the first line of input, two integers N, M i.e. Number of students in the class and number of questions given in this month.\n- Next M lines contain 3 integers -i,j,k i.e. starting roll number, end roll number, and complexity of the question\n\n-----Output:-----\n- For each test case, output in a single line answer - floor value of Mean of the maximum possible score for all students.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N, M \\leq 105$\n- $1 \\leq i \\leq j \\leq N$\n- $1 \\leq k \\leq 100$\n\n-----Sample Input:-----\n1\n5 3\n1 3 5\n2 5 2\n3 4 7\n\n-----Sample Output:-----\n202\n\n-----EXPLANATION:-----\nInitial score of students will be : [10,10,10,10,10]\nafter solving question 1 scores will be: [50,50,50,10,10]\nafter solving question 2 scores will be: [50,100,100,20,20]\nafter solving question 1 scores will be: [50,100,700,140,20]\nHence after all questions mean of maximum scores will (50+100+700+140+20)/5=202\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nnamespace ProfessorScores\n\ndef solve_professor_scores (n m : Nat) (questions : List (Nat × Nat × Nat)) : Nat :=\n  sorry\n\ntheorem result_is_nonnegative (n m : Nat) (questions : List (Nat × Nat × Nat)) :\n  solve_professor_scores n m questions ≥ 0 := sorry\n\ntheorem result_bounded_by_max (n m : Nat) (questions : List (Nat × Nat × Nat)) :\n  solve_professor_scores n m questions ≤ 10 * (10 ^ questions.length) := sorry\n\n\n\ntheorem all_students_same_k (n k : Nat) :\n  n > 0 → k > 0 → k ≤ 10 → solve_professor_scores n 1 [(1,n,k)] = 10 * k := sorry\n\nend ProfessorScores\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0557", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nProf. Sergio Marquina is a mathematics teacher at the University of Spain. Whenever he comes across any good question(with complexity k), he gives that question to students within roll number range i and j.\nAt the start of the semester he assigns a score of 10 to every student in his class if a student submits a question of complexity k, his score gets multiplied by k.\nThis month he gave M questions and he is wondering what will be mean of maximum scores of all the students. He is busy planning a tour of the Bank of Spain for his students, can you help him?\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains the first line of input, two integers N, M i.e. Number of students in the class and number of questions given in this month.\n- Next M lines contain 3 integers -i,j,k i.e. starting roll number, end roll number, and complexity of the question\n\n-----Output:-----\n- For each test case, output in a single line answer - floor value of Mean of the maximum possible score for all students.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N, M \\leq 105$\n- $1 \\leq i \\leq j \\leq N$\n- $1 \\leq k \\leq 100$\n\n-----Sample Input:-----\n1\n5 3\n1 3 5\n2 5 2\n3 4 7\n\n-----Sample Output:-----\n202\n\n-----EXPLANATION:-----\nInitial score of students will be : [10,10,10,10,10]\nafter solving question 1 scores will be: [50,50,50,10,10]\nafter solving question 2 scores will be: [50,100,100,20,20]\nafter solving question 1 scores will be: [50,100,700,140,20]\nHence after all questions mean of maximum scores will (50+100+700+140+20)/5=202\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nnamespace ProfessorScores\n\ndef solve_professor_scores (n m : Nat) (questions : List (Nat × Nat × Nat)) : Nat :=\n  sorry\n\ntheorem result_is_nonnegative (n m : Nat) (questions : List (Nat × Nat × Nat)) :\n  solve_professor_scores n m questions ≥ 0 := sorry\n\ntheorem result_bounded_by_max (n m : Nat) (questions : List (Nat × Nat × Nat)) :\n  solve_professor_scores n m questions ≤ 10 * (10 ^ questions.length) := sorry\n\n\n\ntheorem all_students_same_k (n k : Nat) :\n  n > 0 → k > 0 → k ≤ 10 → solve_professor_scores n 1 [(1,n,k)] = 10 * k := sorry\n\nend ProfessorScores\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0557"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef's new hobby is painting, but he learned the fact that it's not easy to paint 2D pictures in a hard way, after wasting a lot of canvas paper, paint and of course time. From now on, he decided to paint 1D pictures only.\nChef's canvas is N millimeters long and is initially all white. For simplicity, colors will be represented by an integer between 0 and 105. 0 indicates white. The picture he is envisioning is also N millimeters long and the ith millimeter consists purely of the color Ci. Unfortunately, his brush isn't fine enough to paint every millimeter one by one. The brush is 3 millimeters wide and so it can only paint three millimeters at a time with the same color. Painting over the same place completely replaces the color by the new one. Also, Chef has lots of bottles of paints of each color, so he will never run out of paint of any color.\nChef also doesn't want to ruin the edges of the canvas, so he doesn't want to paint any part beyond the painting. This means, for example, Chef cannot paint just the first millimeter of the canvas, or just the last two millimeters, etc.\nHelp Chef by telling him whether he can finish the painting or not with these restrictions.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N. The second line contains N space-separated integers C1, C2, ..., CN denoting the colors of Chef's painting.\n\n-----Output-----\nFor each test case, output a single line containing either “Yes” or “No” (without quotes), denoting whether Chef can finish the painting or not.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 3 ≤ N ≤ 105\n- The sum of the Ns over all the test cases in a single test file is ≤ 5×105\n- 1 ≤ Ci ≤ 105\n\n-----Example-----\nInput:3\n4\n1 5 5 5\n4\n1 1 1 5\n3\n5 5 2\nOutput:Yes\nYes\nNo\n\n-----Explanation-----\nExample case 1. Chef's canvas initially contains the colors [0,0,0,0]. Chef can finish the painting by first painting the first three millimeters with color 1, so the colors become [1,1,1,0], and then the last three millimeters with color 5 so that it becomes [1,5,5,5].\nExample case 2. Chef's canvas initially contains the colors [0,0,0,0]. Chef can finish the painting by first painting the last three millimeters by color 5 so the colors become [0,5,5,5], and then the first three millimeters by color 1 so it becomes [1,1,1,5].\nExample case 3. In this test case, Chef can only paint the painting as a whole, so all parts must have the same color, and the task is impossible.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_chef_paint (arr : List Int) : String := sorry\n\ntheorem can_chef_paint_returns_valid_response {arr : List Int} (h : arr.length ≥ 3) :\n  can_chef_paint arr = \"Yes\" ∨ can_chef_paint arr = \"No\" := sorry\n\ntheorem can_chef_paint_valid_inputs {arr : List Int} (h1 : arr.length ≥ 3)\n  (h2 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 5) :\n  (∃ i, i ≥ 1 ∧ i < arr.length - 1 ∧ \n    arr[i-1]! = arr[i]! ∧ arr[i]! = arr[i+1]!) ↔ \n  can_chef_paint arr = \"Yes\" := sorry\n\ntheorem can_chef_paint_array_bounds {arr : List Int} \n  (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10) :\n  can_chef_paint arr = \"Yes\" → \n  ∃ i, i ≥ 1 ∧ i < arr.length - 1 ∧ \n    arr[i-1]! = arr[i]! ∧ arr[i]! = arr[i+1]! := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0567", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef's new hobby is painting, but he learned the fact that it's not easy to paint 2D pictures in a hard way, after wasting a lot of canvas paper, paint and of course time. From now on, he decided to paint 1D pictures only.\nChef's canvas is N millimeters long and is initially all white. For simplicity, colors will be represented by an integer between 0 and 105. 0 indicates white. The picture he is envisioning is also N millimeters long and the ith millimeter consists purely of the color Ci. Unfortunately, his brush isn't fine enough to paint every millimeter one by one. The brush is 3 millimeters wide and so it can only paint three millimeters at a time with the same color. Painting over the same place completely replaces the color by the new one. Also, Chef has lots of bottles of paints of each color, so he will never run out of paint of any color.\nChef also doesn't want to ruin the edges of the canvas, so he doesn't want to paint any part beyond the painting. This means, for example, Chef cannot paint just the first millimeter of the canvas, or just the last two millimeters, etc.\nHelp Chef by telling him whether he can finish the painting or not with these restrictions.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N. The second line contains N space-separated integers C1, C2, ..., CN denoting the colors of Chef's painting.\n\n-----Output-----\nFor each test case, output a single line containing either “Yes” or “No” (without quotes), denoting whether Chef can finish the painting or not.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 3 ≤ N ≤ 105\n- The sum of the Ns over all the test cases in a single test file is ≤ 5×105\n- 1 ≤ Ci ≤ 105\n\n-----Example-----\nInput:3\n4\n1 5 5 5\n4\n1 1 1 5\n3\n5 5 2\nOutput:Yes\nYes\nNo\n\n-----Explanation-----\nExample case 1. Chef's canvas initially contains the colors [0,0,0,0]. Chef can finish the painting by first painting the first three millimeters with color 1, so the colors become [1,1,1,0], and then the last three millimeters with color 5 so that it becomes [1,5,5,5].\nExample case 2. Chef's canvas initially contains the colors [0,0,0,0]. Chef can finish the painting by first painting the last three millimeters by color 5 so the colors become [0,5,5,5], and then the first three millimeters by color 1 so it becomes [1,1,1,5].\nExample case 3. In this test case, Chef can only paint the painting as a whole, so all parts must have the same color, and the task is impossible.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_chef_paint (arr : List Int) : String := sorry\n\ntheorem can_chef_paint_returns_valid_response {arr : List Int} (h : arr.length ≥ 3) :\n  can_chef_paint arr = \"Yes\" ∨ can_chef_paint arr = \"No\" := sorry\n\ntheorem can_chef_paint_valid_inputs {arr : List Int} (h1 : arr.length ≥ 3)\n  (h2 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 5) :\n  (∃ i, i ≥ 1 ∧ i < arr.length - 1 ∧ \n    arr[i-1]! = arr[i]! ∧ arr[i]! = arr[i+1]!) ↔ \n  can_chef_paint arr = \"Yes\" := sorry\n\ntheorem can_chef_paint_array_bounds {arr : List Int} \n  (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10) :\n  can_chef_paint arr = \"Yes\" → \n  ∃ i, i ≥ 1 ∧ i < arr.length - 1 ∧ \n    arr[i-1]! = arr[i]! ∧ arr[i]! = arr[i+1]! := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0567"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou may have tried your level best to help Chef but Dr Doof has managed to come up with his masterplan in the meantime. Sadly, you have to help Chef once again. Dr Doof has designed a parenthesis-inator. It throws a stream of $N$ brackets at the target, $1$ bracket per second. The brackets can either be opening or closing. Chef appears in front of the stream at time $t$. If Chef faces an opening bracket, he gets hit. However, if he faces a closing bracket, he may choose to let it pass through him (Chef is immune to closing brackets). Chef gets a chance to counter attack Doof as soon as he finds a balanced non-empty bracket sequence. Help Chef by providing him the minimum time $x$ at which he will be able to launch his counter attack. If Chef is unable to counter attack, answer $-1$.\nFormally, you are given a string $S$ of length $N$ consisting only of opening brackets $($ and closing brackets $)$. The substring of $S$ starting at index $L$ and ending at index $R$, i.e. $S_L S_{L+1} \\ldots S_{R}$ is denoted by $S[L, R]$ . Consider $Q$ cases. In the $i^{\\text{th}}$ case, Chef appears at time $t_i$ $(1 \\leq t_i \\leq N)$ and faces all characters from index $t_i$ to $N$. Find the minimum index $x$ $(t_i \\leq x \\leq N)$ such that the substring $S[t_i, x]$ contains a non-empty balanced bracket subsequence containing the same number of opening brackets as $S[t_i, x]$ (i.e., you cannot remove any opening bracket from the substring). If such an $x$ does not exist, print $-1$.\nA string $X$ is called a subsequence of a string $Y$ if it is possible to obtain $X$ by erasing some (possibly zero) characters from $Y$ without changing the order of the remaining characters.\nA balanced bracket sequence is defined as:  \n- an empty string is a balanced bracket sequence.\n- if $s$ is a balanced bracket sequence, then so is $(s)$.\n- if $s$ and $t$ are balanced bracket sequences, then so is $st$.\n$Note :-$ The input files are large. The use of Fast I/O is recommended.\n\n-----Input-----\n- The first line contains a single integer $T$ denoting the number of testcases.\n- The first line of each test case contains the string $S$.\n- The next line contains a single integer $Q$ denoting the number of cases to consider.\n- The next line contains $Q$ space separated integers, each denoting $t_i$.\n\n-----Output-----\nFor each query, print the minimum value of $x$ in a separate line. If no such $x$ exists, print $-1$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq |S| \\leq 10^7$\n- $1 \\leq Q \\leq 10^6$\n- $1 \\leq t_i \\leq N$\n- Every character of $S$ is either $($ or $)$.\n- Sum of $|S|$ and $Q$ over all testcases for a particular test file does not exceed $10^7$ and $10^6$ respectively.\n\n-----Sample Input-----\n1\n)())((()\n3\n1 7 6\n\n-----Sample Output-----\n3\n8\n-1\n\n-----Explanation-----\nFor the first query, Chef chooses to let $S_1$ pass through him, gets hit by $S_2$ and finally completes a balanced bracket sequence by adding $S_3$ to $S_2$ at time $x$ = $3$.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solveBracketSequence (s : String) (queries : List Nat) : List Int := sorry\n\ntheorem arbitrary_brackets_results_valid \n  (s : String) \n  (queries : List Nat) \n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = '(' ∨ c = ')')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ r ∈ result, -1 ≤ r ∧ r ≤ s.length := sorry\n\ntheorem arbitrary_brackets_positions_valid\n  (s : String)\n  (queries : List Nat)\n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = '(' ∨ c = ')')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ (q : Nat) (r : Int),\n    q ∈ queries →\n    r ∈ result →\n    r ≠ -1 →\n    s.data[r.toNat - 1]? = some ')' ∧ r > q := sorry\n\ntheorem all_open_brackets_no_matches\n  (s : String)\n  (queries : List Nat)\n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = '(')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ r ∈ result, r = -1 := sorry\n\ntheorem all_close_brackets_no_matches\n  (s : String)\n  (queries : List Nat)\n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = ')')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ r ∈ result, r = -1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0582", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou may have tried your level best to help Chef but Dr Doof has managed to come up with his masterplan in the meantime. Sadly, you have to help Chef once again. Dr Doof has designed a parenthesis-inator. It throws a stream of $N$ brackets at the target, $1$ bracket per second. The brackets can either be opening or closing. Chef appears in front of the stream at time $t$. If Chef faces an opening bracket, he gets hit. However, if he faces a closing bracket, he may choose to let it pass through him (Chef is immune to closing brackets). Chef gets a chance to counter attack Doof as soon as he finds a balanced non-empty bracket sequence. Help Chef by providing him the minimum time $x$ at which he will be able to launch his counter attack. If Chef is unable to counter attack, answer $-1$.\nFormally, you are given a string $S$ of length $N$ consisting only of opening brackets $($ and closing brackets $)$. The substring of $S$ starting at index $L$ and ending at index $R$, i.e. $S_L S_{L+1} \\ldots S_{R}$ is denoted by $S[L, R]$ . Consider $Q$ cases. In the $i^{\\text{th}}$ case, Chef appears at time $t_i$ $(1 \\leq t_i \\leq N)$ and faces all characters from index $t_i$ to $N$. Find the minimum index $x$ $(t_i \\leq x \\leq N)$ such that the substring $S[t_i, x]$ contains a non-empty balanced bracket subsequence containing the same number of opening brackets as $S[t_i, x]$ (i.e., you cannot remove any opening bracket from the substring). If such an $x$ does not exist, print $-1$.\nA string $X$ is called a subsequence of a string $Y$ if it is possible to obtain $X$ by erasing some (possibly zero) characters from $Y$ without changing the order of the remaining characters.\nA balanced bracket sequence is defined as:  \n- an empty string is a balanced bracket sequence.\n- if $s$ is a balanced bracket sequence, then so is $(s)$.\n- if $s$ and $t$ are balanced bracket sequences, then so is $st$.\n$Note :-$ The input files are large. The use of Fast I/O is recommended.\n\n-----Input-----\n- The first line contains a single integer $T$ denoting the number of testcases.\n- The first line of each test case contains the string $S$.\n- The next line contains a single integer $Q$ denoting the number of cases to consider.\n- The next line contains $Q$ space separated integers, each denoting $t_i$.\n\n-----Output-----\nFor each query, print the minimum value of $x$ in a separate line. If no such $x$ exists, print $-1$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq |S| \\leq 10^7$\n- $1 \\leq Q \\leq 10^6$\n- $1 \\leq t_i \\leq N$\n- Every character of $S$ is either $($ or $)$.\n- Sum of $|S|$ and $Q$ over all testcases for a particular test file does not exceed $10^7$ and $10^6$ respectively.\n\n-----Sample Input-----\n1\n)())((()\n3\n1 7 6\n\n-----Sample Output-----\n3\n8\n-1\n\n-----Explanation-----\nFor the first query, Chef chooses to let $S_1$ pass through him, gets hit by $S_2$ and finally completes a balanced bracket sequence by adding $S_3$ to $S_2$ at time $x$ = $3$.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solveBracketSequence (s : String) (queries : List Nat) : List Int := sorry\n\ntheorem arbitrary_brackets_results_valid \n  (s : String) \n  (queries : List Nat) \n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = '(' ∨ c = ')')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ r ∈ result, -1 ≤ r ∧ r ≤ s.length := sorry\n\ntheorem arbitrary_brackets_positions_valid\n  (s : String)\n  (queries : List Nat)\n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = '(' ∨ c = ')')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ (q : Nat) (r : Int),\n    q ∈ queries →\n    r ∈ result →\n    r ≠ -1 →\n    s.data[r.toNat - 1]? = some ')' ∧ r > q := sorry\n\ntheorem all_open_brackets_no_matches\n  (s : String)\n  (queries : List Nat)\n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = '(')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ r ∈ result, r = -1 := sorry\n\ntheorem all_close_brackets_no_matches\n  (s : String)\n  (queries : List Nat)\n  (h1 : s.length > 0)\n  (h2 : queries.length > 0)\n  (h3 : ∀ c ∈ s.data, c = ')')\n  (h4 : ∀ q ∈ queries, 0 < q ∧ q ≤ s.length) :\n  let result := solveBracketSequence s queries\n  ∀ r ∈ result, r = -1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0582"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are an evil sorcerer at a round table with $N$ sorcerers (including yourself). You can cast $M$ spells which have distinct powers $p_1, p_2, \\ldots, p_M$.\nYou may perform the following operation any number of times (possibly zero):\n- Assign a living sorcerer to each positive integer cyclically to your left starting from yourself ― the closest living sorcerer to your left is assigned to $1$, the next living sorcerer to the left is assigned to $2$ and so on. Note that each living sorcerer (including yourself) is assigned to an infinite number of integers.\n- Choose a spell $j$ (possibly a spell you have chosen before) and kill the living sorcerer assigned to $p_j$. You may not cast a spell to kill yourself. \n\nWhat is the maximum number of sorcerers you can kill using zero or more operations?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- The second line contains $M$ space-separated integers $p_1, p_2, \\ldots, p_M$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum number of sorcerers you can kill.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10^9$\n- $1 \\le M \\le 3 \\cdot 10^5$\n- $1 \\le p_i \\le 10^9$ for each valid $i$\n- $p_1, p_2, \\ldots, p_N$ are pairwise distinct\n- the sum of $M$ over all test cases does not exceed $3 \\cdot 10^5$\n\n-----Example Input-----\n5\n4 1\n5\n6 2\n2 4\n1 4\n7 16 8 29\n1000000000 1\n998244353\n1 1\n20201220\n\n-----Example Output-----\n3\n4\n0\n1755647\n0\n\n-----Explanation-----\nExample case 1: The initial state is shown in the figure from the statement. We can first use spell $1$ and kill the $5$-th sorcerer to our left, i.e. sorcerer $2$. Now there are $3$ living sorcerers and the state is as shown in the following figure:\n\nWe can use spell $1$ again and kill the current $5$-th living sorcerer to our left, i.e. sorcerer $4$. Now there are $2$ living sorcerers and the state is:\n\nFinally, we can use spell $1$ again and kill the only other living sorcerer, i.e. sorcerer $3$. Now, none of the other sorcerers are alive. As we cannot cast a spell to kill ourselves, we cannot improve the answer any further.\nExample case 2: We can perform $4$ operations using the spell $p_1 = 2$ each time. We can also instead use $p_2 = 4$ in the first two operations and $p_1 = 2$ in the last two operations. Note that there may be multiple valid sequences of operations that lead to the best answer.\nExample case 3: We cannot perform any operations using any of the given spells, so we are unable to kill any sorcerers.\nExample case 4: We can perform $1,755,647$ operations, each of them using the spell $p_1 = 998,244,353$.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef gcd (a b : Nat) : Nat :=\n  sorry\n\ndef solve_evil_sorcerer (n : Nat) (p : List Nat) : Nat :=\n  sorry\n\ntheorem solve_evil_sorcerer_properties {n : Nat} {p : List Nat}\n  (n_pos : n > 0) (p_pos : ∀ x ∈ p, x > 0) :\n  let result := solve_evil_sorcerer n p\n  -- Result is non-negative\n  result ≥ 0 ∧\n  -- Result is less than or equal to n \n  result ≤ n := by\n  sorry\n\ntheorem gcd_properties {a b : Nat} (a_pos : a > 0) (b_pos : b > 0) :\n  let g := gcd a b\n  -- GCD divides both numbers\n  (a % g = 0 ∧ b % g = 0) ∧\n  -- GCD is positive\n  g > 0 ∧\n  -- GCD is largest such number\n  ∀ i, g < i → i ≤ min a b → ¬(a % i = 0 ∧ b % i = 0) := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0585", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are an evil sorcerer at a round table with $N$ sorcerers (including yourself). You can cast $M$ spells which have distinct powers $p_1, p_2, \\ldots, p_M$.\nYou may perform the following operation any number of times (possibly zero):\n- Assign a living sorcerer to each positive integer cyclically to your left starting from yourself ― the closest living sorcerer to your left is assigned to $1$, the next living sorcerer to the left is assigned to $2$ and so on. Note that each living sorcerer (including yourself) is assigned to an infinite number of integers.\n- Choose a spell $j$ (possibly a spell you have chosen before) and kill the living sorcerer assigned to $p_j$. You may not cast a spell to kill yourself. \n\nWhat is the maximum number of sorcerers you can kill using zero or more operations?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- The second line contains $M$ space-separated integers $p_1, p_2, \\ldots, p_M$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum number of sorcerers you can kill.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10^9$\n- $1 \\le M \\le 3 \\cdot 10^5$\n- $1 \\le p_i \\le 10^9$ for each valid $i$\n- $p_1, p_2, \\ldots, p_N$ are pairwise distinct\n- the sum of $M$ over all test cases does not exceed $3 \\cdot 10^5$\n\n-----Example Input-----\n5\n4 1\n5\n6 2\n2 4\n1 4\n7 16 8 29\n1000000000 1\n998244353\n1 1\n20201220\n\n-----Example Output-----\n3\n4\n0\n1755647\n0\n\n-----Explanation-----\nExample case 1: The initial state is shown in the figure from the statement. We can first use spell $1$ and kill the $5$-th sorcerer to our left, i.e. sorcerer $2$. Now there are $3$ living sorcerers and the state is as shown in the following figure:\n\nWe can use spell $1$ again and kill the current $5$-th living sorcerer to our left, i.e. sorcerer $4$. Now there are $2$ living sorcerers and the state is:\n\nFinally, we can use spell $1$ again and kill the only other living sorcerer, i.e. sorcerer $3$. Now, none of the other sorcerers are alive. As we cannot cast a spell to kill ourselves, we cannot improve the answer any further.\nExample case 2: We can perform $4$ operations using the spell $p_1 = 2$ each time. We can also instead use $p_2 = 4$ in the first two operations and $p_1 = 2$ in the last two operations. Note that there may be multiple valid sequences of operations that lead to the best answer.\nExample case 3: We cannot perform any operations using any of the given spells, so we are unable to kill any sorcerers.\nExample case 4: We can perform $1,755,647$ operations, each of them using the spell $p_1 = 998,244,353$.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef gcd (a b : Nat) : Nat :=\n  sorry\n\ndef solve_evil_sorcerer (n : Nat) (p : List Nat) : Nat :=\n  sorry\n\ntheorem solve_evil_sorcerer_properties {n : Nat} {p : List Nat}\n  (n_pos : n > 0) (p_pos : ∀ x ∈ p, x > 0) :\n  let result := solve_evil_sorcerer n p\n  -- Result is non-negative\n  result ≥ 0 ∧\n  -- Result is less than or equal to n \n  result ≤ n := by\n  sorry\n\ntheorem gcd_properties {a b : Nat} (a_pos : a > 0) (b_pos : b > 0) :\n  let g := gcd a b\n  -- GCD divides both numbers\n  (a % g = 0 ∧ b % g = 0) ∧\n  -- GCD is positive\n  g > 0 ∧\n  -- GCD is largest such number\n  ∀ i, g < i → i ≤ min a b → ¬(a % i = 0 ∧ b % i = 0) := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0585"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef Ada is building a new restaurant in the following way:\n- First, $N$ points $X_1, X_2, \\ldots, X_N$ are chosen on the $x$-axis.\n- Then, $N$ columns (numbered $1$ through $N$) are made. For simplicity, the columns are represented as vertical segments; for each valid $i$, the height of the $i$-th segment is $H_i$.\n- Ada assigns a column to each of the points $X_1, X_2, \\ldots, X_N$ in an arbitrary way (each column must be assigned to exactly one point).\n- Finally, Ada constructs the roof of the restaurant, represented by a polyline with $N$ vertices. Let's denote the column assigned to the $i$-th point by $P_i$. For each valid $i$, the $i$-th of these vertices is $(X_i, H_{P_i})$, i.e. the polyline joins the tops of the columns from left to right.\nAda wants the biggest restaurant. Help her choose the positions of the columns in such a way that the area below the roof is the biggest possible. Formally, she wants to maximise the area of the polygon whose perimeter is formed by the roof and the segments $(X_N, H_{P_N}) - (X_N, 0) - (X_1, 0) - (X_1, H_{P_1})$. Let $S$ be this maximum area; you should compute $2 \\cdot S$ (it is guaranteed that $2 \\cdot S$ is an integer).\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains two space-separated integers $X_i$ and $H_i$.\n\n-----Output-----\nFor each test case, print a single line containing one integer $2 \\cdot S$.\n\n-----Constraints-----\n- $1 \\le T \\le 3 \\cdot 10^5$\n- $2 \\le N \\le 10^5$\n- $0 \\le X_1 < X_2 < \\ldots < X_N \\le 2 \\cdot 10^9$\n- $1 \\le H_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Example Input-----\n1\n5\n1 1\n2 2\n3 3\n4 4\n5 5\n\n-----Example Output-----\n27\n\n-----Explanation-----\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef calculate_restaurant_area (points : List (Int × Int)) : Int :=\n  sorry\n\ntheorem restaurant_area_nonnegative {points : List (Int × Int)} :\n  calculate_restaurant_area points ≥ 0 :=\nsorry\n\ntheorem restaurant_area_linear_scaling {points : List (Int × Int)} :\n  calculate_restaurant_area ((points.map (fun p => (p.1, 2 * p.2)))) = \n  2 * calculate_restaurant_area points :=\nsorry \n\ntheorem restaurant_area_shift_invariant {points : List (Int × Int)} :\n  calculate_restaurant_area ((points.map (fun p => (p.1 + 10, p.2)))) = \n  calculate_restaurant_area points :=\nsorry\n\ntheorem restaurant_area_zero_height {points : List (Int × Int)} :\n  calculate_restaurant_area ((points.map (fun p => (p.1, 0)))) = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0597", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef Ada is building a new restaurant in the following way:\n- First, $N$ points $X_1, X_2, \\ldots, X_N$ are chosen on the $x$-axis.\n- Then, $N$ columns (numbered $1$ through $N$) are made. For simplicity, the columns are represented as vertical segments; for each valid $i$, the height of the $i$-th segment is $H_i$.\n- Ada assigns a column to each of the points $X_1, X_2, \\ldots, X_N$ in an arbitrary way (each column must be assigned to exactly one point).\n- Finally, Ada constructs the roof of the restaurant, represented by a polyline with $N$ vertices. Let's denote the column assigned to the $i$-th point by $P_i$. For each valid $i$, the $i$-th of these vertices is $(X_i, H_{P_i})$, i.e. the polyline joins the tops of the columns from left to right.\nAda wants the biggest restaurant. Help her choose the positions of the columns in such a way that the area below the roof is the biggest possible. Formally, she wants to maximise the area of the polygon whose perimeter is formed by the roof and the segments $(X_N, H_{P_N}) - (X_N, 0) - (X_1, 0) - (X_1, H_{P_1})$. Let $S$ be this maximum area; you should compute $2 \\cdot S$ (it is guaranteed that $2 \\cdot S$ is an integer).\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains two space-separated integers $X_i$ and $H_i$.\n\n-----Output-----\nFor each test case, print a single line containing one integer $2 \\cdot S$.\n\n-----Constraints-----\n- $1 \\le T \\le 3 \\cdot 10^5$\n- $2 \\le N \\le 10^5$\n- $0 \\le X_1 < X_2 < \\ldots < X_N \\le 2 \\cdot 10^9$\n- $1 \\le H_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Example Input-----\n1\n5\n1 1\n2 2\n3 3\n4 4\n5 5\n\n-----Example Output-----\n27\n\n-----Explanation-----\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef calculate_restaurant_area (points : List (Int × Int)) : Int :=\n  sorry\n\ntheorem restaurant_area_nonnegative {points : List (Int × Int)} :\n  calculate_restaurant_area points ≥ 0 :=\nsorry\n\ntheorem restaurant_area_linear_scaling {points : List (Int × Int)} :\n  calculate_restaurant_area ((points.map (fun p => (p.1, 2 * p.2)))) = \n  2 * calculate_restaurant_area points :=\nsorry \n\ntheorem restaurant_area_shift_invariant {points : List (Int × Int)} :\n  calculate_restaurant_area ((points.map (fun p => (p.1 + 10, p.2)))) = \n  calculate_restaurant_area points :=\nsorry\n\ntheorem restaurant_area_zero_height {points : List (Int × Int)} :\n  calculate_restaurant_area ((points.map (fun p => (p.1, 0)))) = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0597"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nRoman has no idea, why this problem is called Stone. He also has no idea on how to solve the followong problem: given array of N integers A and a number K. During a turn the maximal value over all Ai is chosen, let's call it MAX. Then Ai = \nMAX - Ai is done for every 1 <= i <= N. Help Roman to find out how will the array look like after K turns.\n\n-----Input-----\nThe numbers N and K are given in the first line of an input. Then N integers are given in the second line which denote the array A. \n\n-----Output-----\nOutput N numbers on a single line. It should be the array A after K turns.\n\n-----Constraints-----\n\n- 1 <= N <= 105\n- 0 <= K <= 109\n- Ai does not exceed 2 * 109 by it's absolute value.\n\n-----Example-----\nInput:\n4 1\n5 -1 7 0\n\nOutput:\n2 8 0 7\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_stone_array (n k : Nat) (A : List Int) : List Int :=\n  sorry\n\ndef list_maximum (l : List Int) : Int :=\n  sorry\n\ndef list_minimum (l : List Int) : Int :=\n  sorry\n\ntheorem stone_array_output_length {n k : Nat} {A : List Int} :\n  List.length (solve_stone_array n k A) = List.length A :=\n  sorry\n\ntheorem stone_array_zero_k {n : Nat} {A : List Int} :\n  solve_stone_array n 0 A = A :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0598", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nRoman has no idea, why this problem is called Stone. He also has no idea on how to solve the followong problem: given array of N integers A and a number K. During a turn the maximal value over all Ai is chosen, let's call it MAX. Then Ai = \nMAX - Ai is done for every 1 <= i <= N. Help Roman to find out how will the array look like after K turns.\n\n-----Input-----\nThe numbers N and K are given in the first line of an input. Then N integers are given in the second line which denote the array A. \n\n-----Output-----\nOutput N numbers on a single line. It should be the array A after K turns.\n\n-----Constraints-----\n\n- 1 <= N <= 105\n- 0 <= K <= 109\n- Ai does not exceed 2 * 109 by it's absolute value.\n\n-----Example-----\nInput:\n4 1\n5 -1 7 0\n\nOutput:\n2 8 0 7\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_stone_array (n k : Nat) (A : List Int) : List Int :=\n  sorry\n\ndef list_maximum (l : List Int) : Int :=\n  sorry\n\ndef list_minimum (l : List Int) : Int :=\n  sorry\n\ntheorem stone_array_output_length {n k : Nat} {A : List Int} :\n  List.length (solve_stone_array n k A) = List.length A :=\n  sorry\n\ntheorem stone_array_zero_k {n : Nat} {A : List Int} :\n  solve_stone_array n 0 A = A :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0598"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThe bustling town of Siruseri has just one sports stadium. There are a number of schools, colleges, sports associations, etc. that use this stadium as the venue for their sports events.\nAnyone interested in using the stadium has to apply to the Manager of the stadium indicating both the starting date (a positive integer $S$) and the length of the sporting event in days (a positive integer $D$) they plan to organise. Since these requests could overlap it may not be possible to satisfy everyone. Also, there should be at least one gap day between any two approved events, so that the stadium can be cleaned.\nIt is the job of the Manager to decide who gets to use the stadium and who does not. The Manager, being a genial man, would like to keep as many organisations happy as possible and hence would like to allocate the stadium so that maximum number of events are held.\nSuppose, for example, the Manager receives the following 4 requests:\n$ $\nEvent No.   Starting Date        Length \n\n1                   2                    5\n2                   9                    7\n3                  15                    6\n4                   9                    3\n\n$ $ \nHe would allot the stadium to events $1$, $4$ and $3$. Event $1$ begins on day $2$ and ends on day $6$, event $4$ begins on day $9$ and ends on day $11$ and event $3$ begins on day $15$ and ends on day $20$. You can verify that it is not possible to schedule all the $4$ events (since events $2$ and $3$ overlap and only one of them can get to use the stadium).\nYour task is to help the manager find the best possible allotment (i.e., the maximum number of events that can use the stadium).\n\n-----Input:-----\nThe first line of the input will contain a single integer $N$ indicating the number of events for which the Manager has received a request. Lines $2,3,...,N+1$ describe the requirements of the $N$ events. Line $i+1$ contains two integer $S_i$ and $D_i$ indicating the starting date and the duration of event $i$.\n\n-----Output:-----\nYour output must consist of a single line containing a single integer $M$, indicating the maximum possible number of events that can use the stadium.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 100000$.\n- $1 \\leq S_i \\leq 1000000$.\n- $1 \\leq D_i \\leq 1000$.\n- $50 \\%$ of test cases will also satisfy $1 \\leq N \\leq 10000$.\n\n-----Sample input:-----\n4\n2 5\n9 7\n15 6\n9 3\n\n-----Sample output:-----\n3\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef maxStadiumEvents (events : List (Nat × Nat)) : Nat := sorry\n\ntheorem maxStadiumEvents_non_negative (events : List (Nat × Nat)) :\n  maxStadiumEvents events ≥ 0 := sorry\n\ntheorem maxStadiumEvents_bounded_by_input (events : List (Nat × Nat)) :\n  maxStadiumEvents events ≤ events.length := sorry\n\ntheorem maxStadiumEvents_empty :\n  maxStadiumEvents [] = 0 := sorry\n\ntheorem maxStadiumEvents_single_event (start duration : Nat) :\n  maxStadiumEvents [(start, duration)] = 1 := sorry\n\ntheorem maxStadiumEvents_non_overlapping (events : List (Nat × Nat)) (h : events.length > 0) :\n  (∀ i j, i < events.length → j < events.length → i ≠ j →\n    ((events.get! i).1 + (events.get! i).2 ≤ (events.get! j).1) ∨ \n    ((events.get! j).1 + (events.get! j).2 ≤ (events.get! i).1)) →\n  maxStadiumEvents events = events.length := sorry\n\ntheorem maxStadiumEvents_all_overlapping (events : List (Nat × Nat)) (h : events.length ≥ 2) :\n  maxStadiumEvents (List.map (fun e => (0, e.2)) events) = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0601", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThe bustling town of Siruseri has just one sports stadium. There are a number of schools, colleges, sports associations, etc. that use this stadium as the venue for their sports events.\nAnyone interested in using the stadium has to apply to the Manager of the stadium indicating both the starting date (a positive integer $S$) and the length of the sporting event in days (a positive integer $D$) they plan to organise. Since these requests could overlap it may not be possible to satisfy everyone. Also, there should be at least one gap day between any two approved events, so that the stadium can be cleaned.\nIt is the job of the Manager to decide who gets to use the stadium and who does not. The Manager, being a genial man, would like to keep as many organisations happy as possible and hence would like to allocate the stadium so that maximum number of events are held.\nSuppose, for example, the Manager receives the following 4 requests:\n$ $\nEvent No.   Starting Date        Length \n\n1                   2                    5\n2                   9                    7\n3                  15                    6\n4                   9                    3\n\n$ $ \nHe would allot the stadium to events $1$, $4$ and $3$. Event $1$ begins on day $2$ and ends on day $6$, event $4$ begins on day $9$ and ends on day $11$ and event $3$ begins on day $15$ and ends on day $20$. You can verify that it is not possible to schedule all the $4$ events (since events $2$ and $3$ overlap and only one of them can get to use the stadium).\nYour task is to help the manager find the best possible allotment (i.e., the maximum number of events that can use the stadium).\n\n-----Input:-----\nThe first line of the input will contain a single integer $N$ indicating the number of events for which the Manager has received a request. Lines $2,3,...,N+1$ describe the requirements of the $N$ events. Line $i+1$ contains two integer $S_i$ and $D_i$ indicating the starting date and the duration of event $i$.\n\n-----Output:-----\nYour output must consist of a single line containing a single integer $M$, indicating the maximum possible number of events that can use the stadium.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 100000$.\n- $1 \\leq S_i \\leq 1000000$.\n- $1 \\leq D_i \\leq 1000$.\n- $50 \\%$ of test cases will also satisfy $1 \\leq N \\leq 10000$.\n\n-----Sample input:-----\n4\n2 5\n9 7\n15 6\n9 3\n\n-----Sample output:-----\n3\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef maxStadiumEvents (events : List (Nat × Nat)) : Nat := sorry\n\ntheorem maxStadiumEvents_non_negative (events : List (Nat × Nat)) :\n  maxStadiumEvents events ≥ 0 := sorry\n\ntheorem maxStadiumEvents_bounded_by_input (events : List (Nat × Nat)) :\n  maxStadiumEvents events ≤ events.length := sorry\n\ntheorem maxStadiumEvents_empty :\n  maxStadiumEvents [] = 0 := sorry\n\ntheorem maxStadiumEvents_single_event (start duration : Nat) :\n  maxStadiumEvents [(start, duration)] = 1 := sorry\n\ntheorem maxStadiumEvents_non_overlapping (events : List (Nat × Nat)) (h : events.length > 0) :\n  (∀ i j, i < events.length → j < events.length → i ≠ j →\n    ((events.get! i).1 + (events.get! i).2 ≤ (events.get! j).1) ∨ \n    ((events.get! j).1 + (events.get! j).2 ≤ (events.get! i).1)) →\n  maxStadiumEvents events = events.length := sorry\n\ntheorem maxStadiumEvents_all_overlapping (events : List (Nat × Nat)) (h : events.length ≥ 2) :\n  maxStadiumEvents (List.map (fun e => (0, e.2)) events) = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0601"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThis year $p$ footballers and $q$ cricketers have been invited to participate in IPL (Indian Programming League) as guests. You have to accommodate them in $r$ rooms such that-\n- No room may remain empty.\n- A room may contain either only footballers or only cricketers, not both.\n- No cricketers are allowed to stay alone in a room.\nFind the number of ways to place the players. Note though, that all the rooms are identical. But each of the cricketers and footballers are unique. \nSince the number of ways can be very large, print the answer modulo $998,244,353$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains three space-separated integers $p$, $q$ and $r$ denoting the number of footballers, cricketers and rooms.\n\n-----Output-----\nFor each test case, output the number of ways to place the players modulo $998,244,353$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le p, q, r \\le 100$\n\n-----Example Input-----\n4\n2 1 4\n2 4 4\n2 5 4\n2 8 4\n\n-----Example Output-----\n0\n3\n10\n609\n\n-----Explanation-----\nExample case 2: Three possible ways are:\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 2}, {Cricketer 3, Cricketer 4}\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 3}, {Cricketer 2, Cricketer 4}\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 4}, {Cricketer 2, Cricketer 3}    \nPlease note that the rooms are identical.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef MOD : Nat := 998244353\n\ndef solve_ipl_rooms (p q r : Nat) : Nat :=\n  sorry\n\ntheorem output_in_valid_range (p q r : Nat) (h1 : p > 0) (h2 : q > 0) (h3 : r > 0) :\n  let result := solve_ipl_rooms p q r\n  0 ≤ result ∧ result < MOD :=\nsorry\n\ntheorem empty_when_insufficient_rooms (p q r : Nat) (h1 : p > 0) (h2 : q > 0) (h3 : r > 0) :\n  p + q/2 < r → solve_ipl_rooms p q r = 0 :=\nsorry\n\ntheorem symmetric_case (n : Nat) (h : n > 0) :\n  solve_ipl_rooms n n 1 = solve_ipl_rooms n n 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0664", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThis year $p$ footballers and $q$ cricketers have been invited to participate in IPL (Indian Programming League) as guests. You have to accommodate them in $r$ rooms such that-\n- No room may remain empty.\n- A room may contain either only footballers or only cricketers, not both.\n- No cricketers are allowed to stay alone in a room.\nFind the number of ways to place the players. Note though, that all the rooms are identical. But each of the cricketers and footballers are unique. \nSince the number of ways can be very large, print the answer modulo $998,244,353$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains three space-separated integers $p$, $q$ and $r$ denoting the number of footballers, cricketers and rooms.\n\n-----Output-----\nFor each test case, output the number of ways to place the players modulo $998,244,353$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le p, q, r \\le 100$\n\n-----Example Input-----\n4\n2 1 4\n2 4 4\n2 5 4\n2 8 4\n\n-----Example Output-----\n0\n3\n10\n609\n\n-----Explanation-----\nExample case 2: Three possible ways are:\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 2}, {Cricketer 3, Cricketer 4}\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 3}, {Cricketer 2, Cricketer 4}\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 4}, {Cricketer 2, Cricketer 3}    \nPlease note that the rooms are identical.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef MOD : Nat := 998244353\n\ndef solve_ipl_rooms (p q r : Nat) : Nat :=\n  sorry\n\ntheorem output_in_valid_range (p q r : Nat) (h1 : p > 0) (h2 : q > 0) (h3 : r > 0) :\n  let result := solve_ipl_rooms p q r\n  0 ≤ result ∧ result < MOD :=\nsorry\n\ntheorem empty_when_insufficient_rooms (p q r : Nat) (h1 : p > 0) (h2 : q > 0) (h3 : r > 0) :\n  p + q/2 < r → solve_ipl_rooms p q r = 0 :=\nsorry\n\ntheorem symmetric_case (n : Nat) (h : n > 0) :\n  solve_ipl_rooms n n 1 = solve_ipl_rooms n n 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0664"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn my town ,there live a coder named Chef . He is a cool programmer . One day , he participate in a programming contest ,the contest give him only one problem . If he can’t solve the problem ,the problem setter will kill him . But the round allow you to help Chef. Can you save the life of Chef from problem setter ? :p\nYou are given two point of a straightline in X and Y axis and they are A(x1 , y1) and B(x2 ,y2) . Problem setter will give you another point C(x3 , y3) . If C exist in AB straightline ,then print “YES” . Otherwise ,print “NO” in first line and print the minimum distance from C to AB straightline in second line .\nPlease , save the life of Chef .\nNote : It is not possible that A and B point is similar .\n\n-----Input:-----\nThe first line of the input contains a single integer t (1≤t≤100) — the number of test cases .\nEach test case starts with four integers( x1, y1 , x2 , y2 ) in first line .\nNext line contains a single number q ,the number of queries . Each query contains two integers ( x3 ,y3 )\n\n-----Output:-----\nPrint , q number of “YES” or “NO” (as it mentioned above) in each test case .For every test case , print “Test case : i ” ( 1<= i <=T )\n\n-----Constraints-----\n-1000 <=  x1 , y1 , x2 , y2 , x3 , y3 <= 1000\n\n-----Sample Input:-----\n2\n3  5  6  5\n2\n4  5\n6  8\n3  4  7  10\n1\n7  4\n\n-----Sample Output:-----\nTest case : 1\nYES\nNO\n3.000000\nTest case : 2\nNO\n3.328201\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef String.toFloat? (s : String) : Option Float := sorry\n\ndef solve_geometry (x1 y1 x2 y2 : Int) (queries : List (Int × Int)) : List String :=\nsorry\n\ntheorem solve_geometry_basic_properties {x1 y1 x2 y2 : Int} (h : x1 ≠ x2) \n  (queries : List (Int × Int)) :\n  match solve_geometry x1 y1 x2 y2 queries with\n  | result =>\n    (result.length = queries.length ∨ result.length = 2 * queries.length) ∧\n    ∀ i : Nat, i < result.length →\n      if i % 2 = 0 \n      then List.get! result i = \"YES\" ∨ List.get! result i = \"NO\"\n      else ∃ d : Float, (List.get! result i).toFloat? = some d ∧ d ≥ 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0672", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn my town ,there live a coder named Chef . He is a cool programmer . One day , he participate in a programming contest ,the contest give him only one problem . If he can’t solve the problem ,the problem setter will kill him . But the round allow you to help Chef. Can you save the life of Chef from problem setter ? :p\nYou are given two point of a straightline in X and Y axis and they are A(x1 , y1) and B(x2 ,y2) . Problem setter will give you another point C(x3 , y3) . If C exist in AB straightline ,then print “YES” . Otherwise ,print “NO” in first line and print the minimum distance from C to AB straightline in second line .\nPlease , save the life of Chef .\nNote : It is not possible that A and B point is similar .\n\n-----Input:-----\nThe first line of the input contains a single integer t (1≤t≤100) — the number of test cases .\nEach test case starts with four integers( x1, y1 , x2 , y2 ) in first line .\nNext line contains a single number q ,the number of queries . Each query contains two integers ( x3 ,y3 )\n\n-----Output:-----\nPrint , q number of “YES” or “NO” (as it mentioned above) in each test case .For every test case , print “Test case : i ” ( 1<= i <=T )\n\n-----Constraints-----\n-1000 <=  x1 , y1 , x2 , y2 , x3 , y3 <= 1000\n\n-----Sample Input:-----\n2\n3  5  6  5\n2\n4  5\n6  8\n3  4  7  10\n1\n7  4\n\n-----Sample Output:-----\nTest case : 1\nYES\nNO\n3.000000\nTest case : 2\nNO\n3.328201\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef String.toFloat? (s : String) : Option Float := sorry\n\ndef solve_geometry (x1 y1 x2 y2 : Int) (queries : List (Int × Int)) : List String :=\nsorry\n\ntheorem solve_geometry_basic_properties {x1 y1 x2 y2 : Int} (h : x1 ≠ x2) \n  (queries : List (Int × Int)) :\n  match solve_geometry x1 y1 x2 y2 queries with\n  | result =>\n    (result.length = queries.length ∨ result.length = 2 * queries.length) ∧\n    ∀ i : Nat, i < result.length →\n      if i % 2 = 0 \n      then List.get! result i = \"YES\" ∨ List.get! result i = \"NO\"\n      else ∃ d : Float, (List.get! result i).toFloat? = some d ∧ d ≥ 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0672"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nAll strings in Chefland are beautiful because they are binary strings (a binary string contains only characters '0' and '1'). The beauty of a binary string $S$ is defined as the number of pairs $(i, j)$ ($1 \\le i \\le j \\le |S|$) such that the substring $S_i, S_{i+1}, \\ldots, S_j$ is special.\nFor a binary string $U$, let's denote the number of occurrences of the characters '1' and '0' in $U$ by $cnt_1$ and $cnt_0$ respectively; then, $U$ is special if $cnt_0 = cnt_1 \\cdot cnt_1$.\nToday, Chef's friend Araspa is celebrating her birthday. Chef wants to give Araspa the most beautiful binary string he can find. Currently, he is checking out binary strings in a shop, but he needs your help to calculate their beauties. Tell Chef the beauty of each binary string he gives you.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single string $S$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the beauty of the string $S$.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le |S| \\le 10^5$\n- each character of $S$ is '0' or '1'\n\n-----Example Input-----\n2\n010001\n10\n\n-----Example Output-----\n4\n1\n\n-----Explanation-----\nExample case 1: The special substrings correspond to $(i, j) = (1, 2), (1, 6), (2, 3), (5, 6)$.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef String.isBinaryString (s : String) : Bool := s.all (fun c => c == '0' || c == '1')\n\ndef count_special_substrings (s : String) : Nat :=\n  sorry\n\n\n\n\n\ntheorem count_special_substrings_all_zeros (s : String) \n    (h : s.all (· = '0') = true) :\n    count_special_substrings s = 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0720", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nAll strings in Chefland are beautiful because they are binary strings (a binary string contains only characters '0' and '1'). The beauty of a binary string $S$ is defined as the number of pairs $(i, j)$ ($1 \\le i \\le j \\le |S|$) such that the substring $S_i, S_{i+1}, \\ldots, S_j$ is special.\nFor a binary string $U$, let's denote the number of occurrences of the characters '1' and '0' in $U$ by $cnt_1$ and $cnt_0$ respectively; then, $U$ is special if $cnt_0 = cnt_1 \\cdot cnt_1$.\nToday, Chef's friend Araspa is celebrating her birthday. Chef wants to give Araspa the most beautiful binary string he can find. Currently, he is checking out binary strings in a shop, but he needs your help to calculate their beauties. Tell Chef the beauty of each binary string he gives you.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single string $S$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the beauty of the string $S$.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le |S| \\le 10^5$\n- each character of $S$ is '0' or '1'\n\n-----Example Input-----\n2\n010001\n10\n\n-----Example Output-----\n4\n1\n\n-----Explanation-----\nExample case 1: The special substrings correspond to $(i, j) = (1, 2), (1, 6), (2, 3), (5, 6)$.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef String.isBinaryString (s : String) : Bool := s.all (fun c => c == '0' || c == '1')\n\ndef count_special_substrings (s : String) : Nat :=\n  sorry\n\n\n\n\n\ntheorem count_special_substrings_all_zeros (s : String) \n    (h : s.all (· = '0') = true) :\n    count_special_substrings s = 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0720"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n-----Indian National Olympiad in Informatics 2014-----\nNikhil’s slogan has won the contest conducted by Drongo Airlines and he is entitled to a free ticket between any two destinations served by the airline. All cities served by Drongo Airlines can be reached from each other by some sequence of connecting flights. Nikhil is allowed to take as many connecting flights as needed, but he must take the cheapest route between his chosen destinations.\nEach direct flight between two cities has a fixed price. All pairs of cities connected by direct flights have flights in both directions and the price is the same in either direction. The price for a sequence of connecting flights is the sum of the prices of the direct flights along the route.\nNikhil has information about the cost of each direct flight. He would like to maximize the value of his prize, so he would like to choose a pair of cities on the network for which the cost of the cheapest route is as high as possible.\nFor instance, suppose the network consists of four cities {1, 2, 3, 4}, connected as shown on the right.\nIn this case, Nikhil should choose to travel between 1 and 4, where the cheapest route has cost 19. You can check that for all other pairs of cities, the cheapest route has a smaller cost. For instance, notice that though the direct flight from 1 to 3 costs 24, there is a cheaper route of cost 12 from 1 to 2 to 3.\n\n-----Input Format:-----\n- Line 1 : Two space-separated integers, C and F . C is the number of cities on the network, numbered 1, 2, . . . , C. F is the number of pairs of cities connected by a direct flight\n- Lines 2 to F + 1 : Each line describes one direct flight between a pair of cities and consists of three integers, x, y and p, where x and y are the two cities connected by this flight and p is the price of this\nFor all direct flights, $x \\neq y$, and no pair of cities is connected by more than one direct flight. If there is a direct flight from x to y with price p, there is also a flight from y to x with price p and exactly one of these two will be listed.\n\n-----Output Format-----\n- The output consists of a single integer, the maximum cost among the cheapest routes between all pairs of cities across the airline’s network.\n\n-----Test Data-----\nThe testdata is grouped into three subtasks. In all subtasks, 2 ≤ C ≤ 230 and 1 ≤ F ≤ 23665. In addition, each subtask has the following constraints on the inputs.\n- Subtask 1 (20 marks) : F = C − 1 (that is, the airline network is a tree) and p = 1 for each direct flight.\n- Subtask 2 (30 marks) : There is no constraint on the shape of the network, but for each direct flight, p = 1.\n- Subtask 3 (50 marks) : There is no constraint on the shape of the network, but for each direct flight, 0 ≤ p ≤ $10^5$.\n\n-----Sample Input-----\n4 5\n1 2 10\n1 3 24\n2 3 2\n2 4 15\n3 4 7\n\n-----Sample Output-----\n19\n\nNote: Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Edge where\n  src : Nat\n  dst : Nat \n  cost : Nat\nderiving Repr\n\ndef find_max_route_cost (n : Nat) (edges : List Edge) : Nat := sorry\n\ndef exists_path (edges : List Edge) (u v : Nat) : Bool := sorry\n\ndef shortest_path_cost (edges : List Edge) (u v : Nat) : Nat := sorry\n\ntheorem small_graph_path_costs {n : Nat} {edges : List Edge} \n  (h1 : n = 3)\n  (h2 : ∀ e ∈ edges, e.src ≤ 3 ∧ e.dst ≤ 3)\n  (h3 : ∀ e ∈ edges, e.cost ≤ 100)\n  (h4 : edges.length ≤ 3)\n  (h5 : edges.length ≥ 2)\n  (h6 : ∀ e ∈ edges, e.src ≠ e.dst) :\n  ∀ u v : Nat, u < n → v < n → u ≠ v →\n    if exists_path edges u v then\n      shortest_path_cost edges u v ≤ find_max_route_cost n edges\n    else True := sorry\n\ntheorem symmetry_property {n : Nat} {edges : List Edge}\n  (h1 : n = 3)\n  (h2 : ∀ e ∈ edges, e.src ≤ 3 ∧ e.dst ≤ 3)\n  (h3 : ∀ e ∈ edges, e.cost ≤ 100)\n  (h4 : edges.length ≤ 3)\n  (h5 : edges.length ≥ 2)\n  (h6 : ∀ e ∈ edges, e.src ≠ e.dst) :\n  find_max_route_cost n edges = \n  find_max_route_cost n (edges.map (λ e => ⟨e.dst, e.src, e.cost⟩)) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0731", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n-----Indian National Olympiad in Informatics 2014-----\nNikhil’s slogan has won the contest conducted by Drongo Airlines and he is entitled to a free ticket between any two destinations served by the airline. All cities served by Drongo Airlines can be reached from each other by some sequence of connecting flights. Nikhil is allowed to take as many connecting flights as needed, but he must take the cheapest route between his chosen destinations.\nEach direct flight between two cities has a fixed price. All pairs of cities connected by direct flights have flights in both directions and the price is the same in either direction. The price for a sequence of connecting flights is the sum of the prices of the direct flights along the route.\nNikhil has information about the cost of each direct flight. He would like to maximize the value of his prize, so he would like to choose a pair of cities on the network for which the cost of the cheapest route is as high as possible.\nFor instance, suppose the network consists of four cities {1, 2, 3, 4}, connected as shown on the right.\nIn this case, Nikhil should choose to travel between 1 and 4, where the cheapest route has cost 19. You can check that for all other pairs of cities, the cheapest route has a smaller cost. For instance, notice that though the direct flight from 1 to 3 costs 24, there is a cheaper route of cost 12 from 1 to 2 to 3.\n\n-----Input Format:-----\n- Line 1 : Two space-separated integers, C and F . C is the number of cities on the network, numbered 1, 2, . . . , C. F is the number of pairs of cities connected by a direct flight\n- Lines 2 to F + 1 : Each line describes one direct flight between a pair of cities and consists of three integers, x, y and p, where x and y are the two cities connected by this flight and p is the price of this\nFor all direct flights, $x \\neq y$, and no pair of cities is connected by more than one direct flight. If there is a direct flight from x to y with price p, there is also a flight from y to x with price p and exactly one of these two will be listed.\n\n-----Output Format-----\n- The output consists of a single integer, the maximum cost among the cheapest routes between all pairs of cities across the airline’s network.\n\n-----Test Data-----\nThe testdata is grouped into three subtasks. In all subtasks, 2 ≤ C ≤ 230 and 1 ≤ F ≤ 23665. In addition, each subtask has the following constraints on the inputs.\n- Subtask 1 (20 marks) : F = C − 1 (that is, the airline network is a tree) and p = 1 for each direct flight.\n- Subtask 2 (30 marks) : There is no constraint on the shape of the network, but for each direct flight, p = 1.\n- Subtask 3 (50 marks) : There is no constraint on the shape of the network, but for each direct flight, 0 ≤ p ≤ $10^5$.\n\n-----Sample Input-----\n4 5\n1 2 10\n1 3 24\n2 3 2\n2 4 15\n3 4 7\n\n-----Sample Output-----\n19\n\nNote: Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Edge where\n  src : Nat\n  dst : Nat \n  cost : Nat\nderiving Repr\n\ndef find_max_route_cost (n : Nat) (edges : List Edge) : Nat := sorry\n\ndef exists_path (edges : List Edge) (u v : Nat) : Bool := sorry\n\ndef shortest_path_cost (edges : List Edge) (u v : Nat) : Nat := sorry\n\ntheorem small_graph_path_costs {n : Nat} {edges : List Edge} \n  (h1 : n = 3)\n  (h2 : ∀ e ∈ edges, e.src ≤ 3 ∧ e.dst ≤ 3)\n  (h3 : ∀ e ∈ edges, e.cost ≤ 100)\n  (h4 : edges.length ≤ 3)\n  (h5 : edges.length ≥ 2)\n  (h6 : ∀ e ∈ edges, e.src ≠ e.dst) :\n  ∀ u v : Nat, u < n → v < n → u ≠ v →\n    if exists_path edges u v then\n      shortest_path_cost edges u v ≤ find_max_route_cost n edges\n    else True := sorry\n\ntheorem symmetry_property {n : Nat} {edges : List Edge}\n  (h1 : n = 3)\n  (h2 : ∀ e ∈ edges, e.src ≤ 3 ∧ e.dst ≤ 3)\n  (h3 : ∀ e ∈ edges, e.cost ≤ 100)\n  (h4 : edges.length ≤ 3)\n  (h5 : edges.length ≥ 2)\n  (h6 : ∀ e ∈ edges, e.src ≠ e.dst) :\n  find_max_route_cost n edges = \n  find_max_route_cost n (edges.map (λ e => ⟨e.dst, e.src, e.cost⟩)) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0731"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given two binary strings $S$ and $P$, each with length $N$. A binary string contains only characters '0' and '1'. For each valid $i$, let's denote the $i$-th character of $S$ by $S_i$.\nYou have to convert the string $S$ into $P$ using zero or more operations. In one operation, you should choose two indices $i$ and $j$ ($1 \\leq i < j \\leq N$) such that $S_i$ is '1' and $S_j$ is '0', and swap $S_i$ with $S_j$.\nDetermine if it is possible to convert $S$ into $P$ by performing some operations.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains a single string $S$.\n- The third line contains a single string $P$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Yes\" if it is possible to convert $S$ into $P$ or \"No\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $S$ and $P$ contain only characters '0' and '1'\n- the sum of $N$ over all test cases does not exceed $10^5$\n\n-----Subtasks-----\nSubtask #1 (20 points):\n- $N \\leq 14$\n- the sum of $N$ over all test cases does not exceed $100$\nSubtask #2 (30 points): the sum of $N$ over all test cases does not exceed $1,000$\nSubtask #3 (50 points): original constraints\n\n-----Example Input-----\n3\n2\n00\n00\n3\n101\n010\n4\n0110\n0011\n\n-----Example Output-----\nYes\nNo\nYes\n\n-----Explanation-----\nExample case 1: The strings are already equal.\nExample case 2: It can be showed that it is impossible to convert $S$ into $P$.\nExample case 3: You can swap $S_2$ with $S_4$. The strings will then be equal.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_convert_binary_strings (s p : String) : String := sorry\n\ndef count_ones (s : String) : Nat := sorry\n\ndef has_adjacent_ones (s : String) : Bool := sorry\n\ntheorem same_string_convertible (s : String) \n  (h : s ≠ \"\") : \n  can_convert_binary_strings s s = \"Yes\" :=\nsorry\n\ntheorem conversion_preserves_ones (s p : String)\n  (h1 : s ≠ \"\") (h2 : p ≠ \"\")\n  (h3 : s.length = p.length) :\n  (can_convert_binary_strings s p = \"Yes\") ↔ (count_ones s = count_ones p) :=\nsorry\n\ntheorem cannot_convert_ones_to_zeros (s p : String)\n  (h1 : s ≠ \"\") \n  (h2 : s.length = p.length)\n  (h3 : has_adjacent_ones s = true)\n  (h4 : p = s.replace \"11\" \"00\") :\n  can_convert_binary_strings s p = \"No\" :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0763", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given two binary strings $S$ and $P$, each with length $N$. A binary string contains only characters '0' and '1'. For each valid $i$, let's denote the $i$-th character of $S$ by $S_i$.\nYou have to convert the string $S$ into $P$ using zero or more operations. In one operation, you should choose two indices $i$ and $j$ ($1 \\leq i < j \\leq N$) such that $S_i$ is '1' and $S_j$ is '0', and swap $S_i$ with $S_j$.\nDetermine if it is possible to convert $S$ into $P$ by performing some operations.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains a single string $S$.\n- The third line contains a single string $P$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Yes\" if it is possible to convert $S$ into $P$ or \"No\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $S$ and $P$ contain only characters '0' and '1'\n- the sum of $N$ over all test cases does not exceed $10^5$\n\n-----Subtasks-----\nSubtask #1 (20 points):\n- $N \\leq 14$\n- the sum of $N$ over all test cases does not exceed $100$\nSubtask #2 (30 points): the sum of $N$ over all test cases does not exceed $1,000$\nSubtask #3 (50 points): original constraints\n\n-----Example Input-----\n3\n2\n00\n00\n3\n101\n010\n4\n0110\n0011\n\n-----Example Output-----\nYes\nNo\nYes\n\n-----Explanation-----\nExample case 1: The strings are already equal.\nExample case 2: It can be showed that it is impossible to convert $S$ into $P$.\nExample case 3: You can swap $S_2$ with $S_4$. The strings will then be equal.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_convert_binary_strings (s p : String) : String := sorry\n\ndef count_ones (s : String) : Nat := sorry\n\ndef has_adjacent_ones (s : String) : Bool := sorry\n\ntheorem same_string_convertible (s : String) \n  (h : s ≠ \"\") : \n  can_convert_binary_strings s s = \"Yes\" :=\nsorry\n\ntheorem conversion_preserves_ones (s p : String)\n  (h1 : s ≠ \"\") (h2 : p ≠ \"\")\n  (h3 : s.length = p.length) :\n  (can_convert_binary_strings s p = \"Yes\") ↔ (count_ones s = count_ones p) :=\nsorry\n\ntheorem cannot_convert_ones_to_zeros (s p : String)\n  (h1 : s ≠ \"\") \n  (h2 : s.length = p.length)\n  (h3 : has_adjacent_ones s = true)\n  (h4 : p = s.replace \"11\" \"00\") :\n  can_convert_binary_strings s p = \"No\" :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0763"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an Integer N, write a program to reverse it.\n\n-----Input-----\n\nThe first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, display the reverse of the given number N, in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 1000000\n\n-----Example-----\nInput\n4\n12345\n31203\n2123\n2300\nOutput\n54321\n30213\n3212\n32\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef reverse_numbers (nums : List String) : List Int := sorry\n\ndef is_palindrome (s : String) : Bool := sorry\n\ntheorem reverse_numbers_preserves_length {nums : List String} :\n  List.length (reverse_numbers nums) = List.length nums := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0778", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an Integer N, write a program to reverse it.\n\n-----Input-----\n\nThe first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, display the reverse of the given number N, in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 1000000\n\n-----Example-----\nInput\n4\n12345\n31203\n2123\n2300\nOutput\n54321\n30213\n3212\n32\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef reverse_numbers (nums : List String) : List Int := sorry\n\ndef is_palindrome (s : String) : Bool := sorry\n\ntheorem reverse_numbers_preserves_length {nums : List String} :\n  List.length (reverse_numbers nums) = List.length nums := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0778"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nLimak is a little polar bear.\nHe is playing a video game and he needs your help.\nThere is a row with N cells, each either empty or occupied by a soldier, denoted by '0' and '1' respectively.\nThe goal of the game is to move all soldiers to the right (they should occupy some number of rightmost cells).\nThe only possible command is choosing a soldier and telling him to move to the right as far as possible.\nChoosing a soldier takes 1 second, and a soldier moves with the speed of a cell per second.\nThe soldier stops immediately if he is in the last cell of the row or the next cell is already occupied.\nLimak isn't allowed to choose a soldier that can't move at all (the chosen soldier must move at least one cell to the right).\nLimak enjoys this game very much and wants to play as long as possible.\nIn particular, he doesn't start a new command while the previously chosen soldier moves.\nCan you tell him, how many seconds he can play at most?\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe only line of each test case contains a string S describing the row with N cells.\nEach character is either '0' or '1', denoting an empty cell or a cell with a soldier respectively.\n\n-----Output-----\nFor each test case, output a single line containing one integer — the maximum possible number of seconds Limak will play the game.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 105 (N denotes the length of the string S)\n\n-----Subtasks-----\n- Subtask #1 (25 points): 1 ≤ N ≤ 10\n- Subtask #2 (25 points): 1 ≤ N ≤ 2000\n- Subtask #3 (50 points): Original constraints.\n\n-----Example-----\nInput:\n4\n10100\n1100001\n000000000111\n001110100011010\n\nOutput:\n8\n10\n0\n48\n\n-----Explanation-----\nTest case 1.\nThe initial string is 10100.\nThere are N = 5 cells.\nThere is one soldier in the first cell, and one soldier in the third cell.\nThe following scenario maximizes the total time:\n- Limak chooses the soldier in the first cell.\nThis soldier can move only one cell to the right.\nIt takes 1 second to choose a soldier and 1 second for a soldier to move to the next cell (2 seconds in total).\nThe string is 01100 now.\n- Limak has only one choice.\nHe must choose the soldier in the third cell because the other soldier can't move at all (the soldier in the second cell can't move to the right because the next cell is already occupied).\nChoosing a soldier takes 1 second.\nThe chosen soldier moves from the third cell to the fifth cell, which takes 2 seconds.\nThis operation takes 1 + 2 = 3 seconds in total.\nThe string is 01001 now.\n- Limak has only one choice again.\nSince the soldier in the last row can't move further to the right, the soldier in the second cell must be chosen.\nHe will move 2 cells to the right.\nThis operation takes 1 + 2 = 3 seconds in total.\nThe string become 00011 and the game is over.\nThe total time is 2 + 3 + 3 = 8.\nTest case 2.\nThe initial string is 1100001.\nThere is only one possible scenario:\n- 1100001 is changed to 1000011 in 5 seconds (1 second to choose a soldier and 4 seconds for the soldier to move 4 cells to the right).\n- 1000011 is changed to 0000111 in 5 seconds.\n\nThe total time is 5 + 5 = 10 seconds.\nTest case 3.\nThe game is over immediately because all soldiers occupy rightmost cells already.\nThe answer is 0.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_moving_soldiers (s : String) : Nat :=\n  sorry\n\ntheorem empty_string :\n  solve_moving_soldiers \"\" = 0 :=\nsorry\n\ntheorem all_zeros (n : Nat) :\n  solve_moving_soldiers (String.mk (List.replicate n '0')) = 0 :=\nsorry\n\ntheorem all_ones (n : Nat) :\n  solve_moving_soldiers (String.mk (List.replicate n '1')) = 0 :=\nsorry\n\ntheorem trailing_ones_invariant (s₁ s₂ : String) :\n  s₂ = s₁ ++ String.mk (List.replicate 3 '1') →\n  solve_moving_soldiers s₁ = solve_moving_soldiers s₂ :=\nsorry\n\ntheorem result_nonnegative (s : String) :\n  solve_moving_soldiers s ≥ 0 :=\nsorry\n\ntheorem no_movement_needed (s : String) :\n  (s.toList.filter (· = '1')).length = 0 ∨\n  (s.toList.dropWhile (· = '1')).isEmpty →\n  solve_moving_soldiers s = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0787", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nLimak is a little polar bear.\nHe is playing a video game and he needs your help.\nThere is a row with N cells, each either empty or occupied by a soldier, denoted by '0' and '1' respectively.\nThe goal of the game is to move all soldiers to the right (they should occupy some number of rightmost cells).\nThe only possible command is choosing a soldier and telling him to move to the right as far as possible.\nChoosing a soldier takes 1 second, and a soldier moves with the speed of a cell per second.\nThe soldier stops immediately if he is in the last cell of the row or the next cell is already occupied.\nLimak isn't allowed to choose a soldier that can't move at all (the chosen soldier must move at least one cell to the right).\nLimak enjoys this game very much and wants to play as long as possible.\nIn particular, he doesn't start a new command while the previously chosen soldier moves.\nCan you tell him, how many seconds he can play at most?\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe only line of each test case contains a string S describing the row with N cells.\nEach character is either '0' or '1', denoting an empty cell or a cell with a soldier respectively.\n\n-----Output-----\nFor each test case, output a single line containing one integer — the maximum possible number of seconds Limak will play the game.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 105 (N denotes the length of the string S)\n\n-----Subtasks-----\n- Subtask #1 (25 points): 1 ≤ N ≤ 10\n- Subtask #2 (25 points): 1 ≤ N ≤ 2000\n- Subtask #3 (50 points): Original constraints.\n\n-----Example-----\nInput:\n4\n10100\n1100001\n000000000111\n001110100011010\n\nOutput:\n8\n10\n0\n48\n\n-----Explanation-----\nTest case 1.\nThe initial string is 10100.\nThere are N = 5 cells.\nThere is one soldier in the first cell, and one soldier in the third cell.\nThe following scenario maximizes the total time:\n- Limak chooses the soldier in the first cell.\nThis soldier can move only one cell to the right.\nIt takes 1 second to choose a soldier and 1 second for a soldier to move to the next cell (2 seconds in total).\nThe string is 01100 now.\n- Limak has only one choice.\nHe must choose the soldier in the third cell because the other soldier can't move at all (the soldier in the second cell can't move to the right because the next cell is already occupied).\nChoosing a soldier takes 1 second.\nThe chosen soldier moves from the third cell to the fifth cell, which takes 2 seconds.\nThis operation takes 1 + 2 = 3 seconds in total.\nThe string is 01001 now.\n- Limak has only one choice again.\nSince the soldier in the last row can't move further to the right, the soldier in the second cell must be chosen.\nHe will move 2 cells to the right.\nThis operation takes 1 + 2 = 3 seconds in total.\nThe string become 00011 and the game is over.\nThe total time is 2 + 3 + 3 = 8.\nTest case 2.\nThe initial string is 1100001.\nThere is only one possible scenario:\n- 1100001 is changed to 1000011 in 5 seconds (1 second to choose a soldier and 4 seconds for the soldier to move 4 cells to the right).\n- 1000011 is changed to 0000111 in 5 seconds.\n\nThe total time is 5 + 5 = 10 seconds.\nTest case 3.\nThe game is over immediately because all soldiers occupy rightmost cells already.\nThe answer is 0.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_moving_soldiers (s : String) : Nat :=\n  sorry\n\ntheorem empty_string :\n  solve_moving_soldiers \"\" = 0 :=\nsorry\n\ntheorem all_zeros (n : Nat) :\n  solve_moving_soldiers (String.mk (List.replicate n '0')) = 0 :=\nsorry\n\ntheorem all_ones (n : Nat) :\n  solve_moving_soldiers (String.mk (List.replicate n '1')) = 0 :=\nsorry\n\ntheorem trailing_ones_invariant (s₁ s₂ : String) :\n  s₂ = s₁ ++ String.mk (List.replicate 3 '1') →\n  solve_moving_soldiers s₁ = solve_moving_soldiers s₂ :=\nsorry\n\ntheorem result_nonnegative (s : String) :\n  solve_moving_soldiers s ≥ 0 :=\nsorry\n\ntheorem no_movement_needed (s : String) :\n  (s.toList.filter (· = '1')).length = 0 ∨\n  (s.toList.dropWhile (· = '1')).isEmpty →\n  solve_moving_soldiers s = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0787"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nDustin, is the head of an Intelligence agency. He wants to send a secret message S$S$ to his colleague.The message is a single word consisting of only lowercase english letters but he decides to encrypt the message for security reasons. He makes a string M$M$ of length N$N$, such that after deleting a substring of non-zero length from M$M$, the remaining string is S$S$.\nCalculate the number of all such possible strings he can form.\n\n-----Input:-----\n- First line will contain T$T$, number of testcases. Then the testcases follow.\n- For each testcase the there is a single line which contains an integer, N$N$ and then a string S$S$.\n\n-----Output:-----\nFor each testcase, output the number of possible strings modulo 109+7$10^9+7$.\n\n-----Constraints-----\n- 1≤T≤50$1 \\leq T \\leq 50$\n- 1≤N≤1018$1 \\leq N \\leq 10^{18}$\n- 1≤|S|≤105$1 \\leq |S| \\leq 10^5$\n- S$S$ can contain only lowercase English letters.\n\n-----Sample Input:-----\n2\n\n3 a\n\n3 ab     \n\n-----Sample Output:-----\n1326\n\n76\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_possible_strings (n : Nat) (s : String) : Nat :=\n  sorry\n\ndef MOD := 1000000007\n\n\n\ntheorem count_possible_strings_short_input (n : Nat) (s : String) :\n  n ≤ s.length → count_possible_strings n s = 0 :=\nsorry\n\ntheorem count_possible_strings_long_input (n : Nat) (s : String) :\n  n > s.length → count_possible_strings n s > 0 :=\nsorry\n\ntheorem count_possible_strings_monotone_in_string_length (s : String) :\n  let n := s.length + 2\n  count_possible_strings n s > count_possible_strings n (s.append \"a\") :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0792", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nDustin, is the head of an Intelligence agency. He wants to send a secret message S$S$ to his colleague.The message is a single word consisting of only lowercase english letters but he decides to encrypt the message for security reasons. He makes a string M$M$ of length N$N$, such that after deleting a substring of non-zero length from M$M$, the remaining string is S$S$.\nCalculate the number of all such possible strings he can form.\n\n-----Input:-----\n- First line will contain T$T$, number of testcases. Then the testcases follow.\n- For each testcase the there is a single line which contains an integer, N$N$ and then a string S$S$.\n\n-----Output:-----\nFor each testcase, output the number of possible strings modulo 109+7$10^9+7$.\n\n-----Constraints-----\n- 1≤T≤50$1 \\leq T \\leq 50$\n- 1≤N≤1018$1 \\leq N \\leq 10^{18}$\n- 1≤|S|≤105$1 \\leq |S| \\leq 10^5$\n- S$S$ can contain only lowercase English letters.\n\n-----Sample Input:-----\n2\n\n3 a\n\n3 ab     \n\n-----Sample Output:-----\n1326\n\n76\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_possible_strings (n : Nat) (s : String) : Nat :=\n  sorry\n\ndef MOD := 1000000007\n\n\n\ntheorem count_possible_strings_short_input (n : Nat) (s : String) :\n  n ≤ s.length → count_possible_strings n s = 0 :=\nsorry\n\ntheorem count_possible_strings_long_input (n : Nat) (s : String) :\n  n > s.length → count_possible_strings n s > 0 :=\nsorry\n\ntheorem count_possible_strings_monotone_in_string_length (s : String) :\n  let n := s.length + 2\n  count_possible_strings n s > count_possible_strings n (s.append \"a\") :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0792"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n\tDevuLand is a very strange place. There are n villages in it. Some of the villages are occupied by dinosaurs while the remaining ones by villagers.\n\tYou are given the information of DevuLand \n\tby an array D of size n. If D[i] is non-negative, it means that there are D[i] villagers in that village. \n\tOtherwise, it means that are -D[i] \n\tdinosaurs in that village.\n\n\tIt is also guaranteed that total number of villagers in DevuLand is equal to total number of dinosaurs.\n\nOnce dinosaurs got very hungry and started eating villagers. Frightened villagers gathered immediately and met their Sarpanch Deviji. Deviji, being a very daring and negotiable person, met to the head\nof dinosaurs. Soon both parties called a truce. It was decided that the villagers will provide laddus to \nthe dinosaurs. So everyday, each villager will take exactly one laddu to one of the dinosaurs in such a way that no dinosaur remains hungry (note that this is possible because number of villagers is the same as the number of dinosaurs).\n\nActually, carrying laddus is a quite a tough job. Villagers have to use a bullock cart for that. It takes one unit of grass a bullock to \ncarry a cart with 1 laddu for 1 kilometre. Laddus used to be very heavy in DevuLand, so a bullock cart can not carry more than one laddu.\n\nIt is also given distance between village indexed i and j is |j - i| (the absolute value) kilometres.\n\nNow villagers sat down and found a strategy to feed laddus to dinosaurs so that they need to buy the least amount of grass from the nearby market. \nThey are not very good in \ncalculations, please find out what is the minimum number of units of grass they need to buy.\n\n-----Input-----\n\nFirst line of the input contains an integer T denoting number of test cases.\n\nFor each test case, there are two lines. \n\nFirst line contains a single integer denoting n: number of villages. \n\nSecond line contains n space separated integers denoting the array D.\n\n-----Output-----\n\nFor each test case, print a single line containing the integer corresponding to answer of the problem.\n\n-----Constraints-----\n\n-  1 ≤ T ≤ 10^5 \n-  1 ≤ n ≤ 10^5 \n-  -10^4 ≤ D[i] ≤ 10^4 \n-  Sum of n over all the test cases will be ≤ 10^6 \n-  It is guaranteed that sum of D[i] is zero for a single test case which ensures that there are equal number of villagers and dinosaurs. \n\n-----Example-----\nInput:\n3\n2\n5 -5\n2\n-5 5\n3\n1 2 -3\nOutput:\n5\n5\n4\n\n-----Explanation-----\nExample case 1. Each villager in village 1, need to walk 1 km to reach to the dinosaur in 2nd village.\nExample case 2. Each villager in village 2, need to walk 1 km to reach to the dinosaur 1st village.\nExample case 3. Each villager in village 1, need to walk 2 km to reach to the dinosaur in 3rd village whereas Each villager in village 2, \nneed to walk 1 km to reach to the dinosaur in 3rd village.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sum (l : List Int) : Int := sorry\n\ndef min_grass_needed (arr : List Int) : Nat := sorry\n\ntheorem min_grass_needed_non_negative (arr : List Int) (h : arr ≠ []) : \n  min_grass_needed arr ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0812", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n\tDevuLand is a very strange place. There are n villages in it. Some of the villages are occupied by dinosaurs while the remaining ones by villagers.\n\tYou are given the information of DevuLand \n\tby an array D of size n. If D[i] is non-negative, it means that there are D[i] villagers in that village. \n\tOtherwise, it means that are -D[i] \n\tdinosaurs in that village.\n\n\tIt is also guaranteed that total number of villagers in DevuLand is equal to total number of dinosaurs.\n\nOnce dinosaurs got very hungry and started eating villagers. Frightened villagers gathered immediately and met their Sarpanch Deviji. Deviji, being a very daring and negotiable person, met to the head\nof dinosaurs. Soon both parties called a truce. It was decided that the villagers will provide laddus to \nthe dinosaurs. So everyday, each villager will take exactly one laddu to one of the dinosaurs in such a way that no dinosaur remains hungry (note that this is possible because number of villagers is the same as the number of dinosaurs).\n\nActually, carrying laddus is a quite a tough job. Villagers have to use a bullock cart for that. It takes one unit of grass a bullock to \ncarry a cart with 1 laddu for 1 kilometre. Laddus used to be very heavy in DevuLand, so a bullock cart can not carry more than one laddu.\n\nIt is also given distance between village indexed i and j is |j - i| (the absolute value) kilometres.\n\nNow villagers sat down and found a strategy to feed laddus to dinosaurs so that they need to buy the least amount of grass from the nearby market. \nThey are not very good in \ncalculations, please find out what is the minimum number of units of grass they need to buy.\n\n-----Input-----\n\nFirst line of the input contains an integer T denoting number of test cases.\n\nFor each test case, there are two lines. \n\nFirst line contains a single integer denoting n: number of villages. \n\nSecond line contains n space separated integers denoting the array D.\n\n-----Output-----\n\nFor each test case, print a single line containing the integer corresponding to answer of the problem.\n\n-----Constraints-----\n\n-  1 ≤ T ≤ 10^5 \n-  1 ≤ n ≤ 10^5 \n-  -10^4 ≤ D[i] ≤ 10^4 \n-  Sum of n over all the test cases will be ≤ 10^6 \n-  It is guaranteed that sum of D[i] is zero for a single test case which ensures that there are equal number of villagers and dinosaurs. \n\n-----Example-----\nInput:\n3\n2\n5 -5\n2\n-5 5\n3\n1 2 -3\nOutput:\n5\n5\n4\n\n-----Explanation-----\nExample case 1. Each villager in village 1, need to walk 1 km to reach to the dinosaur in 2nd village.\nExample case 2. Each villager in village 2, need to walk 1 km to reach to the dinosaur 1st village.\nExample case 3. Each villager in village 1, need to walk 2 km to reach to the dinosaur in 3rd village whereas Each villager in village 2, \nneed to walk 1 km to reach to the dinosaur in 3rd village.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sum (l : List Int) : Int := sorry\n\ndef min_grass_needed (arr : List Int) : Nat := sorry\n\ntheorem min_grass_needed_non_negative (arr : List Int) (h : arr ≠ []) : \n  min_grass_needed arr ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0812"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nCoach Moony wants the best team to represent their college in ICPC. He has $N$ students standing in a circle with certain rating $X_i$ on a competitive coding platform. It is an established fact that any coder with more rating on the platform is a better coder.      \nMoony  wants to send his best $3$ coders based upon their rating. But all coders only want to have their friends in their team and every coder is friends with four other coders, adjacent two on left side in the circle, and adjacent two on right. So Moony comes up with a solution that team with maximum cumulative rating of all three members in a team shall be representing their college.\nYou need to give the cumulative score of the team that will be representing the college.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. \n- First line of each test case contains a single integer $N$.\n- Second  line of each test case takes $N$ integers, denoting rating of $ith$ coder.\n\n-----Output:-----\nFor each testcase, output a single integer denoting cumulative rating  of the team.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $7 \\leq N \\leq 10^5$ \n- $0 \\leq X_i \\leq 10^9$\n\n-----Sample Input:-----\n1\n\n7\n\n10 40 30 30 20 0 0  \n\n-----Sample Output:-----\n100\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_max_team_score (n : Nat) (ratings : List Nat) : Nat := sorry\n\ndef list_sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef take_last (n : Nat) (l : List Nat) : List Nat := \n  let rev := l.reverse\n  (rev.take n).reverse\n\ntheorem find_max_team_score_upper_bound \n  (ratings : List Nat) (h : ratings.length ≥ 3) :\n  find_max_team_score ratings.length ratings ≤ list_sum (take_last 3 ratings) := sorry\n\ntheorem find_max_team_score_lower_bound \n  (ratings : List Nat) (h : ratings.length ≥ 3) : \n  find_max_team_score ratings.length ratings ≥ list_sum (ratings.take 3) := sorry\n\ntheorem find_max_team_score_three_elements\n  (ratings : List Nat) (h : ratings.length = 3) :\n  find_max_team_score ratings.length ratings = list_sum ratings := sorry\n\ntheorem find_max_team_score_consecutive\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) (hi : i + 2 < ratings.length) :\n  find_max_team_score ratings.length ratings ≥ \n    ratings[i]! + ratings[i+1]! + ratings[i+2]! := sorry\n\ntheorem find_max_team_score_wrapping\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) :\n  find_max_team_score ratings.length ratings ≥\n    ratings[i % ratings.length]! + \n    ratings[(i + 1) % ratings.length]! + \n    ratings[(i + 2) % ratings.length]! := sorry\n\ntheorem find_max_team_score_all_equal\n  (n : Nat) (h : n ≥ 3) :\n  find_max_team_score n (List.replicate n 1) = 3 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0848", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nCoach Moony wants the best team to represent their college in ICPC. He has $N$ students standing in a circle with certain rating $X_i$ on a competitive coding platform. It is an established fact that any coder with more rating on the platform is a better coder.      \nMoony  wants to send his best $3$ coders based upon their rating. But all coders only want to have their friends in their team and every coder is friends with four other coders, adjacent two on left side in the circle, and adjacent two on right. So Moony comes up with a solution that team with maximum cumulative rating of all three members in a team shall be representing their college.\nYou need to give the cumulative score of the team that will be representing the college.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. \n- First line of each test case contains a single integer $N$.\n- Second  line of each test case takes $N$ integers, denoting rating of $ith$ coder.\n\n-----Output:-----\nFor each testcase, output a single integer denoting cumulative rating  of the team.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $7 \\leq N \\leq 10^5$ \n- $0 \\leq X_i \\leq 10^9$\n\n-----Sample Input:-----\n1\n\n7\n\n10 40 30 30 20 0 0  \n\n-----Sample Output:-----\n100\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_max_team_score (n : Nat) (ratings : List Nat) : Nat := sorry\n\ndef list_sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef take_last (n : Nat) (l : List Nat) : List Nat := \n  let rev := l.reverse\n  (rev.take n).reverse\n\ntheorem find_max_team_score_upper_bound \n  (ratings : List Nat) (h : ratings.length ≥ 3) :\n  find_max_team_score ratings.length ratings ≤ list_sum (take_last 3 ratings) := sorry\n\ntheorem find_max_team_score_lower_bound \n  (ratings : List Nat) (h : ratings.length ≥ 3) : \n  find_max_team_score ratings.length ratings ≥ list_sum (ratings.take 3) := sorry\n\ntheorem find_max_team_score_three_elements\n  (ratings : List Nat) (h : ratings.length = 3) :\n  find_max_team_score ratings.length ratings = list_sum ratings := sorry\n\ntheorem find_max_team_score_consecutive\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) (hi : i + 2 < ratings.length) :\n  find_max_team_score ratings.length ratings ≥ \n    ratings[i]! + ratings[i+1]! + ratings[i+2]! := sorry\n\ntheorem find_max_team_score_wrapping\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) :\n  find_max_team_score ratings.length ratings ≥\n    ratings[i % ratings.length]! + \n    ratings[(i + 1) % ratings.length]! + \n    ratings[(i + 2) % ratings.length]! := sorry\n\ntheorem find_max_team_score_all_equal\n  (n : Nat) (h : n ≥ 3) :\n  find_max_team_score n (List.replicate n 1) = 3 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0848"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nVoritex a big data scientist collected huge amount of big data having structure of two rows and n columns.\nVoritex is storing all the valid data for manipulations and pressing invalid command when data not satisfying the constraints.\nVoritex likes brute force method and he calls it as BT, he decided to run newly created BT engine for getting good result.\nAt each instance when BT engine is outputting a newly created number Voritex calls it as BT number.\nVoritex is daydreaming and thinking that his engine is extremely optimised and will get an interview call in which he will be explaining the structure of BT engine and which will be staring from 1 and simultaneously performing $i$-th xor operation with $i$ and previously(one step before) obtained BT number.\nBT engine is outputting the $K$-th highest BT number in the first $N$ natural numbers.\nChef : (thinking) I also want to create BT engine……..\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of T test cases follows.\n- The line of each test case contains a two integers $N$ and $K$.\n\n-----Output:-----\nFor each test case, print a single line containing integer $K$-th highest number else print -$1$ when invalid command pressed.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100000$\n- $1 \\leq N \\leq 100000$\n- $1 \\leq K \\leq N$\n\n-----Sample Input:-----\n2\n4 2\n5 5\n\n-----Sample Output:-----\n2\n0\n\n-----EXPLANATION:-----\nFor first valid constraints generating output as 0 2 1 5 \n1^1 first BT number is 0\n2^0 second BT number is 2\n3^2 third BT number is 1\n4^1 fourth BT number is 5\nHence the answer is 2.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_kth_highest_bt_number (n k : Nat) : Int :=\nsorry\n\n\n\ntheorem find_kth_highest_non_negative (n k : Nat) :\n  find_kth_highest_bt_number n k ≠ -1 →\n  find_kth_highest_bt_number n k ≥ 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0859", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nVoritex a big data scientist collected huge amount of big data having structure of two rows and n columns.\nVoritex is storing all the valid data for manipulations and pressing invalid command when data not satisfying the constraints.\nVoritex likes brute force method and he calls it as BT, he decided to run newly created BT engine for getting good result.\nAt each instance when BT engine is outputting a newly created number Voritex calls it as BT number.\nVoritex is daydreaming and thinking that his engine is extremely optimised and will get an interview call in which he will be explaining the structure of BT engine and which will be staring from 1 and simultaneously performing $i$-th xor operation with $i$ and previously(one step before) obtained BT number.\nBT engine is outputting the $K$-th highest BT number in the first $N$ natural numbers.\nChef : (thinking) I also want to create BT engine……..\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of T test cases follows.\n- The line of each test case contains a two integers $N$ and $K$.\n\n-----Output:-----\nFor each test case, print a single line containing integer $K$-th highest number else print -$1$ when invalid command pressed.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100000$\n- $1 \\leq N \\leq 100000$\n- $1 \\leq K \\leq N$\n\n-----Sample Input:-----\n2\n4 2\n5 5\n\n-----Sample Output:-----\n2\n0\n\n-----EXPLANATION:-----\nFor first valid constraints generating output as 0 2 1 5 \n1^1 first BT number is 0\n2^0 second BT number is 2\n3^2 third BT number is 1\n4^1 fourth BT number is 5\nHence the answer is 2.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_kth_highest_bt_number (n k : Nat) : Int :=\nsorry\n\n\n\ntheorem find_kth_highest_non_negative (n k : Nat) :\n  find_kth_highest_bt_number n k ≠ -1 →\n  find_kth_highest_bt_number n k ≥ 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0859"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nRecall the definition of the Fibonacci numbers:\n\n\nf1 := 1\n\nf2 := 2\n\nfn := fn-1 + fn-2 (n>=3)\n\nGiven two numbers a and b, calculate how many Fibonacci numbers are in the range [a,b].\n\n\n-----Input-----\n\nThe input contains several test cases. Each test case consists of two non-negative integer numbers a and b. Input is terminated by a=b=0. Otherwise, a<=b<=10^100. The numbers a and b are given with no superfluous leading zeros.\n\n-----Output-----\n\nFor each test case output on a single line the number of Fibonacci numbers fi with a<=fi<=b.\n\n-----Example-----\nInput:\n\n10 100\n1234567890 9876543210\n0 0\n\nOutput:\n\n5\n4\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_fibonacci_in_range (a b : Int) : Nat :=\n  sorry\n\n\n\ntheorem zero_range_is_zero :\n  count_fibonacci_in_range 0 0 = 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0861", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nRecall the definition of the Fibonacci numbers:\n\n\nf1 := 1\n\nf2 := 2\n\nfn := fn-1 + fn-2 (n>=3)\n\nGiven two numbers a and b, calculate how many Fibonacci numbers are in the range [a,b].\n\n\n-----Input-----\n\nThe input contains several test cases. Each test case consists of two non-negative integer numbers a and b. Input is terminated by a=b=0. Otherwise, a<=b<=10^100. The numbers a and b are given with no superfluous leading zeros.\n\n-----Output-----\n\nFor each test case output on a single line the number of Fibonacci numbers fi with a<=fi<=b.\n\n-----Example-----\nInput:\n\n10 100\n1234567890 9876543210\n0 0\n\nOutput:\n\n5\n4\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_fibonacci_in_range (a b : Int) : Nat :=\n  sorry\n\n\n\ntheorem zero_range_is_zero :\n  count_fibonacci_in_range 0 0 = 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0861"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n-----Problem Statement-----\nChef has a sequence of N segments: [L1, R1], [L2, R2], ..., [LN, RN]. He wants to transform the first segment to the last one (with index N). His plan is to do this big deal with a number of transformations: firstly he will transform\n\nthe first segment to the second one, then to the third one, then to the fourth one, and so on till N-th one.\n\nChef can use operation of a single type: shift one segment border by one unit. So, if he has segment [L, R], he can transform it into one of the following segments: [L + 1, R] (we will denote such operation with string L+), [L, R + 1] (will be denoted as R+), [L - 1, R] (L-), [L, R - 1] (R-). Chef doesn't like empty segments, therefore he cannot use any operation that makes a segment empty (L = R).\n\nChef really wants to transform his segment as fast as possible. Please, help him. Find the sequence with minimal number of operations that transforms his segment. If there are multiple such sequences pick the lexicographically minimal one.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \n\nThe first line of each test case contains a single integer N denoting the number of segments Chef has. \n\nThe following N lines contain pairs of integers. The i-th line contains integers Li, Ri, denoting i-th Chef's segment.\n\n-----Output-----\nFor each test case print an answer - two lines. The first line should contain the minimal number of operations. The second line should contain the sequence of operations\n\nwithout any whitespaces.\n\n-----Constraints-----\n- 1 ≤ T, N ≤ 1000.\n- -1000 ≤ Li < Ri ≤ 1000.\nThe total sum of N values for all test cases doesn't exceed 1000.\n\n-----Example-----\nInput:\n4\n3\n-1 0\n0 1\n3 5\n1\n0 1\n3\n-2 -1\n-2 -1\n-2 0\n4\n4 6\n3 5\n-1 1\n1 2\n\nOutput:\n9\nR+L+R+L+R+L+R+L+R+\n0\n\n1\nR+\n13\nL-R-L-L-L-L-R-R-R-R-L+R+L+\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n/- Segment type and operations -/\ndef Segment := Int × Int \n\ninductive Operation\n  | L_plus\n  | L_minus\n  | R_plus \n  | R_minus\n\ndef apply_operation (s : Segment) (op : Operation) : Segment :=\n  match op with\n  | Operation.L_plus => (s.1 + 1, s.2)\n  | Operation.L_minus => (s.1 - 1, s.2) \n  | Operation.R_plus => (s.1, s.2 + 1)\n  | Operation.R_minus => (s.1, s.2 - 1)\n  \ndef is_valid_segment (s : Segment) : Bool :=\n  s.1 < s.2\n\ndef solve (segments : List Segment) : List Operation := sorry\n\ntheorem operations_preserve_validity \n  (segments : List Segment)\n  (h₁ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve segments\n  ∀ i, i ≤ ops.length →\n  let curr := List.foldl apply_operation (List.head segments h₁) (ops.take i)\n  is_valid_segment curr = true :=\nsorry \n\ntheorem reaches_target_segments\n  (segments : List Segment)\n  (h₁ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve segments\n  ∀ target ∈ segments.tail,\n  ∃ i ≤ ops.length,\n  List.foldl apply_operation (List.head segments h₁) (ops.take i) = target :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0896", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n-----Problem Statement-----\nChef has a sequence of N segments: [L1, R1], [L2, R2], ..., [LN, RN]. He wants to transform the first segment to the last one (with index N). His plan is to do this big deal with a number of transformations: firstly he will transform\n\nthe first segment to the second one, then to the third one, then to the fourth one, and so on till N-th one.\n\nChef can use operation of a single type: shift one segment border by one unit. So, if he has segment [L, R], he can transform it into one of the following segments: [L + 1, R] (we will denote such operation with string L+), [L, R + 1] (will be denoted as R+), [L - 1, R] (L-), [L, R - 1] (R-). Chef doesn't like empty segments, therefore he cannot use any operation that makes a segment empty (L = R).\n\nChef really wants to transform his segment as fast as possible. Please, help him. Find the sequence with minimal number of operations that transforms his segment. If there are multiple such sequences pick the lexicographically minimal one.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \n\nThe first line of each test case contains a single integer N denoting the number of segments Chef has. \n\nThe following N lines contain pairs of integers. The i-th line contains integers Li, Ri, denoting i-th Chef's segment.\n\n-----Output-----\nFor each test case print an answer - two lines. The first line should contain the minimal number of operations. The second line should contain the sequence of operations\n\nwithout any whitespaces.\n\n-----Constraints-----\n- 1 ≤ T, N ≤ 1000.\n- -1000 ≤ Li < Ri ≤ 1000.\nThe total sum of N values for all test cases doesn't exceed 1000.\n\n-----Example-----\nInput:\n4\n3\n-1 0\n0 1\n3 5\n1\n0 1\n3\n-2 -1\n-2 -1\n-2 0\n4\n4 6\n3 5\n-1 1\n1 2\n\nOutput:\n9\nR+L+R+L+R+L+R+L+R+\n0\n\n1\nR+\n13\nL-R-L-L-L-L-R-R-R-R-L+R+L+\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n/- Segment type and operations -/\ndef Segment := Int × Int \n\ninductive Operation\n  | L_plus\n  | L_minus\n  | R_plus \n  | R_minus\n\ndef apply_operation (s : Segment) (op : Operation) : Segment :=\n  match op with\n  | Operation.L_plus => (s.1 + 1, s.2)\n  | Operation.L_minus => (s.1 - 1, s.2) \n  | Operation.R_plus => (s.1, s.2 + 1)\n  | Operation.R_minus => (s.1, s.2 - 1)\n  \ndef is_valid_segment (s : Segment) : Bool :=\n  s.1 < s.2\n\ndef solve (segments : List Segment) : List Operation := sorry\n\ntheorem operations_preserve_validity \n  (segments : List Segment)\n  (h₁ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve segments\n  ∀ i, i ≤ ops.length →\n  let curr := List.foldl apply_operation (List.head segments h₁) (ops.take i)\n  is_valid_segment curr = true :=\nsorry \n\ntheorem reaches_target_segments\n  (segments : List Segment)\n  (h₁ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve segments\n  ∀ target ∈ segments.tail,\n  ∃ i ≤ ops.length,\n  List.foldl apply_operation (List.head segments h₁) (ops.take i) = target :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0896"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an empty array A of infinite length and a positive integer K you have to process \nQ queries of type:    \n- ! l r x: Fill the value x in all the empty places in the array from index l to r  (both inclusive).\n- ? l r: Print the number of prime factors of K which is also a prime factor of at least one number in A[l], A[l + 1], A[l + 2], … A[r].   \n\n-----Input-----\n- The first line contains two space separated integers K and Q respectively.\n- Then Q lines follow:\n- Each of the $i^{th}$ line contains one of the above two types of queries.\n\n-----Output-----\nFor each query of the second type, print in a new line the answer to that query. i.e. number of prime factors of K which is also a prime factor of at least one number in A[l], A[l + 1], A[l + 2], … A[r].   \n\n-----Constraints-----\n- $1 \\leq K, x \\leq 10^9$\n- $ 1 \\leq l \\leq r \\leq 10^5$\n- $ 1 \\leq Q \\leq 10^5$ \n\n-----Sample Input-----\n20 5\n\n? 1 5\n\n! 3 5 4\n\n? 1 5\n\n! 1 4 15\n\n? 1 5   \n\n-----Sample Output-----\n0\n\n1\n\n2   \n\n-----EXPLANATION-----\nInitially, all the places in the array are empty. i.e _ _ _ _ _\n\nAfter first update the array looks like: _ _ 4 4 4\n\nIn the range [1, 5] the only factor of 20 which is also a prime factor of at least one number in _ _ 4 4 4  is 2.\n\nAfter the second update the array looks like: 15 15 4 4 4\n\nIn the range [1, 5] the prime factors of 20 i.e. 5 is a prime factor of 15, 15 and 2 is the prime factor of 4, 4, 4.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_prime_array_queries (k : Nat) (queries : List String) : List Nat := sorry\n\ntheorem query_results_bounds \n  (k : Nat) \n  (queries : List String) \n  (h1 : 2 ≤ k)\n  (h2 : k ≤ 1000)\n  (h3 : queries.length > 0)\n  (h4 : queries.length ≤ 10) :\n  let result := solve_prime_array_queries k queries\n  let read_queries := (queries.filter (fun q => q.get! 0 = '?')).length\n  ∀ count ∈ result,\n    read_queries = result.length ∧\n    count ≥ 0 ∧ \n    count ≤ 10 := -- simplified bound since k ≤ 1000\nsorry\n\ntheorem empty_queries_result\n  (k : Nat)\n  (h1 : 2 ≤ k)\n  (h2 : k ≤ 1000) :\n  solve_prime_array_queries k [] = [] :=\nsorry\n\ntheorem non_overlapping_ranges\n  (k : Nat)\n  (l r : Nat)\n  (h1 : 2 ≤ k)\n  (h2 : k ≤ 1000)\n  (h3 : 1 ≤ l)\n  (h4 : l ≤ 50)\n  (h5 : 51 ≤ r)\n  (h6 : r ≤ 100) :\n  let q1 := \"! 1 \" ++ toString l ++ \" 2\"\n  let q2 := \"! \" ++ toString r ++ \" 100 3\"\n  let q3 := \"? \" ++ toString (l+1) ++ \" \" ++ toString (r-1)\n  solve_prime_array_queries k [q1, q2, q3] = [0] :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0924", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an empty array A of infinite length and a positive integer K you have to process \nQ queries of type:    \n- ! l r x: Fill the value x in all the empty places in the array from index l to r  (both inclusive).\n- ? l r: Print the number of prime factors of K which is also a prime factor of at least one number in A[l], A[l + 1], A[l + 2], … A[r].   \n\n-----Input-----\n- The first line contains two space separated integers K and Q respectively.\n- Then Q lines follow:\n- Each of the $i^{th}$ line contains one of the above two types of queries.\n\n-----Output-----\nFor each query of the second type, print in a new line the answer to that query. i.e. number of prime factors of K which is also a prime factor of at least one number in A[l], A[l + 1], A[l + 2], … A[r].   \n\n-----Constraints-----\n- $1 \\leq K, x \\leq 10^9$\n- $ 1 \\leq l \\leq r \\leq 10^5$\n- $ 1 \\leq Q \\leq 10^5$ \n\n-----Sample Input-----\n20 5\n\n? 1 5\n\n! 3 5 4\n\n? 1 5\n\n! 1 4 15\n\n? 1 5   \n\n-----Sample Output-----\n0\n\n1\n\n2   \n\n-----EXPLANATION-----\nInitially, all the places in the array are empty. i.e _ _ _ _ _\n\nAfter first update the array looks like: _ _ 4 4 4\n\nIn the range [1, 5] the only factor of 20 which is also a prime factor of at least one number in _ _ 4 4 4  is 2.\n\nAfter the second update the array looks like: 15 15 4 4 4\n\nIn the range [1, 5] the prime factors of 20 i.e. 5 is a prime factor of 15, 15 and 2 is the prime factor of 4, 4, 4.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_prime_array_queries (k : Nat) (queries : List String) : List Nat := sorry\n\ntheorem query_results_bounds \n  (k : Nat) \n  (queries : List String) \n  (h1 : 2 ≤ k)\n  (h2 : k ≤ 1000)\n  (h3 : queries.length > 0)\n  (h4 : queries.length ≤ 10) :\n  let result := solve_prime_array_queries k queries\n  let read_queries := (queries.filter (fun q => q.get! 0 = '?')).length\n  ∀ count ∈ result,\n    read_queries = result.length ∧\n    count ≥ 0 ∧ \n    count ≤ 10 := -- simplified bound since k ≤ 1000\nsorry\n\ntheorem empty_queries_result\n  (k : Nat)\n  (h1 : 2 ≤ k)\n  (h2 : k ≤ 1000) :\n  solve_prime_array_queries k [] = [] :=\nsorry\n\ntheorem non_overlapping_ranges\n  (k : Nat)\n  (l r : Nat)\n  (h1 : 2 ≤ k)\n  (h2 : k ≤ 1000)\n  (h3 : 1 ≤ l)\n  (h4 : l ≤ 50)\n  (h5 : 51 ≤ r)\n  (h6 : r ≤ 100) :\n  let q1 := \"! 1 \" ++ toString l ++ \" 2\"\n  let q2 := \"! \" ++ toString r ++ \" 100 3\"\n  let q3 := \"? \" ++ toString (l+1) ++ \" \" ++ toString (r-1)\n  solve_prime_array_queries k [q1, q2, q3] = [0] :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0924"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nLet F(X) equals to the number of lucky digits in decimal representation of X. Chef wants to know the number of such integers X, that L ≤ X ≤ R and F(X) is a lucky number. Help him and calculate that number modulo 109+7.\n\n-----Input-----\nFirst line contains one integer T, the number of test cases. Each of the following T lines contains two space separated positive integers L and R.\n\n-----Output-----\nFor each of the T test cases print one integer, the number of such X, that L ≤ X ≤ R and F(X) is a lucky number, modulo 1000000007.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ L ≤ R ≤ 101000\n\n-----Example-----\nInput:\n4\n1 100\n1 10000\n1 100000\n4444 4447\n\nOutput:\n0\n16\n640\n2\n\n-----Notes-----\nFirst test case: of course, any number of less than 4 digits can't contain lucky number of lucky digits, so the answer is 0.\n\nSecond test case: 16 required numbers are 4444 4447 4474 4477 4744 4747 4774 4777 7444 7447 7474 7477 7744 7747 7774 7777.\n\nThird test case: there are 640 required lucky numbers. Some of them are 4474, 14747, 41474, 77277, 44407, 74749.\n\nFourth test case: the only two required numbers are 4444 and 4447.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_lucky_numbers (left right : String) : Nat := sorry\n\ntheorem solve_lucky_numbers_range {left right : String} \n  (h1 : ∀ c ∈ left.data, c.isDigit)\n  (h2 : ∀ c ∈ right.data, c.isDigit)\n  (h3 : left.length > 0)\n  (h4 : right.length > 0)\n  (h5 : left.toNat? = some (l : Nat))\n  (h6 : right.toNat? = some (r : Nat))\n  (h7 : l ≤ 10^9)\n  (h8 : r ≤ 10^9)\n  : solve_lucky_numbers left right ≤ 10^9 + 7 := sorry\n\ntheorem solve_lucky_numbers_identical_input {n : String}\n  (h1 : ∀ c ∈ n.data, c.isDigit) \n  (h2 : n.length > 0)\n  (h3 : n.toNat? = some (num : Nat))\n  (h4 : num ≤ 10^9)\n  : solve_lucky_numbers n n ≤ 1 := sorry\n\ntheorem solve_lucky_numbers_invalid_input_left {n right : String}\n  (h1 : ∃ c ∈ n.data, !c.isDigit)\n  (h2 : ∀ c ∈ right.data, c.isDigit)\n  : solve_lucky_numbers n right = 0 := sorry\n\ntheorem solve_lucky_numbers_invalid_input_right {left n : String}\n  (h1 : ∀ c ∈ left.data, c.isDigit)\n  (h2 : ∃ c ∈ n.data, !c.isDigit)\n  : solve_lucky_numbers left n = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0939", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nLet F(X) equals to the number of lucky digits in decimal representation of X. Chef wants to know the number of such integers X, that L ≤ X ≤ R and F(X) is a lucky number. Help him and calculate that number modulo 109+7.\n\n-----Input-----\nFirst line contains one integer T, the number of test cases. Each of the following T lines contains two space separated positive integers L and R.\n\n-----Output-----\nFor each of the T test cases print one integer, the number of such X, that L ≤ X ≤ R and F(X) is a lucky number, modulo 1000000007.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ L ≤ R ≤ 101000\n\n-----Example-----\nInput:\n4\n1 100\n1 10000\n1 100000\n4444 4447\n\nOutput:\n0\n16\n640\n2\n\n-----Notes-----\nFirst test case: of course, any number of less than 4 digits can't contain lucky number of lucky digits, so the answer is 0.\n\nSecond test case: 16 required numbers are 4444 4447 4474 4477 4744 4747 4774 4777 7444 7447 7474 7477 7744 7747 7774 7777.\n\nThird test case: there are 640 required lucky numbers. Some of them are 4474, 14747, 41474, 77277, 44407, 74749.\n\nFourth test case: the only two required numbers are 4444 and 4447.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_lucky_numbers (left right : String) : Nat := sorry\n\ntheorem solve_lucky_numbers_range {left right : String} \n  (h1 : ∀ c ∈ left.data, c.isDigit)\n  (h2 : ∀ c ∈ right.data, c.isDigit)\n  (h3 : left.length > 0)\n  (h4 : right.length > 0)\n  (h5 : left.toNat? = some (l : Nat))\n  (h6 : right.toNat? = some (r : Nat))\n  (h7 : l ≤ 10^9)\n  (h8 : r ≤ 10^9)\n  : solve_lucky_numbers left right ≤ 10^9 + 7 := sorry\n\ntheorem solve_lucky_numbers_identical_input {n : String}\n  (h1 : ∀ c ∈ n.data, c.isDigit) \n  (h2 : n.length > 0)\n  (h3 : n.toNat? = some (num : Nat))\n  (h4 : num ≤ 10^9)\n  : solve_lucky_numbers n n ≤ 1 := sorry\n\ntheorem solve_lucky_numbers_invalid_input_left {n right : String}\n  (h1 : ∃ c ∈ n.data, !c.isDigit)\n  (h2 : ∀ c ∈ right.data, c.isDigit)\n  : solve_lucky_numbers n right = 0 := sorry\n\ntheorem solve_lucky_numbers_invalid_input_right {left n : String}\n  (h1 : ∀ c ∈ left.data, c.isDigit)\n  (h2 : ∃ c ∈ n.data, !c.isDigit)\n  : solve_lucky_numbers left n = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0939"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef has a circular plot of land of radius $R$ on which he wants to construct a swimming pool.\nHe wants the swimming pool to be square in shape with maximum possible area,so that he along\nwith his friends can enjoy themselves during their summer vacations.\nHelp Chef to find out the maximum area of the swimming pool that can be constructed in his \ncircular plot.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input,  $R$ i.e the radius of the plot. \n\n-----Output:-----\nFor each testcase, output in a single line answer displaying the maximum possible area of the swimming pool.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq R \\leq 10^8$\n\n-----Sample Input:-----\n2\n\n5\n\n10   \n\n-----Sample Output:-----\n50\n\n200\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef max_pool_area (r : Nat) : Nat := sorry\n\ntheorem max_pool_area_quadratic {r : Nat} : \n  max_pool_area r = 2 * (r * r) := sorry\n\ntheorem max_pool_area_positive {r : Nat} (h : r > 0) : \n  max_pool_area r > 0 := sorry\n\ntheorem max_pool_area_zero_iff {r : Nat} :\n  max_pool_area r = 0 ↔ r = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0940", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef has a circular plot of land of radius $R$ on which he wants to construct a swimming pool.\nHe wants the swimming pool to be square in shape with maximum possible area,so that he along\nwith his friends can enjoy themselves during their summer vacations.\nHelp Chef to find out the maximum area of the swimming pool that can be constructed in his \ncircular plot.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input,  $R$ i.e the radius of the plot. \n\n-----Output:-----\nFor each testcase, output in a single line answer displaying the maximum possible area of the swimming pool.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq R \\leq 10^8$\n\n-----Sample Input:-----\n2\n\n5\n\n10   \n\n-----Sample Output:-----\n50\n\n200\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef max_pool_area (r : Nat) : Nat := sorry\n\ntheorem max_pool_area_quadratic {r : Nat} : \n  max_pool_area r = 2 * (r * r) := sorry\n\ntheorem max_pool_area_positive {r : Nat} (h : r > 0) : \n  max_pool_area r > 0 := sorry\n\ntheorem max_pool_area_zero_iff {r : Nat} :\n  max_pool_area r = 0 ↔ r = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0940"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nTejas has invited the Clash Team for a Dinner Party. He places V empty plates (numbered from 1 to V inclusive) in a straight line on a table. He has prepared 2 kinds of Delicious Dishes named dish A and dish B.\n\nHe has exactly V servings of Dish A and W servings of dish B. \n\nNow he wants to serve the dishes in such a way that if theith plate has serving of Dish A then (i-1)th plate should not have serving of Dish B. Assuming all the Dishes are identical find number of ways Tejas can serve the Clash Team.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases . The description of T testcases follow.\n\n- The first line of each test case contains two space seperated integers V W .\n\n-----Output-----\nFor each test case, output the number of ways Tejas can serve the Clash Team.\n\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 100\n- 1 ≤ V ≤ 1000\n- 1 ≤ W ≤ 1000\n\n-----Example-----\nInput:\n\n1\n\n3 3 \n\nOutput:\n4\n\n\n\n-----Explanation-----\n\nIn the above example the 4 ways are:\n\nAAA\n\nAAB\n\nABB\n\nBBB\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_dish_distribution (v w : Nat) : Nat := sorry\n\ntheorem dish_distribution_lower_bound (v w : Nat) :\n  solve_dish_distribution v w ≥ 1 := sorry\n\ntheorem dish_distribution_upper_bound (v w : Nat) :\n  solve_dish_distribution v w ≤ min v w + 1 := sorry\n\ntheorem dish_distribution_equals_min_plus_one (v w : Nat) :\n  solve_dish_distribution v w = min v w + 1 := sorry\n\ntheorem dish_distribution_symmetry (v w : Nat) :\n  solve_dish_distribution v w = solve_dish_distribution w v := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0943", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nTejas has invited the Clash Team for a Dinner Party. He places V empty plates (numbered from 1 to V inclusive) in a straight line on a table. He has prepared 2 kinds of Delicious Dishes named dish A and dish B.\n\nHe has exactly V servings of Dish A and W servings of dish B. \n\nNow he wants to serve the dishes in such a way that if theith plate has serving of Dish A then (i-1)th plate should not have serving of Dish B. Assuming all the Dishes are identical find number of ways Tejas can serve the Clash Team.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases . The description of T testcases follow.\n\n- The first line of each test case contains two space seperated integers V W .\n\n-----Output-----\nFor each test case, output the number of ways Tejas can serve the Clash Team.\n\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 100\n- 1 ≤ V ≤ 1000\n- 1 ≤ W ≤ 1000\n\n-----Example-----\nInput:\n\n1\n\n3 3 \n\nOutput:\n4\n\n\n\n-----Explanation-----\n\nIn the above example the 4 ways are:\n\nAAA\n\nAAB\n\nABB\n\nBBB\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_dish_distribution (v w : Nat) : Nat := sorry\n\ntheorem dish_distribution_lower_bound (v w : Nat) :\n  solve_dish_distribution v w ≥ 1 := sorry\n\ntheorem dish_distribution_upper_bound (v w : Nat) :\n  solve_dish_distribution v w ≤ min v w + 1 := sorry\n\ntheorem dish_distribution_equals_min_plus_one (v w : Nat) :\n  solve_dish_distribution v w = min v w + 1 := sorry\n\ntheorem dish_distribution_symmetry (v w : Nat) :\n  solve_dish_distribution v w = solve_dish_distribution w v := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0943"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nSince due to COVID 19, India has undergone a complete 21 day lockdown. So Amol was attending an online lecture where his professor asked him to solve a question. Amol was unable to solve the question so he asked you to solve the question and give him the correct answer. \n\nThe question was asked a such that his professor gave him a number M and a list of integers of length N (i.e. A1, A2,..... AN) and you have to find out all the subsets that add up to M and the total number of subsets will be the final answer. \n\nInput: \n• The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. \n\n• The first line of each test case contains a single integer N. \n\n• The second line of each test case contains a single integer M. \n\n• The third line contains N space-separated integers A1, A2,..... AN. \n\nOutput: \nFor each test case, print a single line containing one integer ― the no. of subsets that adds upto M.\n\nConstraints: \n• 1≤T≤5\n\n• 1≤N≤100 \n\n• 10≤M≤100 \n\n• 1≤Ai≤100\n\nExampleInput:\n\n2\n\n4\n\n16\n\n2 4 6 10 \n\n4 \n\n20 \n\n2 8 12 10 \n\nOutput:\n\n2\n\n2\n\nExplanation:\nIn the 1st example there are two subsets {2,4,10} and {6,10} that adds upto 16 so the output is 2.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef countsubsetsum (target : Nat) (arr : List Nat) : Nat := sorry\n\ndef List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs\n\ntheorem zero_sum_always_has_one_solution {arr : List Nat} : \n  countsubsetsum 0 arr = 1 := sorry\n\ntheorem single_element_sums {arr : List Nat} {x : Nat} :\n  x ∈ arr → countsubsetsum x arr ≥ 1 := sorry\n\n\n\ntheorem results_non_negative {target : Nat} {arr : List Nat} :\n  countsubsetsum target arr ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "0967", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nSince due to COVID 19, India has undergone a complete 21 day lockdown. So Amol was attending an online lecture where his professor asked him to solve a question. Amol was unable to solve the question so he asked you to solve the question and give him the correct answer. \n\nThe question was asked a such that his professor gave him a number M and a list of integers of length N (i.e. A1, A2,..... AN) and you have to find out all the subsets that add up to M and the total number of subsets will be the final answer. \n\nInput: \n• The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. \n\n• The first line of each test case contains a single integer N. \n\n• The second line of each test case contains a single integer M. \n\n• The third line contains N space-separated integers A1, A2,..... AN. \n\nOutput: \nFor each test case, print a single line containing one integer ― the no. of subsets that adds upto M.\n\nConstraints: \n• 1≤T≤5\n\n• 1≤N≤100 \n\n• 10≤M≤100 \n\n• 1≤Ai≤100\n\nExampleInput:\n\n2\n\n4\n\n16\n\n2 4 6 10 \n\n4 \n\n20 \n\n2 8 12 10 \n\nOutput:\n\n2\n\n2\n\nExplanation:\nIn the 1st example there are two subsets {2,4,10} and {6,10} that adds upto 16 so the output is 2.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef countsubsetsum (target : Nat) (arr : List Nat) : Nat := sorry\n\ndef List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs\n\ntheorem zero_sum_always_has_one_solution {arr : List Nat} : \n  countsubsetsum 0 arr = 1 := sorry\n\ntheorem single_element_sums {arr : List Nat} {x : Nat} :\n  x ∈ arr → countsubsetsum x arr ≥ 1 := sorry\n\n\n\ntheorem results_non_negative {target : Nat} {arr : List Nat} :\n  countsubsetsum target arr ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "0967"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThere are $N$ cities on a circle, numbered $1$ through $N$. For each $i$ ($1 \\le i \\le N-1$), cities $i$ and $i+1$ are directly connected by a bidirectional road with length $A_i$, and cities $N$ and $1$ are also directly connected by a bidirectional road with length $A_N$. However, we do not know the lengths of some roads.\nFor each city $i$, we do know that it has an opposite city — formally, there is a city $j \\neq i$ such that the clockwise distance between cities $i$ and $j$ is equal to the counterclockwise distance between these cities.\nPlease find the lengths of all roads in such a way that the above condition is satisfied and the sum of lengths of all roads is minimised.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of the input contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$. For each valid $i$, $A_i = -1$ denotes that the length of road $i$ is unknown.\n\n-----Output-----\nFor each test case, print a line containing the string \"NO\" if there is no solution or \"YES\" otherwise. If a solution exists, print a second line containing $N$ space-separated positive integers — the lengths of all roads in your solution. Each of these integers should be $\\le 10^9$. If there are multiple solutions, you may print any one.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $3 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ or $A_i = -1$ for each valid $i$\n- the sum of $N$ for all test cases does not exceed $3\\cdot 10^5$\n\n-----Subtasks-----\nSubtask #1 (10 points): $N \\le 4$\nSubtask #2 (20 points): $A_i = \\pm 1$ for each valid $i$\nSubtask #3 (70 points): original constraints\n\n-----Example Input-----\n4\n4\n1 1 1 1\n4\n1 1 1 2\n4\n1 -1 -1 4\n4\n1 -1 2 -1\n\n-----Example Output-----\nYES\n1 1 1 1\nNO\nYES\n1 4 1 4\nNO\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_circular_roads (n : Nat) (road_lengths : List Int) : (String × Option (List Nat)) :=\nsorry\n\ntheorem valid_solution_odd_n (n : Nat) (road_lengths : List Int) (h : n % 2 = 1) :\n  solve_circular_roads n road_lengths = (\"NO\", none) :=\nsorry\n\ntheorem valid_solution_props {n : Nat} {road_lengths : List Int} \n  (h : n % 2 = 0) (result : String × Option (List Nat)) \n  (h2 : result = solve_circular_roads n road_lengths) :\n  (result.1 = \"NO\" ∨ \n   (result.1 = \"YES\" ∧ \n    (∀ roads : List Nat, result.2 = some roads → \n      roads.length = n ∧\n      (∀ (i : Nat) (h3 : i < road_lengths.length) (h4 : i < roads.length),\n         road_lengths.get ⟨i, h3⟩ ≠ -1 → roads.get ⟨i, h4⟩ = road_lengths.get ⟨i, h3⟩) ∧\n      (∀ (i : Nat) (h3 : i < roads.length) (h4 : i + n/2 < roads.length),\n         roads.get ⟨i, h3⟩ = roads.get ⟨i + n/2, h4⟩)))) :=\nsorry\n\ntheorem all_negative_one_has_solution (n : Nat) (h : n % 2 = 0) :\n  let road_lengths := List.replicate n (-1 : Int)\n  let result := solve_circular_roads n road_lengths\n  result.1 = \"YES\" ∧ \n  (∀ roads : List Nat, result.2 = some roads →\n    ∀ x ∈ roads, x = 1) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1022", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThere are $N$ cities on a circle, numbered $1$ through $N$. For each $i$ ($1 \\le i \\le N-1$), cities $i$ and $i+1$ are directly connected by a bidirectional road with length $A_i$, and cities $N$ and $1$ are also directly connected by a bidirectional road with length $A_N$. However, we do not know the lengths of some roads.\nFor each city $i$, we do know that it has an opposite city — formally, there is a city $j \\neq i$ such that the clockwise distance between cities $i$ and $j$ is equal to the counterclockwise distance between these cities.\nPlease find the lengths of all roads in such a way that the above condition is satisfied and the sum of lengths of all roads is minimised.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of the input contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$. For each valid $i$, $A_i = -1$ denotes that the length of road $i$ is unknown.\n\n-----Output-----\nFor each test case, print a line containing the string \"NO\" if there is no solution or \"YES\" otherwise. If a solution exists, print a second line containing $N$ space-separated positive integers — the lengths of all roads in your solution. Each of these integers should be $\\le 10^9$. If there are multiple solutions, you may print any one.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $3 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ or $A_i = -1$ for each valid $i$\n- the sum of $N$ for all test cases does not exceed $3\\cdot 10^5$\n\n-----Subtasks-----\nSubtask #1 (10 points): $N \\le 4$\nSubtask #2 (20 points): $A_i = \\pm 1$ for each valid $i$\nSubtask #3 (70 points): original constraints\n\n-----Example Input-----\n4\n4\n1 1 1 1\n4\n1 1 1 2\n4\n1 -1 -1 4\n4\n1 -1 2 -1\n\n-----Example Output-----\nYES\n1 1 1 1\nNO\nYES\n1 4 1 4\nNO\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_circular_roads (n : Nat) (road_lengths : List Int) : (String × Option (List Nat)) :=\nsorry\n\ntheorem valid_solution_odd_n (n : Nat) (road_lengths : List Int) (h : n % 2 = 1) :\n  solve_circular_roads n road_lengths = (\"NO\", none) :=\nsorry\n\ntheorem valid_solution_props {n : Nat} {road_lengths : List Int} \n  (h : n % 2 = 0) (result : String × Option (List Nat)) \n  (h2 : result = solve_circular_roads n road_lengths) :\n  (result.1 = \"NO\" ∨ \n   (result.1 = \"YES\" ∧ \n    (∀ roads : List Nat, result.2 = some roads → \n      roads.length = n ∧\n      (∀ (i : Nat) (h3 : i < road_lengths.length) (h4 : i < roads.length),\n         road_lengths.get ⟨i, h3⟩ ≠ -1 → roads.get ⟨i, h4⟩ = road_lengths.get ⟨i, h3⟩) ∧\n      (∀ (i : Nat) (h3 : i < roads.length) (h4 : i + n/2 < roads.length),\n         roads.get ⟨i, h3⟩ = roads.get ⟨i + n/2, h4⟩)))) :=\nsorry\n\ntheorem all_negative_one_has_solution (n : Nat) (h : n % 2 = 0) :\n  let road_lengths := List.replicate n (-1 : Int)\n  let result := solve_circular_roads n road_lengths\n  result.1 = \"YES\" ∧ \n  (∀ roads : List Nat, result.2 = some roads →\n    ∀ x ∈ roads, x = 1) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1022"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef has a binary array in an unsorted manner. Cheffina challenges chef to find the transition point in the sorted (ascending) binary array. Here indexing is starting from 0.\nNote: Transition point always exists.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input, $N$.\n- N space-separated binary numbers. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n1\n5\n0 1 0 0 1\n\n-----Sample Output:-----\n3\n\n-----EXPLANATION:-----\nbinary array in sorted form will look like = [0, 0, 0, 1, 1]\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_transition_point (n : Nat) (arr : List Nat) : Option Nat :=\n  sorry\n\ntheorem find_transition_point_valid_index (n : Nat) (arr : List Nat) :\n  let result := find_transition_point n arr\n  ∀ i, result = some i → i < n := \n  sorry\n\ntheorem find_transition_point_zeros_before (n : Nat) (arr : List Nat) :\n  let result := find_transition_point n arr\n  ∀ i, result = some i →\n  ∀ j < i, arr[j]! = 0 := \n  sorry\n\ntheorem find_transition_point_first_one (n : Nat) (arr : List Nat) :\n  let result := find_transition_point n arr\n  ∀ i, result = some i →\n  i < n →\n  arr[i]! = 1 :=\n  sorry\n\ntheorem find_transition_point_no_ones (n : Nat) (arr : List Nat) :\n  (∀ x ∈ arr, x ≠ 1) →\n  find_transition_point n arr = none :=\n  sorry\n\ntheorem find_transition_point_all_ones (n : Nat) :\n  n > 0 →\n  find_transition_point n (List.replicate n 1) = some 0 :=\n  sorry\n\ntheorem find_transition_point_all_zeros (n : Nat) :\n  n > 0 →\n  find_transition_point n (List.replicate n 0) = none :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1053", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef has a binary array in an unsorted manner. Cheffina challenges chef to find the transition point in the sorted (ascending) binary array. Here indexing is starting from 0.\nNote: Transition point always exists.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input, $N$.\n- N space-separated binary numbers. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n1\n5\n0 1 0 0 1\n\n-----Sample Output:-----\n3\n\n-----EXPLANATION:-----\nbinary array in sorted form will look like = [0, 0, 0, 1, 1]\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_transition_point (n : Nat) (arr : List Nat) : Option Nat :=\n  sorry\n\ntheorem find_transition_point_valid_index (n : Nat) (arr : List Nat) :\n  let result := find_transition_point n arr\n  ∀ i, result = some i → i < n := \n  sorry\n\ntheorem find_transition_point_zeros_before (n : Nat) (arr : List Nat) :\n  let result := find_transition_point n arr\n  ∀ i, result = some i →\n  ∀ j < i, arr[j]! = 0 := \n  sorry\n\ntheorem find_transition_point_first_one (n : Nat) (arr : List Nat) :\n  let result := find_transition_point n arr\n  ∀ i, result = some i →\n  i < n →\n  arr[i]! = 1 :=\n  sorry\n\ntheorem find_transition_point_no_ones (n : Nat) (arr : List Nat) :\n  (∀ x ∈ arr, x ≠ 1) →\n  find_transition_point n arr = none :=\n  sorry\n\ntheorem find_transition_point_all_ones (n : Nat) :\n  n > 0 →\n  find_transition_point n (List.replicate n 1) = some 0 :=\n  sorry\n\ntheorem find_transition_point_all_zeros (n : Nat) :\n  n > 0 →\n  find_transition_point n (List.replicate n 0) = none :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1053"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nHo, Ho, Ho!\nIt's Christmas time and our friendly grandpa Santa Claus is busy distributing gifts to all the nice children. With the rising population, Santa's workload every year gets increased and he seeks your help to wrap the gifts with fancy wrapping papers while he gets them distributed. \nEverything was going great until you realised that you'll fall short of wrapping paper. But luckily, you get a very innovative idea, that will allow you to pack all the remaining gifts without worrying about lack of wrapping paper. Any guesses what the idea is? Using ice for wrapping, obviously! That's the only thing available at the North Pole.\nNow, in order to reduce your trips to the ice factory, you decide to write a program that helps you visualize how much ice is needed for a particular gift. \n\n-----Input:-----\nInput will consist of a single line with size $n$.\n\n-----Output:-----\nPrint the ice wrapped gift box for the given size. \n\n-----Constraints-----\n- $0 \\leq n \\leq 1000$\n\n-----Sample Input:-----\n4\n\n-----Sample Output:-----\n4 4 4 4 4 4 4\n4 3 3 3 3 3 4\n4 3 2 2 2 3 4\n4 3 2 1 2 3 4\n4 3 2 2 2 3 4 \n4 3 3 3 3 3 4\n4 4 4 4 4 4 4\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef christmas_box (n : Nat) : List (List Nat) := sorry\n\ntheorem christmas_box_empty (n : Nat) : \n  n = 0 → christmas_box n = [] := sorry\n\ntheorem christmas_box_length {n : Nat} :\n  n > 0 → List.length (christmas_box n) = 2 * n - 1 := sorry\n\n\n\ntheorem christmas_box_top_bottom_match {n : Nat} :\n  n > 1 → \n  List.head! (christmas_box n) = List.getLast! (christmas_box n) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1062", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nHo, Ho, Ho!\nIt's Christmas time and our friendly grandpa Santa Claus is busy distributing gifts to all the nice children. With the rising population, Santa's workload every year gets increased and he seeks your help to wrap the gifts with fancy wrapping papers while he gets them distributed. \nEverything was going great until you realised that you'll fall short of wrapping paper. But luckily, you get a very innovative idea, that will allow you to pack all the remaining gifts without worrying about lack of wrapping paper. Any guesses what the idea is? Using ice for wrapping, obviously! That's the only thing available at the North Pole.\nNow, in order to reduce your trips to the ice factory, you decide to write a program that helps you visualize how much ice is needed for a particular gift. \n\n-----Input:-----\nInput will consist of a single line with size $n$.\n\n-----Output:-----\nPrint the ice wrapped gift box for the given size. \n\n-----Constraints-----\n- $0 \\leq n \\leq 1000$\n\n-----Sample Input:-----\n4\n\n-----Sample Output:-----\n4 4 4 4 4 4 4\n4 3 3 3 3 3 4\n4 3 2 2 2 3 4\n4 3 2 1 2 3 4\n4 3 2 2 2 3 4 \n4 3 3 3 3 3 4\n4 4 4 4 4 4 4\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef christmas_box (n : Nat) : List (List Nat) := sorry\n\ntheorem christmas_box_empty (n : Nat) : \n  n = 0 → christmas_box n = [] := sorry\n\ntheorem christmas_box_length {n : Nat} :\n  n > 0 → List.length (christmas_box n) = 2 * n - 1 := sorry\n\n\n\ntheorem christmas_box_top_bottom_match {n : Nat} :\n  n > 1 → \n  List.head! (christmas_box n) = List.getLast! (christmas_box n) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1062"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n-----Problem-----\n\n\t\t\tOnce THANMAY met PK who is from a different planet visiting earth. THANMAY was very fascinate to learn PK's language. The language contains only lowercase English letters and is based on a simple logic that only certain characters can follow a particular character.\n\n\n\t\t\tNow he is interested in calculating the number of possible words of length L and ending at a particular character C. Help THANMAY to calculate this value. \n\n-----Input-----\n\n\t\t\tThe input begins with 26 lines, each containing 26 space-separated integers. The integers can be either 0 or 1. The jth integer at ith line depicts whether jth English alphabet can follow ith English alphabet or not.\n\n\n\t\t\t Next line contains an integer T. T is the number of queries.\n\n\t\t\t Next T lines contains a character C and an integer L.\n\n-----Output-----\n\n\t\t\tFor each query output the count of words of length L ending with the character C. Answer to each query must be followed by newline character.\n\n\n\t\t\tThe answer may be very large so print it modulo 1000000007.\n\n-----Constraints-----\n- \n\t\t\t\t\t1 ≤ T ≤ 100\n- \nC is lowercase English alphabet.\n\n- \n\t\t\t\t\t2 ≤ L ≤ 10000000\n\t\t\n\n-----Sample Input-----\n0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n2\n\nc 3\n\nb 2\n\n-----Sample Output-----\n1\n\n2\n\n-----Explanation-----\n\n\t\t\tFor query 1, Words of length 3 are: aba, acb, bab, bac, cba. The only word ending with 'c' is bac.\n\t\t p { text-align:justify }\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Matrix := List (List Nat)\n\ndef count_words (matrix : Matrix) (end_char : Char) (length : Nat) : Nat :=\n  sorry\n\ntheorem count_words_non_negative (matrix : Matrix) (end_char : Char) (length : Nat) :\n  count_words matrix end_char length ≥ 0 :=\nsorry\n\ntheorem count_words_less_than_modulo (matrix : Matrix) (end_char : Char) (length : Nat) :\n  count_words matrix end_char length < (10^9 + 7) :=\nsorry\n\ntheorem empty_graph_no_words (end_char : Char) (length : Nat) :\n  let empty_matrix := List.replicate 26 (List.replicate 26 0)\n  count_words empty_matrix end_char length = 0 :=\nsorry\n\ntheorem simple_path_one_word_length_three :\n  let simple_matrix := List.replicate 26 (List.replicate 26 0)\n  let m1 := simple_matrix -- TODO: Add 1 at position [0][1]\n  let m2 := m1 -- TODO: Add 1 at position [1][2]\n  count_words m2 'c' 3 = 1 :=\nsorry\n\ntheorem simple_path_one_word_length_two :\n  let simple_matrix := List.replicate 26 (List.replicate 26 0)\n  let m1 := simple_matrix -- TODO: Add 1 at position [0][1]\n  let m2 := m1 -- TODO: Add 1 at position [1][2]\n  count_words m2 'b' 2 = 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1085", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n-----Problem-----\n\n\t\t\tOnce THANMAY met PK who is from a different planet visiting earth. THANMAY was very fascinate to learn PK's language. The language contains only lowercase English letters and is based on a simple logic that only certain characters can follow a particular character.\n\n\n\t\t\tNow he is interested in calculating the number of possible words of length L and ending at a particular character C. Help THANMAY to calculate this value. \n\n-----Input-----\n\n\t\t\tThe input begins with 26 lines, each containing 26 space-separated integers. The integers can be either 0 or 1. The jth integer at ith line depicts whether jth English alphabet can follow ith English alphabet or not.\n\n\n\t\t\t Next line contains an integer T. T is the number of queries.\n\n\t\t\t Next T lines contains a character C and an integer L.\n\n-----Output-----\n\n\t\t\tFor each query output the count of words of length L ending with the character C. Answer to each query must be followed by newline character.\n\n\n\t\t\tThe answer may be very large so print it modulo 1000000007.\n\n-----Constraints-----\n- \n\t\t\t\t\t1 ≤ T ≤ 100\n- \nC is lowercase English alphabet.\n\n- \n\t\t\t\t\t2 ≤ L ≤ 10000000\n\t\t\n\n-----Sample Input-----\n0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n2\n\nc 3\n\nb 2\n\n-----Sample Output-----\n1\n\n2\n\n-----Explanation-----\n\n\t\t\tFor query 1, Words of length 3 are: aba, acb, bab, bac, cba. The only word ending with 'c' is bac.\n\t\t p { text-align:justify }\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Matrix := List (List Nat)\n\ndef count_words (matrix : Matrix) (end_char : Char) (length : Nat) : Nat :=\n  sorry\n\ntheorem count_words_non_negative (matrix : Matrix) (end_char : Char) (length : Nat) :\n  count_words matrix end_char length ≥ 0 :=\nsorry\n\ntheorem count_words_less_than_modulo (matrix : Matrix) (end_char : Char) (length : Nat) :\n  count_words matrix end_char length < (10^9 + 7) :=\nsorry\n\ntheorem empty_graph_no_words (end_char : Char) (length : Nat) :\n  let empty_matrix := List.replicate 26 (List.replicate 26 0)\n  count_words empty_matrix end_char length = 0 :=\nsorry\n\ntheorem simple_path_one_word_length_three :\n  let simple_matrix := List.replicate 26 (List.replicate 26 0)\n  let m1 := simple_matrix -- TODO: Add 1 at position [0][1]\n  let m2 := m1 -- TODO: Add 1 at position [1][2]\n  count_words m2 'c' 3 = 1 :=\nsorry\n\ntheorem simple_path_one_word_length_two :\n  let simple_matrix := List.replicate 26 (List.replicate 26 0)\n  let m1 := simple_matrix -- TODO: Add 1 at position [0][1]\n  let m2 := m1 -- TODO: Add 1 at position [1][2]\n  count_words m2 'b' 2 = 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1085"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nDue to the COVID pandemic, maintaining social distancing is of utmost importance. In this problem, you'd calculate how many days would it take to reach an apocalypse from an initial case if nobody maintains social distancing.\nThe Earth is flat (for this question) and it's dimensions are $R$ x $C$\nThe whole Earth is already divided into blocks and the virus can spread in all directions except diagonally. The virus from each newly infected person will spread in all directions in the next day, thus growing exponentially.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Next line contains $R$ and $C$ respectively separated by a space.\n- Next line contains $x$ and $y$ respectively separated by a space, denoting the indices of the initial case in the world.\n\n-----Output:-----\nFor each testcase, output in a single line an integer denoting the number of days after which everyone will be infected.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^4$\n- $2 \\leq R,C \\leq 10^7$\n- $0 \\leq x,y \\leq 10^7$\n\n-----Subtasks-----\n- 10 points : $1 \\leq T \\leq 5$ and $2 \\leq R,C \\leq 10$\n- 20 points : $2 \\leq R,C \\leq 10^5$\n- 70 points : Original constraints\n\n-----Sample Input:-----\n2\n4 5\n2 1\n3 4\n1 1\n\n-----Sample Output:-----\n5\n3\n\n-----EXPLANATION:-----\n2nd test case:\nAssuming, it's a small world of $3$ x $4$\n0 is not infected. 1 is infected.\nWorld indexing is like a 2D array:\n(0,0) (0,1) (0,2) (0,3)\n(1,0) (1,1) (1,2) (1,3)\n(2,0) (2,1) (2,2) (2,3)\nIf this is the case on Day 0:\n0 0 0 0\n0 1 0 0\n0 0 0 0\nThis will be the case on Day 1:\n0 1 0 0\n1 1 1 0\n0 1 0 0\nThis will be the case on Day 2:\n1 1 1 0\n1 1 1 1\n1 1 1 0\nThe End on Day 3:\n1 1 1 1\n1 1 1 1\n1 1 1 1\nThus, answer will be 3\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef calc_virus_spread_days (row col x y : Nat) : Nat :=\n  sorry\n\ntheorem virus_spread_bounds \n    (row col : Nat) (x y : Nat)\n    (h_row : row > 0) (h_col : col > 0)\n    (h_x : x < row) (h_y : y < col) :\n  let result := calc_virus_spread_days row col x y\n  result ≥ max x (row - x - 1) + max y (col - y - 1) ∧ result ≥ 0 :=\n  sorry\n\ntheorem virus_spread_square_symmetric\n    (size : Nat) (h_size : size > 0) :\n  let mid := size / 2\n  calc_virus_spread_days size size mid mid = calc_virus_spread_days size size mid mid :=\n  sorry\n\ntheorem virus_spread_corner_symmetry\n    (row col : Nat) (h_row : row > 0) (h_col : col > 0) \n    (h_eq : row = col) :\n  let corners := [(0, 0), (0, col-1), (row-1, 0), (row-1, col-1)]\n  let results := corners.map (fun p => calc_virus_spread_days row col p.1 p.2)\n  ∀ (x y : Nat), x ∈ results → y ∈ results → x = y :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1120", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nDue to the COVID pandemic, maintaining social distancing is of utmost importance. In this problem, you'd calculate how many days would it take to reach an apocalypse from an initial case if nobody maintains social distancing.\nThe Earth is flat (for this question) and it's dimensions are $R$ x $C$\nThe whole Earth is already divided into blocks and the virus can spread in all directions except diagonally. The virus from each newly infected person will spread in all directions in the next day, thus growing exponentially.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Next line contains $R$ and $C$ respectively separated by a space.\n- Next line contains $x$ and $y$ respectively separated by a space, denoting the indices of the initial case in the world.\n\n-----Output:-----\nFor each testcase, output in a single line an integer denoting the number of days after which everyone will be infected.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^4$\n- $2 \\leq R,C \\leq 10^7$\n- $0 \\leq x,y \\leq 10^7$\n\n-----Subtasks-----\n- 10 points : $1 \\leq T \\leq 5$ and $2 \\leq R,C \\leq 10$\n- 20 points : $2 \\leq R,C \\leq 10^5$\n- 70 points : Original constraints\n\n-----Sample Input:-----\n2\n4 5\n2 1\n3 4\n1 1\n\n-----Sample Output:-----\n5\n3\n\n-----EXPLANATION:-----\n2nd test case:\nAssuming, it's a small world of $3$ x $4$\n0 is not infected. 1 is infected.\nWorld indexing is like a 2D array:\n(0,0) (0,1) (0,2) (0,3)\n(1,0) (1,1) (1,2) (1,3)\n(2,0) (2,1) (2,2) (2,3)\nIf this is the case on Day 0:\n0 0 0 0\n0 1 0 0\n0 0 0 0\nThis will be the case on Day 1:\n0 1 0 0\n1 1 1 0\n0 1 0 0\nThis will be the case on Day 2:\n1 1 1 0\n1 1 1 1\n1 1 1 0\nThe End on Day 3:\n1 1 1 1\n1 1 1 1\n1 1 1 1\nThus, answer will be 3\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef calc_virus_spread_days (row col x y : Nat) : Nat :=\n  sorry\n\ntheorem virus_spread_bounds \n    (row col : Nat) (x y : Nat)\n    (h_row : row > 0) (h_col : col > 0)\n    (h_x : x < row) (h_y : y < col) :\n  let result := calc_virus_spread_days row col x y\n  result ≥ max x (row - x - 1) + max y (col - y - 1) ∧ result ≥ 0 :=\n  sorry\n\ntheorem virus_spread_square_symmetric\n    (size : Nat) (h_size : size > 0) :\n  let mid := size / 2\n  calc_virus_spread_days size size mid mid = calc_virus_spread_days size size mid mid :=\n  sorry\n\ntheorem virus_spread_corner_symmetry\n    (row col : Nat) (h_row : row > 0) (h_col : col > 0) \n    (h_eq : row = col) :\n  let corners := [(0, 0), (0, col-1), (row-1, 0), (row-1, col-1)]\n  let results := corners.map (fun p => calc_virus_spread_days row col p.1 p.2)\n  ∀ (x y : Nat), x ∈ results → y ∈ results → x = y :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1120"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef has the string s of length n consisted of digits 4 and 7.\nThe string s is called balanced\nif there exits such integer x (1 ≤ x ≤ n) that the number of digits 4 in substring s[1; x) is equal to the number of digits 7 in substring s(x; n],\nwhere s[1; x) is the substring from the 1st digit to (x-1)th digit of s, and s(x; n] is the substring from the (x+1)th digit to nth digit of s.\nFor example, s = 747474 is a balanced string, because s[1; 4) = 747 has one 4 and s(4; 6] = 74 has one 7.\nNote that x can be 1 or n and s[1; 1) and s(n; n] denote an empty string.\n\nIn one turn Chef can choose any pair of consecutive digits and swap them.\nFind for Chef the total number of different balanced string that can be obtained from string s using any (even 0) number of turns.\nPrint the result modulo 1000000007.\n\n-----Input-----\n\nThe first line of the input contains one integer T, the number of test cases.\nThen T lines follow, each of which contains string s for the corresponding test.\n\n-----Output-----\nT lines, each of which contains single integer - the answer for the corresponding test modulo 109+7.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ n ≤ 5000\n\n-----Example-----\nInput:\n2\n47\n4477\n\nOutput:\n1\n4\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solveBalancedDigits (s : String) : Nat :=\n  sorry\n\ndef makeBalancedString (m n : Nat) : String :=\n  sorry\n\ntheorem equal_fours_and_sevens {n : Nat} (h : n > 0) (h2 : n ≤ 50) :\n  let s := makeBalancedString n n\n  let result := solveBalancedDigits s\n  result ≥ 1 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem arbitrary_fours_and_sevens {m n : Nat} \n  (h1 : m > 0) (h2 : m ≤ 50) (h3 : n > 0) (h4 : n ≤ 50) :\n  let s := makeBalancedString m n\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem valid_string_bounds {s : String}\n  (h : s.length > 0) (h2 : s.length ≤ 50)\n  (h3 : ∀ c ∈ s.data, c = '4' ∨ c = '7') :\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1172", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef has the string s of length n consisted of digits 4 and 7.\nThe string s is called balanced\nif there exits such integer x (1 ≤ x ≤ n) that the number of digits 4 in substring s[1; x) is equal to the number of digits 7 in substring s(x; n],\nwhere s[1; x) is the substring from the 1st digit to (x-1)th digit of s, and s(x; n] is the substring from the (x+1)th digit to nth digit of s.\nFor example, s = 747474 is a balanced string, because s[1; 4) = 747 has one 4 and s(4; 6] = 74 has one 7.\nNote that x can be 1 or n and s[1; 1) and s(n; n] denote an empty string.\n\nIn one turn Chef can choose any pair of consecutive digits and swap them.\nFind for Chef the total number of different balanced string that can be obtained from string s using any (even 0) number of turns.\nPrint the result modulo 1000000007.\n\n-----Input-----\n\nThe first line of the input contains one integer T, the number of test cases.\nThen T lines follow, each of which contains string s for the corresponding test.\n\n-----Output-----\nT lines, each of which contains single integer - the answer for the corresponding test modulo 109+7.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ n ≤ 5000\n\n-----Example-----\nInput:\n2\n47\n4477\n\nOutput:\n1\n4\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solveBalancedDigits (s : String) : Nat :=\n  sorry\n\ndef makeBalancedString (m n : Nat) : String :=\n  sorry\n\ntheorem equal_fours_and_sevens {n : Nat} (h : n > 0) (h2 : n ≤ 50) :\n  let s := makeBalancedString n n\n  let result := solveBalancedDigits s\n  result ≥ 1 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem arbitrary_fours_and_sevens {m n : Nat} \n  (h1 : m > 0) (h2 : m ≤ 50) (h3 : n > 0) (h4 : n ≤ 50) :\n  let s := makeBalancedString m n\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem valid_string_bounds {s : String}\n  (h : s.length > 0) (h2 : s.length ≤ 50)\n  (h3 : ∀ c ∈ s.data, c = '4' ∨ c = '7') :\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1172"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGorodetskiy is a university student. He is really good at math and really likes solving engaging math problems. In the last exam, his professor gave him really hard math problems to solve, but Gorodetskiy could not solve them and failed the exam, so the professor told him: \"These problems are a piece of cake, you should know them from school!\" Here is one of the problems from the exam - you can decide if it really was an easy problem or not.\nYou are given a positive integer $M$. Let's call a positive integer $A$ an interesting number if there is at least one integer $B$ ($A \\le B$) such that $A \\cdot B$ is divisible by $M$ and $\\frac{A \\cdot B}{M} = A+B$.\nFind all interesting numbers. Let's denote the number of such integers by $K$; it is guaranteed that $K \\le 3*10^5$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single integer $M$.\n\n-----Output-----\nFor each test case:\n- First, print a line containing a single integer $K$.\n- Then, print $K$ lines. For each valid $i$, the $i$-th of these lines should contain a single integer ― the $i$-th interesting number in increasing order.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le M \\le 10^{14}$\n\n-----Subtasks-----\nSubtask #1 (20 points): $1 \\le M \\le 100$\nSubtask #2 (20 points): $1 \\le M \\le 10^7$\nSubtask #3 (60 points): original constraints\n\n-----Example Input-----\n2\n3\n6\n\n-----Example Output-----\n2\n4\n6\n5\n7\n8\n9\n10\n12\n\n-----Explanation-----\nExample case 1: There are two interesting numbers, $4$ and $6$. For $A = 4$, we can choose $B = 12$ and for $A = 6$, we can choose $B = 6$.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_interesting_numbers (m : Nat) : List Nat := sorry \ndef solve_test_case (m : Nat) : List Nat := sorry\n\ntheorem find_interesting_numbers_range (m : Nat) (h : 0 < m) (h2 : m ≤ 100) : \n  ∀ x ∈ find_interesting_numbers m, \n    m < x ∧ x ≤ 2 * m := sorry\n\ntheorem find_interesting_numbers_sorted (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  List.Pairwise (· ≤ ·) (find_interesting_numbers m) := sorry\n\ntheorem solve_test_case_first_is_length (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  List.head! (solve_test_case m) = (List.length (solve_test_case m)) - 1 := sorry\n\ntheorem solve_test_case_all_elements (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ x, x ∈ solve_test_case m → x ≥ 0 := sorry\n\ntheorem interesting_numbers_property (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ a ∈ find_interesting_numbers m,\n    (a * m) % (a - m) = 0 := sorry\n\ntheorem find_interesting_numbers_complete (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ a : Nat, m < a → a ≤ 2 * m → \n    (a * m) % (a - m) = 0 → \n    a ∈ find_interesting_numbers m := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1182", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGorodetskiy is a university student. He is really good at math and really likes solving engaging math problems. In the last exam, his professor gave him really hard math problems to solve, but Gorodetskiy could not solve them and failed the exam, so the professor told him: \"These problems are a piece of cake, you should know them from school!\" Here is one of the problems from the exam - you can decide if it really was an easy problem or not.\nYou are given a positive integer $M$. Let's call a positive integer $A$ an interesting number if there is at least one integer $B$ ($A \\le B$) such that $A \\cdot B$ is divisible by $M$ and $\\frac{A \\cdot B}{M} = A+B$.\nFind all interesting numbers. Let's denote the number of such integers by $K$; it is guaranteed that $K \\le 3*10^5$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single integer $M$.\n\n-----Output-----\nFor each test case:\n- First, print a line containing a single integer $K$.\n- Then, print $K$ lines. For each valid $i$, the $i$-th of these lines should contain a single integer ― the $i$-th interesting number in increasing order.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le M \\le 10^{14}$\n\n-----Subtasks-----\nSubtask #1 (20 points): $1 \\le M \\le 100$\nSubtask #2 (20 points): $1 \\le M \\le 10^7$\nSubtask #3 (60 points): original constraints\n\n-----Example Input-----\n2\n3\n6\n\n-----Example Output-----\n2\n4\n6\n5\n7\n8\n9\n10\n12\n\n-----Explanation-----\nExample case 1: There are two interesting numbers, $4$ and $6$. For $A = 4$, we can choose $B = 12$ and for $A = 6$, we can choose $B = 6$.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_interesting_numbers (m : Nat) : List Nat := sorry \ndef solve_test_case (m : Nat) : List Nat := sorry\n\ntheorem find_interesting_numbers_range (m : Nat) (h : 0 < m) (h2 : m ≤ 100) : \n  ∀ x ∈ find_interesting_numbers m, \n    m < x ∧ x ≤ 2 * m := sorry\n\ntheorem find_interesting_numbers_sorted (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  List.Pairwise (· ≤ ·) (find_interesting_numbers m) := sorry\n\ntheorem solve_test_case_first_is_length (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  List.head! (solve_test_case m) = (List.length (solve_test_case m)) - 1 := sorry\n\ntheorem solve_test_case_all_elements (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ x, x ∈ solve_test_case m → x ≥ 0 := sorry\n\ntheorem interesting_numbers_property (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ a ∈ find_interesting_numbers m,\n    (a * m) % (a - m) = 0 := sorry\n\ntheorem find_interesting_numbers_complete (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ a : Nat, m < a → a ≤ 2 * m → \n    (a * m) % (a - m) = 0 → \n    a ∈ find_interesting_numbers m := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1182"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThe chef is having one string of English lower case alphabets only. The chef wants to remove all \"abc\" special pairs where a,b,c are occurring consecutively. After removing the pair, create a new string and again remove \"abc\" special pair from a newly formed string. Repeate the process until no such pair remains in a string.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, $String$. \n\n-----Output:-----\nFor each testcase, output in a single line answer, new String with no \"abc\" special pair.\n\n-----Constraints:-----\n$T \\leq 2 $\n$1 \\leq String length \\leq 1000 $\n\n-----Sample Input:-----\n2\naabcc\nbababccc\n\n-----Sample Output:-----\nac\nbc\n\n-----EXPLANATION:-----\nFor 1) after removing \"abc\" at middle we get a new string as ac.\nFor 2) string = bababccc\nnewString1 = babcc  // After removing middle \"abc\"\nnewString2 = bc   //After removing \"abc\"\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef remove_abc_pairs : String → String := sorry\n\ndef containsSubstr (s : String) (substr : String) : Bool := sorry\n\ntheorem no_abc_in_result (s : String) : \n  ¬(containsSubstr (remove_abc_pairs s) \"abc\") := sorry\n\ntheorem idempotent (s : String) : \n  remove_abc_pairs (remove_abc_pairs s) = remove_abc_pairs s := sorry\n\ntheorem length_decreases (s : String) :\n  (remove_abc_pairs s).length ≤ s.length := sorry\n  \ntheorem preserves_non_abc (s : String) : \n  ¬(containsSubstr s \"abc\") → remove_abc_pairs s = s := sorry\n\ntheorem remaining_chars_unchanged (s : String) :\n  ∃ n : Nat, remove_abc_pairs s = \n    let rec remove_all (s' : String) (fuel : Nat) : String :=\n      match fuel with\n      | 0 => s'\n      | fuel'+1 => \n        if containsSubstr s' \"abc\" \n        then remove_all (s'.replace \"abc\" \"\") fuel'\n        else s'\n    remove_all s n := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1211", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThe chef is having one string of English lower case alphabets only. The chef wants to remove all \"abc\" special pairs where a,b,c are occurring consecutively. After removing the pair, create a new string and again remove \"abc\" special pair from a newly formed string. Repeate the process until no such pair remains in a string.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, $String$. \n\n-----Output:-----\nFor each testcase, output in a single line answer, new String with no \"abc\" special pair.\n\n-----Constraints:-----\n$T \\leq 2 $\n$1 \\leq String length \\leq 1000 $\n\n-----Sample Input:-----\n2\naabcc\nbababccc\n\n-----Sample Output:-----\nac\nbc\n\n-----EXPLANATION:-----\nFor 1) after removing \"abc\" at middle we get a new string as ac.\nFor 2) string = bababccc\nnewString1 = babcc  // After removing middle \"abc\"\nnewString2 = bc   //After removing \"abc\"\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef remove_abc_pairs : String → String := sorry\n\ndef containsSubstr (s : String) (substr : String) : Bool := sorry\n\ntheorem no_abc_in_result (s : String) : \n  ¬(containsSubstr (remove_abc_pairs s) \"abc\") := sorry\n\ntheorem idempotent (s : String) : \n  remove_abc_pairs (remove_abc_pairs s) = remove_abc_pairs s := sorry\n\ntheorem length_decreases (s : String) :\n  (remove_abc_pairs s).length ≤ s.length := sorry\n  \ntheorem preserves_non_abc (s : String) : \n  ¬(containsSubstr s \"abc\") → remove_abc_pairs s = s := sorry\n\ntheorem remaining_chars_unchanged (s : String) :\n  ∃ n : Nat, remove_abc_pairs s = \n    let rec remove_all (s' : String) (fuel : Nat) : String :=\n      match fuel with\n      | 0 => s'\n      | fuel'+1 => \n        if containsSubstr s' \"abc\" \n        then remove_all (s'.replace \"abc\" \"\") fuel'\n        else s'\n    remove_all s n := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1211"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn Byteland there are N cities, numbered 1 through N. Some pairs of cities are connected by bi-directional roads in such a way that starting from any one city you can visit all other cities either directly or indirectly.\n\nChef is currently at city A and wants to visit all other cities in Byteland. Chef can only move according to following rule. \n\nIf Chef is at city A then he continues to move from city A to city B, city B to city C (provided A is directly connected to B, B is directly connected to C) and so on unless there are no more cities leading from current city.\n\nIf so he jumps back to previous city and repeat the same tour with other cities leading from it which are not visited. Chef repeat this step unless all cities are not visited.\n\nHelp Chef to count number of ways in which he can visit all other cities . As this number can be large print it modulo 109+7\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N denoting the number of cities in Byteland.\n-  Next N-1 lines contain two space-separated integers u and v denoting there is bi-directional road between city numbered u and v. \n-  Next line contains a single integer A denoting the city number where Chef is present.\n\n-----Output-----\n- For each test case, output a single line containing number of ways in which Chef can visit all cities modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 105\n- 1 ≤ A ≤ N\n\n-----Subtasks-----\nSubtask #1 : (10 points) \n- 1 ≤ N ≤ 5\nSubtask #2 : (30 points) \n- 1 ≤ N ≤ 100\nSubtask #3 : (60 points) \n- 1 ≤ N ≤ 105\n\n-----Example-----\nInput:\n2\n3\n1 2\n1 3\n1\n5\n1 2\n1 3\n2 4\n2 5\n1\n\nOutput:\n2\n4\n\n-----Explanation-----\nExample case 1. Chef can visit cities in two ways according to the problem: 1-2-3 and 1-3-2\nExample case 1. Chef can visit cities in four ways according to the problem:\n\n1-2-4-5-3\n1-2-5-4-3\n1-3-2-4-5\n1-3-2-5-4\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_city_paths (n: Nat) (roads: List (Nat × Nat)) (start: Nat) : Nat :=\n  sorry\n\n-- Helper definition for valid graphs\ndef is_valid_graph (n: Nat) (roads: List (Nat × Nat)) : Prop :=\n  ∀ (u v: Nat), (u,v) ∈ roads →\n    (1 ≤ u ∧ u ≤ n) ∧\n    (1 ≤ v ∧ v ≤ n) ∧\n    (u ≠ v) ∧\n    (∀ (u' v': Nat), (u',v') ∈ roads → (u',v') = (u,v) ∨ (u',v') ≠ (u,v))\n\n\n\n\n\ntheorem solve_city_paths_single_node :\n  solve_city_paths 1 [] 1 = 1 :=\nsorry\n\ntheorem solve_city_paths_two_nodes :\n  solve_city_paths 2 [(1,2)] 1 = 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1296", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn Byteland there are N cities, numbered 1 through N. Some pairs of cities are connected by bi-directional roads in such a way that starting from any one city you can visit all other cities either directly or indirectly.\n\nChef is currently at city A and wants to visit all other cities in Byteland. Chef can only move according to following rule. \n\nIf Chef is at city A then he continues to move from city A to city B, city B to city C (provided A is directly connected to B, B is directly connected to C) and so on unless there are no more cities leading from current city.\n\nIf so he jumps back to previous city and repeat the same tour with other cities leading from it which are not visited. Chef repeat this step unless all cities are not visited.\n\nHelp Chef to count number of ways in which he can visit all other cities . As this number can be large print it modulo 109+7\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N denoting the number of cities in Byteland.\n-  Next N-1 lines contain two space-separated integers u and v denoting there is bi-directional road between city numbered u and v. \n-  Next line contains a single integer A denoting the city number where Chef is present.\n\n-----Output-----\n- For each test case, output a single line containing number of ways in which Chef can visit all cities modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 105\n- 1 ≤ A ≤ N\n\n-----Subtasks-----\nSubtask #1 : (10 points) \n- 1 ≤ N ≤ 5\nSubtask #2 : (30 points) \n- 1 ≤ N ≤ 100\nSubtask #3 : (60 points) \n- 1 ≤ N ≤ 105\n\n-----Example-----\nInput:\n2\n3\n1 2\n1 3\n1\n5\n1 2\n1 3\n2 4\n2 5\n1\n\nOutput:\n2\n4\n\n-----Explanation-----\nExample case 1. Chef can visit cities in two ways according to the problem: 1-2-3 and 1-3-2\nExample case 1. Chef can visit cities in four ways according to the problem:\n\n1-2-4-5-3\n1-2-5-4-3\n1-3-2-4-5\n1-3-2-5-4\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_city_paths (n: Nat) (roads: List (Nat × Nat)) (start: Nat) : Nat :=\n  sorry\n\n-- Helper definition for valid graphs\ndef is_valid_graph (n: Nat) (roads: List (Nat × Nat)) : Prop :=\n  ∀ (u v: Nat), (u,v) ∈ roads →\n    (1 ≤ u ∧ u ≤ n) ∧\n    (1 ≤ v ∧ v ≤ n) ∧\n    (u ≠ v) ∧\n    (∀ (u' v': Nat), (u',v') ∈ roads → (u',v') = (u,v) ∨ (u',v') ≠ (u,v))\n\n\n\n\n\ntheorem solve_city_paths_single_node :\n  solve_city_paths 1 [] 1 = 1 :=\nsorry\n\ntheorem solve_city_paths_two_nodes :\n  solve_city_paths 2 [(1,2)] 1 = 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1296"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an equilateral triangle ΔABC with the side BC being the base. Each side of the triangle is of length L. There are L-1 additional points on each of the sides dividing the sides into equal parts of unit lengths. Points on the sides of the triangle are called major points. Joining these points with lines parallel to the sides of ΔABC will produce some more equilateral triangles. The intersection points of these parallel lines are called minor points. \n\nLook at the picture below. It contains \n\n- Major points: A, B, C, P1, P2, Q1, Q3, R1, R4, S1, S2, S3 (note that we consider A, B, C as major points as well)\n- Minor points: Q2, R2, R3\n- Equilateral triangles ΔP1Q1Q2, ΔQ2S1S3, etc\n\nWe consider an equilateral triangle to be valid if\n\n- Each of its vertices is either a major or a minor point, and\n- The distance from its base (the base of a triangle is the side parallel to BC) to BC is less than the distance from the other vertex of the triangle (i.e. opposite vertex that doesn't lie on the base of triangle) to BC.\n\nIn the figure above, ΔQ2P1P2 is not a valid triangle but ΔQ2R2R3 is a valid triangle.\n\nYou will be given L, the length of the original triangle ΔABC. You need to find out the number of valid equilateral triangles with side length exactly K.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of each testcase follows.\n- Each test case has one line containing two space-separated integers: L and K.\n\n-----Output-----\nFor each testcase, print \"Case i: \", and then the answer, where i is the testcase number, 1-indexed.\n\n-----Constraints-----\n- 1 ≤ T ≤ 500\n-  1 ≤ L, K ≤ 5000\n\n-----Example-----\nInput:\n2\n4 3\n4 4\n\nOutput:\nCase 1: 3\nCase 2: 1\n\n-----Explanation-----\n\nThe figure presented in the problem description is a triangle with side length 4.\nIn testcase 1, the valid triangles are ΔAR1R4, ΔP1BS3, ΔP2S1C\n\nIn testcase 2, the only valid triangle is ΔABC\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_valid_triangles (L K : Int) : Int := sorry\n\ntheorem count_valid_triangles_non_negative (L K : Int) :\n  count_valid_triangles L K ≥ 0 := sorry\n\ntheorem count_valid_triangles_k_greater_l (L K : Int) :\n  K > L → count_valid_triangles L K = 0 := sorry\n\ntheorem count_valid_triangles_k_one (L : Int) :\n  L ≥ 1 → count_valid_triangles L 1 = (L * (L + 1)) / 2 := sorry\n\ntheorem count_valid_triangles_k_equals_l (L : Int) :\n  L ≥ 1 → count_valid_triangles L L = 1 := sorry\n\ntheorem count_valid_triangles_monotonic (L k1 k2 : Int) :\n  L ≥ 1 → k1 ≤ k2 → k2 ≤ L →\n  count_valid_triangles L k1 ≥ count_valid_triangles L k2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1318", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an equilateral triangle ΔABC with the side BC being the base. Each side of the triangle is of length L. There are L-1 additional points on each of the sides dividing the sides into equal parts of unit lengths. Points on the sides of the triangle are called major points. Joining these points with lines parallel to the sides of ΔABC will produce some more equilateral triangles. The intersection points of these parallel lines are called minor points. \n\nLook at the picture below. It contains \n\n- Major points: A, B, C, P1, P2, Q1, Q3, R1, R4, S1, S2, S3 (note that we consider A, B, C as major points as well)\n- Minor points: Q2, R2, R3\n- Equilateral triangles ΔP1Q1Q2, ΔQ2S1S3, etc\n\nWe consider an equilateral triangle to be valid if\n\n- Each of its vertices is either a major or a minor point, and\n- The distance from its base (the base of a triangle is the side parallel to BC) to BC is less than the distance from the other vertex of the triangle (i.e. opposite vertex that doesn't lie on the base of triangle) to BC.\n\nIn the figure above, ΔQ2P1P2 is not a valid triangle but ΔQ2R2R3 is a valid triangle.\n\nYou will be given L, the length of the original triangle ΔABC. You need to find out the number of valid equilateral triangles with side length exactly K.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of each testcase follows.\n- Each test case has one line containing two space-separated integers: L and K.\n\n-----Output-----\nFor each testcase, print \"Case i: \", and then the answer, where i is the testcase number, 1-indexed.\n\n-----Constraints-----\n- 1 ≤ T ≤ 500\n-  1 ≤ L, K ≤ 5000\n\n-----Example-----\nInput:\n2\n4 3\n4 4\n\nOutput:\nCase 1: 3\nCase 2: 1\n\n-----Explanation-----\n\nThe figure presented in the problem description is a triangle with side length 4.\nIn testcase 1, the valid triangles are ΔAR1R4, ΔP1BS3, ΔP2S1C\n\nIn testcase 2, the only valid triangle is ΔABC\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_valid_triangles (L K : Int) : Int := sorry\n\ntheorem count_valid_triangles_non_negative (L K : Int) :\n  count_valid_triangles L K ≥ 0 := sorry\n\ntheorem count_valid_triangles_k_greater_l (L K : Int) :\n  K > L → count_valid_triangles L K = 0 := sorry\n\ntheorem count_valid_triangles_k_one (L : Int) :\n  L ≥ 1 → count_valid_triangles L 1 = (L * (L + 1)) / 2 := sorry\n\ntheorem count_valid_triangles_k_equals_l (L : Int) :\n  L ≥ 1 → count_valid_triangles L L = 1 := sorry\n\ntheorem count_valid_triangles_monotonic (L k1 k2 : Int) :\n  L ≥ 1 → k1 ≤ k2 → k2 ≤ L →\n  count_valid_triangles L k1 ≥ count_valid_triangles L k2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1318"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a sequence $A_1, A_2, \\ldots, A_N$. Calculate the number of ways to remove a non-empty contiguous subsequence from it such that the resulting sequence is non-empty and strictly increasing.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of ways.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le N \\le 10^5$\n- $|A_i| \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $N \\le 1,000$\nSubtask #2 (60 points): original constraints\n\n-----Example Input-----\n2\n3\n1 1 2\n4\n2 4 3 5\n\n-----Example Output-----\n4\n7\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_subsequence_removal (n : Nat) (arr : List Nat) : Nat := sorry\n\ndef is_increasing (lst : List Nat) : Bool := sorry\n\ntheorem sequence_bounds (n : Nat) (arr : List Nat) : \n  arr.length = n →\n  let result := solve_subsequence_removal n arr\n  result ≥ 0 ∧ result ≤ n * (n+1) / 2 := sorry\n\ntheorem strictly_increasing_sequence (n : Nat) :\n  n > 0 →\n  let arr := List.range n \n  solve_subsequence_removal n arr = n * (n+1) / 2 - 1 := sorry\n\ntheorem duplicate_elements (n : Nat) (arr : List Nat) :\n  n > 0 →\n  let all_ones := List.replicate n 1\n  let result := solve_subsequence_removal n all_ones\n  result ≥ 0 ∧ result ≤ n * (n+1) / 2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1341", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a sequence $A_1, A_2, \\ldots, A_N$. Calculate the number of ways to remove a non-empty contiguous subsequence from it such that the resulting sequence is non-empty and strictly increasing.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of ways.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le N \\le 10^5$\n- $|A_i| \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $N \\le 1,000$\nSubtask #2 (60 points): original constraints\n\n-----Example Input-----\n2\n3\n1 1 2\n4\n2 4 3 5\n\n-----Example Output-----\n4\n7\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_subsequence_removal (n : Nat) (arr : List Nat) : Nat := sorry\n\ndef is_increasing (lst : List Nat) : Bool := sorry\n\ntheorem sequence_bounds (n : Nat) (arr : List Nat) : \n  arr.length = n →\n  let result := solve_subsequence_removal n arr\n  result ≥ 0 ∧ result ≤ n * (n+1) / 2 := sorry\n\ntheorem strictly_increasing_sequence (n : Nat) :\n  n > 0 →\n  let arr := List.range n \n  solve_subsequence_removal n arr = n * (n+1) / 2 - 1 := sorry\n\ntheorem duplicate_elements (n : Nat) (arr : List Nat) :\n  n > 0 →\n  let all_ones := List.replicate n 1\n  let result := solve_subsequence_removal n all_ones\n  result ≥ 0 ∧ result ≤ n * (n+1) / 2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1341"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou have a tree consisting of n vertices. You want to color each vertex of the tree in one of the k colors such that for any pair of vertices having same color, all the vertices belonging to the path joining them should also have same color. In other words, for any two vertices u, v with same color, all the vertices in the path joining them should also have color same as that of the u (or same as v, as u and v have same color). \n\nFind out possible number of ways in which you can color the tree satisfying the above property. As the answer could be large, print your answer modulo 109 + 7.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nFor each test case, first line contains two space separated integers n, k denoting number of vertices in the tree and total number of colors, respectively\nEach of the next n - 1 lines contain two space separated integers ui, vi, denoting that there is an edge between vertices ui and vi in the tree.\n\n-----Output-----\nFor each test case, output a single line corresponding to number of ways of coloring the tree.\n\n-----Constraints-----\n- 1 ≤ T ≤ 50\n- 1 ≤ n, k ≤ 50\n- 1 ≤ ui, vi ≤ n\n- ui ≠ vi\n\n-----Example-----\nInput\n3\n3 2\n1 2\n2 3\n3 1\n1 2\n2 3\n4 3\n1 2\n2 3\n2 4\n\nOutput:\n6\n1\n39\n\n-----Explanation-----\nIn the first example, You can color the vertices in the following 6 ways - {1, 1, 1}, {2, 2, 2}, {1, 2, 2}, {1, 1, 2}, {2, 1, 1}, {2, 2, 1}. Note that you can't color the tree in {1, 2, 1} as the vertices in the path connecting vertex 1 and 3, (i.e. 1, 2, 3) don't have same color. You can see that the color of 2nd vertex is not same as that of 1st and 3rd.\nIn the second example, Only possible coloring you can do is to color all the vertices with color 1.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (n k : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ntheorem solve_result_bounds {n k : Nat} {edges : List (Nat × Nat)}\n  (hn : n > 0) (hk : k > 0) (he : edges.length > 0) :\n  let result := solve n k edges\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem solve_small_values {n k : Nat} {edges : List (Nat × Nat)}\n  (hn : 0 < n ∧ n ≤ 10) (hk : 0 < k ∧ k ≤ 10) :\n  let result := solve n k edges\n  result ≥ 0 ∧ result ≤ k^n :=\nsorry\n\ntheorem solve_base_cases_nonzero {n k : Nat} {edges : List (Nat × Nat)}\n  (h1 : (n = 1 ∧ k = 1) ∨ (n = 2 ∧ k = 1) ∨ (n = 2 ∧ k = 2)) :\n  solve n k edges > 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1354", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou have a tree consisting of n vertices. You want to color each vertex of the tree in one of the k colors such that for any pair of vertices having same color, all the vertices belonging to the path joining them should also have same color. In other words, for any two vertices u, v with same color, all the vertices in the path joining them should also have color same as that of the u (or same as v, as u and v have same color). \n\nFind out possible number of ways in which you can color the tree satisfying the above property. As the answer could be large, print your answer modulo 109 + 7.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nFor each test case, first line contains two space separated integers n, k denoting number of vertices in the tree and total number of colors, respectively\nEach of the next n - 1 lines contain two space separated integers ui, vi, denoting that there is an edge between vertices ui and vi in the tree.\n\n-----Output-----\nFor each test case, output a single line corresponding to number of ways of coloring the tree.\n\n-----Constraints-----\n- 1 ≤ T ≤ 50\n- 1 ≤ n, k ≤ 50\n- 1 ≤ ui, vi ≤ n\n- ui ≠ vi\n\n-----Example-----\nInput\n3\n3 2\n1 2\n2 3\n3 1\n1 2\n2 3\n4 3\n1 2\n2 3\n2 4\n\nOutput:\n6\n1\n39\n\n-----Explanation-----\nIn the first example, You can color the vertices in the following 6 ways - {1, 1, 1}, {2, 2, 2}, {1, 2, 2}, {1, 1, 2}, {2, 1, 1}, {2, 2, 1}. Note that you can't color the tree in {1, 2, 1} as the vertices in the path connecting vertex 1 and 3, (i.e. 1, 2, 3) don't have same color. You can see that the color of 2nd vertex is not same as that of 1st and 3rd.\nIn the second example, Only possible coloring you can do is to color all the vertices with color 1.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (n k : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ntheorem solve_result_bounds {n k : Nat} {edges : List (Nat × Nat)}\n  (hn : n > 0) (hk : k > 0) (he : edges.length > 0) :\n  let result := solve n k edges\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem solve_small_values {n k : Nat} {edges : List (Nat × Nat)}\n  (hn : 0 < n ∧ n ≤ 10) (hk : 0 < k ∧ k ≤ 10) :\n  let result := solve n k edges\n  result ≥ 0 ∧ result ≤ k^n :=\nsorry\n\ntheorem solve_base_cases_nonzero {n k : Nat} {edges : List (Nat × Nat)}\n  (h1 : (n = 1 ∧ k = 1) ∨ (n = 2 ∧ k = 1) ∨ (n = 2 ∧ k = 2)) :\n  solve n k edges > 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1354"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef owns an icecream shop in Chefland named scoORZ. There are only three types of coins in Chefland: Rs. 5, Rs. 10 and Rs. 15. An icecream costs Rs. 5.\nThere are $N$ people (numbered $1$ through $N$) standing in a queue to buy icecream from scoORZ. Each person wants to buy exactly one icecream. For each valid $i$, the $i$-th person has one coin with value $a_i$. It is only possible for someone to buy an icecream when Chef can give them back their change exactly ― for example, if someone pays with a Rs. 10 coin, Chef needs to have a Rs. 5 coin that he gives to this person as change.\nInitially, Chef has no money. He wants to know if he can sell icecream to everyone in the queue, in the given order. Since he is busy eating his own icecream, can you tell him if he can serve all these people?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $a_1, a_2, \\ldots, a_N$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"YES\" if all people can be served or \"NO\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 10^3$\n- $a_i \\in \\{5, 10, 15\\}$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $a_i \\in \\{5, 10\\}$ for each valid $i$\nSubtask #2 (60 points): original constraints\n\n-----Example Input-----\n3\n2\n5 10\n2\n10 5\n2\n5 15\n\n-----Example Output-----\nYES\nNO\nNO\n\n-----Explanation-----\nExample case 1: The first person pays with a Rs. 5 coin. The second person pays with a Rs. 10 coin and Chef gives them back the Rs. 5 coin (which he got from the first person) as change.\nExample case 2: The first person already cannot buy an icecream because Chef cannot give them back Rs. 5.\nExample case 3: The first person pays with a Rs. 5 coin. The second person cannot buy the icecream because Chef has only one Rs. 5 coin, but he needs to give a total of Rs. 10 back as change.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Coin where\n  | five : Coin\n  | ten : Coin\n  | fifteen : Coin\nderiving BEq, Repr, DecidableEq\n\ndef canServeIcecream : List Coin → Bool\n  := sorry\n\ntheorem all_fives_servable {coins : List Coin} (h : ∀ c ∈ coins, c = Coin.five) :\n  canServeIcecream coins = true := sorry\n\ntheorem start_with_ten_fails {coins : List Coin} (h1 : coins.length > 0) \n  (h2 : ∀ c ∈ coins, c = Coin.ten) :\n  canServeIcecream coins = false := sorry\n\ntheorem empty_and_base_cases :\n  canServeIcecream [] = true ∧\n  canServeIcecream [Coin.five] = true ∧\n  canServeIcecream [Coin.ten] = false ∧\n  canServeIcecream [Coin.fifteen] = false := sorry\n\ndef countFives (l : List Coin) : Nat :=\n  (l.filter (. == Coin.five)).length\n\ndef countTens (l : List Coin) : Nat :=\n  (l.filter (. == Coin.ten)).length\n\ntheorem valid_service_has_change {coins : List Coin} \n  (h : ∀ c ∈ coins, c = Coin.five ∨ c = Coin.ten ∨ c = Coin.fifteen) :\n  canServeIcecream coins = true →\n  ∀ p : List Coin, p.isPrefixOf coins →\n  match p.getLast? with\n  | none => True \n  | some last =>\n    if decide (last = Coin.ten)\n    then countFives p > 0\n    else if decide (last = Coin.fifteen)\n    then countTens p > 0 ∨ countFives p ≥ 2\n    else True := sorry\n\ntheorem invalid_service_lacks_change {coins : List Coin}\n  (h : ∀ c ∈ coins, c = Coin.five ∨ c = Coin.ten ∨ c = Coin.fifteen) :\n  canServeIcecream coins = false →\n  ∃ p : List Coin, p.isPrefixOf coins ∧\n  match p.getLast? with\n  | none => False\n  | some last =>\n    (last = Coin.ten ∧ countFives p = 0) ∨ \n    (last = Coin.fifteen ∧ countTens p = 0 ∧ countFives p < 2) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1357", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef owns an icecream shop in Chefland named scoORZ. There are only three types of coins in Chefland: Rs. 5, Rs. 10 and Rs. 15. An icecream costs Rs. 5.\nThere are $N$ people (numbered $1$ through $N$) standing in a queue to buy icecream from scoORZ. Each person wants to buy exactly one icecream. For each valid $i$, the $i$-th person has one coin with value $a_i$. It is only possible for someone to buy an icecream when Chef can give them back their change exactly ― for example, if someone pays with a Rs. 10 coin, Chef needs to have a Rs. 5 coin that he gives to this person as change.\nInitially, Chef has no money. He wants to know if he can sell icecream to everyone in the queue, in the given order. Since he is busy eating his own icecream, can you tell him if he can serve all these people?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $a_1, a_2, \\ldots, a_N$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"YES\" if all people can be served or \"NO\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 10^3$\n- $a_i \\in \\{5, 10, 15\\}$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $a_i \\in \\{5, 10\\}$ for each valid $i$\nSubtask #2 (60 points): original constraints\n\n-----Example Input-----\n3\n2\n5 10\n2\n10 5\n2\n5 15\n\n-----Example Output-----\nYES\nNO\nNO\n\n-----Explanation-----\nExample case 1: The first person pays with a Rs. 5 coin. The second person pays with a Rs. 10 coin and Chef gives them back the Rs. 5 coin (which he got from the first person) as change.\nExample case 2: The first person already cannot buy an icecream because Chef cannot give them back Rs. 5.\nExample case 3: The first person pays with a Rs. 5 coin. The second person cannot buy the icecream because Chef has only one Rs. 5 coin, but he needs to give a total of Rs. 10 back as change.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Coin where\n  | five : Coin\n  | ten : Coin\n  | fifteen : Coin\nderiving BEq, Repr, DecidableEq\n\ndef canServeIcecream : List Coin → Bool\n  := sorry\n\ntheorem all_fives_servable {coins : List Coin} (h : ∀ c ∈ coins, c = Coin.five) :\n  canServeIcecream coins = true := sorry\n\ntheorem start_with_ten_fails {coins : List Coin} (h1 : coins.length > 0) \n  (h2 : ∀ c ∈ coins, c = Coin.ten) :\n  canServeIcecream coins = false := sorry\n\ntheorem empty_and_base_cases :\n  canServeIcecream [] = true ∧\n  canServeIcecream [Coin.five] = true ∧\n  canServeIcecream [Coin.ten] = false ∧\n  canServeIcecream [Coin.fifteen] = false := sorry\n\ndef countFives (l : List Coin) : Nat :=\n  (l.filter (. == Coin.five)).length\n\ndef countTens (l : List Coin) : Nat :=\n  (l.filter (. == Coin.ten)).length\n\ntheorem valid_service_has_change {coins : List Coin} \n  (h : ∀ c ∈ coins, c = Coin.five ∨ c = Coin.ten ∨ c = Coin.fifteen) :\n  canServeIcecream coins = true →\n  ∀ p : List Coin, p.isPrefixOf coins →\n  match p.getLast? with\n  | none => True \n  | some last =>\n    if decide (last = Coin.ten)\n    then countFives p > 0\n    else if decide (last = Coin.fifteen)\n    then countTens p > 0 ∨ countFives p ≥ 2\n    else True := sorry\n\ntheorem invalid_service_lacks_change {coins : List Coin}\n  (h : ∀ c ∈ coins, c = Coin.five ∨ c = Coin.ten ∨ c = Coin.fifteen) :\n  canServeIcecream coins = false →\n  ∃ p : List Coin, p.isPrefixOf coins ∧\n  match p.getLast? with\n  | none => False\n  | some last =>\n    (last = Coin.ten ∧ countFives p = 0) ∨ \n    (last = Coin.fifteen ∧ countTens p = 0 ∧ countFives p < 2) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1357"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGru has not been in the limelight for a long time and is, therefore, planning something particularly nefarious. Frustrated by his minions' incapability which has kept him away from the limelight, he has built a transmogrifier — a machine which mutates minions.\n\nEach minion has an intrinsic characteristic value (similar to our DNA), which is an integer. The transmogrifier adds an integer K to each of the minions' characteristic value. \n\nGru knows that if the new characteristic value of a minion is divisible by 7, then it will have Wolverine-like mutations.\n\nGiven the initial characteristic integers of N minions, all of which are then transmogrified, find out how many of them become Wolverine-like.\n\n-----Input Format:-----\nThe first line contains one integer, T, which is the number of test cases. Each test case is then described in two lines.\nThe first line contains two integers N and K, as described in the statement.\nThe next line contains N integers, which denote the initial characteristic values for the minions.\n\n-----Output Format:-----\nFor each testcase, output one integer in a new line, which is the number of Wolverine-like minions after the transmogrification.\n\n-----Constraints:-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 100\n- 1 ≤ K ≤ 100\n- All initial characteristic values lie between 1 and 105, both inclusive.\n\n-----Example-----\nInput:\n1\n5 10\n2 4 1 35 1\n\nOutput:\n1\n\n-----Explanation:-----\nAfter transmogrification, the characteristic values become {12,14,11,45,11}, out of which only 14 is divisible by 7. So only the second minion becomes Wolverine-like.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_wolverine_mutations (n k : Nat) (characteristics : List Nat) : Nat :=\nsorry\n\n\n\n\n\ntheorem wolverine_mutations_empty \n  (n k : Nat) (h1 : n ≥ 1) (h2 : k ≥ 1) :\n  count_wolverine_mutations n k [] = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1371", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGru has not been in the limelight for a long time and is, therefore, planning something particularly nefarious. Frustrated by his minions' incapability which has kept him away from the limelight, he has built a transmogrifier — a machine which mutates minions.\n\nEach minion has an intrinsic characteristic value (similar to our DNA), which is an integer. The transmogrifier adds an integer K to each of the minions' characteristic value. \n\nGru knows that if the new characteristic value of a minion is divisible by 7, then it will have Wolverine-like mutations.\n\nGiven the initial characteristic integers of N minions, all of which are then transmogrified, find out how many of them become Wolverine-like.\n\n-----Input Format:-----\nThe first line contains one integer, T, which is the number of test cases. Each test case is then described in two lines.\nThe first line contains two integers N and K, as described in the statement.\nThe next line contains N integers, which denote the initial characteristic values for the minions.\n\n-----Output Format:-----\nFor each testcase, output one integer in a new line, which is the number of Wolverine-like minions after the transmogrification.\n\n-----Constraints:-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 100\n- 1 ≤ K ≤ 100\n- All initial characteristic values lie between 1 and 105, both inclusive.\n\n-----Example-----\nInput:\n1\n5 10\n2 4 1 35 1\n\nOutput:\n1\n\n-----Explanation:-----\nAfter transmogrification, the characteristic values become {12,14,11,45,11}, out of which only 14 is divisible by 7. So only the second minion becomes Wolverine-like.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_wolverine_mutations (n k : Nat) (characteristics : List Nat) : Nat :=\nsorry\n\n\n\n\n\ntheorem wolverine_mutations_empty \n  (n k : Nat) (h1 : n ≥ 1) (h2 : k ≥ 1) :\n  count_wolverine_mutations n k [] = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1371"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef has an array of N integers. He wants to play a special game. In this game he needs to make all the integers in the array greater than or equal to 0. \nChef can use two types of operations. The first type is to  increase all the integers of the given array by 1, but it costs X coins. The operation of the second type is to add 1 to only one integer of the given array and to use this operation you need to pay 1 coin. You need to calculate the minimal cost to win this game (to make all integers greater than or equal to 0)  \n\n-----Input-----\n\nThe first line of the input contains an integer N denoting the number of elements in the given array. The second line contains N space-separated integers A1, A2, ..., AN denoting the given array. The third line contains number X - cost of the first type operation. \n\n\n-----Output-----\nFor each test case, output a single line containing minimal cost required to make all the integers greater than or equal to zero.\n\n-----Constraints-----\n\n- 1 ≤ N ≤ 105\n- -109 ≤ Ai ≤  109 \n- 0 ≤ X  ≤ 109\n\n-----Example-----\nInput:\n3\n-1 -2 -3\n2\n\nOutput:\n5\n\n-----Explanation-----\nExample case 1: Use the first type operation twice and the second type once.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_min_cost (n: Nat) (arr: List Int) (x: Nat) : Nat :=\n  sorry\n\ntheorem find_min_cost_nonnegative (n: Nat) (arr: List Int) (x: Nat) :\n  find_min_cost n arr x ≥ 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1382", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef has an array of N integers. He wants to play a special game. In this game he needs to make all the integers in the array greater than or equal to 0. \nChef can use two types of operations. The first type is to  increase all the integers of the given array by 1, but it costs X coins. The operation of the second type is to add 1 to only one integer of the given array and to use this operation you need to pay 1 coin. You need to calculate the minimal cost to win this game (to make all integers greater than or equal to 0)  \n\n-----Input-----\n\nThe first line of the input contains an integer N denoting the number of elements in the given array. The second line contains N space-separated integers A1, A2, ..., AN denoting the given array. The third line contains number X - cost of the first type operation. \n\n\n-----Output-----\nFor each test case, output a single line containing minimal cost required to make all the integers greater than or equal to zero.\n\n-----Constraints-----\n\n- 1 ≤ N ≤ 105\n- -109 ≤ Ai ≤  109 \n- 0 ≤ X  ≤ 109\n\n-----Example-----\nInput:\n3\n-1 -2 -3\n2\n\nOutput:\n5\n\n-----Explanation-----\nExample case 1: Use the first type operation twice and the second type once.\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_min_cost (n: Nat) (arr: List Int) (x: Nat) : Nat :=\n  sorry\n\ntheorem find_min_cost_nonnegative (n: Nat) (arr: List Int) (x: Nat) :\n  find_min_cost n arr x ≥ 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1382"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline). Your task is print the words in the text in reverse order without any punctuation marks.\nFor example consider the following candidate for the input text:\n$ $\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n$ $\nThe corresponding output would read as:\n$ $\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n\n$ $\nThat is, the lines are printed in reverse order and in each line the words are printed in reverse order.\n\n-----Input:-----\nThe first line of input contains a single integer $N$, indicating the number of lines in the input. This is followed by $N$ lines of input text.\n\n-----Output:-----\n$N$ lines of output text containing the input lines in reverse order and where each line contains the words in reverse order as illustrated above.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 10000$.\n- There are at most $80$ characters in each line\n\n-----Sample input-----\n2\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n-----Sample output-----\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef reverse_text (lines : List String) : List String := sorry\n\ntheorem reverse_text_lines_length_eq_input {lines : List String} : \n  List.length (reverse_text lines) = List.length lines := sorry\n\ntheorem reverse_text_all_alpha_or_space {lines : List String} :\n  ∀ line ∈ reverse_text lines, ∀ c ∈ line.data, c.isAlpha ∨ c = ' ' := sorry\n\ntheorem reverse_text_word_all_alpha {lines : List String} :\n  ∀ line ∈ reverse_text lines, ∀ word ∈ line.splitOn \" \", \n    ∀ c ∈ word.data, c.isAlpha := sorry\n\ntheorem reverse_text_preserves_line_count {lines : List String} :\n  ∀ input_line ∈ lines, ∃ output_line ∈ reverse_text lines,\n    ∀ word ∈ output_line.splitOn \" \", ∀ c ∈ word.data, c.isAlpha := sorry\n\ntheorem reverse_text_reverse_order {lines : List String} : \n  ∀ i, i < lines.length → \n    ∃ j, j < (reverse_text lines).length ∧ \n         j = lines.length - 1 - i ∧\n         ∀ word ∈ ((reverse_text lines).get ⟨j, sorry⟩).splitOn \" \",\n           ∀ c ∈ word.data, c.isAlpha := sorry\n\ntheorem reverse_text_nonempty_line_count {lines : List String} :\n  let result := reverse_text lines\n  let result_lines := result.filter (fun l => l.trim ≠ \"\")\n  let input_lines := lines.filter (fun l => ∃ c ∈ l.data, c.isAlpha)\n  List.length result_lines = List.length input_lines := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1389", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline). Your task is print the words in the text in reverse order without any punctuation marks.\nFor example consider the following candidate for the input text:\n$ $\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n$ $\nThe corresponding output would read as:\n$ $\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n\n$ $\nThat is, the lines are printed in reverse order and in each line the words are printed in reverse order.\n\n-----Input:-----\nThe first line of input contains a single integer $N$, indicating the number of lines in the input. This is followed by $N$ lines of input text.\n\n-----Output:-----\n$N$ lines of output text containing the input lines in reverse order and where each line contains the words in reverse order as illustrated above.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 10000$.\n- There are at most $80$ characters in each line\n\n-----Sample input-----\n2\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n-----Sample output-----\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef reverse_text (lines : List String) : List String := sorry\n\ntheorem reverse_text_lines_length_eq_input {lines : List String} : \n  List.length (reverse_text lines) = List.length lines := sorry\n\ntheorem reverse_text_all_alpha_or_space {lines : List String} :\n  ∀ line ∈ reverse_text lines, ∀ c ∈ line.data, c.isAlpha ∨ c = ' ' := sorry\n\ntheorem reverse_text_word_all_alpha {lines : List String} :\n  ∀ line ∈ reverse_text lines, ∀ word ∈ line.splitOn \" \", \n    ∀ c ∈ word.data, c.isAlpha := sorry\n\ntheorem reverse_text_preserves_line_count {lines : List String} :\n  ∀ input_line ∈ lines, ∃ output_line ∈ reverse_text lines,\n    ∀ word ∈ output_line.splitOn \" \", ∀ c ∈ word.data, c.isAlpha := sorry\n\ntheorem reverse_text_reverse_order {lines : List String} : \n  ∀ i, i < lines.length → \n    ∃ j, j < (reverse_text lines).length ∧ \n         j = lines.length - 1 - i ∧\n         ∀ word ∈ ((reverse_text lines).get ⟨j, sorry⟩).splitOn \" \",\n           ∀ c ∈ word.data, c.isAlpha := sorry\n\ntheorem reverse_text_nonempty_line_count {lines : List String} :\n  let result := reverse_text lines\n  let result_lines := result.filter (fun l => l.trim ≠ \"\")\n  let input_lines := lines.filter (fun l => ∃ c ∈ l.data, c.isAlpha)\n  List.length result_lines = List.length input_lines := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1389"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nDhruvil has always been a studious person and will be completing his Engineering soon. He is always kneen about solving problems and is preparing hard for his next interview at Hackerrank. He has practiced lots of problems and now he came across this problem.\nGiven a message containing English letters(A-Z), it is being encoded to numbers using the following mapping:\n'A' -> 1,'B' -> 2 ……………… 'Z' -> 26.\nNow, given a non-empty string containing only digits, help Dhruvil determine the total number of ways to decode it.\nWhile decoding you need to choose a substring of charachters and not a subsequence. Also a chosen substring should not contain any leading \"0\"s, but can contain trailing \"0\"s. Since the output can be very large print the answer as modulo 10^9 + 7 i.e 1000000007.\n\n-----Input:-----\nThe first line of the input consists of single integer T, the number of test cases.\nEach test case consists of a string.\n\n-----Output:-----\nFor each test case print a single integer - the total number of ways to decode the digit string.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq S \\leq 10^9$\n\n-----Sample Input:-----\n2\n12\n\n226\n\n-----Sample Output:-----\n2\n\n3\n\n-----EXPLANATION:-----\nThere are 2 possible ways. It could be decoded as \"AB\" {1,2} or \"L\" {12}.\nThere are 3 possible ways. It could be decoded as \"BZ\" {2,26}, \"VF\" {22,6}, or \"BBF\" {2,2,6}.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef decode_string (s : String) : Nat := sorry\n\n\n\n\n\ntheorem decode_string_empty :\n  decode_string \"\" = 0 := sorry\n\ntheorem decode_string_single_zero :\n  decode_string \"0\" = 0 := sorry\n\ntheorem decode_string_leading_zero :\n  decode_string \"01\" = 0 := sorry\n\ntheorem decode_string_single_digit {d : Char} \n  (h1 : d.isDigit)\n  (h2 : d ≠ '0') :\n  decode_string (String.mk [d]) = 1 := sorry\n\ntheorem decode_string_twelve :\n  decode_string \"12\" = 2 := sorry\n\ntheorem decode_string_226 :\n  decode_string \"226\" = 3 := sorry\n\ntheorem decode_string_eleven :\n  decode_string \"11\" = 2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1403", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nDhruvil has always been a studious person and will be completing his Engineering soon. He is always kneen about solving problems and is preparing hard for his next interview at Hackerrank. He has practiced lots of problems and now he came across this problem.\nGiven a message containing English letters(A-Z), it is being encoded to numbers using the following mapping:\n'A' -> 1,'B' -> 2 ……………… 'Z' -> 26.\nNow, given a non-empty string containing only digits, help Dhruvil determine the total number of ways to decode it.\nWhile decoding you need to choose a substring of charachters and not a subsequence. Also a chosen substring should not contain any leading \"0\"s, but can contain trailing \"0\"s. Since the output can be very large print the answer as modulo 10^9 + 7 i.e 1000000007.\n\n-----Input:-----\nThe first line of the input consists of single integer T, the number of test cases.\nEach test case consists of a string.\n\n-----Output:-----\nFor each test case print a single integer - the total number of ways to decode the digit string.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq S \\leq 10^9$\n\n-----Sample Input:-----\n2\n12\n\n226\n\n-----Sample Output:-----\n2\n\n3\n\n-----EXPLANATION:-----\nThere are 2 possible ways. It could be decoded as \"AB\" {1,2} or \"L\" {12}.\nThere are 3 possible ways. It could be decoded as \"BZ\" {2,26}, \"VF\" {22,6}, or \"BBF\" {2,2,6}.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef decode_string (s : String) : Nat := sorry\n\n\n\n\n\ntheorem decode_string_empty :\n  decode_string \"\" = 0 := sorry\n\ntheorem decode_string_single_zero :\n  decode_string \"0\" = 0 := sorry\n\ntheorem decode_string_leading_zero :\n  decode_string \"01\" = 0 := sorry\n\ntheorem decode_string_single_digit {d : Char} \n  (h1 : d.isDigit)\n  (h2 : d ≠ '0') :\n  decode_string (String.mk [d]) = 1 := sorry\n\ntheorem decode_string_twelve :\n  decode_string \"12\" = 2 := sorry\n\ntheorem decode_string_226 :\n  decode_string \"226\" = 3 := sorry\n\ntheorem decode_string_eleven :\n  decode_string \"11\" = 2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1403"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef has bought N robots to transport cakes for a large community wedding. He has assigned unique indices, from 1 to N, to each of them. How it will happen?\nChef arranges the N robots in a row, in the (increasing) order of their indices. Then, he chooses the first M robots and moves them to the end of the queue. Now, Chef goes to the robot at the first position in the row and hands it one cake. He then notes this robot's index (say k) in his notebook, and goes to the kth position in the row. If the robot at this position does not have a cake, he give him one cake, notes his index in his notebook, and continues the same process. If a robot visited by Chef already has a cake with it, then he stops moving and the cake assignment process is stopped.\nChef will be satisfied if all robots have a cake in the end. In order to prepare the kitchen staff for Chef's wrath (or happiness :) ), you must find out if he will be satisfied or not? If not, you have to find out how much robots have a cake, so that the kitchen staff can prepare themselves accordingly.\n\n-----Input-----\n- The first line of input contains a single integer T denoting the number of test cases.\n- The single line of each test cases contains two space separated integers N and M.\n\n-----Output-----\nFor each of the T test cases, output a single line:\n\n- If all N robots have a cake, output \"Yes\" (without quotes).\n- Otherwise, output \"No\" (without quotes) followed by a space and the number of robots which have a cake.\n\n-----Constraints and Subtasks-----\n- 1 ≤ T ≤ 10\n- 0 ≤ M < NSubtask 1: 25 points\n- 1 ≤ N ≤ 10^5Subtask 3: 75 points\n- 1 ≤ N ≤ 10^9\n\n-----Example-----\nInput:\n3\n2 0\n2 1\n4 2\n\nOutput:\nNo 1\nYes\nNo 2\n\n-----Explanation-----\nIn test case 1, we have two robots indexed 1 and 2. They are arranged as (1 2). Chef goes to the first robot, gives him a cake, and moves to position 1. In the next step, he sees that robot at this position already has a has cake. So Chef stops moving, and our answer is \"No 1\".\nIn test case 2, we again have two robots indexed 1 and 2. Initially, they are arranged as (1 2). Then, Chef moves robot#1 to the end of the row, and thus the arrangement becomes (2 1). Chef goes to the robot at the first position, which is robot#2. Chef hands him a cake, and moves to position 2. Then, he hands a cake to robot#1 at position 2, and moves back to the first position. Since, robot#2 at the first position already ahs a cake, Chef stops moving. All N robots have cakes, so Chef is satisfied, and our answer is \"Yes\".\nIn the 3rd test case, we have the following arrangement of robots: (3 4 1 2). Only robots with indices 3 and 1 will get cakes. So our answer is \"No 2\".\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_robot_cake_distribution (n : Nat) (m : Nat) : String := sorry\n\ntheorem robot_cake_distribution_bounds (n m : Nat)\n  (h1 : 2 ≤ n)\n  (h2 : n ≤ 100)\n  (h3 : m < n) :\n  let result := solve_robot_cake_distribution n m\n  (result = \"Yes\" ∨ ∃ count, result = s!\"No {count}\" ∧ 1 ≤ count ∧ count < n) := sorry\n\ntheorem robot_cake_zero_shift (n : Nat)\n  (h1 : 2 ≤ n)\n  (h2 : n ≤ 100) :\n  solve_robot_cake_distribution n 0 = \"No 1\" := sorry\n\ntheorem robot_cake_count_validity (n m : Nat)\n  (h1 : 2 ≤ n)\n  (h2 : n ≤ 100)\n  (h3 : m < n) :\n  let result := solve_robot_cake_distribution n m\n  (result = \"Yes\" ∨ ∃ count, result = s!\"No {count}\" ∧ 0 < count ∧ count < n) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1452", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef has bought N robots to transport cakes for a large community wedding. He has assigned unique indices, from 1 to N, to each of them. How it will happen?\nChef arranges the N robots in a row, in the (increasing) order of their indices. Then, he chooses the first M robots and moves them to the end of the queue. Now, Chef goes to the robot at the first position in the row and hands it one cake. He then notes this robot's index (say k) in his notebook, and goes to the kth position in the row. If the robot at this position does not have a cake, he give him one cake, notes his index in his notebook, and continues the same process. If a robot visited by Chef already has a cake with it, then he stops moving and the cake assignment process is stopped.\nChef will be satisfied if all robots have a cake in the end. In order to prepare the kitchen staff for Chef's wrath (or happiness :) ), you must find out if he will be satisfied or not? If not, you have to find out how much robots have a cake, so that the kitchen staff can prepare themselves accordingly.\n\n-----Input-----\n- The first line of input contains a single integer T denoting the number of test cases.\n- The single line of each test cases contains two space separated integers N and M.\n\n-----Output-----\nFor each of the T test cases, output a single line:\n\n- If all N robots have a cake, output \"Yes\" (without quotes).\n- Otherwise, output \"No\" (without quotes) followed by a space and the number of robots which have a cake.\n\n-----Constraints and Subtasks-----\n- 1 ≤ T ≤ 10\n- 0 ≤ M < NSubtask 1: 25 points\n- 1 ≤ N ≤ 10^5Subtask 3: 75 points\n- 1 ≤ N ≤ 10^9\n\n-----Example-----\nInput:\n3\n2 0\n2 1\n4 2\n\nOutput:\nNo 1\nYes\nNo 2\n\n-----Explanation-----\nIn test case 1, we have two robots indexed 1 and 2. They are arranged as (1 2). Chef goes to the first robot, gives him a cake, and moves to position 1. In the next step, he sees that robot at this position already has a has cake. So Chef stops moving, and our answer is \"No 1\".\nIn test case 2, we again have two robots indexed 1 and 2. Initially, they are arranged as (1 2). Then, Chef moves robot#1 to the end of the row, and thus the arrangement becomes (2 1). Chef goes to the robot at the first position, which is robot#2. Chef hands him a cake, and moves to position 2. Then, he hands a cake to robot#1 at position 2, and moves back to the first position. Since, robot#2 at the first position already ahs a cake, Chef stops moving. All N robots have cakes, so Chef is satisfied, and our answer is \"Yes\".\nIn the 3rd test case, we have the following arrangement of robots: (3 4 1 2). Only robots with indices 3 and 1 will get cakes. So our answer is \"No 2\".\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_robot_cake_distribution (n : Nat) (m : Nat) : String := sorry\n\ntheorem robot_cake_distribution_bounds (n m : Nat)\n  (h1 : 2 ≤ n)\n  (h2 : n ≤ 100)\n  (h3 : m < n) :\n  let result := solve_robot_cake_distribution n m\n  (result = \"Yes\" ∨ ∃ count, result = s!\"No {count}\" ∧ 1 ≤ count ∧ count < n) := sorry\n\ntheorem robot_cake_zero_shift (n : Nat)\n  (h1 : 2 ≤ n)\n  (h2 : n ≤ 100) :\n  solve_robot_cake_distribution n 0 = \"No 1\" := sorry\n\ntheorem robot_cake_count_validity (n m : Nat)\n  (h1 : 2 ≤ n)\n  (h2 : n ≤ 100)\n  (h3 : m < n) :\n  let result := solve_robot_cake_distribution n m\n  (result = \"Yes\" ∨ ∃ count, result = s!\"No {count}\" ∧ 0 < count ∧ count < n) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1452"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThe chef was busy in solving algebra, he found some interesting results, that there are many numbers which can be formed by sum of some numbers which are prime. Chef wrote those numbers in dairy. Cheffina came and saw what the chef was doing. Cheffina immediately closed chef's dairy and for testing chef's memory, she starts asking numbers and chef needs to answer wheater given number N can be formed by the sum of K prime numbers if it yes then print 1 else print 0. \n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $N, K$.\n\n-----Output:-----\nFor each test case, output in a single line answer as 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $2 \\leq N \\leq 10^5$\n- $1 \\leq K \\leq 10^5$\n\n-----Sample Input:-----\n2\n12 2\n11 2\n\n-----Sample Output:-----\n1\n0\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef is_prime (n : Nat) : Nat := sorry\n\ndef check_sum_of_primes (n k : Nat) : Nat := sorry\n\ntheorem is_prime_properties (n : Nat) (h : n ≤ 1000) :\n  (is_prime n = 0 ∨ is_prime n = 1) ∧\n  (n ≤ 1 → is_prime n = 0) ∧ \n  (n = 2 → is_prime n = 1) ∧\n  (n > 2 ∧ n % 2 = 0 → is_prime n = 0) := sorry\n\ntheorem check_sum_of_primes_properties (n k : Nat) \n  (hn : n ≤ 1000) (hk : k ≤ 10) :\n  (check_sum_of_primes n k = 0 ∨ check_sum_of_primes n k = 1) ∧\n  (n < 2 * k → check_sum_of_primes n k = 0) ∧\n  (k = 1 → check_sum_of_primes n k = is_prime n) ∧\n  (k = 2 ∧ n % 2 = 0 → check_sum_of_primes n k = 1) := sorry\n\ntheorem check_sum_of_primes_k1 (n : Nat) \n  (h1 : n ≥ 3) (h2 : n ≤ 1000) :\n  check_sum_of_primes n 1 = is_prime n := sorry\n\ntheorem check_sum_of_primes_k2_even (n : Nat)\n  (h1 : n ≥ 4) (h2 : n ≤ 1000) (h3 : n % 2 = 0) :\n  check_sum_of_primes n 2 = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1518", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThe chef was busy in solving algebra, he found some interesting results, that there are many numbers which can be formed by sum of some numbers which are prime. Chef wrote those numbers in dairy. Cheffina came and saw what the chef was doing. Cheffina immediately closed chef's dairy and for testing chef's memory, she starts asking numbers and chef needs to answer wheater given number N can be formed by the sum of K prime numbers if it yes then print 1 else print 0. \n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $N, K$.\n\n-----Output:-----\nFor each test case, output in a single line answer as 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $2 \\leq N \\leq 10^5$\n- $1 \\leq K \\leq 10^5$\n\n-----Sample Input:-----\n2\n12 2\n11 2\n\n-----Sample Output:-----\n1\n0\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef is_prime (n : Nat) : Nat := sorry\n\ndef check_sum_of_primes (n k : Nat) : Nat := sorry\n\ntheorem is_prime_properties (n : Nat) (h : n ≤ 1000) :\n  (is_prime n = 0 ∨ is_prime n = 1) ∧\n  (n ≤ 1 → is_prime n = 0) ∧ \n  (n = 2 → is_prime n = 1) ∧\n  (n > 2 ∧ n % 2 = 0 → is_prime n = 0) := sorry\n\ntheorem check_sum_of_primes_properties (n k : Nat) \n  (hn : n ≤ 1000) (hk : k ≤ 10) :\n  (check_sum_of_primes n k = 0 ∨ check_sum_of_primes n k = 1) ∧\n  (n < 2 * k → check_sum_of_primes n k = 0) ∧\n  (k = 1 → check_sum_of_primes n k = is_prime n) ∧\n  (k = 2 ∧ n % 2 = 0 → check_sum_of_primes n k = 1) := sorry\n\ntheorem check_sum_of_primes_k1 (n : Nat) \n  (h1 : n ≥ 3) (h2 : n ≤ 1000) :\n  check_sum_of_primes n 1 = is_prime n := sorry\n\ntheorem check_sum_of_primes_k2_even (n : Nat)\n  (h1 : n ≥ 4) (h2 : n ≤ 1000) (h3 : n % 2 = 0) :\n  check_sum_of_primes n 2 = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1518"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nI started this as a joke among friends, telling that converting numbers to other integer bases is for n00bs, while an actual coder at least converts numbers to more complex bases like [pi (or π or however you wish to spell it in your language)](http://en.wikipedia.org/wiki/Pi), so they dared me proving I was better.\n\nAnd I did it in few hours, discovering that what I started as a joke actually has [some math ground and application (particularly the conversion to base pi, it seems)](http://en.wikipedia.org/wiki/Non-integer_representation).\n\nThat said, now I am daring you to do the same, that is to build a function so that it takes a **number** (any number, you are warned!) and optionally the **number of decimals** (default: 0) and a **base** (default: pi), returning the proper conversion **as a string**:\n\n#Note\nIn Java there is no easy way with optional parameters so all three parameters will be given; the same in C# because, as of now, the used version is not known. \n\n```python\nconverter(13) #returns '103'\nconverter(13,3) #returns '103.010'\nconverter(-13,0,2) #returns '-1101'\n```\n\nI know most of the world uses a comma as a [decimal mark](http://en.wikipedia.org/wiki/Decimal_mark), but as English language and culture are *de facto* the Esperanto of us coders, we will stick to our common glorious traditions and uses, adopting the trivial dot (\".\") as decimal separator; if the absolute value of the result is <1, you have of course to put one (and only one) leading 0 before the decimal separator.\n\nFinally, you may assume that decimals if provided will always be >= 0 and that no test base will be smaller than 2 (because, you know, converting to base 1 is pretty lame) or greater than 36; as usual, for digits greater than 9 you can use uppercase alphabet letter, so your base of numeration is going to be: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\nThat is my first 3-languages-kata, so I count on you all to give me extensive feedback, no matter how harsh it may sound, so to improve myself even further :)\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef converter (n : Float) (decimals : Nat := 0) (base : Float := 3.14159265359) : String := sorry\n\ndef intToFloat (n : Int) : Float := Float.ofInt n\n\ntheorem converter_sign_property {n : Float} {decimals : Nat} {base : Float}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000)\n  (h3 : 1.1 ≤ base) (h4 : base ≤ 36) :\n  (converter n decimals base).startsWith \"-\" = (n < 0) := sorry\n\ntheorem converter_decimal_property {n : Float} {decimals : Nat} {base : Float}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000)\n  (h3 : 1.1 ≤ base) (h4 : base ≤ 36) :\n  (converter n decimals base).contains '.' = (decimals > 0) := sorry\n\ntheorem converter_decimal_length {n : Float} {decimals : Nat} {base : Float}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000)\n  (h3 : decimals > 0)\n  (h4 : 1.1 ≤ base) (h5 : base ≤ 36) :\n  ((converter n decimals base).split (· = '.')).getLast!.length = decimals := sorry\n\ntheorem converter_integer_no_decimal {n : Int}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000) :\n  ¬(converter (intToFloat n) 0).contains '.' := sorry\n\ntheorem converter_default_base_is_pi {n : Float} {decimals : Nat}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000) :\n  converter n decimals = converter n decimals 3.14159265359 := sorry\n\ntheorem converter_base_2_is_binary {n : Nat}\n  (h : n ≤ 1000) :\n  ∀ c ∈ (converter (intToFloat n) 0 2).data, c = '0' ∨ c = '1' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1617", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nI started this as a joke among friends, telling that converting numbers to other integer bases is for n00bs, while an actual coder at least converts numbers to more complex bases like [pi (or π or however you wish to spell it in your language)](http://en.wikipedia.org/wiki/Pi), so they dared me proving I was better.\n\nAnd I did it in few hours, discovering that what I started as a joke actually has [some math ground and application (particularly the conversion to base pi, it seems)](http://en.wikipedia.org/wiki/Non-integer_representation).\n\nThat said, now I am daring you to do the same, that is to build a function so that it takes a **number** (any number, you are warned!) and optionally the **number of decimals** (default: 0) and a **base** (default: pi), returning the proper conversion **as a string**:\n\n#Note\nIn Java there is no easy way with optional parameters so all three parameters will be given; the same in C# because, as of now, the used version is not known. \n\n```python\nconverter(13) #returns '103'\nconverter(13,3) #returns '103.010'\nconverter(-13,0,2) #returns '-1101'\n```\n\nI know most of the world uses a comma as a [decimal mark](http://en.wikipedia.org/wiki/Decimal_mark), but as English language and culture are *de facto* the Esperanto of us coders, we will stick to our common glorious traditions and uses, adopting the trivial dot (\".\") as decimal separator; if the absolute value of the result is <1, you have of course to put one (and only one) leading 0 before the decimal separator.\n\nFinally, you may assume that decimals if provided will always be >= 0 and that no test base will be smaller than 2 (because, you know, converting to base 1 is pretty lame) or greater than 36; as usual, for digits greater than 9 you can use uppercase alphabet letter, so your base of numeration is going to be: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\nThat is my first 3-languages-kata, so I count on you all to give me extensive feedback, no matter how harsh it may sound, so to improve myself even further :)\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef converter (n : Float) (decimals : Nat := 0) (base : Float := 3.14159265359) : String := sorry\n\ndef intToFloat (n : Int) : Float := Float.ofInt n\n\ntheorem converter_sign_property {n : Float} {decimals : Nat} {base : Float}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000)\n  (h3 : 1.1 ≤ base) (h4 : base ≤ 36) :\n  (converter n decimals base).startsWith \"-\" = (n < 0) := sorry\n\ntheorem converter_decimal_property {n : Float} {decimals : Nat} {base : Float}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000)\n  (h3 : 1.1 ≤ base) (h4 : base ≤ 36) :\n  (converter n decimals base).contains '.' = (decimals > 0) := sorry\n\ntheorem converter_decimal_length {n : Float} {decimals : Nat} {base : Float}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000)\n  (h3 : decimals > 0)\n  (h4 : 1.1 ≤ base) (h5 : base ≤ 36) :\n  ((converter n decimals base).split (· = '.')).getLast!.length = decimals := sorry\n\ntheorem converter_integer_no_decimal {n : Int}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000) :\n  ¬(converter (intToFloat n) 0).contains '.' := sorry\n\ntheorem converter_default_base_is_pi {n : Float} {decimals : Nat}\n  (h1 : -1000 ≤ n) (h2 : n ≤ 1000) :\n  converter n decimals = converter n decimals 3.14159265359 := sorry\n\ntheorem converter_base_2_is_binary {n : Nat}\n  (h : n ≤ 1000) :\n  ∀ c ∈ (converter (intToFloat n) 0 2).data, c = '0' ∨ c = '1' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1617"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nCreate a function that takes a Number as its argument and returns a Chinese numeral string. You don't need to validate the input argument, it will always be a Number in the range `[-99999.999, 99999.999]`, rounded to 8 decimal places.\n\nSimplified Chinese numerals have characters representing each number from 0 to 9 and additional numbers representing larger numbers like 10, 100, 1000, and 10000. \n\n```\n0 líng 零\n1 yī 一\n2 èr 二\n3 sān 三\n4 sì 四\n5 wǔ 五\n6 liù 六\n7 qī 七\n8 bā 八\n9 jiǔ 九\n10 shí 十\n100 bǎi 百\n1000 qiān 千\n10000 wàn 万\n```\n\nMultiple-digit numbers are constructed by first the digit value (1 to 9) and then the place multiplier (such as 10, 100, 1000), starting with the most significant digit. A special case is made for 10 - 19 where the leading digit value (yī 一) is dropped. Note that this special case is only made for the actual values 10 - 19, not any larger values.\n\n```\n10 十\n11 十一\n18 十八\n21 二十一\n110 一百一十\n123 一百二十三\n24681 二万四千六百八十一\n```\n\nTrailing zeros are omitted, but interior zeros are grouped together and indicated by a single 零 character without giving the place multiplier.\n\n```\n10 十\n20 二十\n104 一百零四\n1004 一千零四\n10004 一万零四\n10000 一万\n```\n\nDecimal numbers are constructed by first writing the whole number part, and then inserting a point (diǎn 点), followed by the decimal portion. The decimal portion is expressed using only the digits 0 to 9, without any positional characters and without grouping zeros.\n\n```\n0.1 零点一\n123.45 一百二十三点四五\n```\n\nNegative numbers are the same as other numbers, but add a 负 (fù) before the number.\n\nFor more information, please see http://en.wikipedia.org/wiki/Chinese_numerals.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef to_chinese_numeral (n : Int) : String := sorry\n\ndef DIGS : List String := [\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"]\ndef POWS : List String := [\"\", \"十\", \"百\", \"千\", \"万\"]\ndef NEG : String := \"负\"\n\ntheorem sign_property {n : Int} :\n  n < 0 → (to_chinese_numeral n).startsWith NEG ∧\n  n ≥ 0 → ¬(to_chinese_numeral n).startsWith NEG := sorry\n\ntheorem char_validation {n : Int} :\n  ∀ c : Char, c ∈ (to_chinese_numeral n).data →\n    c ∈ (NEG.data ++ (String.join DIGS).data ++ (String.join POWS).data) := sorry \n\ntheorem single_digit {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 9) :\n  to_chinese_numeral n = DIGS[n.toNat - 1]! := sorry\n\ntheorem teen_numbers {n : Int} (h1 : 10 ≤ n) (h2 : n ≤ 19) :\n  (to_chinese_numeral n).startsWith \"十\" ∧\n  (n > 10 → ∃ c : Char, c ∈ (String.join DIGS).data ∧ \n    (to_chinese_numeral n).data[1]? = some c) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1633", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nCreate a function that takes a Number as its argument and returns a Chinese numeral string. You don't need to validate the input argument, it will always be a Number in the range `[-99999.999, 99999.999]`, rounded to 8 decimal places.\n\nSimplified Chinese numerals have characters representing each number from 0 to 9 and additional numbers representing larger numbers like 10, 100, 1000, and 10000. \n\n```\n0 líng 零\n1 yī 一\n2 èr 二\n3 sān 三\n4 sì 四\n5 wǔ 五\n6 liù 六\n7 qī 七\n8 bā 八\n9 jiǔ 九\n10 shí 十\n100 bǎi 百\n1000 qiān 千\n10000 wàn 万\n```\n\nMultiple-digit numbers are constructed by first the digit value (1 to 9) and then the place multiplier (such as 10, 100, 1000), starting with the most significant digit. A special case is made for 10 - 19 where the leading digit value (yī 一) is dropped. Note that this special case is only made for the actual values 10 - 19, not any larger values.\n\n```\n10 十\n11 十一\n18 十八\n21 二十一\n110 一百一十\n123 一百二十三\n24681 二万四千六百八十一\n```\n\nTrailing zeros are omitted, but interior zeros are grouped together and indicated by a single 零 character without giving the place multiplier.\n\n```\n10 十\n20 二十\n104 一百零四\n1004 一千零四\n10004 一万零四\n10000 一万\n```\n\nDecimal numbers are constructed by first writing the whole number part, and then inserting a point (diǎn 点), followed by the decimal portion. The decimal portion is expressed using only the digits 0 to 9, without any positional characters and without grouping zeros.\n\n```\n0.1 零点一\n123.45 一百二十三点四五\n```\n\nNegative numbers are the same as other numbers, but add a 负 (fù) before the number.\n\nFor more information, please see http://en.wikipedia.org/wiki/Chinese_numerals.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef to_chinese_numeral (n : Int) : String := sorry\n\ndef DIGS : List String := [\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"]\ndef POWS : List String := [\"\", \"十\", \"百\", \"千\", \"万\"]\ndef NEG : String := \"负\"\n\ntheorem sign_property {n : Int} :\n  n < 0 → (to_chinese_numeral n).startsWith NEG ∧\n  n ≥ 0 → ¬(to_chinese_numeral n).startsWith NEG := sorry\n\ntheorem char_validation {n : Int} :\n  ∀ c : Char, c ∈ (to_chinese_numeral n).data →\n    c ∈ (NEG.data ++ (String.join DIGS).data ++ (String.join POWS).data) := sorry \n\ntheorem single_digit {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 9) :\n  to_chinese_numeral n = DIGS[n.toNat - 1]! := sorry\n\ntheorem teen_numbers {n : Int} (h1 : 10 ≤ n) (h2 : n ≤ 19) :\n  (to_chinese_numeral n).startsWith \"十\" ∧\n  (n > 10 → ∃ c : Char, c ∈ (String.join DIGS).data ∧ \n    (to_chinese_numeral n).data[1]? = some c) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1633"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nChef has a rectangular matrix A of nxm integers. Rows are numbered by integers from 1 to n from top to bottom, columns - from 1 to m from left to right. Ai, j denotes the j-th integer of the i-th row.\nChef wants you to guess his matrix. To guess integers, you can ask Chef questions of next type: \"How many integers from submatrix iL, iR, jL, jR are grater than or equal to x and less than or equal to y?\". By submatrix iL, iR, jL, jR we mean all elements Ai, j for all iL ≤ i ≤ iR and jL ≤ j ≤ jR. \nAlso Chef can answer not more than C questions of next type: \"What is the sum of integers from submatrix iL, iR, jL, jR?\"\nAs soon as you think you know the Chefs matrix, you can stop asking questions and tell to the Chef your variant of the matrix. Please see \"Scoring\" part to understand how your solution will be evaluated. \n\n-----Input-----\nThe first line of the input contains three space-separated integers n, m and C denoting the sizes of the matrix and the maximum number of the second-type questions. After that the judge will answer your questions and evaluate the resuts. Read more about that in the \"Interaction with the judge\" part of the statement. \n\n-----Interaction with the judge-----\nTo ask a first-type question you should print to the standard output one line containing seven space-separated integers 1 iL iR jL jR x y. To ask a second-type question you should print one line containing five space-separated integers 2 iL iR jL jR. After that you should read from the standard input one integer - answer to the question. To end the game you should print 3 and starting from next line print n lines, each of them contains m space-separated integers - your variant of the matrix A. After that your program must stop. Remember to flush the output after every line you print.\n\n-----Constraints-----\n- 1 ≤ n, m ≤ 2.5 * 105\n- 1 ≤ n * m ≤ 2.5 * 105\n- 103 ≤ C ≤ 104\n- 1 ≤ Ai, j ≤ 50\n- 1 ≤ iL ≤ iR ≤ n\n- 1 ≤ jL ≤ jR ≤ m\n- 1 ≤ x ≤ y ≤ 50\n- 0 ≤ number of asked questions ≤ 5 * 105\n- 1 ≤ Bi, j ≤ 50\n- 1 ≤ a1, a2, a3 ≤ 10\n\n----- Scoring -----\nLet B will be the matrix you output and diff = ∑ |Ai, j - Bi, j| for all 1 ≤ i ≤ n, 1 ≤ j ≤ m. The number of questions you asked is questions. The number of integers, you correctly guessed is correct(i. e. the number of elements i, j such that Ai, j = Bi, j). \nThe score for each test case will be: score = a1 * questions +  a2 * diff +  a3 * (n * m - correct).\nYour goal is to minimize this score.\nYour total score for the problem will be the sum of scores on all the test cases.\n\n-----Example-----\nInput:\n3 3 10\n4\n0\n3\n1\n6\n\nOutput:\n1 1 2 1 2 1 3\n1 3 3 1 3 1 1\n1 3 3 1 3 2 2\n1 1 2 3 3 1 1\n2 3 3 1 3\n3\n2 2 1\n2 2 1\n2 2 2\n\n\n-----Explanation-----\n\n[1, 2, 3]\nA = [3, 2, 1]\n[2, 2, 2]\n\nFor this test case a1 = 1, a2 = 1 and a3 = 1.\nThe score for this test case will be 1 * 5 + 1 * 4 + 1 * (9 - 6) = 12.\n\n----- Test data generation -----\nThere will be four types of the test files.\n- Type #1: n = 10,  m = 25000\n- Type #2: n = 100,  m = 2500\n- Type #3: n = 250,  m = 1000\n- Type #4: n = 500,  m = 500\nThere will be 5 test files of each type. During the contest, you will be shown the score for only one test file of each type.\nAll elements of matrix A are randomly chosen.\nFor each test case C is randomly chosen from interval [103 .. 104].\nFor each test case values a1, a2 and a3 are manually chosen. \n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_matrix_guessing (n m K : Nat) (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) : List (List Nat) := sorry\n\n/-- Query function is consistent for matrices with small values (1-25) -/\ntheorem solve_matrix_query_consistency_small {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m → \n  1 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 25 := sorry\n\n/-- Query function is consistent for matrices with large values (26-50) -/\ntheorem solve_matrix_query_consistency_large {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m →\n  26 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 50 := sorry\n\n/-- Result matrix has correct dimensions -/\ntheorem basic_dimensions {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  result.length = n ∧ ∀ row ∈ result, row.length = m := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1691", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nChef has a rectangular matrix A of nxm integers. Rows are numbered by integers from 1 to n from top to bottom, columns - from 1 to m from left to right. Ai, j denotes the j-th integer of the i-th row.\nChef wants you to guess his matrix. To guess integers, you can ask Chef questions of next type: \"How many integers from submatrix iL, iR, jL, jR are grater than or equal to x and less than or equal to y?\". By submatrix iL, iR, jL, jR we mean all elements Ai, j for all iL ≤ i ≤ iR and jL ≤ j ≤ jR. \nAlso Chef can answer not more than C questions of next type: \"What is the sum of integers from submatrix iL, iR, jL, jR?\"\nAs soon as you think you know the Chefs matrix, you can stop asking questions and tell to the Chef your variant of the matrix. Please see \"Scoring\" part to understand how your solution will be evaluated. \n\n-----Input-----\nThe first line of the input contains three space-separated integers n, m and C denoting the sizes of the matrix and the maximum number of the second-type questions. After that the judge will answer your questions and evaluate the resuts. Read more about that in the \"Interaction with the judge\" part of the statement. \n\n-----Interaction with the judge-----\nTo ask a first-type question you should print to the standard output one line containing seven space-separated integers 1 iL iR jL jR x y. To ask a second-type question you should print one line containing five space-separated integers 2 iL iR jL jR. After that you should read from the standard input one integer - answer to the question. To end the game you should print 3 and starting from next line print n lines, each of them contains m space-separated integers - your variant of the matrix A. After that your program must stop. Remember to flush the output after every line you print.\n\n-----Constraints-----\n- 1 ≤ n, m ≤ 2.5 * 105\n- 1 ≤ n * m ≤ 2.5 * 105\n- 103 ≤ C ≤ 104\n- 1 ≤ Ai, j ≤ 50\n- 1 ≤ iL ≤ iR ≤ n\n- 1 ≤ jL ≤ jR ≤ m\n- 1 ≤ x ≤ y ≤ 50\n- 0 ≤ number of asked questions ≤ 5 * 105\n- 1 ≤ Bi, j ≤ 50\n- 1 ≤ a1, a2, a3 ≤ 10\n\n----- Scoring -----\nLet B will be the matrix you output and diff = ∑ |Ai, j - Bi, j| for all 1 ≤ i ≤ n, 1 ≤ j ≤ m. The number of questions you asked is questions. The number of integers, you correctly guessed is correct(i. e. the number of elements i, j such that Ai, j = Bi, j). \nThe score for each test case will be: score = a1 * questions +  a2 * diff +  a3 * (n * m - correct).\nYour goal is to minimize this score.\nYour total score for the problem will be the sum of scores on all the test cases.\n\n-----Example-----\nInput:\n3 3 10\n4\n0\n3\n1\n6\n\nOutput:\n1 1 2 1 2 1 3\n1 3 3 1 3 1 1\n1 3 3 1 3 2 2\n1 1 2 3 3 1 1\n2 3 3 1 3\n3\n2 2 1\n2 2 1\n2 2 2\n\n\n-----Explanation-----\n\n[1, 2, 3]\nA = [3, 2, 1]\n[2, 2, 2]\n\nFor this test case a1 = 1, a2 = 1 and a3 = 1.\nThe score for this test case will be 1 * 5 + 1 * 4 + 1 * (9 - 6) = 12.\n\n----- Test data generation -----\nThere will be four types of the test files.\n- Type #1: n = 10,  m = 25000\n- Type #2: n = 100,  m = 2500\n- Type #3: n = 250,  m = 1000\n- Type #4: n = 500,  m = 500\nThere will be 5 test files of each type. During the contest, you will be shown the score for only one test file of each type.\nAll elements of matrix A are randomly chosen.\nFor each test case C is randomly chosen from interval [103 .. 104].\nFor each test case values a1, a2 and a3 are manually chosen. \n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_matrix_guessing (n m K : Nat) (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) : List (List Nat) := sorry\n\n/-- Query function is consistent for matrices with small values (1-25) -/\ntheorem solve_matrix_query_consistency_small {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m → \n  1 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 25 := sorry\n\n/-- Query function is consistent for matrices with large values (26-50) -/\ntheorem solve_matrix_query_consistency_large {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m →\n  26 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 50 := sorry\n\n/-- Result matrix has correct dimensions -/\ntheorem basic_dimensions {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  result.length = n ∧ ∀ row ∈ result, row.length = m := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1691"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nMartha — as a professional problemsetter — proposed a problem for a world-class contest. This is the problem statement:\n\nTomorrow is Nadia's birthday, and Bardia (her brother) is assigned to make the balloons ready!\n\nThere are n balloons (initially empty) that are tied to a straight line on certain positions x_1, x_2, ..., x_{n}. Bardia inflates the balloons from left to right. As a result, i-th balloon gets bigger and bigger until its radius reaches the pressure endurance p_{i} or it touches another previously-inflated balloon. [Image] \n\nWhile Bardia was busy with the balloons, he wondered \"What will be the sum of radius of balloons after all of the balloons are inflated?\". Being a nerdy type of guy, he is now thinking about the problem instead of preparing his sister's birthday. Calculate the answer to Bardia's problem so that Nadia's birthday won't be balloon-less.\n\nArtha — Martha's student — claimed his solution got accepted. Martha (being his teacher for a long time!) knew he couldn't have solved the problem for real and thus thinks there is something wrong with the testcases. Artha isn't anyhow logical, which means there is no way for Martha to explain the wrong point in his algorithm. So, the only way is to find a testcase to prove him wrong!\n\nArtha's pseudo-code is shown below: [Image] \n\nYou should output a small testcase for the problem such that Artha's algorithm is incorrect. The algorithm's output is considered correct if it differs from the correct value by no more than 1.\n\n\n-----Input-----\n\nPlease pay attention! No input will be given to your program for this problem. So you do not have to read from the input anything.\n\n\n-----Output-----\n\nYou should output the generated small testcase (which Artha's solution doesn't get it right). It should be in the following format:  First line must contain the only number n (1 ≤ n ≤ 500).  The i-th of the next n lines should contain the description of the i-th balloon — two space-separated integers x_{i}, p_{i} (1 ≤ p_{i} ≤ 10^6, 0 ≤ x_1 < x_2 < ... < x_{n} ≤ 10^6). \n\n\n-----Examples-----\n\n\n-----Note-----\n\nThe testcase depicted in the figure above (just showing how output should be formatted):\n\n4\n\n0 9\n\n6 3\n\n12 7\n\n17 1\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef generate_testcase : (Nat × List (Nat × Nat)) := sorry\n\ntheorem testcase_properties (n : Nat) (balloons : List (Nat × Nat)) \n    (h : (n, balloons) = generate_testcase) : \n    List.length balloons = n ∧ \n    (List.get? balloons 0).map Prod.fst = some 0 ∧\n    List.all balloons (fun p => p.1 ≥ 0 ∧ p.2 > 0) ∧\n    List.Pairwise (fun p1 p2 => p1.1 < p2.1) balloons := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1692", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nMartha — as a professional problemsetter — proposed a problem for a world-class contest. This is the problem statement:\n\nTomorrow is Nadia's birthday, and Bardia (her brother) is assigned to make the balloons ready!\n\nThere are n balloons (initially empty) that are tied to a straight line on certain positions x_1, x_2, ..., x_{n}. Bardia inflates the balloons from left to right. As a result, i-th balloon gets bigger and bigger until its radius reaches the pressure endurance p_{i} or it touches another previously-inflated balloon. [Image] \n\nWhile Bardia was busy with the balloons, he wondered \"What will be the sum of radius of balloons after all of the balloons are inflated?\". Being a nerdy type of guy, he is now thinking about the problem instead of preparing his sister's birthday. Calculate the answer to Bardia's problem so that Nadia's birthday won't be balloon-less.\n\nArtha — Martha's student — claimed his solution got accepted. Martha (being his teacher for a long time!) knew he couldn't have solved the problem for real and thus thinks there is something wrong with the testcases. Artha isn't anyhow logical, which means there is no way for Martha to explain the wrong point in his algorithm. So, the only way is to find a testcase to prove him wrong!\n\nArtha's pseudo-code is shown below: [Image] \n\nYou should output a small testcase for the problem such that Artha's algorithm is incorrect. The algorithm's output is considered correct if it differs from the correct value by no more than 1.\n\n\n-----Input-----\n\nPlease pay attention! No input will be given to your program for this problem. So you do not have to read from the input anything.\n\n\n-----Output-----\n\nYou should output the generated small testcase (which Artha's solution doesn't get it right). It should be in the following format:  First line must contain the only number n (1 ≤ n ≤ 500).  The i-th of the next n lines should contain the description of the i-th balloon — two space-separated integers x_{i}, p_{i} (1 ≤ p_{i} ≤ 10^6, 0 ≤ x_1 < x_2 < ... < x_{n} ≤ 10^6). \n\n\n-----Examples-----\n\n\n-----Note-----\n\nThe testcase depicted in the figure above (just showing how output should be formatted):\n\n4\n\n0 9\n\n6 3\n\n12 7\n\n17 1\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef generate_testcase : (Nat × List (Nat × Nat)) := sorry\n\ntheorem testcase_properties (n : Nat) (balloons : List (Nat × Nat)) \n    (h : (n, balloons) = generate_testcase) : \n    List.length balloons = n ∧ \n    (List.get? balloons 0).map Prod.fst = some 0 ∧\n    List.all balloons (fun p => p.1 ≥ 0 ∧ p.2 > 0) ∧\n    List.Pairwise (fun p1 p2 => p1.1 < p2.1) balloons := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1692"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n![alt text](https://2.bp.blogspot.com/-DNNiOXduuvQ/Vh-FR-qbKXI/AAAAAAAAEOA/HT0IzJ36zW4/s1600/voz.jpg)\n\nCreate a class called `Warrior` which calculates and keeps track of their level and skills, and ranks them as the warrior they've proven to be.\n\nBusiness Rules:\n\n- A warrior starts at level 1 and can progress all the way to 100.\n- A warrior starts at rank `\"Pushover\"` and can progress all the way to `\"Greatest\"`.\n- The only acceptable range of rank values is `\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"`.\n- Warriors will compete in battles. Battles will always accept an enemy level to match against your own.\n- With each battle successfully finished, your warrior's experience is updated based on the enemy's level.\n- The experience earned from the battle is relative to what the warrior's current level is compared to the level of the enemy.\n- A warrior's experience starts from 100. Each time the warrior's experience increases by another 100, the warrior's level rises to the next level.\n- A warrior's experience is cumulative, and does not reset with each rise of level. The only exception is when the warrior reaches level 100, with which the experience stops at 10000\n- At every 10 levels, your warrior will reach a new rank tier. (ex. levels 1-9 falls within `\"Pushover\"` tier, levels 80-89 fall within `\"Champion\"` tier, etc.)\n- A warrior cannot progress beyond level 100 and rank `\"Greatest\"`.\n\nBattle Progress Rules & Calculations:\n\n- If an enemy level does not fall in the range of 1 to 100, the battle cannot happen and should return `\"Invalid level\"`.\n- Completing a battle against an enemy with the same level as your warrior will be worth 10 experience points.\n- Completing a battle against an enemy who is one level lower than your warrior will be worth 5 experience points.\n- Completing a battle against an enemy who is two levels lower or more than your warrior will give 0 experience points.\n- Completing a battle against an enemy who is one level higher or more than your warrior will accelarate your experience gaining. The greater the difference between levels, the more experinece your warrior will gain. The formula is `20 * diff * diff` where `diff` equals the difference in levels between the enemy and your warrior.\n- However, if your warrior is at least one rank lower than your enemy, and at least 5 levels lower, your warrior cannot fight against an enemy that strong and must instead return `\"You've been defeated\"`.\n- Every successful battle will also return one of three responses: `\"Easy fight\", \"A good fight\", \"An intense fight\"`. Return `\"Easy fight\"` if your warrior is 2 or more levels higher than your enemy's level. Return `\"A good fight\"` if your warrior is either 1 level higher or equal to your enemy's level. Return `\"An intense fight\"` if your warrior's level is lower than the enemy's level.\n\nLogic Examples:\n\n- If a warrior level 1 fights an enemy level 1, they will receive 10 experience points.\n- If a warrior level 1 fights an enemy level 3, they will receive 80 experience points.\n- If a warrior level 5 fights an enemy level 4, they will receive 5 experience points.\n- If a warrior level 3 fights an enemy level 9, they will receive 720 experience points, resulting in the warrior rising up by at least 7 levels.\n- If a warrior level 8 fights an enemy level 13, they will receive 0 experience points and return `\"You've been defeated\"`. (Remember, difference in rank & enemy level being 5 levels higher or more must be established for this.)\n- If a warrior level 6 fights an enemy level 2, they will receive 0 experience points.\n\n Training Rules & Calculations:\n- In addition to earning experience point from battles, warriors can also gain experience points from training.\n- Training will accept an array of three elements (except in java where you'll get 3 separated arguments): the description, the experience points your warrior earns, and the minimum level requirement.\n- If the warrior's level meets the minimum level requirement, the warrior will receive the experience points from it and store the description of the training. It should end up returning that description as well.\n- If the warrior's level does not meet the minimum level requirement, the warrior doesn not receive the experience points and description and instead returns `\"Not strong enough\"`, without any archiving of the result.\n\n Code Examples:\n```python\nbruce_lee = Warrior()\nbruce_lee.level         # => 1\nbruce_lee.experience    # => 100\nbruce_lee.rank          # => \"Pushover\"\nbruce_lee.achievements  # => []\nbruce_lee.training([\"Defeated Chuck Norris\", 9000, 1]) # => \"Defeated Chuck Norris\"\nbruce_lee.experience    # => 9100\nbruce_lee.level         # => 91\nbruce_lee.rank          # => \"Master\"\nbruce_lee.battle(90)    # => \"A good fight\"\nbruce_lee.experience    # => 9105\nbruce_lee.achievements  # => [\"Defeated Chuck Norris\"]\n```\n```\n#####\n\nTo answer this question, you need to replace the 10 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Warrior where\n  experience : Nat\n  achievements : List String\n  deriving Repr\n\ndef Warrior.level (self : Warrior) : Nat := sorry\ndef Warrior.rank (self : Warrior) : String := sorry\ndef Warrior.training (self : Warrior) (t : String × Nat × Nat) : String := sorry\ndef Warrior.battle (self : Warrior) (level : Nat) : String := sorry\n\ntheorem experience_level_relationship (exp : Nat) (h : exp > 0 ∧ exp ≤ 10000) :\n  let w : Warrior := ⟨exp, []⟩\n  w.level = min 100 (exp / 100) := sorry\n\ntheorem training_sequence (trainings : List (String × Nat × Nat)) :\n  let w : Warrior := ⟨0, []⟩\n  ∀ t ∈ trainings,\n    (t.2.2 ≤ w.level → \n      w.training t = t.1 ∧ \n      t.1 ∈ w.achievements) ∧\n    (t.2.2 > w.level → \n      w.training t = \"Not strong enough\") := sorry\n\ntheorem battle_level_bounds (level : Nat) :\n  let w : Warrior := ⟨0, []⟩\n  (level = 0 ∨ level > 100) →\n    w.battle level = \"Invalid level\" := sorry\n\ntheorem experience_cap (exp_gain : Nat) (h : exp_gain > 0 ∧ exp_gain ≤ 100) :\n  let w : Warrior := ⟨10000, []⟩\n  w.experience = 10000 := sorry\n\ntheorem rank_progression (exp : Nat) (h : exp < 10000) :\n  let w : Warrior := ⟨exp, []⟩\n  let ranks := [\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \n                \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"]\n  have h' : min 10 (exp / 1000) < 11 := by\n    exact Nat.lt_succ_of_le (Nat.min_le_left 10 (exp / 1000))\n  w.rank = ranks[min 10 (exp / 1000)]'h' := sorry\n\ntheorem battle_outcomes (level : Nat) (h : level > 0 ∧ level ≤ 100) :\n  let w : Warrior := ⟨0, []⟩\n  w.battle level ∈ [\"A good fight\", \"An intense fight\", \n                    \"Easy fight\", \"You've been defeated\"] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1710", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n![alt text](https://2.bp.blogspot.com/-DNNiOXduuvQ/Vh-FR-qbKXI/AAAAAAAAEOA/HT0IzJ36zW4/s1600/voz.jpg)\n\nCreate a class called `Warrior` which calculates and keeps track of their level and skills, and ranks them as the warrior they've proven to be.\n\nBusiness Rules:\n\n- A warrior starts at level 1 and can progress all the way to 100.\n- A warrior starts at rank `\"Pushover\"` and can progress all the way to `\"Greatest\"`.\n- The only acceptable range of rank values is `\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"`.\n- Warriors will compete in battles. Battles will always accept an enemy level to match against your own.\n- With each battle successfully finished, your warrior's experience is updated based on the enemy's level.\n- The experience earned from the battle is relative to what the warrior's current level is compared to the level of the enemy.\n- A warrior's experience starts from 100. Each time the warrior's experience increases by another 100, the warrior's level rises to the next level.\n- A warrior's experience is cumulative, and does not reset with each rise of level. The only exception is when the warrior reaches level 100, with which the experience stops at 10000\n- At every 10 levels, your warrior will reach a new rank tier. (ex. levels 1-9 falls within `\"Pushover\"` tier, levels 80-89 fall within `\"Champion\"` tier, etc.)\n- A warrior cannot progress beyond level 100 and rank `\"Greatest\"`.\n\nBattle Progress Rules & Calculations:\n\n- If an enemy level does not fall in the range of 1 to 100, the battle cannot happen and should return `\"Invalid level\"`.\n- Completing a battle against an enemy with the same level as your warrior will be worth 10 experience points.\n- Completing a battle against an enemy who is one level lower than your warrior will be worth 5 experience points.\n- Completing a battle against an enemy who is two levels lower or more than your warrior will give 0 experience points.\n- Completing a battle against an enemy who is one level higher or more than your warrior will accelarate your experience gaining. The greater the difference between levels, the more experinece your warrior will gain. The formula is `20 * diff * diff` where `diff` equals the difference in levels between the enemy and your warrior.\n- However, if your warrior is at least one rank lower than your enemy, and at least 5 levels lower, your warrior cannot fight against an enemy that strong and must instead return `\"You've been defeated\"`.\n- Every successful battle will also return one of three responses: `\"Easy fight\", \"A good fight\", \"An intense fight\"`. Return `\"Easy fight\"` if your warrior is 2 or more levels higher than your enemy's level. Return `\"A good fight\"` if your warrior is either 1 level higher or equal to your enemy's level. Return `\"An intense fight\"` if your warrior's level is lower than the enemy's level.\n\nLogic Examples:\n\n- If a warrior level 1 fights an enemy level 1, they will receive 10 experience points.\n- If a warrior level 1 fights an enemy level 3, they will receive 80 experience points.\n- If a warrior level 5 fights an enemy level 4, they will receive 5 experience points.\n- If a warrior level 3 fights an enemy level 9, they will receive 720 experience points, resulting in the warrior rising up by at least 7 levels.\n- If a warrior level 8 fights an enemy level 13, they will receive 0 experience points and return `\"You've been defeated\"`. (Remember, difference in rank & enemy level being 5 levels higher or more must be established for this.)\n- If a warrior level 6 fights an enemy level 2, they will receive 0 experience points.\n\n Training Rules & Calculations:\n- In addition to earning experience point from battles, warriors can also gain experience points from training.\n- Training will accept an array of three elements (except in java where you'll get 3 separated arguments): the description, the experience points your warrior earns, and the minimum level requirement.\n- If the warrior's level meets the minimum level requirement, the warrior will receive the experience points from it and store the description of the training. It should end up returning that description as well.\n- If the warrior's level does not meet the minimum level requirement, the warrior doesn not receive the experience points and description and instead returns `\"Not strong enough\"`, without any archiving of the result.\n\n Code Examples:\n```python\nbruce_lee = Warrior()\nbruce_lee.level         # => 1\nbruce_lee.experience    # => 100\nbruce_lee.rank          # => \"Pushover\"\nbruce_lee.achievements  # => []\nbruce_lee.training([\"Defeated Chuck Norris\", 9000, 1]) # => \"Defeated Chuck Norris\"\nbruce_lee.experience    # => 9100\nbruce_lee.level         # => 91\nbruce_lee.rank          # => \"Master\"\nbruce_lee.battle(90)    # => \"A good fight\"\nbruce_lee.experience    # => 9105\nbruce_lee.achievements  # => [\"Defeated Chuck Norris\"]\n```\n```\n#####\n\nTo answer this question, you need to replace the 10 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Warrior where\n  experience : Nat\n  achievements : List String\n  deriving Repr\n\ndef Warrior.level (self : Warrior) : Nat := sorry\ndef Warrior.rank (self : Warrior) : String := sorry\ndef Warrior.training (self : Warrior) (t : String × Nat × Nat) : String := sorry\ndef Warrior.battle (self : Warrior) (level : Nat) : String := sorry\n\ntheorem experience_level_relationship (exp : Nat) (h : exp > 0 ∧ exp ≤ 10000) :\n  let w : Warrior := ⟨exp, []⟩\n  w.level = min 100 (exp / 100) := sorry\n\ntheorem training_sequence (trainings : List (String × Nat × Nat)) :\n  let w : Warrior := ⟨0, []⟩\n  ∀ t ∈ trainings,\n    (t.2.2 ≤ w.level → \n      w.training t = t.1 ∧ \n      t.1 ∈ w.achievements) ∧\n    (t.2.2 > w.level → \n      w.training t = \"Not strong enough\") := sorry\n\ntheorem battle_level_bounds (level : Nat) :\n  let w : Warrior := ⟨0, []⟩\n  (level = 0 ∨ level > 100) →\n    w.battle level = \"Invalid level\" := sorry\n\ntheorem experience_cap (exp_gain : Nat) (h : exp_gain > 0 ∧ exp_gain ≤ 100) :\n  let w : Warrior := ⟨10000, []⟩\n  w.experience = 10000 := sorry\n\ntheorem rank_progression (exp : Nat) (h : exp < 10000) :\n  let w : Warrior := ⟨exp, []⟩\n  let ranks := [\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \n                \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"]\n  have h' : min 10 (exp / 1000) < 11 := by\n    exact Nat.lt_succ_of_le (Nat.min_le_left 10 (exp / 1000))\n  w.rank = ranks[min 10 (exp / 1000)]'h' := sorry\n\ntheorem battle_outcomes (level : Nat) (h : level > 0 ∧ level ≤ 100) :\n  let w : Warrior := ⟨0, []⟩\n  w.battle level ∈ [\"A good fight\", \"An intense fight\", \n                    \"Easy fight\", \"You've been defeated\"] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1710"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nLet's say you have a bunch of points, and you want to round them all up and calculate the area of the smallest polygon containing all of the points (nevermind why, you just want a challenge). What you're looking for is the area of the *convex hull* of these points. Here is an example, delimited in blue :\n\n\n\n## Your task\n\nImplement a function that will compute the area covered by the convex hull that can be formed from an array of points, the area being rounded to two decimal places. The points are given as `(x,y)`, like in an orthonormal coordinates system.\n\n```python\npoints = [(0, 0), (0, 3), (4, 0)]\nconvex_hull_area(points) == 6.00\n```\n\n*Note* : In Python, the scipy module has a [ready made solution](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html) for this. Of course, if you use it here, you are lame.\n\n*P. S.* : If you enjoy this kata, you may also like this one, which asks you to compute a convex hull, without finding its area.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Point := Float × Float\n\ndef convex_hull_area (points : List Point) : Float :=\n  sorry\n\ntheorem convex_hull_area_non_negative (points : List Point) :\n  convex_hull_area points ≥ 0 :=\nsorry\n\ntheorem convex_hull_area_less_than_three_points (points : List Point) :\n  points.length < 3 → convex_hull_area points = 0 :=\nsorry\n\ntheorem convex_hull_area_permutation_invariant {points perm : List Point} :\n  points.length > 0 →\n  points.Perm perm →\n  convex_hull_area points = convex_hull_area perm :=\nsorry\n\ndef is_internal_point (p : Point) (points : List Point) : Prop :=\n  sorry\n\ntheorem convex_hull_area_internal_points {points : List Point} {p : Point} :\n  points.length ≥ 3 →\n  is_internal_point p points →\n  convex_hull_area (p::points) = convex_hull_area points :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1786", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nLet's say you have a bunch of points, and you want to round them all up and calculate the area of the smallest polygon containing all of the points (nevermind why, you just want a challenge). What you're looking for is the area of the *convex hull* of these points. Here is an example, delimited in blue :\n\n\n\n## Your task\n\nImplement a function that will compute the area covered by the convex hull that can be formed from an array of points, the area being rounded to two decimal places. The points are given as `(x,y)`, like in an orthonormal coordinates system.\n\n```python\npoints = [(0, 0), (0, 3), (4, 0)]\nconvex_hull_area(points) == 6.00\n```\n\n*Note* : In Python, the scipy module has a [ready made solution](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html) for this. Of course, if you use it here, you are lame.\n\n*P. S.* : If you enjoy this kata, you may also like this one, which asks you to compute a convex hull, without finding its area.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Point := Float × Float\n\ndef convex_hull_area (points : List Point) : Float :=\n  sorry\n\ntheorem convex_hull_area_non_negative (points : List Point) :\n  convex_hull_area points ≥ 0 :=\nsorry\n\ntheorem convex_hull_area_less_than_three_points (points : List Point) :\n  points.length < 3 → convex_hull_area points = 0 :=\nsorry\n\ntheorem convex_hull_area_permutation_invariant {points perm : List Point} :\n  points.length > 0 →\n  points.Perm perm →\n  convex_hull_area points = convex_hull_area perm :=\nsorry\n\ndef is_internal_point (p : Point) (points : List Point) : Prop :=\n  sorry\n\ntheorem convex_hull_area_internal_points {points : List Point} {p : Point} :\n  points.length ≥ 3 →\n  is_internal_point p points →\n  convex_hull_area (p::points) = convex_hull_area points :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1786"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThe prime `149` has 3 permutations which are also primes: `419`, `491` and `941`.\n\nThere are 3 primes below `1000` with three prime permutations:\n```python\n149 ==> 419 ==> 491 ==> 941\n179 ==> 197 ==> 719 ==> 971\n379 ==> 397 ==> 739 ==> 937\n```\n\nBut there are 9 primes below `1000` with two prime permutations:\n```python\n113 ==> 131 ==> 311\n137 ==> 173 ==> 317\n157 ==> 571 ==> 751\n163 ==> 613 ==> 631\n167 ==> 617 ==> 761\n199 ==> 919 ==> 991\n337 ==> 373 ==> 733\n359 ==> 593 ==> 953\n389 ==> 839 ==> 983\n```\n\nFinally, we can find 34 primes below `1000` with only one prime permutation: \n```python\n[13, 17, 37, 79, 107, 127, 139, 181, 191, 239, 241, 251, 277, 281, 283, 313, 347, 349, 367, 457, 461, 463, 467, 479, 563, 569, 577, 587, 619, 683, 709, 769, 787, 797]\n```\n\nEach set of permuted primes are represented by its smallest value, for example the set `149, 419, 491, 941` is represented by `149`, and the set has 3 permutations.\n\n**Notes**\n* the original number (`149` in the above example) is **not** counted as a permutation;\n* permutations with leading zeros are **not valid**\n\n## Your Task\n\nYour task is to create a function that takes two arguments:\n* an upper limit (`n_max`) and\n* the number of prime permutations (`k_perms`) that the primes should generate **below** `n_max`\n\nThe function should return the following three values as a list:\n* the number of permutational primes below the given limit,\n* the smallest prime such prime,\n* and the largest such prime\n\nIf no eligible primes were found below the limit, the output should be `[0, 0, 0]`\n\n## Examples\n\nLet's see how it would be with the previous cases:\n```python\npermutational_primes(1000, 3) ==> [3, 149, 379]\n''' 3 primes with 3 permutations below 1000, smallest: 149, largest: 379 '''\n\npermutational_primes(1000, 2) ==> [9, 113, 389]\n''' 9 primes with 2 permutations below 1000, smallest: 113, largest: 389 '''\n\npermutational_primes(1000, 1) ==> [34, 13, 797]\n''' 34 primes with 1 permutation below 1000, smallest: 13, largest: 797 '''\n```\n\nHappy coding!!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef permutational_primes (n_max k_perms : Nat) : List Nat := sorry\n\n-- Type signature property\ntheorem perm_primes_returns_three_nats (n_max k_perms : Nat) : \n  let result := permutational_primes n_max k_perms;\n  result.length = 3\n  ∧ result.all (λ x => x ≥ 0) := sorry\n\n-- Count non-negative property  \ntheorem perm_primes_count_nonneg (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n  (result.get! 0) ≥ 0 := sorry\n\n-- Zero count implies zero min/max property\ntheorem perm_primes_zero_count (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n  (result.get! 0 = 0) →\n  (result.get! 1 = 0 ∧ result.get! 2 = 0) := sorry\n\n-- Valid count implies valid min/max property  \ntheorem perm_primes_valid_bounds (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n  (result.get! 0 > 0) →\n  (result.get! 1 > 1 \n   ∧ result.get! 2 > 1\n   ∧ result.get! 1 ≤ result.get! 2\n   ∧ result.get! 1 < n_max\n   ∧ result.get! 2 < n_max) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1800", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThe prime `149` has 3 permutations which are also primes: `419`, `491` and `941`.\n\nThere are 3 primes below `1000` with three prime permutations:\n```python\n149 ==> 419 ==> 491 ==> 941\n179 ==> 197 ==> 719 ==> 971\n379 ==> 397 ==> 739 ==> 937\n```\n\nBut there are 9 primes below `1000` with two prime permutations:\n```python\n113 ==> 131 ==> 311\n137 ==> 173 ==> 317\n157 ==> 571 ==> 751\n163 ==> 613 ==> 631\n167 ==> 617 ==> 761\n199 ==> 919 ==> 991\n337 ==> 373 ==> 733\n359 ==> 593 ==> 953\n389 ==> 839 ==> 983\n```\n\nFinally, we can find 34 primes below `1000` with only one prime permutation: \n```python\n[13, 17, 37, 79, 107, 127, 139, 181, 191, 239, 241, 251, 277, 281, 283, 313, 347, 349, 367, 457, 461, 463, 467, 479, 563, 569, 577, 587, 619, 683, 709, 769, 787, 797]\n```\n\nEach set of permuted primes are represented by its smallest value, for example the set `149, 419, 491, 941` is represented by `149`, and the set has 3 permutations.\n\n**Notes**\n* the original number (`149` in the above example) is **not** counted as a permutation;\n* permutations with leading zeros are **not valid**\n\n## Your Task\n\nYour task is to create a function that takes two arguments:\n* an upper limit (`n_max`) and\n* the number of prime permutations (`k_perms`) that the primes should generate **below** `n_max`\n\nThe function should return the following three values as a list:\n* the number of permutational primes below the given limit,\n* the smallest prime such prime,\n* and the largest such prime\n\nIf no eligible primes were found below the limit, the output should be `[0, 0, 0]`\n\n## Examples\n\nLet's see how it would be with the previous cases:\n```python\npermutational_primes(1000, 3) ==> [3, 149, 379]\n''' 3 primes with 3 permutations below 1000, smallest: 149, largest: 379 '''\n\npermutational_primes(1000, 2) ==> [9, 113, 389]\n''' 9 primes with 2 permutations below 1000, smallest: 113, largest: 389 '''\n\npermutational_primes(1000, 1) ==> [34, 13, 797]\n''' 34 primes with 1 permutation below 1000, smallest: 13, largest: 797 '''\n```\n\nHappy coding!!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef permutational_primes (n_max k_perms : Nat) : List Nat := sorry\n\n-- Type signature property\ntheorem perm_primes_returns_three_nats (n_max k_perms : Nat) : \n  let result := permutational_primes n_max k_perms;\n  result.length = 3\n  ∧ result.all (λ x => x ≥ 0) := sorry\n\n-- Count non-negative property  \ntheorem perm_primes_count_nonneg (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n  (result.get! 0) ≥ 0 := sorry\n\n-- Zero count implies zero min/max property\ntheorem perm_primes_zero_count (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n  (result.get! 0 = 0) →\n  (result.get! 1 = 0 ∧ result.get! 2 = 0) := sorry\n\n-- Valid count implies valid min/max property  \ntheorem perm_primes_valid_bounds (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n  (result.get! 0 > 0) →\n  (result.get! 1 > 1 \n   ∧ result.get! 2 > 1\n   ∧ result.get! 1 ≤ result.get! 2\n   ∧ result.get! 1 < n_max\n   ∧ result.get! 2 < n_max) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1800"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. The fractions can be in any order.\n \nExample 1:\nInput: n = 2\nOutput: [\"1/2\"]\nExplanation: \"1/2\" is the only unique fraction with a denominator less-than-or-equal-to 2.\nExample 2:\nInput: n = 3\nOutput: [\"1/2\",\"1/3\",\"2/3\"]\n\nExample 3:\nInput: n = 4\nOutput: [\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\nExplanation: \"2/4\" is not a simplified fraction because it can be simplified to \"1/2\".\nExample 4:\nInput: n = 1\nOutput: []\n\n \nConstraints:\n\n1 <= n <= 100\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef gcd (a b : Nat) : Nat := sorry\n\ndef simplifiedFractions (n : Nat) : List String := sorry\n\nstructure Fraction where\n  num : Nat\n  denom : Nat\n\ndef stringToFraction (s : String) : Fraction := sorry\n\ntheorem fractions_are_valid {n : Nat} (h : n > 0) :\n  ∀ frac, frac ∈ simplifiedFractions n → \n    let f := stringToFraction frac\n    0 < f.num ∧ f.num < f.denom ∧ f.denom ≤ n ∧ gcd f.num f.denom = 1 := sorry\n\ntheorem fractions_are_unique {n : Nat} (h : n > 0) :\n  ∀ x y, x ∈ simplifiedFractions n → y ∈ simplifiedFractions n → \n    x = y → stringToFraction x = stringToFraction y := sorry\n\ntheorem all_simplified_fractions_included {n : Nat} (h : n > 0) :\n  ∀ i j : Nat, 1 ≤ i → i < j → j ≤ n → gcd i j = 1 →\n    ∃ frac, frac ∈ simplifiedFractions n ∧ stringToFraction frac = ⟨i, j⟩ := sorry\n\ntheorem empty_for_n_less_than_2 :\n  simplifiedFractions 1 = [] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1807", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. The fractions can be in any order.\n \nExample 1:\nInput: n = 2\nOutput: [\"1/2\"]\nExplanation: \"1/2\" is the only unique fraction with a denominator less-than-or-equal-to 2.\nExample 2:\nInput: n = 3\nOutput: [\"1/2\",\"1/3\",\"2/3\"]\n\nExample 3:\nInput: n = 4\nOutput: [\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\nExplanation: \"2/4\" is not a simplified fraction because it can be simplified to \"1/2\".\nExample 4:\nInput: n = 1\nOutput: []\n\n \nConstraints:\n\n1 <= n <= 100\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef gcd (a b : Nat) : Nat := sorry\n\ndef simplifiedFractions (n : Nat) : List String := sorry\n\nstructure Fraction where\n  num : Nat\n  denom : Nat\n\ndef stringToFraction (s : String) : Fraction := sorry\n\ntheorem fractions_are_valid {n : Nat} (h : n > 0) :\n  ∀ frac, frac ∈ simplifiedFractions n → \n    let f := stringToFraction frac\n    0 < f.num ∧ f.num < f.denom ∧ f.denom ≤ n ∧ gcd f.num f.denom = 1 := sorry\n\ntheorem fractions_are_unique {n : Nat} (h : n > 0) :\n  ∀ x y, x ∈ simplifiedFractions n → y ∈ simplifiedFractions n → \n    x = y → stringToFraction x = stringToFraction y := sorry\n\ntheorem all_simplified_fractions_included {n : Nat} (h : n > 0) :\n  ∀ i j : Nat, 1 ≤ i → i < j → j ≤ n → gcd i j = 1 →\n    ∃ frac, frac ∈ simplifiedFractions n ∧ stringToFraction frac = ⟨i, j⟩ := sorry\n\ntheorem empty_for_n_less_than_2 :\n  simplifiedFractions 1 = [] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1807"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].\nWe want to place these books in order onto bookcase shelves that have total width shelf_width.\nWe choose some of the books to place on this shelf (such that the sum of their thickness is <= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.  We repeat this process until there are no more books to place.\nNote again that at each step of the above process, the order of the books we place is the same order as the given sequence of books.  For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\nReturn the minimum possible height that the total bookshelf can be after placing shelves in this manner.\n \nExample 1:\n\nInput: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4\nOutput: 6\nExplanation:\nThe sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n \nConstraints:\n\n1 <= books.length <= 1000\n1 <= books[i][0] <= shelf_width <= 1000\n1 <= books[i][1] <= 1000\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Book where\n  width : Nat\n  height : Nat\nderiving Repr\n\nabbrev Books := List Book\nabbrev ShelfWidth := Nat\n\ninstance : OfNat ShelfWidth n where\n  ofNat := n\n\ninstance : Add ShelfWidth where\n  add := Nat.add\n\ndef min_height_shelves (books : Books) (width : ShelfWidth) : Nat :=\n  sorry\n\ntheorem min_height_lower_bound_tallest (books : Books) (width : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : width > 0) :\n  min_height_shelves books width ≥ books.foldl (λ acc b => max acc b.height) 0 :=\nsorry\n\ntheorem min_height_width_one_lower_bound (books : Books)\n  (h1 : books.length > 0)\n  (h2 : width = 1) :\n  min_height_shelves books 1 ≥ books.foldl (λ acc b => acc + b.height) 0 :=\nsorry\n\ntheorem min_height_upper_bound (books : Books) (width : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : width > 0) :\n  min_height_shelves books width ≤ books.foldl (λ acc b => acc + b.height) 0 :=\nsorry\n\ntheorem min_height_monotonic_width (books : Books) (w1 w2 : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : w1 > 0)\n  (h3 : w2 = w1 + 1) :\n  min_height_shelves books w2 ≤ min_height_shelves books w1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1813", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].\nWe want to place these books in order onto bookcase shelves that have total width shelf_width.\nWe choose some of the books to place on this shelf (such that the sum of their thickness is <= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.  We repeat this process until there are no more books to place.\nNote again that at each step of the above process, the order of the books we place is the same order as the given sequence of books.  For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\nReturn the minimum possible height that the total bookshelf can be after placing shelves in this manner.\n \nExample 1:\n\nInput: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4\nOutput: 6\nExplanation:\nThe sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n \nConstraints:\n\n1 <= books.length <= 1000\n1 <= books[i][0] <= shelf_width <= 1000\n1 <= books[i][1] <= 1000\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Book where\n  width : Nat\n  height : Nat\nderiving Repr\n\nabbrev Books := List Book\nabbrev ShelfWidth := Nat\n\ninstance : OfNat ShelfWidth n where\n  ofNat := n\n\ninstance : Add ShelfWidth where\n  add := Nat.add\n\ndef min_height_shelves (books : Books) (width : ShelfWidth) : Nat :=\n  sorry\n\ntheorem min_height_lower_bound_tallest (books : Books) (width : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : width > 0) :\n  min_height_shelves books width ≥ books.foldl (λ acc b => max acc b.height) 0 :=\nsorry\n\ntheorem min_height_width_one_lower_bound (books : Books)\n  (h1 : books.length > 0)\n  (h2 : width = 1) :\n  min_height_shelves books 1 ≥ books.foldl (λ acc b => acc + b.height) 0 :=\nsorry\n\ntheorem min_height_upper_bound (books : Books) (width : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : width > 0) :\n  min_height_shelves books width ≤ books.foldl (λ acc b => acc + b.height) 0 :=\nsorry\n\ntheorem min_height_monotonic_width (books : Books) (w1 w2 : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : w1 > 0)\n  (h3 : w2 = w1 + 1) :\n  min_height_shelves books w2 ≤ min_height_shelves books w1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1813"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].\nRearrange the barcodes so that no two adjacent barcodes are equal.  You may return any answer, and it is guaranteed an answer exists.\n \nExample 1:\nInput: [1,1,1,2,2,2]\nOutput: [2,1,2,1,2,1]\n\n\nExample 2:\nInput: [1,1,1,1,2,2,3,3]\nOutput: [1,3,1,3,2,1,2,1]\n\n \nNote:\n\n1 <= barcodes.length <= 10000\n1 <= barcodes[i] <= 10000\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef rearrange_barcodes (barcodes: List Int) : List Int := sorry\n\ndef validate_solution (barcodes: List Int) : Bool := sorry\n\ntheorem single_element {n : Int} : \n  rearrange_barcodes [n] = [n] := sorry\n\ntheorem unique_elements_length {xs : List Int} (h: xs.length ≥ 2) :\n  (rearrange_barcodes xs).length = xs.length := sorry\n\ntheorem unique_elements_same_elements {xs ys : List Int} (h: xs.length ≥ 2) :\n  (rearrange_barcodes xs = ys) → List.length xs = List.length ys ∧ \n  ∀ (x : Int), List.contains xs x = List.contains ys x := sorry\n\ntheorem unique_elements_valid {xs : List Int} (h: xs.length ≥ 2) :\n  validate_solution (rearrange_barcodes xs) = true := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1828", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].\nRearrange the barcodes so that no two adjacent barcodes are equal.  You may return any answer, and it is guaranteed an answer exists.\n \nExample 1:\nInput: [1,1,1,2,2,2]\nOutput: [2,1,2,1,2,1]\n\n\nExample 2:\nInput: [1,1,1,1,2,2,3,3]\nOutput: [1,3,1,3,2,1,2,1]\n\n \nNote:\n\n1 <= barcodes.length <= 10000\n1 <= barcodes[i] <= 10000\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef rearrange_barcodes (barcodes: List Int) : List Int := sorry\n\ndef validate_solution (barcodes: List Int) : Bool := sorry\n\ntheorem single_element {n : Int} : \n  rearrange_barcodes [n] = [n] := sorry\n\ntheorem unique_elements_length {xs : List Int} (h: xs.length ≥ 2) :\n  (rearrange_barcodes xs).length = xs.length := sorry\n\ntheorem unique_elements_same_elements {xs ys : List Int} (h: xs.length ≥ 2) :\n  (rearrange_barcodes xs = ys) → List.length xs = List.length ys ∧ \n  ∀ (x : Int), List.contains xs x = List.contains ys x := sorry\n\ntheorem unique_elements_valid {xs : List Int} (h: xs.length ≥ 2) :\n  validate_solution (rearrange_barcodes xs) = true := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1828"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nA move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).\n\nGiven a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False.\n\n\nExamples:\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: True\nExplanation:\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: False\n\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: True\n\n\n\nNote:\n\n\n       sx, sy, tx, ty will all be integers in the range [1, 10^9].\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_transform_point (sx sy tx ty : Nat) : Bool := sorry \n\ntheorem same_point_always_true {sx sy : Nat} : \n  can_transform_point sx sy sx sy = true := sorry\n\ntheorem target_less_than_start_always_false {sx sy tx ty : Nat} :\n  (tx < sx ∨ ty < sy) → can_transform_point sx sy tx ty = false := sorry\n\ntheorem no_valid_moves_if_too_far {sx sy tx ty : Nat} :\n  (sx > tx ∧ sy > ty) → can_transform_point sx sy tx ty = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1838", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nA move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).\n\nGiven a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False.\n\n\nExamples:\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: True\nExplanation:\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: False\n\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: True\n\n\n\nNote:\n\n\n       sx, sy, tx, ty will all be integers in the range [1, 10^9].\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef can_transform_point (sx sy tx ty : Nat) : Bool := sorry \n\ntheorem same_point_always_true {sx sy : Nat} : \n  can_transform_point sx sy sx sy = true := sorry\n\ntheorem target_less_than_start_always_false {sx sy tx ty : Nat} :\n  (tx < sx ∨ ty < sy) → can_transform_point sx sy tx ty = false := sorry\n\ntheorem no_valid_moves_if_too_far {sx sy tx ty : Nat} :\n  (sx > tx ∧ sy > ty) → can_transform_point sx sy tx ty = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1838"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\nExample 1:\n\n\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n\nExample 2:\n\n\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n\n\nFollow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive TreeNode where\n  | mk : Int → Option TreeNode → Option TreeNode → TreeNode\n  deriving Repr\n\ndef kthSmallest (root : TreeNode) (k : Nat) : Int := sorry\n\ndef getSortedValues (root : TreeNode) : List Int := sorry\n\n-- Main theorem for kth smallest element matching sorted list\ntheorem kth_smallest_matches_sorted\n  {root : TreeNode} {vals : List Int} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k ≤ vals.length)\n  (h3 : vals = getSortedValues root) :\n  kthSmallest root k = vals[k-1] := sorry\n\n-- Theorem for sorted property of values\ntheorem sorted_values_ordered\n  {root : TreeNode} {vals : List Int}\n  (h : vals = getSortedValues root)\n  {i : Nat} (hi : i < vals.length - 1) :\n  vals[i] ≤ vals[i+1] := sorry\n\n-- Edge case theorems\ntheorem single_node_kth_smallest\n  {n : Int} (root : TreeNode)\n  (h1 : root = TreeNode.mk n none none) :\n  kthSmallest root 1 = n := sorry\n\ntheorem linear_left_tree_first_element\n  (root : TreeNode)\n  (h1 : root = TreeNode.mk 3 (some (TreeNode.mk 2 (some (TreeNode.mk 1 none none)) none)) none) :\n  kthSmallest root 1 = 1 := sorry\n\ntheorem linear_right_tree_last_element\n  (root : TreeNode)\n  (h1 : root = TreeNode.mk 1 none (some (TreeNode.mk 2 none (some (TreeNode.mk 3 none none))))) :\n  kthSmallest root 3 = 3 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1867", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\nExample 1:\n\n\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n\nExample 2:\n\n\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n\n\nFollow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive TreeNode where\n  | mk : Int → Option TreeNode → Option TreeNode → TreeNode\n  deriving Repr\n\ndef kthSmallest (root : TreeNode) (k : Nat) : Int := sorry\n\ndef getSortedValues (root : TreeNode) : List Int := sorry\n\n-- Main theorem for kth smallest element matching sorted list\ntheorem kth_smallest_matches_sorted\n  {root : TreeNode} {vals : List Int} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k ≤ vals.length)\n  (h3 : vals = getSortedValues root) :\n  kthSmallest root k = vals[k-1] := sorry\n\n-- Theorem for sorted property of values\ntheorem sorted_values_ordered\n  {root : TreeNode} {vals : List Int}\n  (h : vals = getSortedValues root)\n  {i : Nat} (hi : i < vals.length - 1) :\n  vals[i] ≤ vals[i+1] := sorry\n\n-- Edge case theorems\ntheorem single_node_kth_smallest\n  {n : Int} (root : TreeNode)\n  (h1 : root = TreeNode.mk n none none) :\n  kthSmallest root 1 = n := sorry\n\ntheorem linear_left_tree_first_element\n  (root : TreeNode)\n  (h1 : root = TreeNode.mk 3 (some (TreeNode.mk 2 (some (TreeNode.mk 1 none none)) none)) none) :\n  kthSmallest root 1 = 1 := sorry\n\ntheorem linear_right_tree_last_element\n  (root : TreeNode)\n  (h1 : root = TreeNode.mk 1 none (some (TreeNode.mk 2 none (some (TreeNode.mk 3 none none))))) :\n  kthSmallest root 3 = 3 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1867"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nLet f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\n\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\n\n\nExample 1:\nInput: K = 0\nOutput: 5\nExplanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.\n\nExample 2:\nInput: K = 5\nOutput: 0\nExplanation: There is no x such that x! ends in K = 5 zeroes.\n\n\nNote:\n\n\n       K will be an integer in the range [0, 10^9].\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_factorial_zeros (n : Nat) : Nat := sorry\n\ndef count_actual_zeros (n : Nat) : Nat := sorry\n\ntheorem count_factorial_zeros_non_negative (k : Nat) : \n  count_factorial_zeros k ≥ 0 := sorry\n\ntheorem count_factorial_zeros_zero_case : \n  count_factorial_zeros 0 = 5 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1873", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nLet f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\n\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\n\n\nExample 1:\nInput: K = 0\nOutput: 5\nExplanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.\n\nExample 2:\nInput: K = 5\nOutput: 0\nExplanation: There is no x such that x! ends in K = 5 zeroes.\n\n\nNote:\n\n\n       K will be an integer in the range [0, 10^9].\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_factorial_zeros (n : Nat) : Nat := sorry\n\ndef count_actual_zeros (n : Nat) : Nat := sorry\n\ntheorem count_factorial_zeros_non_negative (k : Nat) : \n  count_factorial_zeros k ≥ 0 := sorry\n\ntheorem count_factorial_zeros_zero_case : \n  count_factorial_zeros 0 = 5 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1873"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe are given an elevation map, heights[i] representing the height of the terrain at that index.  The width at each index is 1.  After V units of water fall at index K, how much water is at each index?\n\nWater first drops at index K and rests on top of the highest terrain or water at that index.  Then, it flows according to the following rules:\nIf the droplet would eventually fall by moving left, then move left.\nOtherwise, if the droplet would eventually fall by moving right, then move right.\nOtherwise, rise at it's current position.\nHere, \"eventually fall\" means that the droplet will eventually be at a lower level if it moves in that direction.\nAlso, \"level\" means the height of the terrain plus any water in that column.\n\nWe can assume there's infinitely high terrain on the two sides out of bounds of the array.  Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.\n\n\nExample 1:\n\nInput: heights = [2,1,1,2,1,2,2], V = 4, K = 3\nOutput: [2,2,2,3,2,2,2]\nExplanation:\n#       #\n#       #\n##  # ###\n#########\n 0123456    \n\n\nExample 2:\n\nInput: heights = [1,2,3,4], V = 2, K = 2\nOutput: [2,3,3,4]\nExplanation:\nThe last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.\n\n\n\nExample 3:\n\nInput: heights = [3,1,3], V = 5, K = 1\nOutput: [4,4,4]\n\n\n\nNote:\nheights will have length in [1, 100] and contain integers in [0, 99].\nV will be in range [0, 2000].\nK will be in range [0, heights.length - 1].\n```\n#####\n\nTo answer this question, you need to replace the 11 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef pour_water (heights : List Nat) (V : Nat) (K : Nat) : List Nat :=\n  sorry\n\ntheorem pour_water_result_length {heights : List Nat} {V K : Nat} \n  (h : K < heights.length) :\n  (pour_water heights V K).length = heights.length :=\n  sorry\n\ntheorem pour_water_total_water_added {heights : List Nat} {V K : Nat}\n  (h : K < heights.length) :\n  (pour_water heights V K).foldl (· + ·) 0 - heights.foldl (· + ·) 0 = V :=\n  sorry\n\ntheorem pour_water_heights_never_decrease {heights : List Nat} {V K : Nat}\n  (h : K < heights.length) :\n  List.zip (pour_water heights V K) heights\n  |>.all (fun p => p.1 ≥ p.2) := \n  sorry\n\ntheorem pour_water_water_trapped {heights : List Nat} {V K : Nat} \n  (h : K < heights.length)\n  (i : Nat)\n  (hi : i > 0 ∧ i < (heights.length - 1))\n  (hw : (pour_water heights V K).get ⟨i, sorry⟩ > heights.get ⟨i, sorry⟩) :\n  ((pour_water heights V K).get ⟨i-1, sorry⟩ ≥ (pour_water heights V K).get ⟨i, sorry⟩) ∨\n  ((pour_water heights V K).get ⟨i+1, sorry⟩ ≥ (pour_water heights V K).get ⟨i, sorry⟩) :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1876", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe are given an elevation map, heights[i] representing the height of the terrain at that index.  The width at each index is 1.  After V units of water fall at index K, how much water is at each index?\n\nWater first drops at index K and rests on top of the highest terrain or water at that index.  Then, it flows according to the following rules:\nIf the droplet would eventually fall by moving left, then move left.\nOtherwise, if the droplet would eventually fall by moving right, then move right.\nOtherwise, rise at it's current position.\nHere, \"eventually fall\" means that the droplet will eventually be at a lower level if it moves in that direction.\nAlso, \"level\" means the height of the terrain plus any water in that column.\n\nWe can assume there's infinitely high terrain on the two sides out of bounds of the array.  Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.\n\n\nExample 1:\n\nInput: heights = [2,1,1,2,1,2,2], V = 4, K = 3\nOutput: [2,2,2,3,2,2,2]\nExplanation:\n#       #\n#       #\n##  # ###\n#########\n 0123456    \n\n\nExample 2:\n\nInput: heights = [1,2,3,4], V = 2, K = 2\nOutput: [2,3,3,4]\nExplanation:\nThe last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.\n\n\n\nExample 3:\n\nInput: heights = [3,1,3], V = 5, K = 1\nOutput: [4,4,4]\n\n\n\nNote:\nheights will have length in [1, 100] and contain integers in [0, 99].\nV will be in range [0, 2000].\nK will be in range [0, heights.length - 1].\n```\n#####\n\nTo answer this question, you need to replace the 11 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef pour_water (heights : List Nat) (V : Nat) (K : Nat) : List Nat :=\n  sorry\n\ntheorem pour_water_result_length {heights : List Nat} {V K : Nat} \n  (h : K < heights.length) :\n  (pour_water heights V K).length = heights.length :=\n  sorry\n\ntheorem pour_water_total_water_added {heights : List Nat} {V K : Nat}\n  (h : K < heights.length) :\n  (pour_water heights V K).foldl (· + ·) 0 - heights.foldl (· + ·) 0 = V :=\n  sorry\n\ntheorem pour_water_heights_never_decrease {heights : List Nat} {V K : Nat}\n  (h : K < heights.length) :\n  List.zip (pour_water heights V K) heights\n  |>.all (fun p => p.1 ≥ p.2) := \n  sorry\n\ntheorem pour_water_water_trapped {heights : List Nat} {V K : Nat} \n  (h : K < heights.length)\n  (i : Nat)\n  (hi : i > 0 ∧ i < (heights.length - 1))\n  (hw : (pour_water heights V K).get ⟨i, sorry⟩ > heights.get ⟨i, sorry⟩) :\n  ((pour_water heights V K).get ⟨i-1, sorry⟩ ≥ (pour_water heights V K).get ⟨i, sorry⟩) ∨\n  ((pour_water heights V K).get ⟨i+1, sorry⟩ ≥ (pour_water heights V K).get ⟨i, sorry⟩) :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1876"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe are given a list schedule of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping Intervals, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing common, positive-length free time for all employees, also in sorted order.\n\n\nExample 1:\n\nInput: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\nOutput: [[3,4]]\nExplanation:\nThere are a total of three employees, and all common\nfree time intervals would be [-inf, 1], [3, 4], [10, inf].\nWe discard any intervals that contain inf as they aren't finite.\n\n\nExample 2:\n\nInput: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]\nOutput: [[5,6],[7,9]]\n\n\n\n\n(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays.  For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined.)\n\nAlso, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.\n\n\nNote:\nschedule and schedule[i] are lists with lengths in range [1, 50].\n0 .\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Interval where\n  start : Int\n  finish : Int\n  deriving Repr\n\ninstance : Inhabited Interval where\n  default := { start := 0, finish := 1 }\n\ndef employeeFreeTime (schedule : List (List Interval)) : List Interval :=\n  sorry\n\nvariable (schedule : List (List Interval))\nvariable (result : List Interval := employeeFreeTime schedule)\nvariable (allIntervals : List Interval := schedule.join)\n\ntheorem free_time_sorted : \n  ∀ i : Nat, i + 1 < result.length → \n  (result[i]!).finish < (result[i+1]!).start :=\n  sorry\n\ntheorem no_overlap_with_work :\n  ∀ free work : Interval, \n  free ∈ result → work ∈ allIntervals → \n  ¬(free.start < work.finish ∧ work.start < free.finish) :=\n  sorry\n\ntheorem valid_interval_bounds :\n  ∀ i : Interval, i ∈ result → i.start < i.finish :=\n  sorry\n \ntheorem continuous_work_valid_bounds (raw_times : List (List Int)) :\n  let schedule := raw_times.map (λ times => times.map (λ t => { start := t, finish := t+1 }))\n  let result := employeeFreeTime schedule\n  ∀ i : Interval, i ∈ result → i.start < i.finish :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1881", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe are given a list schedule of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping Intervals, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing common, positive-length free time for all employees, also in sorted order.\n\n\nExample 1:\n\nInput: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\nOutput: [[3,4]]\nExplanation:\nThere are a total of three employees, and all common\nfree time intervals would be [-inf, 1], [3, 4], [10, inf].\nWe discard any intervals that contain inf as they aren't finite.\n\n\nExample 2:\n\nInput: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]\nOutput: [[5,6],[7,9]]\n\n\n\n\n(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays.  For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined.)\n\nAlso, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.\n\n\nNote:\nschedule and schedule[i] are lists with lengths in range [1, 50].\n0 .\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Interval where\n  start : Int\n  finish : Int\n  deriving Repr\n\ninstance : Inhabited Interval where\n  default := { start := 0, finish := 1 }\n\ndef employeeFreeTime (schedule : List (List Interval)) : List Interval :=\n  sorry\n\nvariable (schedule : List (List Interval))\nvariable (result : List Interval := employeeFreeTime schedule)\nvariable (allIntervals : List Interval := schedule.join)\n\ntheorem free_time_sorted : \n  ∀ i : Nat, i + 1 < result.length → \n  (result[i]!).finish < (result[i+1]!).start :=\n  sorry\n\ntheorem no_overlap_with_work :\n  ∀ free work : Interval, \n  free ∈ result → work ∈ allIntervals → \n  ¬(free.start < work.finish ∧ work.start < free.finish) :=\n  sorry\n\ntheorem valid_interval_bounds :\n  ∀ i : Interval, i ∈ result → i.start < i.finish :=\n  sorry\n \ntheorem continuous_work_valid_bounds (raw_times : List (List Int)) :\n  let schedule := raw_times.map (λ times => times.map (λ t => { start := t, finish := t+1 }))\n  let result := employeeFreeTime schedule\n  ∀ i : Interval, i ∈ result → i.start < i.finish :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1881"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nOn a 2-dimensional grid, there are 4 types of squares:\n\n1 represents the starting square.  There is exactly one starting square.\n2 represents the ending square.  There is exactly one ending square.\n0 represents empty squares we can walk over.\n-1 represents obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n \n\nExample 1:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\nInput: [[0,1],[2,0]]\nOutput: 0\nExplanation: \nThere is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n\n\n\n \nNote:\n\n1 <= grid.length * grid[0].length <= 20\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef unique_paths_covering_all_squares (grid : List (List Int)) : Int :=\nsorry\n\n-- Different grid dimensions produce valid output\ntheorem valid_dims_produce_valid_output {rows cols : Nat} \n  (h1 : rows > 0) (h2 : cols > 0) (h3 : rows ≤ 5) (h4 : cols ≤ 5) :\n  let grid := List.replicate rows (List.replicate cols 0)\n  -- assuming we can place start/end points at (0,0) and (rows-1,cols-1)\n  unique_paths_covering_all_squares grid ≥ 0 := \nsorry\n\n-- Valid grids produce natural number outputs\ntheorem valid_grid_produces_nat_output (grid : List (List Int))\n  (h : ∀ row ∈ grid, ∀ cell ∈ row, cell ∈ [-1, 0, 1, 2]) :\n  unique_paths_covering_all_squares grid ≥ 0 :=\nsorry\n\n-- Adjacent start/end has exactly one path\ntheorem adjacent_start_end_one_path :\n  unique_paths_covering_all_squares [[1,2]] = 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1883", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nOn a 2-dimensional grid, there are 4 types of squares:\n\n1 represents the starting square.  There is exactly one starting square.\n2 represents the ending square.  There is exactly one ending square.\n0 represents empty squares we can walk over.\n-1 represents obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n \n\nExample 1:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\nInput: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\nInput: [[0,1],[2,0]]\nOutput: 0\nExplanation: \nThere is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n\n\n\n \nNote:\n\n1 <= grid.length * grid[0].length <= 20\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef unique_paths_covering_all_squares (grid : List (List Int)) : Int :=\nsorry\n\n-- Different grid dimensions produce valid output\ntheorem valid_dims_produce_valid_output {rows cols : Nat} \n  (h1 : rows > 0) (h2 : cols > 0) (h3 : rows ≤ 5) (h4 : cols ≤ 5) :\n  let grid := List.replicate rows (List.replicate cols 0)\n  -- assuming we can place start/end points at (0,0) and (rows-1,cols-1)\n  unique_paths_covering_all_squares grid ≥ 0 := \nsorry\n\n-- Valid grids produce natural number outputs\ntheorem valid_grid_produces_nat_output (grid : List (List Int))\n  (h : ∀ row ∈ grid, ∀ cell ∈ row, cell ∈ [-1, 0, 1, 2]) :\n  unique_paths_covering_all_squares grid ≥ 0 :=\nsorry\n\n-- Adjacent start/end has exactly one path\ntheorem adjacent_start_end_one_path :\n  unique_paths_covering_all_squares [[1,2]] = 1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1883"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.\n \nExample 1:\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 9\n\nExample 2:\nInput: grid = [[1,1,0,0]]\nOutput: 1\n\n \nConstraints:\n\n1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef largest1BorderedSquare (grid : List (List Nat)) : Nat := sorry\n\ntheorem all_zeros (n : Nat) (h : n ≥ 1) : \n  let grid := List.replicate n (List.replicate n 0)\n  largest1BorderedSquare grid = 0 := sorry\n\ntheorem all_ones (n : Nat) (h : n ≥ 1) :\n  let grid := List.replicate n (List.replicate n 1) \n  largest1BorderedSquare grid = n * n := sorry\n\ntheorem perfect_square_2x2 (grid : List (List Nat)) \n  (h1 : grid.length = 2)\n  (h2 : ∀ row ∈ grid, row.length = 2)\n  (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  let result := largest1BorderedSquare grid\n  result * result = result := sorry\n\ntheorem bounds_3x3 (grid : List (List Nat))\n  (h1 : grid.length = 3)\n  (h2 : ∀ row ∈ grid, row.length = 3)\n  (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  let result := largest1BorderedSquare grid\n  let maxPossible := (min grid.length (grid.head?.getD []).length) ^ 2\n  0 ≤ result ∧ result ≤ maxPossible := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1909", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.\n \nExample 1:\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 9\n\nExample 2:\nInput: grid = [[1,1,0,0]]\nOutput: 1\n\n \nConstraints:\n\n1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef largest1BorderedSquare (grid : List (List Nat)) : Nat := sorry\n\ntheorem all_zeros (n : Nat) (h : n ≥ 1) : \n  let grid := List.replicate n (List.replicate n 0)\n  largest1BorderedSquare grid = 0 := sorry\n\ntheorem all_ones (n : Nat) (h : n ≥ 1) :\n  let grid := List.replicate n (List.replicate n 1) \n  largest1BorderedSquare grid = n * n := sorry\n\ntheorem perfect_square_2x2 (grid : List (List Nat)) \n  (h1 : grid.length = 2)\n  (h2 : ∀ row ∈ grid, row.length = 2)\n  (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  let result := largest1BorderedSquare grid\n  result * result = result := sorry\n\ntheorem bounds_3x3 (grid : List (List Nat))\n  (h1 : grid.length = 3)\n  (h2 : ∀ row ∈ grid, row.length = 3)\n  (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  let result := largest1BorderedSquare grid\n  let maxPossible := (min grid.length (grid.head?.getD []).length) ^ 2\n  0 ≤ result ∧ result ≤ maxPossible := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1909"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.\nImplement the DinnerPlates class:\n\nDinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks.\nvoid push(int val) Pushes the given positive integer val into the leftmost stack with size less than capacity.\nint pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all stacks are empty.\nint popAtStack(int index) Returns the value at the top of the stack with the given index and removes it from that stack, and returns -1 if the stack with that given index is empty.\n\nExample:\nInput: \n[\"DinnerPlates\",\"push\",\"push\",\"push\",\"push\",\"push\",\"popAtStack\",\"push\",\"push\",\"popAtStack\",\"popAtStack\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]\nOutput: \n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]\n\nExplanation: \nDinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // The stacks are now:  2  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                       1  3  5\n                                                       ﹈ ﹈ ﹈\nD.push(20);        // The stacks are now: 20  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.push(21);        // The stacks are now: 20  4 21\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈\nD.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈ \nD.pop()            // Returns 5.  The stacks are now:      4\n                                                        1  3 \n                                                        ﹈ ﹈  \nD.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                        ﹈ ﹈   \nD.pop()            // Returns 3.  The stacks are now:   1 \n                                                        ﹈   \nD.pop()            // Returns 1.  There are no stacks.\nD.pop()            // Returns -1.  There are still no stacks.\n\n \nConstraints:\n\n1 <= capacity <= 20000\n1 <= val <= 20000\n0 <= index <= 100000\nAt most 200000 calls will be made to push, pop, and popAtStack.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nclass DinnerPlates (α : Type) where\n  push : α → Unit\n  pop : Option α  \n  popAtStack : Nat → Option α\n  stacks : List (List α)\n  capacity : Nat\n\ntheorem test_empty_pop {α : Type} (plates : DinnerPlates α) (cap : Nat)\n    (h : cap > 0) (h2 : cap ≤ 100) :\n    plates.pop = none := sorry\n\ntheorem test_push_pop_sequence {α : Type} (plates : DinnerPlates α) \n    (cap : Nat) (values : List α)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length > 0) (h4 : values.length ≤ 20) :\n    ∀ v ∈ values, plates.pop = some v ∨ plates.pop = none := sorry\n\ntheorem test_pop_at_stack {α : Type} (plates : DinnerPlates α)\n    (cap : Nat) (values : List α) (stackIdx : Nat)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length > 0) \n    (h4 : values.length ≤ 20) (h5 : stackIdx ≤ 5) :\n    plates.stacks ≠ [] →\n    ∃ v, plates.popAtStack stackIdx = some v ∧ v ∈ values ∨ plates.popAtStack stackIdx = none := sorry\n\ntheorem test_sequential_operations {α : Type} (plates : DinnerPlates α)\n    (cap : Nat) (values : List α)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length ≤ 20) :\n    values.length > 2 →\n    ∃ v, plates.pop = some v ∧ v ∈ values ∨ plates.pop = none := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1921", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.\nImplement the DinnerPlates class:\n\nDinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks.\nvoid push(int val) Pushes the given positive integer val into the leftmost stack with size less than capacity.\nint pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all stacks are empty.\nint popAtStack(int index) Returns the value at the top of the stack with the given index and removes it from that stack, and returns -1 if the stack with that given index is empty.\n\nExample:\nInput: \n[\"DinnerPlates\",\"push\",\"push\",\"push\",\"push\",\"push\",\"popAtStack\",\"push\",\"push\",\"popAtStack\",\"popAtStack\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]\nOutput: \n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]\n\nExplanation: \nDinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // The stacks are now:  2  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                       1  3  5\n                                                       ﹈ ﹈ ﹈\nD.push(20);        // The stacks are now: 20  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.push(21);        // The stacks are now: 20  4 21\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈\nD.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈ \nD.pop()            // Returns 5.  The stacks are now:      4\n                                                        1  3 \n                                                        ﹈ ﹈  \nD.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                        ﹈ ﹈   \nD.pop()            // Returns 3.  The stacks are now:   1 \n                                                        ﹈   \nD.pop()            // Returns 1.  There are no stacks.\nD.pop()            // Returns -1.  There are still no stacks.\n\n \nConstraints:\n\n1 <= capacity <= 20000\n1 <= val <= 20000\n0 <= index <= 100000\nAt most 200000 calls will be made to push, pop, and popAtStack.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nclass DinnerPlates (α : Type) where\n  push : α → Unit\n  pop : Option α  \n  popAtStack : Nat → Option α\n  stacks : List (List α)\n  capacity : Nat\n\ntheorem test_empty_pop {α : Type} (plates : DinnerPlates α) (cap : Nat)\n    (h : cap > 0) (h2 : cap ≤ 100) :\n    plates.pop = none := sorry\n\ntheorem test_push_pop_sequence {α : Type} (plates : DinnerPlates α) \n    (cap : Nat) (values : List α)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length > 0) (h4 : values.length ≤ 20) :\n    ∀ v ∈ values, plates.pop = some v ∨ plates.pop = none := sorry\n\ntheorem test_pop_at_stack {α : Type} (plates : DinnerPlates α)\n    (cap : Nat) (values : List α) (stackIdx : Nat)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length > 0) \n    (h4 : values.length ≤ 20) (h5 : stackIdx ≤ 5) :\n    plates.stacks ≠ [] →\n    ∃ v, plates.popAtStack stackIdx = some v ∧ v ∈ values ∨ plates.popAtStack stackIdx = none := sorry\n\ntheorem test_sequential_operations {α : Type} (plates : DinnerPlates α)\n    (cap : Nat) (values : List α)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length ≤ 20) :\n    values.length > 2 →\n    ∃ v, plates.pop = some v ∧ v ∈ values ∨ plates.pop = none := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1921"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\n\nEvery time you are located in a cell you will collect all the gold in that cell.\nFrom your position you can walk one step to the left, right, up or down.\nYou can't visit the same cell more than once.\nNever visit a cell with 0 gold.\nYou can start and stop collecting gold from any position in the grid that has some gold.\n\n \nExample 1:\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n\nExample 2:\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n\n \nConstraints:\n\n1 <= grid.length, grid[i].length <= 15\n0 <= grid[i][j] <= 100\nThere are at most 25 cells containing gold.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sum (xs : List Nat) : Nat := \n  match xs with\n  | [] => 0\n  | h :: t => h + sum t\n\ndef sumOfLists (xss : List (List Nat)) : Nat :=\n  sum (xss.map sum)\n\ndef get_maximum_gold (grid : List (List Nat)) : Nat := sorry \n\ntheorem result_less_than_total (grid : List (List Nat)) :\n  get_maximum_gold grid ≤ sumOfLists grid := sorry\n\ntheorem empty_grid_is_zero {w h : Nat} (grid : List (List Nat)) \n  (h1 : grid.length = h)\n  (h2 : ∀ row ∈ grid, row.length = w ∧ ∀ x ∈ row, x = 0) :\n  get_maximum_gold grid = 0 := sorry\n\ntheorem result_is_non_negative (grid : List (List Nat)) :\n  get_maximum_gold grid ≥ 0 := sorry\n\ntheorem grid_unchanged (grid original : List (List Nat)) :\n  original = grid →\n  get_maximum_gold grid = get_maximum_gold grid ∧ grid = original := sorry\n\ntheorem single_value {w h val : Nat} (grid : List (List Nat))\n  (h1 : grid.length = h)\n  (h2 : ∀ row ∈ grid, row.length = w)\n  (h3 : grid.head!.head! = val)\n  (h4 : ∀ (i j : Nat), (i,j) ≠ (0,0) → \n    i < h → j < w → (grid.get! i).get! j = 0) :\n  get_maximum_gold grid = val := sorry\n\ntheorem max_path_viable (grid : List (List Nat)) :\n  get_maximum_gold grid ≤ sumOfLists grid := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1949", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\n\nEvery time you are located in a cell you will collect all the gold in that cell.\nFrom your position you can walk one step to the left, right, up or down.\nYou can't visit the same cell more than once.\nNever visit a cell with 0 gold.\nYou can start and stop collecting gold from any position in the grid that has some gold.\n\n \nExample 1:\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n\nExample 2:\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n\n \nConstraints:\n\n1 <= grid.length, grid[i].length <= 15\n0 <= grid[i][j] <= 100\nThere are at most 25 cells containing gold.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sum (xs : List Nat) : Nat := \n  match xs with\n  | [] => 0\n  | h :: t => h + sum t\n\ndef sumOfLists (xss : List (List Nat)) : Nat :=\n  sum (xss.map sum)\n\ndef get_maximum_gold (grid : List (List Nat)) : Nat := sorry \n\ntheorem result_less_than_total (grid : List (List Nat)) :\n  get_maximum_gold grid ≤ sumOfLists grid := sorry\n\ntheorem empty_grid_is_zero {w h : Nat} (grid : List (List Nat)) \n  (h1 : grid.length = h)\n  (h2 : ∀ row ∈ grid, row.length = w ∧ ∀ x ∈ row, x = 0) :\n  get_maximum_gold grid = 0 := sorry\n\ntheorem result_is_non_negative (grid : List (List Nat)) :\n  get_maximum_gold grid ≥ 0 := sorry\n\ntheorem grid_unchanged (grid original : List (List Nat)) :\n  original = grid →\n  get_maximum_gold grid = get_maximum_gold grid ∧ grid = original := sorry\n\ntheorem single_value {w h val : Nat} (grid : List (List Nat))\n  (h1 : grid.length = h)\n  (h2 : ∀ row ∈ grid, row.length = w)\n  (h3 : grid.head!.head! = val)\n  (h4 : ∀ (i j : Nat), (i,j) ≠ (0,0) → \n    i < h → j < w → (grid.get! i).get! j = 0) :\n  get_maximum_gold grid = val := sorry\n\ntheorem max_path_viable (grid : List (List Nat)) :\n  get_maximum_gold grid ≤ sumOfLists grid := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1949"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThere are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.\nYou are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.\nReturn a list of groups such that each person i is in a group of size groupSizes[i].\nEach person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.\n \nExample 1:\nInput: groupSizes = [3,3,3,3,3,1,3]\nOutput: [[5],[0,1,2],[3,4,6]]\nExplanation: \nThe first group is [5]. The size is 1, and groupSizes[5] = 1.\nThe second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.\nThe third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.\nOther possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].\n\nExample 2:\nInput: groupSizes = [2,1,3,3,3,2]\nOutput: [[1],[0,5],[2,3,4]]\n\n \nConstraints:\n\ngroupSizes.length == n\n1 <= n <= 500\n1 <= groupSizes[i] <= n\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef groupThePeople (groupSizes : List Nat) : List (List Nat) := sorry\n\ntheorem group_sizes_match_values (groupSizes : List Nat) \n  (h : ∀ x ∈ groupSizes, 1 ≤ x ∧ x ≤ 10) :\n  let result := groupThePeople groupSizes\n  ∀ group ∈ result,\n    let size := group.length \n    ∀ i ∈ group, groupSizes.get! i = size := sorry\n\ntheorem no_overlapping_groups (groupSizes : List Nat)\n  (h : ∀ x ∈ groupSizes, 1 ≤ x ∧ x ≤ 10) :\n  let result := groupThePeople groupSizes\n  ∀ g1 ∈ result,\n    ∀ g2 ∈ result,\n      g1 ≠ g2 →\n      ∀ i ∈ g1, i ∉ g2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1958", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThere are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.\nYou are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.\nReturn a list of groups such that each person i is in a group of size groupSizes[i].\nEach person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.\n \nExample 1:\nInput: groupSizes = [3,3,3,3,3,1,3]\nOutput: [[5],[0,1,2],[3,4,6]]\nExplanation: \nThe first group is [5]. The size is 1, and groupSizes[5] = 1.\nThe second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.\nThe third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.\nOther possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].\n\nExample 2:\nInput: groupSizes = [2,1,3,3,3,2]\nOutput: [[1],[0,5],[2,3,4]]\n\n \nConstraints:\n\ngroupSizes.length == n\n1 <= n <= 500\n1 <= groupSizes[i] <= n\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef groupThePeople (groupSizes : List Nat) : List (List Nat) := sorry\n\ntheorem group_sizes_match_values (groupSizes : List Nat) \n  (h : ∀ x ∈ groupSizes, 1 ≤ x ∧ x ≤ 10) :\n  let result := groupThePeople groupSizes\n  ∀ group ∈ result,\n    let size := group.length \n    ∀ i ∈ group, groupSizes.get! i = size := sorry\n\ntheorem no_overlapping_groups (groupSizes : List Nat)\n  (h : ∀ x ∈ groupSizes, 1 ≤ x ∧ x ≤ 10) :\n  let result := groupThePeople groupSizes\n  ∀ g1 ∈ result,\n    ∀ g2 ∈ result,\n      g1 ≠ g2 →\n      ∀ i ∈ g1, i ∉ g2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1958"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.\n\nThen, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\n\n\nNow after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)\n\n \n\n\nExample 1:\nInput: poured = 1, query_glass = 1, query_row = 1\nOutput: 0.0\nExplanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\nExample 2:\nInput: poured = 2, query_glass = 1, query_row = 1\nOutput: 0.5\nExplanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n\n \n\nNote:\n\n\n       poured will be in the range of [0, 10 ^ 9].\n       query_glass and query_row will be in the range of [0, 99].\n```\n#####\n\nTo answer this question, you need to replace the 10 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n/-- The champagne_tower function takes a volume of poured champagne and outputs\n    the fill level (between 0 and 1) of a specific glass in the tower -/\ndef champagne_tower (poured : Float) (query_row glass : Nat) : Float := sorry\n\ntheorem champagne_tower_bounds\n  (poured : Float) (query_row glass : Nat)\n  (h1 : poured ≥ 0) :\n  let result := champagne_tower poured query_row glass\n  0 ≤ result ∧ result ≤ 1 := sorry\n\ntheorem champagne_tower_glass_position\n  (poured : Float) (query_row glass : Nat)\n  (h1 : poured ≥ 0)\n  (h2 : glass > query_row) :\n  champagne_tower poured query_row glass = 0 := sorry\n\ntheorem champagne_tower_zero_poured\n  (query_row glass : Nat) :\n  champagne_tower 0 query_row glass = 0 := sorry\n\ntheorem champagne_tower_first_glass\n  (poured : Float)\n  (h1 : poured ≥ 0) :\n  champagne_tower poured 0 0 = min 1 poured := sorry\n\ntheorem champagne_tower_symmetry\n  (poured : Float) (row glass : Nat)\n  (h1 : poured ≥ 1)\n  (h2 : row ≥ 0)\n  (h3 : glass ≤ row) :\n  champagne_tower poured row glass = champagne_tower poured row (row - glass) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_1\n  (h1 : poured = 1) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 1 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_2\n  (h1 : poured = 2) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 3 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_4\n  (h1 : poured = 4) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 6 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_8\n  (h1 : poured = 8) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 10 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1959", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.\n\nThen, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\n\n\nNow after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)\n\n \n\n\nExample 1:\nInput: poured = 1, query_glass = 1, query_row = 1\nOutput: 0.0\nExplanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\nExample 2:\nInput: poured = 2, query_glass = 1, query_row = 1\nOutput: 0.5\nExplanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n\n \n\nNote:\n\n\n       poured will be in the range of [0, 10 ^ 9].\n       query_glass and query_row will be in the range of [0, 99].\n```\n#####\n\nTo answer this question, you need to replace the 10 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n/-- The champagne_tower function takes a volume of poured champagne and outputs\n    the fill level (between 0 and 1) of a specific glass in the tower -/\ndef champagne_tower (poured : Float) (query_row glass : Nat) : Float := sorry\n\ntheorem champagne_tower_bounds\n  (poured : Float) (query_row glass : Nat)\n  (h1 : poured ≥ 0) :\n  let result := champagne_tower poured query_row glass\n  0 ≤ result ∧ result ≤ 1 := sorry\n\ntheorem champagne_tower_glass_position\n  (poured : Float) (query_row glass : Nat)\n  (h1 : poured ≥ 0)\n  (h2 : glass > query_row) :\n  champagne_tower poured query_row glass = 0 := sorry\n\ntheorem champagne_tower_zero_poured\n  (query_row glass : Nat) :\n  champagne_tower 0 query_row glass = 0 := sorry\n\ntheorem champagne_tower_first_glass\n  (poured : Float)\n  (h1 : poured ≥ 0) :\n  champagne_tower poured 0 0 = min 1 poured := sorry\n\ntheorem champagne_tower_symmetry\n  (poured : Float) (row glass : Nat)\n  (h1 : poured ≥ 1)\n  (h2 : row ≥ 0)\n  (h3 : glass ≤ row) :\n  champagne_tower poured row glass = champagne_tower poured row (row - glass) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_1\n  (h1 : poured = 1) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 1 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_2\n  (h1 : poured = 2) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 3 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_4\n  (h1 : poured = 4) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 6 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_8\n  (h1 : poured = 8) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 10 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1959"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a list of folders, remove all sub-folders in those folders and return in any order the folders after removing.\nIf a folder[i] is located within another folder[j], it is called a sub-folder of it.\nThe format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters. For example, /leetcode and /leetcode/problems are valid paths while an empty string and / are not.\n \nExample 1:\nInput: folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\nOutput: [\"/a\",\"/c/d\",\"/c/f\"]\nExplanation: Folders \"/a/b/\" is a subfolder of \"/a\" and \"/c/d/e\" is inside of folder \"/c/d\" in our filesystem.\n\nExample 2:\nInput: folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\nOutput: [\"/a\"]\nExplanation: Folders \"/a/b/c\" and \"/a/b/d/\" will be removed because they are subfolders of \"/a\".\n\nExample 3:\nInput: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\nOutput: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n\n \nConstraints:\n\n1 <= folder.length <= 4 * 10^4\n2 <= folder[i].length <= 100\nfolder[i] contains only lowercase letters and '/'\nfolder[i] always starts with character '/'\nEach folder name is unique.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef remove_subfolders (folders: List String) : List String :=\nsorry\n\ntheorem empty_folder_list : remove_subfolders [] = [] :=\nsorry\n\ntheorem single_folder_unchanged (a : String) : \n  remove_subfolders [a] = [a] :=\nsorry\n\ntheorem folder_with_subfolder : \n  remove_subfolders [\"/a\", \"/a/b\"] = [\"/a\"] :=\nsorry\n\ntheorem separate_folders : \n  remove_subfolders [\"/a\", \"/b\"] = [\"/a\", \"/b\"] :=\nsorry\n\ntheorem result_subset (folders : List String) :\n  ∀ x, x ∈ remove_subfolders folders → x ∈ folders :=\nsorry\n\ntheorem result_ascending (folders : List String) :\n  ∀ i j, i < j → \n  List.get! (remove_subfolders folders) i ≤ List.get! (remove_subfolders folders) j :=\nsorry\n\ntheorem no_subfolders_in_result (folders : List String) :\n  ∀ p1 p2, p1 ∈ remove_subfolders folders → \n  p2 ∈ remove_subfolders folders →\n  p1 ≠ p2 → ¬(p2.startsWith (p1 ++ \"/\")) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1968", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a list of folders, remove all sub-folders in those folders and return in any order the folders after removing.\nIf a folder[i] is located within another folder[j], it is called a sub-folder of it.\nThe format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters. For example, /leetcode and /leetcode/problems are valid paths while an empty string and / are not.\n \nExample 1:\nInput: folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\nOutput: [\"/a\",\"/c/d\",\"/c/f\"]\nExplanation: Folders \"/a/b/\" is a subfolder of \"/a\" and \"/c/d/e\" is inside of folder \"/c/d\" in our filesystem.\n\nExample 2:\nInput: folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\nOutput: [\"/a\"]\nExplanation: Folders \"/a/b/c\" and \"/a/b/d/\" will be removed because they are subfolders of \"/a\".\n\nExample 3:\nInput: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\nOutput: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n\n \nConstraints:\n\n1 <= folder.length <= 4 * 10^4\n2 <= folder[i].length <= 100\nfolder[i] contains only lowercase letters and '/'\nfolder[i] always starts with character '/'\nEach folder name is unique.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef remove_subfolders (folders: List String) : List String :=\nsorry\n\ntheorem empty_folder_list : remove_subfolders [] = [] :=\nsorry\n\ntheorem single_folder_unchanged (a : String) : \n  remove_subfolders [a] = [a] :=\nsorry\n\ntheorem folder_with_subfolder : \n  remove_subfolders [\"/a\", \"/a/b\"] = [\"/a\"] :=\nsorry\n\ntheorem separate_folders : \n  remove_subfolders [\"/a\", \"/b\"] = [\"/a\", \"/b\"] :=\nsorry\n\ntheorem result_subset (folders : List String) :\n  ∀ x, x ∈ remove_subfolders folders → x ∈ folders :=\nsorry\n\ntheorem result_ascending (folders : List String) :\n  ∀ i j, i < j → \n  List.get! (remove_subfolders folders) i ≤ List.get! (remove_subfolders folders) j :=\nsorry\n\ntheorem no_subfolders_in_result (folders : List String) :\n  ∀ p1 p2, p1 ∈ remove_subfolders folders → \n  p2 ∈ remove_subfolders folders →\n  p1 ≠ p2 → ¬(p2.startsWith (p1 ++ \"/\")) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1968"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it palindrome.\nReturn the length of the maximum length awesome substring of s.\n \nExample 1:\nInput: s = \"3242415\"\nOutput: 5\nExplanation: \"24241\" is the longest awesome substring, we can form the palindrome \"24142\" with some swaps.\n\nExample 2:\nInput: s = \"12345678\"\nOutput: 1\n\nExample 3:\nInput: s = \"213123\"\nOutput: 6\nExplanation: \"213123\" is the longest awesome substring, we can form the palindrome \"231132\" with some swaps.\n\nExample 4:\nInput: s = \"00\"\nOutput: 2\n\n \nConstraints:\n\n1 <= s.length <= 10^5\ns consists only of digits.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef longest_awesome_substring (s : String) : Nat := sorry\n\ndef is_digit (c : Char) : Bool := \n  '0' ≤ c ∧ c ≤ '9'\n\ndef string_reversal (s : String) : String := sorry\n\ntheorem valid_length (s : String) (h : s.length > 0) (h2 : ∀ c ∈ s.data, is_digit c) :\n  let result := longest_awesome_substring s\n  1 ≤ result ∧ result ≤ s.length := sorry\n\ntheorem repeated_digit_awesome (d : Char) (n : Nat) (h : is_digit d) (h2 : n > 0) :\n  let s := String.mk (List.replicate n d)\n  longest_awesome_substring s = s.length := sorry\n\ntheorem palindrome_awesome (s : String) (h : s.length > 0) (h2 : ∀ c ∈ s.data, is_digit c) :\n  let palindrome := s ++ string_reversal s\n  longest_awesome_substring palindrome = palindrome.length := sorry\n\ntheorem single_odd_count_awesome (d1 d2 : Char) (h1 : is_digit d1) (h2 : is_digit d2) (h3 : d1 ≠ d2) :\n  let s := String.mk (List.replicate 10 d1 ++ [d2]) \n  longest_awesome_substring s ≥ 11 := sorry\n\ntheorem reversal_invariant (s : String) (h : s.length > 0) (h2 : ∀ c ∈ s.data, is_digit c) :\n  longest_awesome_substring s = longest_awesome_substring (string_reversal s) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1989", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it palindrome.\nReturn the length of the maximum length awesome substring of s.\n \nExample 1:\nInput: s = \"3242415\"\nOutput: 5\nExplanation: \"24241\" is the longest awesome substring, we can form the palindrome \"24142\" with some swaps.\n\nExample 2:\nInput: s = \"12345678\"\nOutput: 1\n\nExample 3:\nInput: s = \"213123\"\nOutput: 6\nExplanation: \"213123\" is the longest awesome substring, we can form the palindrome \"231132\" with some swaps.\n\nExample 4:\nInput: s = \"00\"\nOutput: 2\n\n \nConstraints:\n\n1 <= s.length <= 10^5\ns consists only of digits.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef longest_awesome_substring (s : String) : Nat := sorry\n\ndef is_digit (c : Char) : Bool := \n  '0' ≤ c ∧ c ≤ '9'\n\ndef string_reversal (s : String) : String := sorry\n\ntheorem valid_length (s : String) (h : s.length > 0) (h2 : ∀ c ∈ s.data, is_digit c) :\n  let result := longest_awesome_substring s\n  1 ≤ result ∧ result ≤ s.length := sorry\n\ntheorem repeated_digit_awesome (d : Char) (n : Nat) (h : is_digit d) (h2 : n > 0) :\n  let s := String.mk (List.replicate n d)\n  longest_awesome_substring s = s.length := sorry\n\ntheorem palindrome_awesome (s : String) (h : s.length > 0) (h2 : ∀ c ∈ s.data, is_digit c) :\n  let palindrome := s ++ string_reversal s\n  longest_awesome_substring palindrome = palindrome.length := sorry\n\ntheorem single_odd_count_awesome (d1 d2 : Char) (h1 : is_digit d1) (h2 : is_digit d2) (h3 : d1 ≠ d2) :\n  let s := String.mk (List.replicate 10 d1 ++ [d2]) \n  longest_awesome_substring s ≥ 11 := sorry\n\ntheorem reversal_invariant (s : String) (h : s.length > 0) (h2 : ∀ c ∈ s.data, is_digit c) :\n  longest_awesome_substring s = longest_awesome_substring (string_reversal s) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1989"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.\nAt each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.\nNotice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).\nReturn the count of all possible routes from start to finish.\nSince the answer may be too large, return it modulo 10^9 + 7.\n \nExample 1:\nInput: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\nOutput: 4\nExplanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\nExample 2:\nInput: locations = [4,3,1], start = 1, finish = 0, fuel = 6\nOutput: 5\nExplanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\nExample 3:\nInput: locations = [5,2,1], start = 0, finish = 2, fuel = 3\nOutput: 0\nExplanation: It's impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\nExample 4:\nInput: locations = [2,1,5], start = 0, finish = 0, fuel = 3\nOutput: 2\nExplanation: There are two possible routes, 0 and 0 -> 1 -> 0.\nExample 5:\nInput: locations = [1,2,3], start = 0, finish = 2, fuel = 40\nOutput: 615088286\nExplanation: The total number of possible routes is 2615088300. Taking this number modulo 10^9 + 7 gives us 615088286.\n\n \nConstraints:\n\n2 <= locations.length <= 100\n1 <= locations[i] <= 10^9\nAll integers in locations are distinct.\n0 <= start, finish < locations.length\n1 <= fuel <= 200\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_routes (locations : List Int) (start finish : Nat) (fuel : Nat) : Nat := sorry\n\ndef MOD := 1000000007\n\ntheorem count_routes_bounds \n  (locations : List Int)\n  (start finish fuel : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length)\n  (h3 : start < locations.length)\n  (h4 : finish < locations.length)\n  (h5 : fuel ≤ 200) :\n  0 ≤ count_routes locations start finish fuel ∧ \n  count_routes locations start finish fuel < MOD := sorry\n\ntheorem zero_fuel_routes\n  (locations : List Int)\n  (start finish : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length)\n  (h3 : start < locations.length)\n  (h4 : finish < locations.length) :\n  (count_routes locations start finish 0 > 0) ↔ (start = finish) := sorry\n\ntheorem self_routes_nonempty\n  (locations : List Int)\n  (fuel : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length) :\n  count_routes locations 0 0 fuel ≥ 1 := sorry\n\ntheorem routes_symmetric\n  (locations : List Int)\n  (fuel : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length) :\n  count_routes locations 0 1 fuel = count_routes locations 1 0 fuel := sorry\n\ntheorem more_fuel_more_routes\n  (locations : List Int)\n  (start finish : Nat)\n  (fuel1 fuel2 : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length)\n  (h3 : start < locations.length)\n  (h4 : finish < locations.length)\n  (h5 : fuel1 ≤ fuel2) :\n  count_routes locations start finish fuel1 ≤ \n  count_routes locations start finish fuel2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "1991", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.\nAt each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.\nNotice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).\nReturn the count of all possible routes from start to finish.\nSince the answer may be too large, return it modulo 10^9 + 7.\n \nExample 1:\nInput: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\nOutput: 4\nExplanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\nExample 2:\nInput: locations = [4,3,1], start = 1, finish = 0, fuel = 6\nOutput: 5\nExplanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\nExample 3:\nInput: locations = [5,2,1], start = 0, finish = 2, fuel = 3\nOutput: 0\nExplanation: It's impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\nExample 4:\nInput: locations = [2,1,5], start = 0, finish = 0, fuel = 3\nOutput: 2\nExplanation: There are two possible routes, 0 and 0 -> 1 -> 0.\nExample 5:\nInput: locations = [1,2,3], start = 0, finish = 2, fuel = 40\nOutput: 615088286\nExplanation: The total number of possible routes is 2615088300. Taking this number modulo 10^9 + 7 gives us 615088286.\n\n \nConstraints:\n\n2 <= locations.length <= 100\n1 <= locations[i] <= 10^9\nAll integers in locations are distinct.\n0 <= start, finish < locations.length\n1 <= fuel <= 200\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_routes (locations : List Int) (start finish : Nat) (fuel : Nat) : Nat := sorry\n\ndef MOD := 1000000007\n\ntheorem count_routes_bounds \n  (locations : List Int)\n  (start finish fuel : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length)\n  (h3 : start < locations.length)\n  (h4 : finish < locations.length)\n  (h5 : fuel ≤ 200) :\n  0 ≤ count_routes locations start finish fuel ∧ \n  count_routes locations start finish fuel < MOD := sorry\n\ntheorem zero_fuel_routes\n  (locations : List Int)\n  (start finish : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length)\n  (h3 : start < locations.length)\n  (h4 : finish < locations.length) :\n  (count_routes locations start finish 0 > 0) ↔ (start = finish) := sorry\n\ntheorem self_routes_nonempty\n  (locations : List Int)\n  (fuel : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length) :\n  count_routes locations 0 0 fuel ≥ 1 := sorry\n\ntheorem routes_symmetric\n  (locations : List Int)\n  (fuel : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length) :\n  count_routes locations 0 1 fuel = count_routes locations 1 0 fuel := sorry\n\ntheorem more_fuel_more_routes\n  (locations : List Int)\n  (start finish : Nat)\n  (fuel1 fuel2 : Nat)\n  (h1 : ∀ x ∈ locations, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : 2 ≤ locations.length)\n  (h3 : start < locations.length)\n  (h4 : finish < locations.length)\n  (h5 : fuel1 ≤ fuel2) :\n  count_routes locations start finish fuel1 ≤ \n  count_routes locations start finish fuel2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "1991"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThis is the easy version of the problem. The only difference between easy and hard versions is the constraint of $m$. You can make hacks only if both versions are solved.\n\nChiori loves dolls and now she is going to decorate her bedroom![Image] \n\nAs a doll collector, Chiori has got $n$ dolls. The $i$-th doll has a non-negative integer value $a_i$ ($a_i < 2^m$, $m$ is given). Chiori wants to pick some (maybe zero) dolls for the decoration, so there are $2^n$ different picking ways.\n\nLet $x$ be the bitwise-xor-sum of values of dolls Chiori picks (in case Chiori picks no dolls $x = 0$). The value of this picking way is equal to the number of $1$-bits in the binary representation of $x$. More formally, it is also equal to the number of indices $0 \\leq i < m$, such that $\\left\\lfloor \\frac{x}{2^i} \\right\\rfloor$ is odd.\n\nTell her the number of picking ways with value $i$ for each integer $i$ from $0$ to $m$. Due to the answers can be very huge, print them by modulo $998\\,244\\,353$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 35$)  — the number of dolls and the maximum value of the picking way.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^m$)  — the values of dolls.\n\n\n-----Output-----\n\nPrint $m+1$ integers $p_0, p_1, \\ldots, p_m$  — $p_i$ is equal to the number of picking ways with value $i$ by modulo $998\\,244\\,353$.\n\n\n-----Examples-----\nInput\n4 4\n3 5 8 14\n\nOutput\n2 2 6 6 0 \nInput\n6 7\n11 45 14 9 19 81\n\nOutput\n1 2 11 20 15 10 5 0\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef pow (base : Nat) (exp : Nat) (mod : Nat) : Nat := sorry\n\ndef solve_dolls (n : Nat) (m : Nat) (dolls : List Nat) : List Nat := sorry\n\ntheorem solve_dolls_minimal_case (n : Nat) (hn : 0 < n ∧ n ≤ 10):\n  solve_dolls n 0 (List.replicate n 0) = [pow 2 n 998244353] := sorry\n\ntheorem solve_dolls_output_length (n m : Nat) \n  (hn : 0 < n ∧ n ≤ 10) (hm : m ≤ 4) :\n  List.length (solve_dolls n m (List.replicate n 0)) = m + 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2035", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThis is the easy version of the problem. The only difference between easy and hard versions is the constraint of $m$. You can make hacks only if both versions are solved.\n\nChiori loves dolls and now she is going to decorate her bedroom![Image] \n\nAs a doll collector, Chiori has got $n$ dolls. The $i$-th doll has a non-negative integer value $a_i$ ($a_i < 2^m$, $m$ is given). Chiori wants to pick some (maybe zero) dolls for the decoration, so there are $2^n$ different picking ways.\n\nLet $x$ be the bitwise-xor-sum of values of dolls Chiori picks (in case Chiori picks no dolls $x = 0$). The value of this picking way is equal to the number of $1$-bits in the binary representation of $x$. More formally, it is also equal to the number of indices $0 \\leq i < m$, such that $\\left\\lfloor \\frac{x}{2^i} \\right\\rfloor$ is odd.\n\nTell her the number of picking ways with value $i$ for each integer $i$ from $0$ to $m$. Due to the answers can be very huge, print them by modulo $998\\,244\\,353$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 35$)  — the number of dolls and the maximum value of the picking way.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^m$)  — the values of dolls.\n\n\n-----Output-----\n\nPrint $m+1$ integers $p_0, p_1, \\ldots, p_m$  — $p_i$ is equal to the number of picking ways with value $i$ by modulo $998\\,244\\,353$.\n\n\n-----Examples-----\nInput\n4 4\n3 5 8 14\n\nOutput\n2 2 6 6 0 \nInput\n6 7\n11 45 14 9 19 81\n\nOutput\n1 2 11 20 15 10 5 0\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef pow (base : Nat) (exp : Nat) (mod : Nat) : Nat := sorry\n\ndef solve_dolls (n : Nat) (m : Nat) (dolls : List Nat) : List Nat := sorry\n\ntheorem solve_dolls_minimal_case (n : Nat) (hn : 0 < n ∧ n ≤ 10):\n  solve_dolls n 0 (List.replicate n 0) = [pow 2 n 998244353] := sorry\n\ntheorem solve_dolls_output_length (n m : Nat) \n  (hn : 0 < n ∧ n ≤ 10) (hm : m ≤ 4) :\n  List.length (solve_dolls n m (List.replicate n 0)) = m + 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2035"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nAllen dreams of one day owning a enormous fleet of electric cars, the car of the future! He knows that this will give him a big status boost. As Allen is planning out all of the different types of cars he will own and how he will arrange them, he realizes that he has a problem. \n\nAllen's future parking lot can be represented as a rectangle with $4$ rows and $n$ ($n \\le 50$) columns of rectangular spaces, each of which can contain at most one car at any time. He imagines having $k$ ($k \\le 2n$) cars in the grid, and all the cars are initially in the second and third rows. Each of the cars also has a different designated parking space in the first or fourth row. Allen has to put the cars into corresponding parking places.\n\n [Image] Illustration to the first example. \n\nHowever, since Allen would never entrust his cars to anyone else, only one car can be moved at a time. He can drive a car from a space in any of the four cardinal directions to a neighboring empty space. Furthermore, Allen can only move one of his cars into a space on the first or fourth rows if it is the car's designated parking space. \n\nAllen knows he will be a very busy man, and will only have time to move cars at most $20000$ times before he realizes that moving cars is not worth his time. Help Allen determine if he should bother parking his cars or leave it to someone less important.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers $n$ and $k$ ($1 \\le n \\le 50$, $1 \\le k \\le 2n$), representing the number of columns and the number of cars, respectively.\n\nThe next four lines will contain $n$ integers each between $0$ and $k$ inclusive, representing the initial state of the parking lot. The rows are numbered $1$ to $4$ from top to bottom and the columns are numbered $1$ to $n$ from left to right.\n\nIn the first and last line, an integer $1 \\le x \\le k$ represents a parking spot assigned to car $x$ (you can only move this car to this place), while the integer $0$ represents a empty space (you can't move any car to this place).\n\nIn the second and third line, an integer $1 \\le x \\le k$ represents initial position of car $x$, while the integer $0$ represents an empty space (you can move any car to this place).\n\nEach $x$ between $1$ and $k$ appears exactly once in the second and third line, and exactly once in the first and fourth line.\n\n\n-----Output-----\n\nIf there is a sequence of moves that brings all of the cars to their parking spaces, with at most $20000$ car moves, then print $m$, the number of moves, on the first line. On the following $m$ lines, print the moves (one move per line) in the format $i$ $r$ $c$, which corresponds to Allen moving car $i$ to the neighboring space at row $r$ and column $c$.\n\nIf it is not possible for Allen to move all the cars to the correct spaces with at most $20000$ car moves, print a single line with the integer $-1$.\n\n\n-----Examples-----\nInput\n4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n\nOutput\n6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n\nInput\n1 2\n1\n2\n1\n2\n\nOutput\n-1\n\nInput\n1 2\n1\n1\n2\n2\n\nOutput\n2\n1 1 1\n2 4 1\n\n\n\n-----Note-----\n\nIn the first sample test case, all cars are in front of their spots except car $5$, which is in front of the parking spot adjacent. The example shows the shortest possible sequence of moves, but any sequence of length at most $20000$ will be accepted.\n\nIn the second sample test case, there is only one column, and the cars are in the wrong order, so no cars can move and the task is impossible.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_parking (n k : Nat) (grid : List (List Nat)) : List Nat :=\nsorry\n\ntheorem parking_properties (n k : Nat)\n  (h1 : 1 ≤ n ∧ n ≤ 10)\n  (h2 : 1 ≤ k ∧ k ≤ 20)\n  (grid : List (List Nat))\n  (h3 : grid.length = 4)\n  (h4 : ∀ row ∈ grid, row.length = n) :\n  let result := solve_parking n k grid;\n  -- Result is a list\n  result.length > 0\n  -- First element is non-negative  \n  ∧ result.head?.isSome\n  ∧ (∀ h, result.head?.get h ≥ 0)\n  -- If solution exists (head ≠ 1), then rest of list represents valid moves  \n  ∧ (∀ h, result.head?.get h ≠ 1 → \n      -- Number of moves matches head\n      result.tail.length = result.head?.get h\n      -- Moves are valid format\n      ∧ ∀ move ∈ result.tail,\n          -- Car number in valid range\n          0 ≤ move ∧ move ≤ k\n          -- Row in valid range \n          ∧ 1 ≤ move ∧ move ≤ 4\n          -- Column in valid range\n          ∧ 1 ≤ move ∧ move ≤ n\n      -- Solution has finite moves\n      ∧ result.head?.get h ≤ 20000) :=\nsorry\n\ntheorem empty_grid (n : Nat)\n  (h1 : 1 ≤ n ∧ n ≤ 10)\n  (grid : List (List Nat))\n  (h2 : grid.length = 4)\n  (h3 : ∀ row ∈ grid, row.length = n)\n  (h4 : ∀ row ∈ grid, ∀ cell ∈ row, cell = 0) :\n  let result := solve_parking n n grid;\n  result.head? = some 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2047", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nAllen dreams of one day owning a enormous fleet of electric cars, the car of the future! He knows that this will give him a big status boost. As Allen is planning out all of the different types of cars he will own and how he will arrange them, he realizes that he has a problem. \n\nAllen's future parking lot can be represented as a rectangle with $4$ rows and $n$ ($n \\le 50$) columns of rectangular spaces, each of which can contain at most one car at any time. He imagines having $k$ ($k \\le 2n$) cars in the grid, and all the cars are initially in the second and third rows. Each of the cars also has a different designated parking space in the first or fourth row. Allen has to put the cars into corresponding parking places.\n\n [Image] Illustration to the first example. \n\nHowever, since Allen would never entrust his cars to anyone else, only one car can be moved at a time. He can drive a car from a space in any of the four cardinal directions to a neighboring empty space. Furthermore, Allen can only move one of his cars into a space on the first or fourth rows if it is the car's designated parking space. \n\nAllen knows he will be a very busy man, and will only have time to move cars at most $20000$ times before he realizes that moving cars is not worth his time. Help Allen determine if he should bother parking his cars or leave it to someone less important.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers $n$ and $k$ ($1 \\le n \\le 50$, $1 \\le k \\le 2n$), representing the number of columns and the number of cars, respectively.\n\nThe next four lines will contain $n$ integers each between $0$ and $k$ inclusive, representing the initial state of the parking lot. The rows are numbered $1$ to $4$ from top to bottom and the columns are numbered $1$ to $n$ from left to right.\n\nIn the first and last line, an integer $1 \\le x \\le k$ represents a parking spot assigned to car $x$ (you can only move this car to this place), while the integer $0$ represents a empty space (you can't move any car to this place).\n\nIn the second and third line, an integer $1 \\le x \\le k$ represents initial position of car $x$, while the integer $0$ represents an empty space (you can move any car to this place).\n\nEach $x$ between $1$ and $k$ appears exactly once in the second and third line, and exactly once in the first and fourth line.\n\n\n-----Output-----\n\nIf there is a sequence of moves that brings all of the cars to their parking spaces, with at most $20000$ car moves, then print $m$, the number of moves, on the first line. On the following $m$ lines, print the moves (one move per line) in the format $i$ $r$ $c$, which corresponds to Allen moving car $i$ to the neighboring space at row $r$ and column $c$.\n\nIf it is not possible for Allen to move all the cars to the correct spaces with at most $20000$ car moves, print a single line with the integer $-1$.\n\n\n-----Examples-----\nInput\n4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n\nOutput\n6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n\nInput\n1 2\n1\n2\n1\n2\n\nOutput\n-1\n\nInput\n1 2\n1\n1\n2\n2\n\nOutput\n2\n1 1 1\n2 4 1\n\n\n\n-----Note-----\n\nIn the first sample test case, all cars are in front of their spots except car $5$, which is in front of the parking spot adjacent. The example shows the shortest possible sequence of moves, but any sequence of length at most $20000$ will be accepted.\n\nIn the second sample test case, there is only one column, and the cars are in the wrong order, so no cars can move and the task is impossible.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_parking (n k : Nat) (grid : List (List Nat)) : List Nat :=\nsorry\n\ntheorem parking_properties (n k : Nat)\n  (h1 : 1 ≤ n ∧ n ≤ 10)\n  (h2 : 1 ≤ k ∧ k ≤ 20)\n  (grid : List (List Nat))\n  (h3 : grid.length = 4)\n  (h4 : ∀ row ∈ grid, row.length = n) :\n  let result := solve_parking n k grid;\n  -- Result is a list\n  result.length > 0\n  -- First element is non-negative  \n  ∧ result.head?.isSome\n  ∧ (∀ h, result.head?.get h ≥ 0)\n  -- If solution exists (head ≠ 1), then rest of list represents valid moves  \n  ∧ (∀ h, result.head?.get h ≠ 1 → \n      -- Number of moves matches head\n      result.tail.length = result.head?.get h\n      -- Moves are valid format\n      ∧ ∀ move ∈ result.tail,\n          -- Car number in valid range\n          0 ≤ move ∧ move ≤ k\n          -- Row in valid range \n          ∧ 1 ≤ move ∧ move ≤ 4\n          -- Column in valid range\n          ∧ 1 ≤ move ∧ move ≤ n\n      -- Solution has finite moves\n      ∧ result.head?.get h ≤ 20000) :=\nsorry\n\ntheorem empty_grid (n : Nat)\n  (h1 : 1 ≤ n ∧ n ≤ 10)\n  (grid : List (List Nat))\n  (h2 : grid.length = 4)\n  (h3 : ∀ row ∈ grid, row.length = n)\n  (h4 : ∀ row ∈ grid, ∀ cell ∈ row, cell = 0) :\n  let result := solve_parking n n grid;\n  result.head? = some 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2047"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe have three stones at points (0, 0), (1,0), and (0,1) on a two-dimensional plane.\nThese three stones are said to form an L when they satisfy the following conditions:\n - Each of the stones is at integer coordinates.\n - Each of the stones is adjacent to another stone. (That is, for each stone, there is another stone whose distance from that stone is 1.)\n - The three stones do not lie on the same line.\nParticularly, the initial arrangement of the stone - (0, 0), (1,0), and (0,1) - forms an L.\nYou can do the following operation any number of times: choose one of the stones and move it to any position. However, after each operation, the stones must form an L.\nYou want to do as few operations as possible to put stones at points (ax, ay), (bx, by), and (cx, cy). How many operations do you need to do this?\nIt is guaranteed that the desired arrangement of stones - (ax, ay), (bx, by), and (cx, cy) - forms an L. Under this condition, it is always possible to achieve the objective with a finite number of operations.\nYou will be given T cases of this problem. Solve each of them.\n\n-----Notes-----\nWe assume that the three stones are indistinguishable. For example, the stone that is initially at point (0,0) may be at any of the points (ax, ay), (bx, by), and (cx, cy) in the end.\n\n-----Constraints-----\n - 1 \\leq T \\leq 10^3\n - |ax|,|ay|,|bx|,|by|,|cx|,|cy| \\leq 10^9\n - The desired arrangement of stones - (ax, ay), (bx, by), and (cx, cy) - forms an L.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nT\n\\text{case}_1\n\\vdots\n\\text{case}_T\n\nEach case is in the following format:\nax ay bx by cx cy\n\n-----Output-----\nPrint T values. The i-th value should be the minimum number of operations for \\text{case}_i.\n\n-----Sample Input-----\n1\n3 2 2 2 2 1\n\n-----Sample Output-----\n4\n\nLet us use # to represent a stone.\nYou can move the stones to the specified positions with four operations, as follows:\n....    ....    ....    ..#.    ..##\n#... -> ##.. -> .##. -> .##. -> ..#.\n##..    .#..    .#..    ....    ....\n\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (ax ay bx b_y cx c_y : Int) : Nat := sorry\n\ntheorem solve_non_negative (ax ay bx b_y cx c_y : Int) :\n  solve ax ay bx b_y cx c_y ≥ 0 := sorry\n\n\n\ntheorem solve_symmetric_ab (ax ay bx b_y cx c_y : Int) :\n  solve ax ay bx b_y cx c_y = solve bx b_y ax ay cx c_y := sorry\n\ntheorem solve_symmetric_bc (ax ay bx b_y cx c_y : Int) :\n  solve ax ay bx b_y cx c_y = solve ax ay cx c_y bx b_y := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2061", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe have three stones at points (0, 0), (1,0), and (0,1) on a two-dimensional plane.\nThese three stones are said to form an L when they satisfy the following conditions:\n - Each of the stones is at integer coordinates.\n - Each of the stones is adjacent to another stone. (That is, for each stone, there is another stone whose distance from that stone is 1.)\n - The three stones do not lie on the same line.\nParticularly, the initial arrangement of the stone - (0, 0), (1,0), and (0,1) - forms an L.\nYou can do the following operation any number of times: choose one of the stones and move it to any position. However, after each operation, the stones must form an L.\nYou want to do as few operations as possible to put stones at points (ax, ay), (bx, by), and (cx, cy). How many operations do you need to do this?\nIt is guaranteed that the desired arrangement of stones - (ax, ay), (bx, by), and (cx, cy) - forms an L. Under this condition, it is always possible to achieve the objective with a finite number of operations.\nYou will be given T cases of this problem. Solve each of them.\n\n-----Notes-----\nWe assume that the three stones are indistinguishable. For example, the stone that is initially at point (0,0) may be at any of the points (ax, ay), (bx, by), and (cx, cy) in the end.\n\n-----Constraints-----\n - 1 \\leq T \\leq 10^3\n - |ax|,|ay|,|bx|,|by|,|cx|,|cy| \\leq 10^9\n - The desired arrangement of stones - (ax, ay), (bx, by), and (cx, cy) - forms an L.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nT\n\\text{case}_1\n\\vdots\n\\text{case}_T\n\nEach case is in the following format:\nax ay bx by cx cy\n\n-----Output-----\nPrint T values. The i-th value should be the minimum number of operations for \\text{case}_i.\n\n-----Sample Input-----\n1\n3 2 2 2 2 1\n\n-----Sample Output-----\n4\n\nLet us use # to represent a stone.\nYou can move the stones to the specified positions with four operations, as follows:\n....    ....    ....    ..#.    ..##\n#... -> ##.. -> .##. -> .##. -> ..#.\n##..    .#..    .#..    ....    ....\n\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (ax ay bx b_y cx c_y : Int) : Nat := sorry\n\ntheorem solve_non_negative (ax ay bx b_y cx c_y : Int) :\n  solve ax ay bx b_y cx c_y ≥ 0 := sorry\n\n\n\ntheorem solve_symmetric_ab (ax ay bx b_y cx c_y : Int) :\n  solve ax ay bx b_y cx c_y = solve bx b_y ax ay cx c_y := sorry\n\ntheorem solve_symmetric_bc (ax ay bx b_y cx c_y : Int) :\n  solve ax ay bx b_y cx c_y = solve ax ay cx c_y bx b_y := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2061"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nMaxim always goes to the supermarket on Sundays. Today the supermarket has a special offer of discount systems.\n\nThere are m types of discounts. We assume that the discounts are indexed from 1 to m. To use the discount number i, the customer takes a special basket, where he puts exactly q_{i} items he buys. Under the terms of the discount system, in addition to the items in the cart the customer can receive at most two items from the supermarket for free. The number of the \"free items\" (0, 1 or 2) to give is selected by the customer. The only condition imposed on the selected \"free items\" is as follows: each of them mustn't be more expensive than the cheapest item out of the q_{i} items in the cart.\n\nMaxim now needs to buy n items in the shop. Count the minimum sum of money that Maxim needs to buy them, if he use the discount system optimally well.\n\nPlease assume that the supermarket has enough carts for any actions. Maxim can use the same discount multiple times. Of course, Maxim can buy items without any discounts.\n\n\n-----Input-----\n\nThe first line contains integer m (1 ≤ m ≤ 10^5) — the number of discount types. The second line contains m integers: q_1, q_2, ..., q_{m} (1 ≤ q_{i} ≤ 10^5). \n\nThe third line contains integer n (1 ≤ n ≤ 10^5) — the number of items Maxim needs. The fourth line contains n integers: a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^4) — the items' prices.\n\nThe numbers in the lines are separated by single spaces.\n\n\n-----Output-----\n\nIn a single line print a single integer — the answer to the problem.\n\n\n-----Examples-----\nInput\n1\n2\n4\n50 50 100 100\n\nOutput\n200\n\nInput\n2\n2 3\n5\n50 50 50 50 50\n\nOutput\n150\n\nInput\n1\n1\n7\n1 1 1 1 1 1 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample Maxim needs to buy two items that cost 100 and get a discount for two free items that cost 50. In that case, Maxim is going to pay 200.\n\nIn the second sample the best strategy for Maxim is to buy 3 items and get 2 items for free using the discount. In that case, Maxim is going to pay 150.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_discount_shopping (n_discounts : Nat) (discount_values : List Nat) (n_items : Nat) (item_values : List Nat) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t\n\ndef list_sort (l : List Nat) : List Nat :=\n  sorry\n\ndef list_take (n : Nat) (l : List Nat) : List Nat :=\n  match n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, h :: t => h :: list_take n t\n\ntheorem discount_shopping_non_negative\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat) \n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  0 ≤ solve_discount_shopping n_discounts discount_values n_items item_values :=\n  sorry\n\ntheorem discount_shopping_upper_bound\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  solve_discount_shopping n_discounts discount_values n_items item_values ≤ list_sum item_values :=\n  sorry\n\ntheorem discount_shopping_min_items\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  let sorted_items := list_sort item_values\n  let min_disc := match discount_values with\n                  | [] => n_items\n                  | h :: t => min h n_items\n  let min_items_sum := list_sum (list_take min_disc sorted_items)\n  solve_discount_shopping n_discounts discount_values n_items item_values ≥ min_items_sum :=\n  sorry\n\ndef list_replicate (n : Nat) (v : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n+1 => v :: list_replicate n v\n\ntheorem identical_items_result\n  (n_discounts : Nat)\n  (n_items : Nat)\n  (item_value : Nat)\n  (h1 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h2 : 1 ≤ n_items ∧ n_items ≤ 5)\n  (h3 : 1 ≤ item_value ∧ item_value ≤ 100) :\n  let discount_values := list_replicate n_discounts 2\n  let item_values := list_replicate n_items item_value\n  let result := solve_discount_shopping n_discounts discount_values n_items item_values\n  result % item_value = 0 ∧ result ≤ item_value * n_items :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2080", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nMaxim always goes to the supermarket on Sundays. Today the supermarket has a special offer of discount systems.\n\nThere are m types of discounts. We assume that the discounts are indexed from 1 to m. To use the discount number i, the customer takes a special basket, where he puts exactly q_{i} items he buys. Under the terms of the discount system, in addition to the items in the cart the customer can receive at most two items from the supermarket for free. The number of the \"free items\" (0, 1 or 2) to give is selected by the customer. The only condition imposed on the selected \"free items\" is as follows: each of them mustn't be more expensive than the cheapest item out of the q_{i} items in the cart.\n\nMaxim now needs to buy n items in the shop. Count the minimum sum of money that Maxim needs to buy them, if he use the discount system optimally well.\n\nPlease assume that the supermarket has enough carts for any actions. Maxim can use the same discount multiple times. Of course, Maxim can buy items without any discounts.\n\n\n-----Input-----\n\nThe first line contains integer m (1 ≤ m ≤ 10^5) — the number of discount types. The second line contains m integers: q_1, q_2, ..., q_{m} (1 ≤ q_{i} ≤ 10^5). \n\nThe third line contains integer n (1 ≤ n ≤ 10^5) — the number of items Maxim needs. The fourth line contains n integers: a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^4) — the items' prices.\n\nThe numbers in the lines are separated by single spaces.\n\n\n-----Output-----\n\nIn a single line print a single integer — the answer to the problem.\n\n\n-----Examples-----\nInput\n1\n2\n4\n50 50 100 100\n\nOutput\n200\n\nInput\n2\n2 3\n5\n50 50 50 50 50\n\nOutput\n150\n\nInput\n1\n1\n7\n1 1 1 1 1 1 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample Maxim needs to buy two items that cost 100 and get a discount for two free items that cost 50. In that case, Maxim is going to pay 200.\n\nIn the second sample the best strategy for Maxim is to buy 3 items and get 2 items for free using the discount. In that case, Maxim is going to pay 150.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_discount_shopping (n_discounts : Nat) (discount_values : List Nat) (n_items : Nat) (item_values : List Nat) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t\n\ndef list_sort (l : List Nat) : List Nat :=\n  sorry\n\ndef list_take (n : Nat) (l : List Nat) : List Nat :=\n  match n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, h :: t => h :: list_take n t\n\ntheorem discount_shopping_non_negative\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat) \n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  0 ≤ solve_discount_shopping n_discounts discount_values n_items item_values :=\n  sorry\n\ntheorem discount_shopping_upper_bound\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  solve_discount_shopping n_discounts discount_values n_items item_values ≤ list_sum item_values :=\n  sorry\n\ntheorem discount_shopping_min_items\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  let sorted_items := list_sort item_values\n  let min_disc := match discount_values with\n                  | [] => n_items\n                  | h :: t => min h n_items\n  let min_items_sum := list_sum (list_take min_disc sorted_items)\n  solve_discount_shopping n_discounts discount_values n_items item_values ≥ min_items_sum :=\n  sorry\n\ndef list_replicate (n : Nat) (v : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n+1 => v :: list_replicate n v\n\ntheorem identical_items_result\n  (n_discounts : Nat)\n  (n_items : Nat)\n  (item_value : Nat)\n  (h1 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h2 : 1 ≤ n_items ∧ n_items ≤ 5)\n  (h3 : 1 ≤ item_value ∧ item_value ≤ 100) :\n  let discount_values := list_replicate n_discounts 2\n  let item_values := list_replicate n_items item_value\n  let result := solve_discount_shopping n_discounts discount_values n_items item_values\n  result % item_value = 0 ∧ result ≤ item_value * n_items :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2080"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nA tree is an undirected connected graph without cycles.\n\nLet's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p_1, p_2, ..., p_{n}, where p_{i} denotes a parent of vertex i (here, for convenience a root is considered its own parent). [Image] For this rooted tree the array p is [2, 3, 3, 2]. \n\nGiven a sequence p_1, p_2, ..., p_{n}, one is able to restore a tree:  There must be exactly one index r that p_{r} = r. A vertex r is a root of the tree.  For all other n - 1 vertices i, there is an edge between vertex i and vertex p_{i}. \n\nA sequence p_1, p_2, ..., p_{n} is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a_1, a_2, ..., a_{n}, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.\n\n\n-----Input-----\n\nThe first line of the input contains an integer n (2 ≤ n ≤ 200 000) — the number of vertices in the tree.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ n).\n\n\n-----Output-----\n\nIn the first line print the minimum number of elements to change, in order to get a valid sequence.\n\nIn the second line, print any valid sequence possible to get from (a_1, a_2, ..., a_{n}) in the minimum number of changes. If there are many such sequences, any of them will be accepted.\n\n\n-----Examples-----\nInput\n4\n2 3 3 4\n\nOutput\n1\n2 3 4 4 \n\nInput\n5\n3 2 2 5 3\n\nOutput\n0\n3 2 2 5 3 \n\nInput\n8\n2 3 5 4 1 6 6 7\n\nOutput\n2\n2 3 7 8 1 6 6 7\n\n\n\n-----Note-----\n\nIn the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p_4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red. [Image] \n\nIn the second sample, the given sequence is already valid.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef fix_tree_sequence (n : Nat) (A : List Nat) : Nat × List Nat := sorry\n\ndef is_valid_tree (A : List Nat) : Bool := sorry\n\ntheorem fix_tree_sequence_properties \n  (n : Nat) \n  (A : List Nat)\n  (h : A.length = n) :\n  let (changes, result) := fix_tree_sequence n A\n  -- Result has same length\n  result.length = A.length ∧ \n  -- Changes non-negative (implicit for Nat)\n  -- Result is valid tree\n  is_valid_tree result = true ∧\n  -- Original array unchanged\n  A = A ∧\n  -- Changes matches actual differences\n  changes = (List.zip A result).foldl (fun acc p => if p.1 = p.2 then acc else acc + 1) 0\n  := sorry\n\ntheorem already_valid_tree\n  (A : List Nat)\n  (h : is_valid_tree A = true) :\n  let (changes, result) := fix_tree_sequence A.length A\n  changes = 0 ∧ result = A\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2095", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nA tree is an undirected connected graph without cycles.\n\nLet's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p_1, p_2, ..., p_{n}, where p_{i} denotes a parent of vertex i (here, for convenience a root is considered its own parent). [Image] For this rooted tree the array p is [2, 3, 3, 2]. \n\nGiven a sequence p_1, p_2, ..., p_{n}, one is able to restore a tree:  There must be exactly one index r that p_{r} = r. A vertex r is a root of the tree.  For all other n - 1 vertices i, there is an edge between vertex i and vertex p_{i}. \n\nA sequence p_1, p_2, ..., p_{n} is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a_1, a_2, ..., a_{n}, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.\n\n\n-----Input-----\n\nThe first line of the input contains an integer n (2 ≤ n ≤ 200 000) — the number of vertices in the tree.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ n).\n\n\n-----Output-----\n\nIn the first line print the minimum number of elements to change, in order to get a valid sequence.\n\nIn the second line, print any valid sequence possible to get from (a_1, a_2, ..., a_{n}) in the minimum number of changes. If there are many such sequences, any of them will be accepted.\n\n\n-----Examples-----\nInput\n4\n2 3 3 4\n\nOutput\n1\n2 3 4 4 \n\nInput\n5\n3 2 2 5 3\n\nOutput\n0\n3 2 2 5 3 \n\nInput\n8\n2 3 5 4 1 6 6 7\n\nOutput\n2\n2 3 7 8 1 6 6 7\n\n\n\n-----Note-----\n\nIn the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p_4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red. [Image] \n\nIn the second sample, the given sequence is already valid.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef fix_tree_sequence (n : Nat) (A : List Nat) : Nat × List Nat := sorry\n\ndef is_valid_tree (A : List Nat) : Bool := sorry\n\ntheorem fix_tree_sequence_properties \n  (n : Nat) \n  (A : List Nat)\n  (h : A.length = n) :\n  let (changes, result) := fix_tree_sequence n A\n  -- Result has same length\n  result.length = A.length ∧ \n  -- Changes non-negative (implicit for Nat)\n  -- Result is valid tree\n  is_valid_tree result = true ∧\n  -- Original array unchanged\n  A = A ∧\n  -- Changes matches actual differences\n  changes = (List.zip A result).foldl (fun acc p => if p.1 = p.2 then acc else acc + 1) 0\n  := sorry\n\ntheorem already_valid_tree\n  (A : List Nat)\n  (h : is_valid_tree A = true) :\n  let (changes, result) := fix_tree_sequence A.length A\n  changes = 0 ∧ result = A\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2095"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.\n\nSorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.\n\nEvery element of the sequence must appear in exactly one subsequence.\n\n\n-----Input-----\n\nThe first line of input data contains integer n (1 ≤ n ≤ 10^5) — the length of the sequence.\n\nThe second line of input data contains n different integers a_1, a_2, ..., a_{n} ( - 10^9 ≤ a_{i} ≤ 10^9) — the elements of the sequence. It is guaranteed that all elements of the sequence are distinct.\n\n\n-----Output-----\n\nIn the first line print the maximum number of subsequences k, which the original sequence can be split into while fulfilling the requirements.\n\nIn the next k lines print the description of subsequences in the following format: the number of elements in subsequence c_{i} (0 < c_{i} ≤ n), then c_{i} integers l_1, l_2, ..., l_{c}_{i} (1 ≤ l_{j} ≤ n) — indices of these elements in the original sequence. \n\nIndices could be printed in any order. Every index from 1 to n must appear in output exactly once.\n\nIf there are several possible answers, print any of them.\n\n\n-----Examples-----\nInput\n6\n3 2 1 6 5 4\n\nOutput\n4\n2 1 3\n1 2\n2 4 6\n1 5\n\nInput\n6\n83 -75 -49 11 37 62\n\nOutput\n1\n6 1 2 3 4 5 6\n\n\n\n-----Note-----\n\nIn the first sample output:\n\nAfter sorting the first subsequence we will get sequence 1 2 3 6 5 4.\n\nSorting the second subsequence changes nothing.\n\nAfter sorting the third subsequence we will get sequence 1 2 3 4 5 6.\n\nSorting the last subsequence changes nothing.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum (xs : List Nat) : Nat := \n  sorry\n\ndef max_subsequences (n : Nat) (arr : List Int) : List (List Nat) :=\n  sorry\n\ndef is_valid_result (n : Nat) (result : List (List Nat)) : Bool :=\n  sorry\n\ntheorem max_subsequences_valid {n : Nat} {arr : List Int} \n  (h1 : n > 0) \n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  is_valid_result n (max_subsequences n arr) := by\n  sorry\n\ntheorem max_subsequences_bounds {n : Nat} {arr : List Int} \n  (h1 : n > 0)\n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  1 ≤ result.head!.head! ∧ result.head!.head! ≤ n := by\n  sorry\n\ntheorem max_subsequences_sum {n : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  List.sum (result.tail.map (λ subseq => subseq.head!)) = n := by\n  sorry\n\ntheorem max_subsequences_lengths {n : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : n = arr.length) \n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  ∀ subseq ∈ result.tail, subseq.head! ≥ 1 := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2096", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.\n\nSorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.\n\nEvery element of the sequence must appear in exactly one subsequence.\n\n\n-----Input-----\n\nThe first line of input data contains integer n (1 ≤ n ≤ 10^5) — the length of the sequence.\n\nThe second line of input data contains n different integers a_1, a_2, ..., a_{n} ( - 10^9 ≤ a_{i} ≤ 10^9) — the elements of the sequence. It is guaranteed that all elements of the sequence are distinct.\n\n\n-----Output-----\n\nIn the first line print the maximum number of subsequences k, which the original sequence can be split into while fulfilling the requirements.\n\nIn the next k lines print the description of subsequences in the following format: the number of elements in subsequence c_{i} (0 < c_{i} ≤ n), then c_{i} integers l_1, l_2, ..., l_{c}_{i} (1 ≤ l_{j} ≤ n) — indices of these elements in the original sequence. \n\nIndices could be printed in any order. Every index from 1 to n must appear in output exactly once.\n\nIf there are several possible answers, print any of them.\n\n\n-----Examples-----\nInput\n6\n3 2 1 6 5 4\n\nOutput\n4\n2 1 3\n1 2\n2 4 6\n1 5\n\nInput\n6\n83 -75 -49 11 37 62\n\nOutput\n1\n6 1 2 3 4 5 6\n\n\n\n-----Note-----\n\nIn the first sample output:\n\nAfter sorting the first subsequence we will get sequence 1 2 3 6 5 4.\n\nSorting the second subsequence changes nothing.\n\nAfter sorting the third subsequence we will get sequence 1 2 3 4 5 6.\n\nSorting the last subsequence changes nothing.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum (xs : List Nat) : Nat := \n  sorry\n\ndef max_subsequences (n : Nat) (arr : List Int) : List (List Nat) :=\n  sorry\n\ndef is_valid_result (n : Nat) (result : List (List Nat)) : Bool :=\n  sorry\n\ntheorem max_subsequences_valid {n : Nat} {arr : List Int} \n  (h1 : n > 0) \n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  is_valid_result n (max_subsequences n arr) := by\n  sorry\n\ntheorem max_subsequences_bounds {n : Nat} {arr : List Int} \n  (h1 : n > 0)\n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  1 ≤ result.head!.head! ∧ result.head!.head! ≤ n := by\n  sorry\n\ntheorem max_subsequences_sum {n : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  List.sum (result.tail.map (λ subseq => subseq.head!)) = n := by\n  sorry\n\ntheorem max_subsequences_lengths {n : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : n = arr.length) \n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  ∀ subseq ∈ result.tail, subseq.head! ≥ 1 := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2096"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nLesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer a_{i} — the current skill level. All skills have the same maximum level A.\n\nAlong with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:  The number of skills that a character has perfected (i.e., such that a_{i} = A), multiplied by coefficient c_{f}. The minimum skill level among all skills (min a_{i}), multiplied by coefficient c_{m}. \n\nNow Lesha has m hacknetian currency units, which he is willing to spend. Each currency unit can increase the current level of any skill by 1 (if it's not equal to A yet). Help him spend his money in order to achieve the maximum possible value of the Force.\n\n\n-----Input-----\n\nThe first line of the input contains five space-separated integers n, A, c_{f}, c_{m} and m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 10^9, 0 ≤ c_{f}, c_{m} ≤ 1000, 0 ≤ m ≤ 10^15).\n\nThe second line contains exactly n integers a_{i} (0 ≤ a_{i} ≤ A), separated by spaces, — the current levels of skills.\n\n\n-----Output-----\n\nOn the first line print the maximum value of the Force that the character can achieve using no more than m currency units.\n\nOn the second line print n integers a'_{i} (a_{i} ≤ a'_{i} ≤ A), skill levels which one must achieve in order to reach the specified value of the Force, while using no more than m currency units. Numbers should be separated by spaces.\n\n\n-----Examples-----\nInput\n3 5 10 1 5\n1 3 1\n\nOutput\n12\n2 5 2 \n\nInput\n3 5 10 1 339\n1 3 1\n\nOutput\n35\n5 5 5 \n\n\n\n-----Note-----\n\nIn the first test the optimal strategy is to increase the second skill to its maximum, and increase the two others by 1.\n\nIn the second test one should increase all skills to maximum.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_hacknet (n A cf cm m : Nat) (skills : List Nat) : Nat × List Nat :=\n  sorry\n\ndef list_count {α} [BEq α] (p : α → Bool) (l : List α) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => (if p x then 1 else 0) + list_count p xs\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ntheorem solution_invariants {n A cf cm m : Nat} {skills ans : List Nat} {max_level : Nat}\n  (h : solve_hacknet n A cf cm m skills = (max_level, ans)) :\n  (ans.length = n) ∧ \n  (∀ x ∈ ans, x ≤ A) ∧\n  (list_sum (List.map (λ i => max 0 ((ans.get! i) - (skills.get! i))) \n    (List.range n)) ≤ m) ∧\n  (max_level = cf * (list_count (λ x => x == A) ans) + cm * (List.foldl min A ans)) := \n  sorry\n\ntheorem zero_money {n A cf : Nat} {skills : List Nat} \n  (h : skills.length = n) :\n  solve_hacknet n A cf 1 0 skills = (0, skills) := \n  sorry\n\ntheorem infinite_money {n A : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A 1 1 (Nat.max A 0) skills = \n    (n + A, List.replicate n A) :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2111", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nLesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer a_{i} — the current skill level. All skills have the same maximum level A.\n\nAlong with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:  The number of skills that a character has perfected (i.e., such that a_{i} = A), multiplied by coefficient c_{f}. The minimum skill level among all skills (min a_{i}), multiplied by coefficient c_{m}. \n\nNow Lesha has m hacknetian currency units, which he is willing to spend. Each currency unit can increase the current level of any skill by 1 (if it's not equal to A yet). Help him spend his money in order to achieve the maximum possible value of the Force.\n\n\n-----Input-----\n\nThe first line of the input contains five space-separated integers n, A, c_{f}, c_{m} and m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 10^9, 0 ≤ c_{f}, c_{m} ≤ 1000, 0 ≤ m ≤ 10^15).\n\nThe second line contains exactly n integers a_{i} (0 ≤ a_{i} ≤ A), separated by spaces, — the current levels of skills.\n\n\n-----Output-----\n\nOn the first line print the maximum value of the Force that the character can achieve using no more than m currency units.\n\nOn the second line print n integers a'_{i} (a_{i} ≤ a'_{i} ≤ A), skill levels which one must achieve in order to reach the specified value of the Force, while using no more than m currency units. Numbers should be separated by spaces.\n\n\n-----Examples-----\nInput\n3 5 10 1 5\n1 3 1\n\nOutput\n12\n2 5 2 \n\nInput\n3 5 10 1 339\n1 3 1\n\nOutput\n35\n5 5 5 \n\n\n\n-----Note-----\n\nIn the first test the optimal strategy is to increase the second skill to its maximum, and increase the two others by 1.\n\nIn the second test one should increase all skills to maximum.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_hacknet (n A cf cm m : Nat) (skills : List Nat) : Nat × List Nat :=\n  sorry\n\ndef list_count {α} [BEq α] (p : α → Bool) (l : List α) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => (if p x then 1 else 0) + list_count p xs\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ntheorem solution_invariants {n A cf cm m : Nat} {skills ans : List Nat} {max_level : Nat}\n  (h : solve_hacknet n A cf cm m skills = (max_level, ans)) :\n  (ans.length = n) ∧ \n  (∀ x ∈ ans, x ≤ A) ∧\n  (list_sum (List.map (λ i => max 0 ((ans.get! i) - (skills.get! i))) \n    (List.range n)) ≤ m) ∧\n  (max_level = cf * (list_count (λ x => x == A) ans) + cm * (List.foldl min A ans)) := \n  sorry\n\ntheorem zero_money {n A cf : Nat} {skills : List Nat} \n  (h : skills.length = n) :\n  solve_hacknet n A cf 1 0 skills = (0, skills) := \n  sorry\n\ntheorem infinite_money {n A : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A 1 1 (Nat.max A 0) skills = \n    (n + A, List.replicate n A) :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2111"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThere are n kangaroos with pockets. Each kangaroo has a size (integer number). A kangaroo can go into another kangaroo's pocket if and only if the size of kangaroo who hold the kangaroo is at least twice as large as the size of kangaroo who is held.\n\nEach kangaroo can hold at most one kangaroo, and the kangaroo who is held by another kangaroo cannot hold any kangaroos.\n\nThe kangaroo who is held by another kangaroo cannot be visible from outside. Please, find a plan of holding kangaroos with the minimal number of kangaroos who is visible.\n\n\n-----Input-----\n\nThe first line contains a single integer — n (1 ≤ n ≤ 5·10^5). Each of the next n lines contains an integer s_{i} — the size of the i-th kangaroo (1 ≤ s_{i} ≤ 10^5).\n\n\n-----Output-----\n\nOutput a single integer — the optimal number of visible kangaroos.\n\n\n-----Examples-----\nInput\n8\n2\n5\n7\n6\n9\n8\n4\n2\n\nOutput\n5\n\nInput\n8\n9\n1\n6\n2\n6\n5\n8\n3\n\nOutput\n5\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef min_visible_kangaroos (n : Nat) (sizes : List Nat) : Nat := sorry\n\n\n\n\n\n\n\n\n\ntheorem min_visible_kangaroos_edge_cases :\n  min_visible_kangaroos 1 [1] = 1 ∧\n  min_visible_kangaroos 2 [1, 3] = 1 ∧\n  min_visible_kangaroos 3 [1, 2, 4] = 2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2121", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThere are n kangaroos with pockets. Each kangaroo has a size (integer number). A kangaroo can go into another kangaroo's pocket if and only if the size of kangaroo who hold the kangaroo is at least twice as large as the size of kangaroo who is held.\n\nEach kangaroo can hold at most one kangaroo, and the kangaroo who is held by another kangaroo cannot hold any kangaroos.\n\nThe kangaroo who is held by another kangaroo cannot be visible from outside. Please, find a plan of holding kangaroos with the minimal number of kangaroos who is visible.\n\n\n-----Input-----\n\nThe first line contains a single integer — n (1 ≤ n ≤ 5·10^5). Each of the next n lines contains an integer s_{i} — the size of the i-th kangaroo (1 ≤ s_{i} ≤ 10^5).\n\n\n-----Output-----\n\nOutput a single integer — the optimal number of visible kangaroos.\n\n\n-----Examples-----\nInput\n8\n2\n5\n7\n6\n9\n8\n4\n2\n\nOutput\n5\n\nInput\n8\n9\n1\n6\n2\n6\n5\n8\n3\n\nOutput\n5\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef min_visible_kangaroos (n : Nat) (sizes : List Nat) : Nat := sorry\n\n\n\n\n\n\n\n\n\ntheorem min_visible_kangaroos_edge_cases :\n  min_visible_kangaroos 1 [1] = 1 ∧\n  min_visible_kangaroos 2 [1, 3] = 1 ∧\n  min_visible_kangaroos 3 [1, 2, 4] = 2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2121"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThis is the easier version of the problem. In this version, $1 \\le n \\le 10^5$ and $0 \\le a_i \\le 1$. You can hack this problem only if you solve and lock both problems.\n\nChristmas is coming, and our protagonist, Bob, is preparing a spectacular present for his long-time best friend Alice. This year, he decides to prepare $n$ boxes of chocolate, numbered from $1$ to $n$. Initially, the $i$-th box contains $a_i$ chocolate pieces.\n\nSince Bob is a typical nice guy, he will not send Alice $n$ empty boxes. In other words, at least one of $a_1, a_2, \\ldots, a_n$ is positive. Since Alice dislikes coprime sets, she will be happy only if there exists some integer $k > 1$ such that the number of pieces in each box is divisible by $k$. Note that Alice won't mind if there exists some empty boxes. \n\nCharlie, Alice's boyfriend, also is Bob's second best friend, so he decides to help Bob by rearranging the chocolate pieces. In one second, Charlie can pick up a piece in box $i$ and put it into either box $i-1$ or box $i+1$ (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Alice happy.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of chocolate boxes.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 1$) — the number of chocolate pieces in the $i$-th box.\n\nIt is guaranteed that at least one of $a_1, a_2, \\ldots, a_n$ is positive.\n\n\n-----Output-----\n\nIf there is no way for Charlie to make Alice happy, print $-1$.\n\nOtherwise, print a single integer $x$ — the minimum number of seconds for Charlie to help Bob make Alice happy.\n\n\n-----Examples-----\nInput\n3\n1 0 1\n\nOutput\n2\n\nInput\n1\n1\n\nOutput\n-1\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum (xs : List Nat) : Nat := \n  xs.foldl (· + ·) 0\n\ndef solve_christmas_boxes (n: Nat) (boxes: List Nat) : Int :=\nsorry\n\ntheorem solve_christmas_boxes_result_valid {n: Nat} {boxes: List Nat} :\n  let result := solve_christmas_boxes n boxes \n  result ≥ -1 :=\nsorry\n\ntheorem solve_christmas_boxes_single_one_impossible {n: Nat} {boxes: List Nat} :\n  boxes.length = n →\n  boxes.sum = 1 →\n  solve_christmas_boxes n boxes = -1 :=\nsorry\n\ntheorem solve_christmas_boxes_result_positive {n: Nat} {boxes: List Nat} :\n  let result := solve_christmas_boxes n boxes\n  result ≠ -1 → result > 0 :=\nsorry\n\ntheorem solve_christmas_boxes_length_matches {n: Nat} {boxes: List Nat} :\n  solve_christmas_boxes n boxes = solve_christmas_boxes n boxes →\n  boxes.length = n :=\nsorry\n\ntheorem solve_christmas_boxes_valid_values {n: Nat} {boxes: List Nat} :\n  solve_christmas_boxes n boxes = solve_christmas_boxes n boxes →\n  ∀ x ∈ boxes, x = 0 ∨ x = 1 :=\nsorry\n\ntheorem solve_christmas_boxes_all_ones {n: Nat} :\n  let boxes := List.replicate n 1\n  solve_christmas_boxes n boxes ≥ -1 :=\nsorry\n\ntheorem solve_christmas_boxes_all_zeros {n: Nat} :\n  let boxes := List.replicate n 0\n  solve_christmas_boxes n boxes = -1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2152", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThis is the easier version of the problem. In this version, $1 \\le n \\le 10^5$ and $0 \\le a_i \\le 1$. You can hack this problem only if you solve and lock both problems.\n\nChristmas is coming, and our protagonist, Bob, is preparing a spectacular present for his long-time best friend Alice. This year, he decides to prepare $n$ boxes of chocolate, numbered from $1$ to $n$. Initially, the $i$-th box contains $a_i$ chocolate pieces.\n\nSince Bob is a typical nice guy, he will not send Alice $n$ empty boxes. In other words, at least one of $a_1, a_2, \\ldots, a_n$ is positive. Since Alice dislikes coprime sets, she will be happy only if there exists some integer $k > 1$ such that the number of pieces in each box is divisible by $k$. Note that Alice won't mind if there exists some empty boxes. \n\nCharlie, Alice's boyfriend, also is Bob's second best friend, so he decides to help Bob by rearranging the chocolate pieces. In one second, Charlie can pick up a piece in box $i$ and put it into either box $i-1$ or box $i+1$ (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Alice happy.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of chocolate boxes.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 1$) — the number of chocolate pieces in the $i$-th box.\n\nIt is guaranteed that at least one of $a_1, a_2, \\ldots, a_n$ is positive.\n\n\n-----Output-----\n\nIf there is no way for Charlie to make Alice happy, print $-1$.\n\nOtherwise, print a single integer $x$ — the minimum number of seconds for Charlie to help Bob make Alice happy.\n\n\n-----Examples-----\nInput\n3\n1 0 1\n\nOutput\n2\n\nInput\n1\n1\n\nOutput\n-1\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum (xs : List Nat) : Nat := \n  xs.foldl (· + ·) 0\n\ndef solve_christmas_boxes (n: Nat) (boxes: List Nat) : Int :=\nsorry\n\ntheorem solve_christmas_boxes_result_valid {n: Nat} {boxes: List Nat} :\n  let result := solve_christmas_boxes n boxes \n  result ≥ -1 :=\nsorry\n\ntheorem solve_christmas_boxes_single_one_impossible {n: Nat} {boxes: List Nat} :\n  boxes.length = n →\n  boxes.sum = 1 →\n  solve_christmas_boxes n boxes = -1 :=\nsorry\n\ntheorem solve_christmas_boxes_result_positive {n: Nat} {boxes: List Nat} :\n  let result := solve_christmas_boxes n boxes\n  result ≠ -1 → result > 0 :=\nsorry\n\ntheorem solve_christmas_boxes_length_matches {n: Nat} {boxes: List Nat} :\n  solve_christmas_boxes n boxes = solve_christmas_boxes n boxes →\n  boxes.length = n :=\nsorry\n\ntheorem solve_christmas_boxes_valid_values {n: Nat} {boxes: List Nat} :\n  solve_christmas_boxes n boxes = solve_christmas_boxes n boxes →\n  ∀ x ∈ boxes, x = 0 ∨ x = 1 :=\nsorry\n\ntheorem solve_christmas_boxes_all_ones {n: Nat} :\n  let boxes := List.replicate n 1\n  solve_christmas_boxes n boxes ≥ -1 :=\nsorry\n\ntheorem solve_christmas_boxes_all_zeros {n: Nat} :\n  let boxes := List.replicate n 0\n  solve_christmas_boxes n boxes = -1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2152"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nAfter learning a lot about space exploration, a little girl named Ana wants to change the subject.\n\nAna is a girl who loves palindromes (string that can be read the same backwards as forward). She has learned how to check for a given string whether it's a palindrome or not, but soon she grew tired of this problem, so she came up with a more interesting one and she needs your help to solve it:\n\nYou are given an array of strings which consist of only small letters of the alphabet. Your task is to find how many palindrome pairs are there in the array. A palindrome pair is a pair of strings such that the following condition holds: at least one permutation of the concatenation of the two strings is a palindrome. In other words, if you have two strings, let's say \"aab\" and \"abcac\", and you concatenate them into \"aababcac\", we have to check if there exists a permutation of this new string such that it is a palindrome (in this case there exists the permutation \"aabccbaa\"). \n\nTwo pairs are considered different if the strings are located on different indices. The pair of strings with indices $(i,j)$ is considered the same as the pair $(j,i)$.\n\n\n-----Input-----\n\nThe first line contains a positive integer $N$ ($1 \\le N \\le 100\\,000$), representing the length of the input array.\n\nEacg of the next $N$ lines contains a string (consisting of lowercase English letters from 'a' to 'z') — an element of the input array. \n\nThe total number of characters in the input array will be less than $1\\,000\\,000$.\n\n\n-----Output-----\n\nOutput one number, representing how many palindrome pairs there are in the array.\n\n\n-----Examples-----\nInput\n3\naa\nbb\ncd\n\nOutput\n1\n\nInput\n6\naab\nabcac\ndffe\ned\naa\naade\n\nOutput\n6\n\n\n\n-----Note-----\n\nThe first example:  aa $+$ bb $\\to$ abba. \n\nThe second example:  aab $+$ abcac $=$ aababcac $\\to$ aabccbaa aab $+$ aa $=$ aabaa abcac $+$ aa $=$ abcacaa $\\to$ aacbcaa dffe $+$ ed $=$ dffeed $\\to$ fdeedf dffe $+$ aade $=$ dffeaade $\\to$ adfaafde ed $+$ aade $=$ edaade $\\to$ aeddea\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_palindrome_pairs (strings : List String) : Nat :=\n  sorry\n\ntheorem palindrome_pairs_non_negative (strings : List String) :\n  count_palindrome_pairs strings ≥ 0 :=\n  sorry\n\ntheorem empty_list_gives_zero :\n  count_palindrome_pairs [] = 0 :=\n  sorry\n\ntheorem singleton_list_gives_zero (s : String) :\n  count_palindrome_pairs [s] = 0 :=\n  sorry\n\ntheorem identical_strings_follow_pattern (s : String) (n : Nat) :\n  let strings := List.replicate n s\n  count_palindrome_pairs strings = n * (n - 1) / 2 :=\n  sorry\n\ntheorem empty_strings_pair_with_each_other (n : Nat) :\n  let empty_strings := List.replicate n \"\"\n  count_palindrome_pairs empty_strings = n * (n - 1) / 2 :=\n  sorry\n\ntheorem single_char_strings_pair_with_each_other (n : Nat) :\n  let a_strings := List.replicate n \"a\"\n  count_palindrome_pairs a_strings = n * (n - 1) / 2 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2252", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nAfter learning a lot about space exploration, a little girl named Ana wants to change the subject.\n\nAna is a girl who loves palindromes (string that can be read the same backwards as forward). She has learned how to check for a given string whether it's a palindrome or not, but soon she grew tired of this problem, so she came up with a more interesting one and she needs your help to solve it:\n\nYou are given an array of strings which consist of only small letters of the alphabet. Your task is to find how many palindrome pairs are there in the array. A palindrome pair is a pair of strings such that the following condition holds: at least one permutation of the concatenation of the two strings is a palindrome. In other words, if you have two strings, let's say \"aab\" and \"abcac\", and you concatenate them into \"aababcac\", we have to check if there exists a permutation of this new string such that it is a palindrome (in this case there exists the permutation \"aabccbaa\"). \n\nTwo pairs are considered different if the strings are located on different indices. The pair of strings with indices $(i,j)$ is considered the same as the pair $(j,i)$.\n\n\n-----Input-----\n\nThe first line contains a positive integer $N$ ($1 \\le N \\le 100\\,000$), representing the length of the input array.\n\nEacg of the next $N$ lines contains a string (consisting of lowercase English letters from 'a' to 'z') — an element of the input array. \n\nThe total number of characters in the input array will be less than $1\\,000\\,000$.\n\n\n-----Output-----\n\nOutput one number, representing how many palindrome pairs there are in the array.\n\n\n-----Examples-----\nInput\n3\naa\nbb\ncd\n\nOutput\n1\n\nInput\n6\naab\nabcac\ndffe\ned\naa\naade\n\nOutput\n6\n\n\n\n-----Note-----\n\nThe first example:  aa $+$ bb $\\to$ abba. \n\nThe second example:  aab $+$ abcac $=$ aababcac $\\to$ aabccbaa aab $+$ aa $=$ aabaa abcac $+$ aa $=$ abcacaa $\\to$ aacbcaa dffe $+$ ed $=$ dffeed $\\to$ fdeedf dffe $+$ aade $=$ dffeaade $\\to$ adfaafde ed $+$ aade $=$ edaade $\\to$ aeddea\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_palindrome_pairs (strings : List String) : Nat :=\n  sorry\n\ntheorem palindrome_pairs_non_negative (strings : List String) :\n  count_palindrome_pairs strings ≥ 0 :=\n  sorry\n\ntheorem empty_list_gives_zero :\n  count_palindrome_pairs [] = 0 :=\n  sorry\n\ntheorem singleton_list_gives_zero (s : String) :\n  count_palindrome_pairs [s] = 0 :=\n  sorry\n\ntheorem identical_strings_follow_pattern (s : String) (n : Nat) :\n  let strings := List.replicate n s\n  count_palindrome_pairs strings = n * (n - 1) / 2 :=\n  sorry\n\ntheorem empty_strings_pair_with_each_other (n : Nat) :\n  let empty_strings := List.replicate n \"\"\n  count_palindrome_pairs empty_strings = n * (n - 1) / 2 :=\n  sorry\n\ntheorem single_char_strings_pair_with_each_other (n : Nat) :\n  let a_strings := List.replicate n \"a\"\n  count_palindrome_pairs a_strings = n * (n - 1) / 2 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2252"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nNote that the only difference between String Transformation 1 and String Transformation 2 is in the move Koa does. In this version the letter $y$ Koa selects must be strictly greater alphabetically than $x$ (read statement for better understanding). You can make hacks in these problems independently.\n\nKoa the Koala has two strings $A$ and $B$ of the same length $n$ ($|A|=|B|=n$) consisting of the first $20$ lowercase English alphabet letters (ie. from a to t).\n\nIn one move Koa:\n\n  selects some subset of positions $p_1, p_2, \\ldots, p_k$ ($k \\ge 1; 1 \\le p_i \\le n; p_i \\neq p_j$ if $i \\neq j$) of $A$ such that $A_{p_1} = A_{p_2} = \\ldots = A_{p_k} = x$ (ie. all letters on this positions are equal to some letter $x$).\n\n  selects a letter $y$ (from the first $20$ lowercase letters in English alphabet) such that $y>x$ (ie. letter $y$ is strictly greater alphabetically than $x$).\n\n  sets each letter in positions $p_1, p_2, \\ldots, p_k$ to letter $y$. More formally: for each $i$ ($1 \\le i \\le k$) Koa sets $A_{p_i} = y$.\n\n Note that you can only modify letters in string $A$.\n\nKoa wants to know the smallest number of moves she has to do to make strings equal to each other ($A = B$) or to determine that there is no way to make them equal. Help her!\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains $t$ ($1 \\le t \\le 10$) — the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 10^5$) — the length of strings $A$ and $B$.\n\nThe second line of each test case contains string $A$ ($|A|=n$).\n\nThe third line of each test case contains string $B$ ($|B|=n$).\n\nBoth strings consists of the first $20$ lowercase English alphabet letters (ie. from a to t).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case:\n\nPrint on a single line the smallest number of moves she has to do to make strings equal to each other ($A = B$) or $-1$ if there is no way to make them equal.\n\n\n-----Example-----\nInput\n5\n3\naab\nbcc\n4\ncabc\nabcb\n3\nabc\ntsr\n4\naabd\ncccd\n5\nabcbd\nbcdda\n\nOutput\n2\n-1\n3\n2\n-1\n\n\n\n-----Note-----  In the $1$-st test case Koa:   selects positions $1$ and $2$ and sets $A_1 = A_2 = $ b ($\\color{red}{aa}b \\rightarrow \\color{blue}{bb}b$).  selects positions $2$ and $3$ and sets $A_2 = A_3 = $ c ($b\\color{red}{bb} \\rightarrow b\\color{blue}{cc}$). \n\n  In the $2$-nd test case Koa has no way to make string $A$ equal $B$.\n\n  In the $3$-rd test case Koa:   selects position $1$ and sets $A_1 = $ t ($\\color{red}{a}bc \\rightarrow \\color{blue}{t}bc$).  selects position $2$ and sets $A_2 = $ s ($t\\color{red}{b}c \\rightarrow t\\color{blue}{s}c$).  selects position $3$ and sets $A_3 = $ r ($ts\\color{red}{c} \\rightarrow ts\\color{blue}{r}$).\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_string_transformation (s1 s2 : String) : Int := sorry\n\ntheorem identical_strings_zero_transforms (s : String) :\n  solve_string_transformation s s = 0 := sorry\n\n\n\ntheorem result_bounds {s1 s2 : String} :\n  s1.length = s2.length →\n  solve_string_transformation s1 s2 ≠ -1 →\n  0 ≤ solve_string_transformation s1 s2 ∧ \n  solve_string_transformation s1 s2 ≤ s1.length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2257", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nNote that the only difference between String Transformation 1 and String Transformation 2 is in the move Koa does. In this version the letter $y$ Koa selects must be strictly greater alphabetically than $x$ (read statement for better understanding). You can make hacks in these problems independently.\n\nKoa the Koala has two strings $A$ and $B$ of the same length $n$ ($|A|=|B|=n$) consisting of the first $20$ lowercase English alphabet letters (ie. from a to t).\n\nIn one move Koa:\n\n  selects some subset of positions $p_1, p_2, \\ldots, p_k$ ($k \\ge 1; 1 \\le p_i \\le n; p_i \\neq p_j$ if $i \\neq j$) of $A$ such that $A_{p_1} = A_{p_2} = \\ldots = A_{p_k} = x$ (ie. all letters on this positions are equal to some letter $x$).\n\n  selects a letter $y$ (from the first $20$ lowercase letters in English alphabet) such that $y>x$ (ie. letter $y$ is strictly greater alphabetically than $x$).\n\n  sets each letter in positions $p_1, p_2, \\ldots, p_k$ to letter $y$. More formally: for each $i$ ($1 \\le i \\le k$) Koa sets $A_{p_i} = y$.\n\n Note that you can only modify letters in string $A$.\n\nKoa wants to know the smallest number of moves she has to do to make strings equal to each other ($A = B$) or to determine that there is no way to make them equal. Help her!\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains $t$ ($1 \\le t \\le 10$) — the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 10^5$) — the length of strings $A$ and $B$.\n\nThe second line of each test case contains string $A$ ($|A|=n$).\n\nThe third line of each test case contains string $B$ ($|B|=n$).\n\nBoth strings consists of the first $20$ lowercase English alphabet letters (ie. from a to t).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case:\n\nPrint on a single line the smallest number of moves she has to do to make strings equal to each other ($A = B$) or $-1$ if there is no way to make them equal.\n\n\n-----Example-----\nInput\n5\n3\naab\nbcc\n4\ncabc\nabcb\n3\nabc\ntsr\n4\naabd\ncccd\n5\nabcbd\nbcdda\n\nOutput\n2\n-1\n3\n2\n-1\n\n\n\n-----Note-----  In the $1$-st test case Koa:   selects positions $1$ and $2$ and sets $A_1 = A_2 = $ b ($\\color{red}{aa}b \\rightarrow \\color{blue}{bb}b$).  selects positions $2$ and $3$ and sets $A_2 = A_3 = $ c ($b\\color{red}{bb} \\rightarrow b\\color{blue}{cc}$). \n\n  In the $2$-nd test case Koa has no way to make string $A$ equal $B$.\n\n  In the $3$-rd test case Koa:   selects position $1$ and sets $A_1 = $ t ($\\color{red}{a}bc \\rightarrow \\color{blue}{t}bc$).  selects position $2$ and sets $A_2 = $ s ($t\\color{red}{b}c \\rightarrow t\\color{blue}{s}c$).  selects position $3$ and sets $A_3 = $ r ($ts\\color{red}{c} \\rightarrow ts\\color{blue}{r}$).\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_string_transformation (s1 s2 : String) : Int := sorry\n\ntheorem identical_strings_zero_transforms (s : String) :\n  solve_string_transformation s s = 0 := sorry\n\n\n\ntheorem result_bounds {s1 s2 : String} :\n  s1.length = s2.length →\n  solve_string_transformation s1 s2 ≠ -1 →\n  0 ≤ solve_string_transformation s1 s2 ∧ \n  solve_string_transformation s1 s2 ≤ s1.length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2257"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThere are M chairs arranged in a line. The coordinate of the i-th chair (1 ≤ i ≤ M) is i.\nN people of the Takahashi clan played too much games, and they are all suffering from backaches. They need to sit in chairs and rest, but they are particular about which chairs they sit in. Specifically, the i-th person wishes to sit in a chair whose coordinate is not greater than L_i, or not less than R_i. Naturally, only one person can sit in the same chair.\nIt may not be possible for all of them to sit in their favorite chairs, if nothing is done.\nAoki, who cares for the health of the people of the Takahashi clan, decides to provide additional chairs so that all of them can sit in chairs at their favorite positions.\nAdditional chairs can be placed at arbitrary real coordinates. Find the minimum required number of additional chairs.\n\n-----Constraints-----\n - 1 ≤ N,M ≤ 2 × 10^5\n - 0 ≤ L_i < R_i ≤ M + 1(1 ≤ i ≤ N)\n - All input values are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nL_1 R_1\n:\nL_N R_N\n\n-----Output-----\nPrint the minimum required number of additional chairs.\n\n-----Sample Input-----\n4 4\n0 3\n2 3\n1 3\n3 4\n\n-----Sample Output-----\n0\n\nThe four people can sit in chairs at the coordinates 3, 2, 1 and 4, respectively, and no more chair is needed.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure LazySegmentTree (M : Nat) where\n  mk ::\n\ndef initTree (M : Nat) : LazySegmentTree M := sorry\ndef updateTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int → LazySegmentTree M := sorry\ndef queryTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int := sorry\n\ndef LV : Nat := sorry\ndef N0 : Nat := sorry\ndef INF : Int := sorry\n\ntheorem lst_initialization_invariants {M : Nat} (h : M > 0) (h2 : M ≤ 100) :\n  N0 = 2^LV ∧ N0 > 0 := by sorry\n\ntheorem segment_tree_operations_sound {M : Nat} (l r : Nat) (x : Int)\n  (h1 : l ≤ r) (h2 : r < M) (h3 : M > 0)\n  (h4 : l ≤ 10) (h5 : r ≤ 10) (h6 : x ≥ -100) (h7 : x ≤ 100) :\n  let lst := initTree M\n  let lst' := updateTree M lst l r x\n  let result := queryTree M lst' l r \n  x ≥ 0 → result ≤ INF := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2266", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThere are M chairs arranged in a line. The coordinate of the i-th chair (1 ≤ i ≤ M) is i.\nN people of the Takahashi clan played too much games, and they are all suffering from backaches. They need to sit in chairs and rest, but they are particular about which chairs they sit in. Specifically, the i-th person wishes to sit in a chair whose coordinate is not greater than L_i, or not less than R_i. Naturally, only one person can sit in the same chair.\nIt may not be possible for all of them to sit in their favorite chairs, if nothing is done.\nAoki, who cares for the health of the people of the Takahashi clan, decides to provide additional chairs so that all of them can sit in chairs at their favorite positions.\nAdditional chairs can be placed at arbitrary real coordinates. Find the minimum required number of additional chairs.\n\n-----Constraints-----\n - 1 ≤ N,M ≤ 2 × 10^5\n - 0 ≤ L_i < R_i ≤ M + 1(1 ≤ i ≤ N)\n - All input values are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nL_1 R_1\n:\nL_N R_N\n\n-----Output-----\nPrint the minimum required number of additional chairs.\n\n-----Sample Input-----\n4 4\n0 3\n2 3\n1 3\n3 4\n\n-----Sample Output-----\n0\n\nThe four people can sit in chairs at the coordinates 3, 2, 1 and 4, respectively, and no more chair is needed.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure LazySegmentTree (M : Nat) where\n  mk ::\n\ndef initTree (M : Nat) : LazySegmentTree M := sorry\ndef updateTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int → LazySegmentTree M := sorry\ndef queryTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int := sorry\n\ndef LV : Nat := sorry\ndef N0 : Nat := sorry\ndef INF : Int := sorry\n\ntheorem lst_initialization_invariants {M : Nat} (h : M > 0) (h2 : M ≤ 100) :\n  N0 = 2^LV ∧ N0 > 0 := by sorry\n\ntheorem segment_tree_operations_sound {M : Nat} (l r : Nat) (x : Int)\n  (h1 : l ≤ r) (h2 : r < M) (h3 : M > 0)\n  (h4 : l ≤ 10) (h5 : r ≤ 10) (h6 : x ≥ -100) (h7 : x ≤ 100) :\n  let lst := initTree M\n  let lst' := updateTree M lst l r x\n  let result := queryTree M lst' l r \n  x ≥ 0 → result ≤ INF := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2266"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn the State of Takahashi in AtCoderian Federation, there are N cities, numbered 1, 2, ..., N.\nM bidirectional roads connect these cities.\nThe i-th road connects City A_i and City B_i.\nEvery road connects two distinct cities.\nAlso, for any two cities, there is at most one road that directly connects them.\nOne day, it was decided that the State of Takahashi would be divided into two states, Taka and Hashi.\nAfter the division, each city in Takahashi would belong to either Taka or Hashi.\nIt is acceptable for all the cities to belong Taka, or for all the cities to belong Hashi.\nHere, the following condition should be satisfied:\n - Any two cities in the same state, Taka or Hashi, are directly connected by a road.\nFind the minimum possible number of roads whose endpoint cities belong to the same state.\nIf it is impossible to divide the cities into Taka and Hashi so that the condition is satisfied, print -1.\n\n-----Constraints-----\n - 2 \\leq N \\leq 700\n - 0 \\leq M \\leq N(N-1)/2\n - 1 \\leq A_i \\leq N\n - 1 \\leq B_i \\leq N\n - A_i \\neq B_i\n - If i \\neq j, at least one of the following holds: A_i \\neq A_j and B_i \\neq B_j.\n - If i \\neq j, at least one of the following holds: A_i \\neq B_j and B_i \\neq A_j.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 B_1\nA_2 B_2\n:\nA_M B_M\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n5 5\n1 2\n1 3\n3 4\n3 5\n4 5\n\n-----Sample Output-----\n4\n\nFor example, if the cities 1, 2 belong to Taka and the cities 3, 4, 5 belong to Hashi, the condition is satisfied.\nHere, the number of roads whose endpoint cities belong to the same state, is 4.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_city_division (n m : Nat) (edges : List (Nat × Nat)) : Int :=\nsorry\n\ntheorem solve_city_division_original_cases :\n  (solve_city_division 5 5 [(1,2), (1,3), (3,4), (3,5), (4,5)] = 4) ∧\n  (solve_city_division 5 1 [(1,2)] = -1) ∧\n  (solve_city_division 4 3 [(1,2), (1,3), (2,3)] = 3) :=\nsorry\n\n\n\ntheorem solve_city_division_single_edge :\n  solve_city_division 2 1 [(1,2)] = 0 :=\nsorry\n\ntheorem solve_city_division_bounds :\n  ∀ (n m : Nat) (edges : List (Nat × Nat)),\n  n ≥ 2 →\n  m ≤ n * (n-1) / 2 →\n  edges.length = m →\n  solve_city_division n m edges ≥ -1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2269", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn the State of Takahashi in AtCoderian Federation, there are N cities, numbered 1, 2, ..., N.\nM bidirectional roads connect these cities.\nThe i-th road connects City A_i and City B_i.\nEvery road connects two distinct cities.\nAlso, for any two cities, there is at most one road that directly connects them.\nOne day, it was decided that the State of Takahashi would be divided into two states, Taka and Hashi.\nAfter the division, each city in Takahashi would belong to either Taka or Hashi.\nIt is acceptable for all the cities to belong Taka, or for all the cities to belong Hashi.\nHere, the following condition should be satisfied:\n - Any two cities in the same state, Taka or Hashi, are directly connected by a road.\nFind the minimum possible number of roads whose endpoint cities belong to the same state.\nIf it is impossible to divide the cities into Taka and Hashi so that the condition is satisfied, print -1.\n\n-----Constraints-----\n - 2 \\leq N \\leq 700\n - 0 \\leq M \\leq N(N-1)/2\n - 1 \\leq A_i \\leq N\n - 1 \\leq B_i \\leq N\n - A_i \\neq B_i\n - If i \\neq j, at least one of the following holds: A_i \\neq A_j and B_i \\neq B_j.\n - If i \\neq j, at least one of the following holds: A_i \\neq B_j and B_i \\neq A_j.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 B_1\nA_2 B_2\n:\nA_M B_M\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n5 5\n1 2\n1 3\n3 4\n3 5\n4 5\n\n-----Sample Output-----\n4\n\nFor example, if the cities 1, 2 belong to Taka and the cities 3, 4, 5 belong to Hashi, the condition is satisfied.\nHere, the number of roads whose endpoint cities belong to the same state, is 4.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_city_division (n m : Nat) (edges : List (Nat × Nat)) : Int :=\nsorry\n\ntheorem solve_city_division_original_cases :\n  (solve_city_division 5 5 [(1,2), (1,3), (3,4), (3,5), (4,5)] = 4) ∧\n  (solve_city_division 5 1 [(1,2)] = -1) ∧\n  (solve_city_division 4 3 [(1,2), (1,3), (2,3)] = 3) :=\nsorry\n\n\n\ntheorem solve_city_division_single_edge :\n  solve_city_division 2 1 [(1,2)] = 0 :=\nsorry\n\ntheorem solve_city_division_bounds :\n  ∀ (n m : Nat) (edges : List (Nat × Nat)),\n  n ≥ 2 →\n  m ≤ n * (n-1) / 2 →\n  edges.length = m →\n  solve_city_division n m edges ≥ -1 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2269"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe have a permutation of the integers from 1 through N, p_1, p_2, .., p_N.\nWe also have M pairs of two integers between 1 and N (inclusive), represented as (x_1,y_1), (x_2,y_2), .., (x_M,y_M).\nAtCoDeer the deer is going to perform the following operation on p as many times as desired so that the number of i (1 ≤ i ≤ N) such that p_i = i is maximized:\n - Choose j such that 1 ≤ j ≤ M, and swap p_{x_j} and p_{y_j}.\nFind the maximum possible number of i such that p_i = i after operations.\n\n-----Constraints-----\n - 2 ≤ N ≤ 10^5\n - 1 ≤ M ≤ 10^5\n - p is a permutation of integers from 1 through N.\n - 1 ≤ x_j,y_j ≤ N\n - x_j ≠ y_j\n - If i ≠ j, \\{x_i,y_i\\} ≠ \\{x_j,y_j\\}.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\np_1 p_2 .. p_N\nx_1 y_1\nx_2 y_2\n:\nx_M y_M\n\n-----Output-----\nPrint the maximum possible number of i such that p_i = i after operations.\n\n-----Sample Input-----\n5 2\n5 3 1 4 2\n1 3\n5 4\n\n-----Sample Output-----\n2\n\nIf we perform the operation by choosing j=1, p becomes 1 3 5 4 2, which is optimal, so the answer is 2.\n```\n#####\n\nTo answer this question, you need to replace the 11 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure UnionFind where\n  size : Array Nat\n  parent : Array Nat\n\ndef UnionFind.new (n : Nat) : UnionFind := sorry\ndef UnionFind.isConnected (uf : UnionFind) (x y : Nat) : Bool := sorry\ndef UnionFind.unite (uf : UnionFind) (x y : Nat) : UnionFind := sorry\ndef solve (n m : Nat) (p : List Nat) (swaps : List (Nat × Nat)) : Nat := sorry\n\ntheorem UnionFind_init (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  Array.size (UnionFind.size uf) = n ∧ \n  Array.size (UnionFind.parent uf) = n ∧\n  (∀ i, i < n → (UnionFind.size uf)[i]! = 1) ∧\n  (∀ i, i < n → (UnionFind.parent uf)[i]! = i) := by sorry\n\ntheorem UnionFind_reflexive (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i < n → UnionFind.isConnected uf i i = true := by sorry\n\ntheorem UnionFind_symmetry (n : Nat) (h : 1 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i < n-1 → \n    let uf' := UnionFind.unite uf i (i+1);\n    UnionFind.isConnected uf' i (i+1) = true ∧ \n    UnionFind.isConnected uf' (i+1) i = true := by sorry\n\ntheorem solve_no_swaps (n m : Nat) (h1 : 0 < n) (h2 : n ≤ 20) (h3 : m ≤ 10) :\n  let p := List.range n;\n  let swaps := [];\n  solve n m (p.map (·+1)) swaps = n := by sorry\n\ntheorem solve_valid_swaps (n : Nat) (swaps : List (Nat × Nat)) \n  (h1 : 0 < n) (h2 : n ≤ 20) (h3 : swaps.length ≤ 10) :\n  let p := List.range n |>.map (·+1);\n  let result := solve n swaps.length p swaps;\n  0 ≤ result ∧ result ≤ n := by sorry\n\ndef isValidPerm (arr : List Nat) : Bool := sorry\n\ntheorem solve_permutation_property (p : List Nat) \n  (h1 : p.length ≤ 20) (h2 : p.length > 0)\n  (h3 : isValidPerm (p.map (·-1)) = true) :\n  let n := p.length;\n  let result := solve n 0 p [];\n  0 ≤ result ∧ result ≤ n := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2271", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe have a permutation of the integers from 1 through N, p_1, p_2, .., p_N.\nWe also have M pairs of two integers between 1 and N (inclusive), represented as (x_1,y_1), (x_2,y_2), .., (x_M,y_M).\nAtCoDeer the deer is going to perform the following operation on p as many times as desired so that the number of i (1 ≤ i ≤ N) such that p_i = i is maximized:\n - Choose j such that 1 ≤ j ≤ M, and swap p_{x_j} and p_{y_j}.\nFind the maximum possible number of i such that p_i = i after operations.\n\n-----Constraints-----\n - 2 ≤ N ≤ 10^5\n - 1 ≤ M ≤ 10^5\n - p is a permutation of integers from 1 through N.\n - 1 ≤ x_j,y_j ≤ N\n - x_j ≠ y_j\n - If i ≠ j, \\{x_i,y_i\\} ≠ \\{x_j,y_j\\}.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\np_1 p_2 .. p_N\nx_1 y_1\nx_2 y_2\n:\nx_M y_M\n\n-----Output-----\nPrint the maximum possible number of i such that p_i = i after operations.\n\n-----Sample Input-----\n5 2\n5 3 1 4 2\n1 3\n5 4\n\n-----Sample Output-----\n2\n\nIf we perform the operation by choosing j=1, p becomes 1 3 5 4 2, which is optimal, so the answer is 2.\n```\n#####\n\nTo answer this question, you need to replace the 11 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure UnionFind where\n  size : Array Nat\n  parent : Array Nat\n\ndef UnionFind.new (n : Nat) : UnionFind := sorry\ndef UnionFind.isConnected (uf : UnionFind) (x y : Nat) : Bool := sorry\ndef UnionFind.unite (uf : UnionFind) (x y : Nat) : UnionFind := sorry\ndef solve (n m : Nat) (p : List Nat) (swaps : List (Nat × Nat)) : Nat := sorry\n\ntheorem UnionFind_init (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  Array.size (UnionFind.size uf) = n ∧ \n  Array.size (UnionFind.parent uf) = n ∧\n  (∀ i, i < n → (UnionFind.size uf)[i]! = 1) ∧\n  (∀ i, i < n → (UnionFind.parent uf)[i]! = i) := by sorry\n\ntheorem UnionFind_reflexive (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i < n → UnionFind.isConnected uf i i = true := by sorry\n\ntheorem UnionFind_symmetry (n : Nat) (h : 1 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i < n-1 → \n    let uf' := UnionFind.unite uf i (i+1);\n    UnionFind.isConnected uf' i (i+1) = true ∧ \n    UnionFind.isConnected uf' (i+1) i = true := by sorry\n\ntheorem solve_no_swaps (n m : Nat) (h1 : 0 < n) (h2 : n ≤ 20) (h3 : m ≤ 10) :\n  let p := List.range n;\n  let swaps := [];\n  solve n m (p.map (·+1)) swaps = n := by sorry\n\ntheorem solve_valid_swaps (n : Nat) (swaps : List (Nat × Nat)) \n  (h1 : 0 < n) (h2 : n ≤ 20) (h3 : swaps.length ≤ 10) :\n  let p := List.range n |>.map (·+1);\n  let result := solve n swaps.length p swaps;\n  0 ≤ result ∧ result ≤ n := by sorry\n\ndef isValidPerm (arr : List Nat) : Bool := sorry\n\ntheorem solve_permutation_property (p : List Nat) \n  (h1 : p.length ≤ 20) (h2 : p.length > 0)\n  (h3 : isValidPerm (p.map (·-1)) = true) :\n  let n := p.length;\n  let result := solve n 0 p [];\n  0 ≤ result ∧ result ≤ n := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2271"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed.\nLet the total number of sequences listed in FEIS be X. Among those sequences, find the (X/2)-th (rounded up to the nearest integer) lexicographically smallest one.\n\n-----Constraints-----\n - 1 \\leq N,K \\leq 3 × 10^5\n - N and K are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nK N\n\n-----Output-----\nPrint the (X/2)-th (rounded up to the nearest integer) lexicographically smallest sequence listed in FEIS, with spaces in between, where X is the total number of sequences listed in FEIS.\n\n-----Sample Input-----\n3 2\n\n-----Sample Output-----\n2 1 \n\nThere are 12 sequences listed in FEIS: (1),(1,1),(1,2),(1,3),(2),(2,1),(2,2),(2,3),(3),(3,1),(3,2),(3,3).\nThe (12/2 = 6)-th lexicographically smallest one among them is (2,1).\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_sequence (k n : Nat) : List Nat :=\n  sorry\n\ntheorem sequence_values {k n : Nat} (h1 : k ≥ 1) (h2 : n ≥ 1) :\n  let seq := find_sequence k n\n  ∀ x ∈ seq, 0 < x ∧ x ≤ k :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2286", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed.\nLet the total number of sequences listed in FEIS be X. Among those sequences, find the (X/2)-th (rounded up to the nearest integer) lexicographically smallest one.\n\n-----Constraints-----\n - 1 \\leq N,K \\leq 3 × 10^5\n - N and K are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nK N\n\n-----Output-----\nPrint the (X/2)-th (rounded up to the nearest integer) lexicographically smallest sequence listed in FEIS, with spaces in between, where X is the total number of sequences listed in FEIS.\n\n-----Sample Input-----\n3 2\n\n-----Sample Output-----\n2 1 \n\nThere are 12 sequences listed in FEIS: (1),(1,1),(1,2),(1,3),(2),(2,1),(2,2),(2,3),(3),(3,1),(3,2),(3,3).\nThe (12/2 = 6)-th lexicographically smallest one among them is (2,1).\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_sequence (k n : Nat) : List Nat :=\n  sorry\n\ntheorem sequence_values {k n : Nat} (h1 : k ≥ 1) (h2 : n ≥ 1) :\n  let seq := find_sequence k n\n  ∀ x ∈ seq, 0 < x ∧ x ≤ k :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2286"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe have a sandglass consisting of two bulbs, bulb A and bulb B. These bulbs contain some amount of sand.\nWhen we put the sandglass, either bulb A or B lies on top of the other and becomes the upper bulb. The other bulb becomes the lower bulb.\nThe sand drops from the upper bulb to the lower bulb at a rate of 1 gram per second.\nWhen the upper bulb no longer contains any sand, nothing happens.\nInitially at time 0, bulb A is the upper bulb and contains a grams of sand; bulb B contains X-a grams of sand (for a total of X grams).\nWe will turn over the sandglass at time r_1,r_2,..,r_K. Assume that this is an instantaneous action and takes no time. Here, time t refer to the time t seconds after time 0.\nYou are given Q queries.\nEach query is in the form of (t_i,a_i).\nFor each query, assume that a=a_i and find the amount of sand that would be contained in bulb A at time t_i.\n\n-----Constraints-----\n - 1≤X≤10^9\n - 1≤K≤10^5\n - 1≤r_1<r_2< .. <r_K≤10^9\n - 1≤Q≤10^5\n - 0≤t_1<t_2< .. <t_Q≤10^9\n - 0≤a_i≤X (1≤i≤Q)\n - All input values are integers.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nX\nK\nr_1 r_2 .. r_K\nQ\nt_1 a_1\nt_2 a_2\n:\nt_Q a_Q\n\n-----Output-----\nFor each query, print the answer in its own line.\n\n-----Sample Input-----\n180\n3\n60 120 180\n3\n30 90\n61 1\n180 180\n\n-----Sample Output-----\n60\n1\n120\n\nIn the first query, 30 out of the initial 90 grams of sand will drop from bulb A, resulting in 60 grams.\nIn the second query, the initial 1 gram of sand will drop from bulb A, and nothing will happen for the next 59 seconds. Then, we will turn over the sandglass, and 1 second after this, bulb A contains 1 gram of sand at the time in question.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_sandglass_wrapped (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) : List Nat := sorry\n\ntheorem sandglass_results_length_matches_queries (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) :\n  queries.length = Q → (solve_sandglass_wrapped X K r Q queries).length = Q := sorry\n\ntheorem sandglass_results_within_bounds (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) \n  (result : Nat) : \n  result ∈ solve_sandglass_wrapped X K r Q queries → result ≤ X ∧ result ≥ 0 := sorry\n\ntheorem sandglass_each_result_valid (X K : Nat) (r : List Nat) (Q : Nat) \n  (queries : List (Nat × Nat)) (t a : Nat) :\n  (t, a) ∈ queries → \n  ∃ result, result ∈ solve_sandglass_wrapped X K r Q queries ∧ result ≤ X ∧ result ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2288", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe have a sandglass consisting of two bulbs, bulb A and bulb B. These bulbs contain some amount of sand.\nWhen we put the sandglass, either bulb A or B lies on top of the other and becomes the upper bulb. The other bulb becomes the lower bulb.\nThe sand drops from the upper bulb to the lower bulb at a rate of 1 gram per second.\nWhen the upper bulb no longer contains any sand, nothing happens.\nInitially at time 0, bulb A is the upper bulb and contains a grams of sand; bulb B contains X-a grams of sand (for a total of X grams).\nWe will turn over the sandglass at time r_1,r_2,..,r_K. Assume that this is an instantaneous action and takes no time. Here, time t refer to the time t seconds after time 0.\nYou are given Q queries.\nEach query is in the form of (t_i,a_i).\nFor each query, assume that a=a_i and find the amount of sand that would be contained in bulb A at time t_i.\n\n-----Constraints-----\n - 1≤X≤10^9\n - 1≤K≤10^5\n - 1≤r_1<r_2< .. <r_K≤10^9\n - 1≤Q≤10^5\n - 0≤t_1<t_2< .. <t_Q≤10^9\n - 0≤a_i≤X (1≤i≤Q)\n - All input values are integers.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nX\nK\nr_1 r_2 .. r_K\nQ\nt_1 a_1\nt_2 a_2\n:\nt_Q a_Q\n\n-----Output-----\nFor each query, print the answer in its own line.\n\n-----Sample Input-----\n180\n3\n60 120 180\n3\n30 90\n61 1\n180 180\n\n-----Sample Output-----\n60\n1\n120\n\nIn the first query, 30 out of the initial 90 grams of sand will drop from bulb A, resulting in 60 grams.\nIn the second query, the initial 1 gram of sand will drop from bulb A, and nothing will happen for the next 59 seconds. Then, we will turn over the sandglass, and 1 second after this, bulb A contains 1 gram of sand at the time in question.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_sandglass_wrapped (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) : List Nat := sorry\n\ntheorem sandglass_results_length_matches_queries (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) :\n  queries.length = Q → (solve_sandglass_wrapped X K r Q queries).length = Q := sorry\n\ntheorem sandglass_results_within_bounds (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) \n  (result : Nat) : \n  result ∈ solve_sandglass_wrapped X K r Q queries → result ≤ X ∧ result ≥ 0 := sorry\n\ntheorem sandglass_each_result_valid (X K : Nat) (r : List Nat) (Q : Nat) \n  (queries : List (Nat × Nat)) (t a : Nat) :\n  (t, a) ∈ queries → \n  ∃ result, result ∈ solve_sandglass_wrapped X K r Q queries ∧ result ≤ X ∧ result ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2288"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThere are N bags, each containing two white balls. The i-th box contains two balls with integers x_i and y_i written on them, respectively.\nFor each of these bags, you will paint one of the balls red, and paint the other blue.\nAfterwards, the 2N balls will be classified according to color.\nThen, we will define the following:\n - R_{max}: the maximum integer written on a ball painted in red\n - R_{min}: the minimum integer written on a ball painted in red\n - B_{max}: the maximum integer written on a ball painted in blue\n - B_{min}: the minimum integer written on a ball painted in blue\nFind the minimum possible value of (R_{max} - R_{min}) \\times (B_{max} - B_{min}).\n\n-----Constraints-----\n - 1 ≤ N ≤ 200,000\n - 1 ≤ x_i, y_i ≤ 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nx_1 y_1\nx_2 y_2\n:\nx_N y_N\n\n-----Output-----\nPrint the minimum possible value.\n\n-----Sample Input-----\n3\n1 2\n3 4\n5 6\n\n-----Sample Output-----\n15\n\nThe optimal solution is to paint the balls with x_1, x_2, y_3 red, and paint the balls with y_1, y_2, x_3 blue.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_colored_balls (n : Nat) (pairs : List (List Nat)) : Nat := sorry\n\ntheorem solve_colored_balls_non_negative (n : Nat) (pairs : List (List Nat)) : \n  solve_colored_balls n pairs ≥ 0 := sorry\n\ntheorem solve_colored_balls_max_bound (n : Nat) (pairs : List (List Nat)) :\n  solve_colored_balls n pairs ≤ (10^9 - 1) * (10^9 - 1) := sorry\n\ntheorem solve_colored_balls_reverse_invariant (n : Nat) (pairs : List (List Nat)) \n  (h₁ : ∀ p ∈ pairs, p.length = 2) :\n  solve_colored_balls n pairs = \n  solve_colored_balls n (pairs.map (fun p => [p.get ⟨1, sorry⟩, p.get ⟨0, sorry⟩])) := sorry\n\ntheorem solve_colored_balls_identical_pairs (n : Nat) :\n  solve_colored_balls n (List.replicate n [1,1]) = 0 := sorry\n\ntheorem solve_colored_balls_edge_case :\n  solve_colored_balls 2 [[1,1], [1000000000,1000000000]] = \n  (1000000000-1) * (1000000000-1) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2294", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThere are N bags, each containing two white balls. The i-th box contains two balls with integers x_i and y_i written on them, respectively.\nFor each of these bags, you will paint one of the balls red, and paint the other blue.\nAfterwards, the 2N balls will be classified according to color.\nThen, we will define the following:\n - R_{max}: the maximum integer written on a ball painted in red\n - R_{min}: the minimum integer written on a ball painted in red\n - B_{max}: the maximum integer written on a ball painted in blue\n - B_{min}: the minimum integer written on a ball painted in blue\nFind the minimum possible value of (R_{max} - R_{min}) \\times (B_{max} - B_{min}).\n\n-----Constraints-----\n - 1 ≤ N ≤ 200,000\n - 1 ≤ x_i, y_i ≤ 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nx_1 y_1\nx_2 y_2\n:\nx_N y_N\n\n-----Output-----\nPrint the minimum possible value.\n\n-----Sample Input-----\n3\n1 2\n3 4\n5 6\n\n-----Sample Output-----\n15\n\nThe optimal solution is to paint the balls with x_1, x_2, y_3 red, and paint the balls with y_1, y_2, x_3 blue.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_colored_balls (n : Nat) (pairs : List (List Nat)) : Nat := sorry\n\ntheorem solve_colored_balls_non_negative (n : Nat) (pairs : List (List Nat)) : \n  solve_colored_balls n pairs ≥ 0 := sorry\n\ntheorem solve_colored_balls_max_bound (n : Nat) (pairs : List (List Nat)) :\n  solve_colored_balls n pairs ≤ (10^9 - 1) * (10^9 - 1) := sorry\n\ntheorem solve_colored_balls_reverse_invariant (n : Nat) (pairs : List (List Nat)) \n  (h₁ : ∀ p ∈ pairs, p.length = 2) :\n  solve_colored_balls n pairs = \n  solve_colored_balls n (pairs.map (fun p => [p.get ⟨1, sorry⟩, p.get ⟨0, sorry⟩])) := sorry\n\ntheorem solve_colored_balls_identical_pairs (n : Nat) :\n  solve_colored_balls n (List.replicate n [1,1]) = 0 := sorry\n\ntheorem solve_colored_balls_edge_case :\n  solve_colored_balls 2 [[1,1], [1000000000,1000000000]] = \n  (1000000000-1) * (1000000000-1) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2294"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nKalila and Dimna are two jackals living in a huge jungle. One day they decided to join a logging factory in order to make money. \n\nThe manager of logging factory wants them to go to the jungle and cut n trees with heights a_1, a_2, ..., a_{n}. They bought a chain saw from a shop. Each time they use the chain saw on the tree number i, they can decrease the height of this tree by one unit. Each time that Kalila and Dimna use the chain saw, they need to recharge it. Cost of charging depends on the id of the trees which have been cut completely (a tree is cut completely if its height equal to 0). If the maximum id of a tree which has been cut completely is i (the tree that have height a_{i} in the beginning), then the cost of charging the chain saw would be b_{i}. If no tree is cut completely, Kalila and Dimna cannot charge the chain saw. The chainsaw is charged in the beginning. We know that for each i < j, a_{i} < a_{j} and b_{i} > b_{j} and also b_{n} = 0 and a_1 = 1. Kalila and Dimna want to cut all the trees completely, with minimum cost. \n\nThey want you to help them! Will you?\n\n\n-----Input-----\n\nThe first line of input contains an integer n (1 ≤ n ≤ 10^5). The second line of input contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The third line of input contains n integers b_1, b_2, ..., b_{n} (0 ≤ b_{i} ≤ 10^9).\n\nIt's guaranteed that a_1 = 1, b_{n} = 0, a_1 < a_2 < ... < a_{n} and b_1 > b_2 > ... > b_{n}.\n\n\n-----Output-----\n\nThe only line of output must contain the minimum cost of cutting all the trees completely.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n5 4 3 2 0\n\nOutput\n25\n\nInput\n6\n1 2 3 10 20 30\n6 5 4 3 2 0\n\nOutput\n138\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef min_cost_to_cut_trees (n : Nat) (heights : List Nat) (costs : List Nat) : Nat :=\n  sorry\n\ndef sum_list : List Nat → Nat\n  | [] => 0\n  | h::t => h + sum_list t  \n\ntheorem min_cost_non_negative (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≥ 0 :=\nsorry\n\ntheorem min_cost_upper_bound (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≤ sum_list (heights.map (· * costs.head!)) :=\nsorry\n\ntheorem min_cost_last_worker_bound (heights : List Nat) (costs : List Nat)\n  (h1 : heights.length ≥ 2)\n  (h2 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 100)\n  (h3 : costs.length = heights.length)\n  (h4 : ∀ c ∈ costs, c ≤ 100) \n  (h5 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees heights.length heights costs ≥ heights.getLast! * costs.getLast! :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2313", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nKalila and Dimna are two jackals living in a huge jungle. One day they decided to join a logging factory in order to make money. \n\nThe manager of logging factory wants them to go to the jungle and cut n trees with heights a_1, a_2, ..., a_{n}. They bought a chain saw from a shop. Each time they use the chain saw on the tree number i, they can decrease the height of this tree by one unit. Each time that Kalila and Dimna use the chain saw, they need to recharge it. Cost of charging depends on the id of the trees which have been cut completely (a tree is cut completely if its height equal to 0). If the maximum id of a tree which has been cut completely is i (the tree that have height a_{i} in the beginning), then the cost of charging the chain saw would be b_{i}. If no tree is cut completely, Kalila and Dimna cannot charge the chain saw. The chainsaw is charged in the beginning. We know that for each i < j, a_{i} < a_{j} and b_{i} > b_{j} and also b_{n} = 0 and a_1 = 1. Kalila and Dimna want to cut all the trees completely, with minimum cost. \n\nThey want you to help them! Will you?\n\n\n-----Input-----\n\nThe first line of input contains an integer n (1 ≤ n ≤ 10^5). The second line of input contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The third line of input contains n integers b_1, b_2, ..., b_{n} (0 ≤ b_{i} ≤ 10^9).\n\nIt's guaranteed that a_1 = 1, b_{n} = 0, a_1 < a_2 < ... < a_{n} and b_1 > b_2 > ... > b_{n}.\n\n\n-----Output-----\n\nThe only line of output must contain the minimum cost of cutting all the trees completely.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n5 4 3 2 0\n\nOutput\n25\n\nInput\n6\n1 2 3 10 20 30\n6 5 4 3 2 0\n\nOutput\n138\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef min_cost_to_cut_trees (n : Nat) (heights : List Nat) (costs : List Nat) : Nat :=\n  sorry\n\ndef sum_list : List Nat → Nat\n  | [] => 0\n  | h::t => h + sum_list t  \n\ntheorem min_cost_non_negative (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≥ 0 :=\nsorry\n\ntheorem min_cost_upper_bound (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≤ sum_list (heights.map (· * costs.head!)) :=\nsorry\n\ntheorem min_cost_last_worker_bound (heights : List Nat) (costs : List Nat)\n  (h1 : heights.length ≥ 2)\n  (h2 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 100)\n  (h3 : costs.length = heights.length)\n  (h4 : ∀ c ∈ costs, c ≤ 100) \n  (h5 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees heights.length heights costs ≥ heights.getLast! * costs.getLast! :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2313"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n$n$ robots have escaped from your laboratory! You have to find them as soon as possible, because these robots are experimental, and their behavior is not tested yet, so they may be really dangerous!\n\nFortunately, even though your robots have escaped, you still have some control over them. First of all, you know the location of each robot: the world you live in can be modeled as an infinite coordinate plane, and the $i$-th robot is currently located at the point having coordinates ($x_i$, $y_i$). Furthermore, you may send exactly one command to all of the robots. The command should contain two integer numbers $X$ and $Y$, and when each robot receives this command, it starts moving towards the point having coordinates ($X$, $Y$). The robot stops its movement in two cases:  either it reaches ($X$, $Y$);  or it cannot get any closer to ($X$, $Y$). \n\nNormally, all robots should be able to get from any point of the coordinate plane to any other point. Each robot usually can perform four actions to move. Let's denote the current coordinates of the robot as ($x_c$, $y_c$). Then the movement system allows it to move to any of the four adjacent points:  the first action allows it to move from ($x_c$, $y_c$) to ($x_c - 1$, $y_c$);  the second action allows it to move from ($x_c$, $y_c$) to ($x_c$, $y_c + 1$);  the third action allows it to move from ($x_c$, $y_c$) to ($x_c + 1$, $y_c$);  the fourth action allows it to move from ($x_c$, $y_c$) to ($x_c$, $y_c - 1$). \n\nUnfortunately, it seems that some movement systems of some robots are malfunctioning. For each robot you know which actions it can perform, and which it cannot perform.\n\nYou want to send a command so all robots gather at the same point. To do so, you have to choose a pair of integer numbers $X$ and $Y$ so that each robot can reach the point ($X$, $Y$). Is it possible to find such a point?\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 10^5$) — the number of queries.\n\nThen $q$ queries follow. Each query begins with one line containing one integer $n$ ($1 \\le n \\le 10^5$) — the number of robots in the query. Then $n$ lines follow, the $i$-th of these lines describes the $i$-th robot in the current query: it contains six integer numbers $x_i$, $y_i$, $f_{i, 1}$, $f_{i, 2}$, $f_{i, 3}$ and $f_{i, 4}$ ($-10^5 \\le x_i, y_i \\le 10^5$, $0 \\le f_{i, j} \\le 1$). The first two numbers describe the initial location of the $i$-th robot, and the following four numbers describe which actions the $i$-th robot can use to move ($f_{i, j} = 1$ if the $i$-th robot can use the $j$-th action, and $f_{i, j} = 0$ if it cannot use the $j$-th action).\n\nIt is guaranteed that the total number of robots over all queries does not exceed $10^5$.\n\n\n-----Output-----\n\nYou should answer each query independently, in the order these queries appear in the input.\n\nTo answer a query, you should do one of the following:  if it is impossible to find a point that is reachable by all $n$ robots, print one number $0$ on a separate line;  if it is possible to find a point that is reachable by all $n$ robots, print three space-separated integers on the same line: $1$ $X$ $Y$, where $X$ and $Y$ are the coordinates of the point reachable by all $n$ robots. Both $X$ and $Y$ should not exceed $10^5$ by absolute value; it is guaranteed that if there exists at least one point reachable by all robots, then at least one of such points has both coordinates not exceeding $10^5$ by absolute value.\n\n\n-----Example-----\nInput\n4\n2\n-1 -2 0 0 0 0\n-1 -2 0 0 0 0\n3\n1 5 1 1 1 1\n2 5 0 1 0 1\n3 5 1 0 0 0\n2\n1337 1337 0 1 1 1\n1336 1337 1 1 0 1\n1\n3 5 1 1 1 1\n\nOutput\n1 -1 -2\n1 2 5\n0\n1 -100000 -100000\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Position := Int × Int × Bool × Bool × Bool × Bool\n\ndef find_robot_gather_point (robots : List Position) : List Int :=\nsorry\n\ndef in_bounds (x y : Int) : Bool :=\n-100000 ≤ x ∧ x ≤ 100000 ∧ -100000 ≤ y ∧ y ≤ 100000\n\ntheorem gather_point_valid (robots : List Position) :\n  let result := find_robot_gather_point robots\n  (result.length = 1 ∧ result = [0]) ∨ \n  (result.length = 3 ∧ \n   result.get! 0 = 1 ∧\n   let x := result.get! 1\n   let y := result.get! 2\n   in_bounds x y ∧\n   ∀ (robot : Position),\n   robot ∈ robots →\n   let (rx, ry, can_left, can_up, can_right, can_down) := robot\n   (¬can_left → x ≥ rx) ∧\n   (¬can_right → x ≤ rx) ∧\n   (¬can_up → y ≤ ry) ∧\n   (¬can_down → y ≥ ry)) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2362", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n$n$ robots have escaped from your laboratory! You have to find them as soon as possible, because these robots are experimental, and their behavior is not tested yet, so they may be really dangerous!\n\nFortunately, even though your robots have escaped, you still have some control over them. First of all, you know the location of each robot: the world you live in can be modeled as an infinite coordinate plane, and the $i$-th robot is currently located at the point having coordinates ($x_i$, $y_i$). Furthermore, you may send exactly one command to all of the robots. The command should contain two integer numbers $X$ and $Y$, and when each robot receives this command, it starts moving towards the point having coordinates ($X$, $Y$). The robot stops its movement in two cases:  either it reaches ($X$, $Y$);  or it cannot get any closer to ($X$, $Y$). \n\nNormally, all robots should be able to get from any point of the coordinate plane to any other point. Each robot usually can perform four actions to move. Let's denote the current coordinates of the robot as ($x_c$, $y_c$). Then the movement system allows it to move to any of the four adjacent points:  the first action allows it to move from ($x_c$, $y_c$) to ($x_c - 1$, $y_c$);  the second action allows it to move from ($x_c$, $y_c$) to ($x_c$, $y_c + 1$);  the third action allows it to move from ($x_c$, $y_c$) to ($x_c + 1$, $y_c$);  the fourth action allows it to move from ($x_c$, $y_c$) to ($x_c$, $y_c - 1$). \n\nUnfortunately, it seems that some movement systems of some robots are malfunctioning. For each robot you know which actions it can perform, and which it cannot perform.\n\nYou want to send a command so all robots gather at the same point. To do so, you have to choose a pair of integer numbers $X$ and $Y$ so that each robot can reach the point ($X$, $Y$). Is it possible to find such a point?\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 10^5$) — the number of queries.\n\nThen $q$ queries follow. Each query begins with one line containing one integer $n$ ($1 \\le n \\le 10^5$) — the number of robots in the query. Then $n$ lines follow, the $i$-th of these lines describes the $i$-th robot in the current query: it contains six integer numbers $x_i$, $y_i$, $f_{i, 1}$, $f_{i, 2}$, $f_{i, 3}$ and $f_{i, 4}$ ($-10^5 \\le x_i, y_i \\le 10^5$, $0 \\le f_{i, j} \\le 1$). The first two numbers describe the initial location of the $i$-th robot, and the following four numbers describe which actions the $i$-th robot can use to move ($f_{i, j} = 1$ if the $i$-th robot can use the $j$-th action, and $f_{i, j} = 0$ if it cannot use the $j$-th action).\n\nIt is guaranteed that the total number of robots over all queries does not exceed $10^5$.\n\n\n-----Output-----\n\nYou should answer each query independently, in the order these queries appear in the input.\n\nTo answer a query, you should do one of the following:  if it is impossible to find a point that is reachable by all $n$ robots, print one number $0$ on a separate line;  if it is possible to find a point that is reachable by all $n$ robots, print three space-separated integers on the same line: $1$ $X$ $Y$, where $X$ and $Y$ are the coordinates of the point reachable by all $n$ robots. Both $X$ and $Y$ should not exceed $10^5$ by absolute value; it is guaranteed that if there exists at least one point reachable by all robots, then at least one of such points has both coordinates not exceeding $10^5$ by absolute value.\n\n\n-----Example-----\nInput\n4\n2\n-1 -2 0 0 0 0\n-1 -2 0 0 0 0\n3\n1 5 1 1 1 1\n2 5 0 1 0 1\n3 5 1 0 0 0\n2\n1337 1337 0 1 1 1\n1336 1337 1 1 0 1\n1\n3 5 1 1 1 1\n\nOutput\n1 -1 -2\n1 2 5\n0\n1 -100000 -100000\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Position := Int × Int × Bool × Bool × Bool × Bool\n\ndef find_robot_gather_point (robots : List Position) : List Int :=\nsorry\n\ndef in_bounds (x y : Int) : Bool :=\n-100000 ≤ x ∧ x ≤ 100000 ∧ -100000 ≤ y ∧ y ≤ 100000\n\ntheorem gather_point_valid (robots : List Position) :\n  let result := find_robot_gather_point robots\n  (result.length = 1 ∧ result = [0]) ∨ \n  (result.length = 3 ∧ \n   result.get! 0 = 1 ∧\n   let x := result.get! 1\n   let y := result.get! 2\n   in_bounds x y ∧\n   ∀ (robot : Position),\n   robot ∈ robots →\n   let (rx, ry, can_left, can_up, can_right, can_down) := robot\n   (¬can_left → x ≥ rx) ∧\n   (¬can_right → x ≤ rx) ∧\n   (¬can_up → y ≤ ry) ∧\n   (¬can_down → y ≥ ry)) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2362"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nMishka wants to buy some food in the nearby shop. Initially, he has $s$ burles on his card. \n\nMishka can perform the following operation any number of times (possibly, zero): choose some positive integer number $1 \\le x \\le s$, buy food that costs exactly $x$ burles and obtain $\\lfloor\\frac{x}{10}\\rfloor$ burles as a cashback (in other words, Mishka spends $x$ burles and obtains $\\lfloor\\frac{x}{10}\\rfloor$ back). The operation $\\lfloor\\frac{a}{b}\\rfloor$ means $a$ divided by $b$ rounded down.\n\nIt is guaranteed that you can always buy some food that costs $x$ for any possible value of $x$.\n\nYour task is to say the maximum number of burles Mishka can spend if he buys food optimally.\n\nFor example, if Mishka has $s=19$ burles then the maximum number of burles he can spend is $21$. Firstly, he can spend $x=10$ burles, obtain $1$ burle as a cashback. Now he has $s=10$ burles, so can spend $x=10$ burles, obtain $1$ burle as a cashback and spend it too.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases.\n\nThe next $t$ lines describe test cases. Each test case is given on a separate line and consists of one integer $s$ ($1 \\le s \\le 10^9$) — the number of burles Mishka initially has.\n\n\n-----Output-----\n\nFor each test case print the answer on it — the maximum number of burles Mishka can spend if he buys food optimally.\n\n\n-----Example-----\nInput\n6\n1\n10\n19\n9876\n12345\n1000000000\n\nOutput\n1\n11\n21\n10973\n13716\n1111111111\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef max_spending (initial_burles : Nat) : Nat :=\n  sorry\n\ntheorem max_spending_ge_input (initial_burles : Nat) :\n  max_spending initial_burles ≥ initial_burles := by\n  sorry\n\ntheorem max_spending_eq_input_when_small (initial_burles : Nat) \n  (h : initial_burles < 10) :\n  max_spending initial_burles = initial_burles := by\n  sorry\n\ntheorem max_spending_nat_valued (initial_burles : Nat) :\n  max_spending initial_burles ≥ 0 := by\n  sorry\n\ntheorem max_spending_growth (initial_burles : Nat)\n  (h : initial_burles ≥ 10) :\n  max_spending (initial_burles + 10) ≥ max_spending initial_burles + 11 := by\n  sorry\n\ntheorem max_spending_upper_bound (initial_burles : Nat)\n  (h : initial_burles > 0) :\n  max_spending initial_burles ≤ initial_burles * 10 / 9 + 10 := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2387", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nMishka wants to buy some food in the nearby shop. Initially, he has $s$ burles on his card. \n\nMishka can perform the following operation any number of times (possibly, zero): choose some positive integer number $1 \\le x \\le s$, buy food that costs exactly $x$ burles and obtain $\\lfloor\\frac{x}{10}\\rfloor$ burles as a cashback (in other words, Mishka spends $x$ burles and obtains $\\lfloor\\frac{x}{10}\\rfloor$ back). The operation $\\lfloor\\frac{a}{b}\\rfloor$ means $a$ divided by $b$ rounded down.\n\nIt is guaranteed that you can always buy some food that costs $x$ for any possible value of $x$.\n\nYour task is to say the maximum number of burles Mishka can spend if he buys food optimally.\n\nFor example, if Mishka has $s=19$ burles then the maximum number of burles he can spend is $21$. Firstly, he can spend $x=10$ burles, obtain $1$ burle as a cashback. Now he has $s=10$ burles, so can spend $x=10$ burles, obtain $1$ burle as a cashback and spend it too.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases.\n\nThe next $t$ lines describe test cases. Each test case is given on a separate line and consists of one integer $s$ ($1 \\le s \\le 10^9$) — the number of burles Mishka initially has.\n\n\n-----Output-----\n\nFor each test case print the answer on it — the maximum number of burles Mishka can spend if he buys food optimally.\n\n\n-----Example-----\nInput\n6\n1\n10\n19\n9876\n12345\n1000000000\n\nOutput\n1\n11\n21\n10973\n13716\n1111111111\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef max_spending (initial_burles : Nat) : Nat :=\n  sorry\n\ntheorem max_spending_ge_input (initial_burles : Nat) :\n  max_spending initial_burles ≥ initial_burles := by\n  sorry\n\ntheorem max_spending_eq_input_when_small (initial_burles : Nat) \n  (h : initial_burles < 10) :\n  max_spending initial_burles = initial_burles := by\n  sorry\n\ntheorem max_spending_nat_valued (initial_burles : Nat) :\n  max_spending initial_burles ≥ 0 := by\n  sorry\n\ntheorem max_spending_growth (initial_burles : Nat)\n  (h : initial_burles ≥ 10) :\n  max_spending (initial_burles + 10) ≥ max_spending initial_burles + 11 := by\n  sorry\n\ntheorem max_spending_upper_bound (initial_burles : Nat)\n  (h : initial_burles > 0) :\n  max_spending initial_burles ≤ initial_burles * 10 / 9 + 10 := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2387"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an undirected unweighted connected graph consisting of $n$ vertices and $m$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.\n\nYour task is to choose at most $\\lfloor\\frac{n}{2}\\rfloor$ vertices in this graph so each unchosen vertex is adjacent (in other words, connected by an edge) to at least one of chosen vertices.\n\nIt is guaranteed that the answer exists. If there are multiple answers, you can print any.\n\nYou will be given multiple independent queries to answer.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) — the number of queries.\n\nThen $t$ queries follow.\n\nThe first line of each query contains two integers $n$ and $m$ ($2 \\le n \\le 2 \\cdot 10^5$, $n - 1 \\le m \\le min(2 \\cdot 10^5, \\frac{n(n-1)}{2})$) — the number of vertices and the number of edges, respectively.\n\nThe following $m$ lines denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \\le v_i, u_i \\le n$, $u_i \\ne v_i$), which are the indices of vertices connected by the edge.\n\nThere are no self-loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the list of edges, and for each pair ($v_i, u_i$) the condition $v_i \\ne u_i$ is satisfied. It is guaranteed that the given graph is connected.\n\nIt is guaranteed that $\\sum m \\le 2 \\cdot 10^5$ over all queries.\n\n\n-----Output-----\n\nFor each query print two lines.\n\nIn the first line print $k$ ($1 \\le \\lfloor\\frac{n}{2}\\rfloor$) — the number of chosen vertices.\n\nIn the second line print $k$ distinct integers $c_1, c_2, \\dots, c_k$ in any order, where $c_i$ is the index of the $i$-th chosen vertex.\n\nIt is guaranteed that the answer exists. If there are multiple answers, you can print any.\n\n\n-----Example-----\nInput\n2\n4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n6 8\n2 5\n5 4\n4 3\n4 1\n1 3\n2 3\n2 6\n5 6\n\nOutput\n2\n1 3\n3\n4 3 6\n\n\n\n-----Note-----\n\nIn the first query any vertex or any pair of vertices will suffice.\n\n [Image] \n\nNote that you don't have to minimize the number of chosen vertices. In the second query two vertices can be enough (vertices $2$ and $4$) but three is also ok.\n\n [Image]\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_graph_cover (test_cases : List (Nat × Nat × List (Nat × Nat))) : \n  List (Nat × List Nat) := sorry\n\ntheorem graph_cover_size_matches_vertices {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  result_size = result_vertices.length := sorry\n\ntheorem graph_cover_vertices_valid {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  ∀ v ∈ result_vertices, 1 ≤ v ∧ v ≤ n := sorry\n\ntheorem graph_cover_vertices_no_duplicates {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  ∀ x ∈ result_vertices, ∀ y ∈ result_vertices, x = y → \n  result_vertices.indexOf x = result_vertices.indexOf y := sorry\n\ntheorem graph_cover_size_bound {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  result_size ≤ (n + 1) / 2 := sorry\n\ntheorem minimal_graph_cover {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(2, 1, [(1,2)])] = [(result_size, result_vertices)] →\n  result_size = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2388", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an undirected unweighted connected graph consisting of $n$ vertices and $m$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.\n\nYour task is to choose at most $\\lfloor\\frac{n}{2}\\rfloor$ vertices in this graph so each unchosen vertex is adjacent (in other words, connected by an edge) to at least one of chosen vertices.\n\nIt is guaranteed that the answer exists. If there are multiple answers, you can print any.\n\nYou will be given multiple independent queries to answer.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) — the number of queries.\n\nThen $t$ queries follow.\n\nThe first line of each query contains two integers $n$ and $m$ ($2 \\le n \\le 2 \\cdot 10^5$, $n - 1 \\le m \\le min(2 \\cdot 10^5, \\frac{n(n-1)}{2})$) — the number of vertices and the number of edges, respectively.\n\nThe following $m$ lines denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \\le v_i, u_i \\le n$, $u_i \\ne v_i$), which are the indices of vertices connected by the edge.\n\nThere are no self-loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the list of edges, and for each pair ($v_i, u_i$) the condition $v_i \\ne u_i$ is satisfied. It is guaranteed that the given graph is connected.\n\nIt is guaranteed that $\\sum m \\le 2 \\cdot 10^5$ over all queries.\n\n\n-----Output-----\n\nFor each query print two lines.\n\nIn the first line print $k$ ($1 \\le \\lfloor\\frac{n}{2}\\rfloor$) — the number of chosen vertices.\n\nIn the second line print $k$ distinct integers $c_1, c_2, \\dots, c_k$ in any order, where $c_i$ is the index of the $i$-th chosen vertex.\n\nIt is guaranteed that the answer exists. If there are multiple answers, you can print any.\n\n\n-----Example-----\nInput\n2\n4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n6 8\n2 5\n5 4\n4 3\n4 1\n1 3\n2 3\n2 6\n5 6\n\nOutput\n2\n1 3\n3\n4 3 6\n\n\n\n-----Note-----\n\nIn the first query any vertex or any pair of vertices will suffice.\n\n [Image] \n\nNote that you don't have to minimize the number of chosen vertices. In the second query two vertices can be enough (vertices $2$ and $4$) but three is also ok.\n\n [Image]\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_graph_cover (test_cases : List (Nat × Nat × List (Nat × Nat))) : \n  List (Nat × List Nat) := sorry\n\ntheorem graph_cover_size_matches_vertices {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  result_size = result_vertices.length := sorry\n\ntheorem graph_cover_vertices_valid {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  ∀ v ∈ result_vertices, 1 ≤ v ∧ v ≤ n := sorry\n\ntheorem graph_cover_vertices_no_duplicates {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  ∀ x ∈ result_vertices, ∀ y ∈ result_vertices, x = y → \n  result_vertices.indexOf x = result_vertices.indexOf y := sorry\n\ntheorem graph_cover_size_bound {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  result_size ≤ (n + 1) / 2 := sorry\n\ntheorem minimal_graph_cover {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(2, 1, [(1,2)])] = [(result_size, result_vertices)] →\n  result_size = 1 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2388"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThe only difference between easy and hard versions is the size of the input.\n\nYou are given a string $s$ consisting of $n$ characters, each character is 'R', 'G' or 'B'.\n\nYou are also given an integer $k$. Your task is to change the minimum number of characters in the initial string $s$ so that after the changes there will be a string of length $k$ that is a substring of $s$, and is also a substring of the infinite string \"RGBRGBRGB ...\".\n\nA string $a$ is a substring of string $b$ if there exists a positive integer $i$ such that $a_1 = b_i$, $a_2 = b_{i + 1}$, $a_3 = b_{i + 2}$, ..., $a_{|a|} = b_{i + |a| - 1}$. For example, strings \"GBRG\", \"B\", \"BR\" are substrings of the infinite string \"RGBRGBRGB ...\" while \"GR\", \"RGR\" and \"GGG\" are not.\n\nYou have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries. Then $q$ queries follow.\n\nThe first line of the query contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) — the length of the string $s$ and the length of the substring.\n\nThe second line of the query contains a string $s$ consisting of $n$ characters 'R', 'G' and 'B'.\n\nIt is guaranteed that the sum of $n$ over all queries does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each query print one integer — the minimum number of characters you need to change in the initial string $s$ so that after changing there will be a substring of length $k$ in $s$ that is also a substring of the infinite string \"RGBRGBRGB ...\".\n\n\n-----Example-----\nInput\n3\n5 2\nBGGGG\n5 3\nRBRGR\n5 5\nBBBRR\n\nOutput\n1\n0\n3\n\n\n\n-----Note-----\n\nIn the first example, you can change the first character to 'R' and obtain the substring \"RG\", or change the second character to 'R' and obtain \"BR\", or change the third, fourth or fifth character to 'B' and obtain \"GB\".\n\nIn the second example, the substring is \"BRG\".\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n-- Function signature (not implemented)\ndef min_changes_for_rgb_substring (n k : Nat) (s : String) : Nat :=\n  sorry\n\n-- General properties\ntheorem min_changes_non_negative (n k : Nat) (s : String) :\n  (1 ≤ k) → (k ≤ n) → (s.length = n) → \n  min_changes_for_rgb_substring n k s ≥ 0 :=\n  sorry\n\ntheorem min_changes_upper_bound (n k : Nat) (s : String) :\n  (1 ≤ k) → (k ≤ n) → (s.length = n) →\n  min_changes_for_rgb_substring n k s ≤ k :=\n  sorry\n\n-- When k equals string length\ntheorem k_equals_length (s : String) :\n  s.length > 0 →\n  let n := s.length\n  0 ≤ min_changes_for_rgb_substring n n s ∧ \n  min_changes_for_rgb_substring n n s ≤ n :=\n  sorry\n\n-- When k equals 1\ntheorem k_equals_one (n : Nat) (s : String) :\n  (s.length = n) →\n  min_changes_for_rgb_substring n 1 s ≤ 1 :=\n  sorry\n\n-- For string of all same characters\ntheorem all_same_char (n : Nat) (s : String) :\n  n ≥ 3 →\n  (s.length = n) →\n  (∀ c, c ∈ s.data → c = 'R') →\n  min_changes_for_rgb_substring n 3 s > 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2389", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThe only difference between easy and hard versions is the size of the input.\n\nYou are given a string $s$ consisting of $n$ characters, each character is 'R', 'G' or 'B'.\n\nYou are also given an integer $k$. Your task is to change the minimum number of characters in the initial string $s$ so that after the changes there will be a string of length $k$ that is a substring of $s$, and is also a substring of the infinite string \"RGBRGBRGB ...\".\n\nA string $a$ is a substring of string $b$ if there exists a positive integer $i$ such that $a_1 = b_i$, $a_2 = b_{i + 1}$, $a_3 = b_{i + 2}$, ..., $a_{|a|} = b_{i + |a| - 1}$. For example, strings \"GBRG\", \"B\", \"BR\" are substrings of the infinite string \"RGBRGBRGB ...\" while \"GR\", \"RGR\" and \"GGG\" are not.\n\nYou have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries. Then $q$ queries follow.\n\nThe first line of the query contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) — the length of the string $s$ and the length of the substring.\n\nThe second line of the query contains a string $s$ consisting of $n$ characters 'R', 'G' and 'B'.\n\nIt is guaranteed that the sum of $n$ over all queries does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each query print one integer — the minimum number of characters you need to change in the initial string $s$ so that after changing there will be a substring of length $k$ in $s$ that is also a substring of the infinite string \"RGBRGBRGB ...\".\n\n\n-----Example-----\nInput\n3\n5 2\nBGGGG\n5 3\nRBRGR\n5 5\nBBBRR\n\nOutput\n1\n0\n3\n\n\n\n-----Note-----\n\nIn the first example, you can change the first character to 'R' and obtain the substring \"RG\", or change the second character to 'R' and obtain \"BR\", or change the third, fourth or fifth character to 'B' and obtain \"GB\".\n\nIn the second example, the substring is \"BRG\".\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n-- Function signature (not implemented)\ndef min_changes_for_rgb_substring (n k : Nat) (s : String) : Nat :=\n  sorry\n\n-- General properties\ntheorem min_changes_non_negative (n k : Nat) (s : String) :\n  (1 ≤ k) → (k ≤ n) → (s.length = n) → \n  min_changes_for_rgb_substring n k s ≥ 0 :=\n  sorry\n\ntheorem min_changes_upper_bound (n k : Nat) (s : String) :\n  (1 ≤ k) → (k ≤ n) → (s.length = n) →\n  min_changes_for_rgb_substring n k s ≤ k :=\n  sorry\n\n-- When k equals string length\ntheorem k_equals_length (s : String) :\n  s.length > 0 →\n  let n := s.length\n  0 ≤ min_changes_for_rgb_substring n n s ∧ \n  min_changes_for_rgb_substring n n s ≤ n :=\n  sorry\n\n-- When k equals 1\ntheorem k_equals_one (n : Nat) (s : String) :\n  (s.length = n) →\n  min_changes_for_rgb_substring n 1 s ≤ 1 :=\n  sorry\n\n-- For string of all same characters\ntheorem all_same_char (n : Nat) (s : String) :\n  n ≥ 3 →\n  (s.length = n) →\n  (∀ c, c ∈ s.data → c = 'R') →\n  min_changes_for_rgb_substring n 3 s > 0 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2389"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nPolycarp is reading a book consisting of $n$ pages numbered from $1$ to $n$. Every time he finishes the page with the number divisible by $m$, he writes down the last digit of this page number. For example, if $n=15$ and $m=5$, pages divisible by $m$ are $5, 10, 15$. Their last digits are $5, 0, 5$ correspondingly, their sum is $10$.\n\nYour task is to calculate the sum of all digits Polycarp has written down.\n\nYou have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 1000$) — the number of queries.\n\nThe following $q$ lines contain queries, one per line. Each query is given as two integers $n$ and $m$ ($1 \\le n, m \\le 10^{16}$) — the number of pages in the book and required divisor, respectively.\n\n\n-----Output-----\n\nFor each query print the answer for it — the sum of digits written down by Polycarp.\n\n\n-----Example-----\nInput\n7\n1 1\n10 1\n100 3\n1024 14\n998244353 1337\n123 144\n1234312817382646 13\n\nOutput\n1\n45\n153\n294\n3359835\n0\n427262129093995\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_book_pages (n m : Nat) : Nat :=\nsorry\n\ntheorem solve_book_pages_nonnegative (n m : Nat) \n    (h1 : n > 0) (h2 : m > 0) :\n  solve_book_pages n m ≥ 0 :=\nsorry\n\ntheorem solve_book_pages_equals_sum (n m : Nat)\n    (h1 : n > 0) (h2 : m > 0) :\n  solve_book_pages n m = \n    (List.range (n / m)).foldl (fun acc i => acc + ((i + 1) * m % 10)) 0 :=\nsorry\n\ntheorem divisibility_property (n m : Nat)\n    (h1 : n > 0) (h2 : m > 0) :\n  solve_book_pages n m = solve_book_pages (n - n % m) m :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2392", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nPolycarp is reading a book consisting of $n$ pages numbered from $1$ to $n$. Every time he finishes the page with the number divisible by $m$, he writes down the last digit of this page number. For example, if $n=15$ and $m=5$, pages divisible by $m$ are $5, 10, 15$. Their last digits are $5, 0, 5$ correspondingly, their sum is $10$.\n\nYour task is to calculate the sum of all digits Polycarp has written down.\n\nYou have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 1000$) — the number of queries.\n\nThe following $q$ lines contain queries, one per line. Each query is given as two integers $n$ and $m$ ($1 \\le n, m \\le 10^{16}$) — the number of pages in the book and required divisor, respectively.\n\n\n-----Output-----\n\nFor each query print the answer for it — the sum of digits written down by Polycarp.\n\n\n-----Example-----\nInput\n7\n1 1\n10 1\n100 3\n1024 14\n998244353 1337\n123 144\n1234312817382646 13\n\nOutput\n1\n45\n153\n294\n3359835\n0\n427262129093995\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve_book_pages (n m : Nat) : Nat :=\nsorry\n\ntheorem solve_book_pages_nonnegative (n m : Nat) \n    (h1 : n > 0) (h2 : m > 0) :\n  solve_book_pages n m ≥ 0 :=\nsorry\n\ntheorem solve_book_pages_equals_sum (n m : Nat)\n    (h1 : n > 0) (h2 : m > 0) :\n  solve_book_pages n m = \n    (List.range (n / m)).foldl (fun acc i => acc + ((i + 1) * m % 10)) 0 :=\nsorry\n\ntheorem divisibility_property (n m : Nat)\n    (h1 : n > 0) (h2 : m > 0) :\n  solve_book_pages n m = solve_book_pages (n - n % m) m :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2392"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n \nExample 1:\nInput: num = 14\nOutput: 6\nExplanation: \nStep 1) 14 is even; divide by 2 and obtain 7. \nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3. \nStep 4) 3 is odd; subtract 1 and obtain 2. \nStep 5) 2 is even; divide by 2 and obtain 1. \nStep 6) 1 is odd; subtract 1 and obtain 0.\n\nExample 2:\nInput: num = 8\nOutput: 4\nExplanation: \nStep 1) 8 is even; divide by 2 and obtain 4. \nStep 2) 4 is even; divide by 2 and obtain 2. \nStep 3) 2 is even; divide by 2 and obtain 1. \nStep 4) 1 is odd; subtract 1 and obtain 0.\n\nExample 3:\nInput: num = 123\nOutput: 12\n\n \nConstraints:\n\n0 <= num <= 10^6\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef number_of_steps (n: Nat) : Nat := sorry\n\ndef is_power_of_two (n: Nat) : Bool := sorry\n\ntheorem number_of_steps_nonneg (n: Nat) : \n  number_of_steps n ≥ 0 := sorry\n\ndef simulation_loop (n steps: Nat) : Nat :=\n  match n with\n  | 0 => steps\n  | n+1 => if n % 2 = 0 \n           then simulation_loop (n / 2) (steps + 1)\n           else simulation_loop (n - 1) (steps + 1)\n\n\n\n\n\ntheorem zero_steps :\n  number_of_steps 0 = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2486", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n \nExample 1:\nInput: num = 14\nOutput: 6\nExplanation: \nStep 1) 14 is even; divide by 2 and obtain 7. \nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3. \nStep 4) 3 is odd; subtract 1 and obtain 2. \nStep 5) 2 is even; divide by 2 and obtain 1. \nStep 6) 1 is odd; subtract 1 and obtain 0.\n\nExample 2:\nInput: num = 8\nOutput: 4\nExplanation: \nStep 1) 8 is even; divide by 2 and obtain 4. \nStep 2) 4 is even; divide by 2 and obtain 2. \nStep 3) 2 is even; divide by 2 and obtain 1. \nStep 4) 1 is odd; subtract 1 and obtain 0.\n\nExample 3:\nInput: num = 123\nOutput: 12\n\n \nConstraints:\n\n0 <= num <= 10^6\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef number_of_steps (n: Nat) : Nat := sorry\n\ndef is_power_of_two (n: Nat) : Bool := sorry\n\ntheorem number_of_steps_nonneg (n: Nat) : \n  number_of_steps n ≥ 0 := sorry\n\ndef simulation_loop (n steps: Nat) : Nat :=\n  match n with\n  | 0 => steps\n  | n+1 => if n % 2 = 0 \n           then simulation_loop (n / 2) (steps + 1)\n           else simulation_loop (n - 1) (steps + 1)\n\n\n\n\n\ntheorem zero_steps :\n  number_of_steps 0 = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2486"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThe Tribonacci sequence Tn is defined as follows: \nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n \nExample 1:\nInput: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n\nExample 2:\nInput: n = 25\nOutput: 1389537\n\n \nConstraints:\n\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef tribonacci (n : Int) : Int :=\n  sorry\n\n\n\ntheorem tribonacci_base_zero :\n  tribonacci 0 = 0 :=\n  sorry\n\ntheorem tribonacci_base_one :\n  tribonacci 1 = 1 :=\n  sorry\n\ntheorem tribonacci_base_two :\n  tribonacci 2 = 1 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2517", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThe Tribonacci sequence Tn is defined as follows: \nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.\n \nExample 1:\nInput: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n\nExample 2:\nInput: n = 25\nOutput: 1389537\n\n \nConstraints:\n\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef tribonacci (n : Int) : Int :=\n  sorry\n\n\n\ntheorem tribonacci_base_zero :\n  tribonacci 0 = 0 :=\n  sorry\n\ntheorem tribonacci_base_one :\n  tribonacci 1 = 1 :=\n  sorry\n\ntheorem tribonacci_base_two :\n  tribonacci 2 = 1 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2517"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nExample 1:\n\n\nInput: 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: 120\nOutput: 21\n\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef reverse_integer (x : Int) : Int := sorry\n\n-- 32-bit integer bounds\ndef INT32_MAX : Int := 2^31 - 1\ndef INT32_MIN : Int := -(2^31)\n\ntheorem reverse_integer_sign (x : Int) :\n  let result := reverse_integer x\n  (result = 0) ∨ (result > 0 ∧ x > 0) ∨ (result < 0 ∧ x < 0) := sorry\n\ntheorem reverse_integer_bounds (x : Int) :\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX := sorry\n\ntheorem single_digit_numbers (x : Int) :\n  0 ≤ x ∧ x ≤ 9 →\n  reverse_integer x = x := sorry\n\ntheorem trailing_zeros (x : Int) :\n  x > 0 →\n  x % 10 = 0 →\n  reverse_integer x < x := sorry\n\ntheorem int32_bounds (x : Int) :\n  INT32_MIN ≤ x ∧ x ≤ INT32_MAX →\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX := sorry\n\ntheorem overflow_cases : \n  reverse_integer 1534236469 = 0 ∧\n  reverse_integer (-2147483648) = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2520", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nExample 1:\n\n\nInput: 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: 120\nOutput: 21\n\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef reverse_integer (x : Int) : Int := sorry\n\n-- 32-bit integer bounds\ndef INT32_MAX : Int := 2^31 - 1\ndef INT32_MIN : Int := -(2^31)\n\ntheorem reverse_integer_sign (x : Int) :\n  let result := reverse_integer x\n  (result = 0) ∨ (result > 0 ∧ x > 0) ∨ (result < 0 ∧ x < 0) := sorry\n\ntheorem reverse_integer_bounds (x : Int) :\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX := sorry\n\ntheorem single_digit_numbers (x : Int) :\n  0 ≤ x ∧ x ≤ 9 →\n  reverse_integer x = x := sorry\n\ntheorem trailing_zeros (x : Int) :\n  x > 0 →\n  x % 10 = 0 →\n  reverse_integer x < x := sorry\n\ntheorem int32_bounds (x : Int) :\n  INT32_MIN ≤ x ∧ x ≤ INT32_MAX →\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX := sorry\n\ntheorem overflow_cases : \n  reverse_integer 1534236469 = 0 ∧\n  reverse_integer (-2147483648) = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2520"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n=====Problem Statement=====\nA valid email address meets the following criteria:\n\nIt's composed of a username, domain name, and extension assembled in this format: username@domain.extension\nThe username starts with an English alphabetical character, and any subsequent characters consist of one or more of the following: alphanumeric characters, -,., and _.\nThe domain and extension contain only English alphabetical characters.\nThe extension is 1, 2, or 3 characters in length.\n\nGiven n pairs of names and email addresses as input, print each name and email address pair having a valid email address on a new line.\n\nHint: Try using Email.utils() to complete this challenge. For example, this code:\n\nimport email.utils\nprint email.utils.parseaddr('DOSHI <DOSHI@hackerrank.com>')\nprint email.utils.formataddr(('DOSHI', 'DOSHI@hackerrank.com'))\n\nproduces this output:\n\n('DOSHI', 'DOSHI@hackerrank.com')\nDOSHI <DOSHI@hackerrank.com>\n\n=====Input Format=====\nThe first line contains a single integer, n, denoting the number of email address.\nEach line i of the n subsequent lines contains a name and an email address as two space-separated values following this format:\nname <user@email.com>\n\n=====Constraints=====\n0<n<100\n\n=====Output Format=====\nPrint the space-separated name and email address pairs containing valid email addresses only. Each pair must be printed on a new line in the following format:\nname <user@email.com>\n\nYou must print each valid email address in the same order as it was received as input.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Email := String\ndef validate_emails (emails : List Email) : List Email := sorry\n\ndef isValidEmailFormat (e : Email) : Bool := sorry\n\n/-- For a list of valid email addresses, all should be returned unchanged -/\ntheorem validate_valid_emails (emails : List Email) \n  (h : ∀ e ∈ emails, isValidEmailFormat e) :\n  validate_emails emails = emails :=\nsorry\n\n/-- For a list of invalid email addresses, an empty list should be returned -/\ntheorem validate_invalid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, ¬ isValidEmailFormat e) :\n  validate_emails emails = [] := \nsorry\n\n/-- For a mixed list of valid and invalid emails, only valid ones should be returned -/\ntheorem validate_mixed_emails (emails : List Email)\n  (valid : List Email := emails.filter isValidEmailFormat) :\n  validate_emails emails = valid :=\nsorry\n\n/-- Function should not crash on arbitrary string input -/\ntheorem validate_arbitrary_input (inputs : List String) :\n  ∃ result, validate_emails inputs = result :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2564", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n=====Problem Statement=====\nA valid email address meets the following criteria:\n\nIt's composed of a username, domain name, and extension assembled in this format: username@domain.extension\nThe username starts with an English alphabetical character, and any subsequent characters consist of one or more of the following: alphanumeric characters, -,., and _.\nThe domain and extension contain only English alphabetical characters.\nThe extension is 1, 2, or 3 characters in length.\n\nGiven n pairs of names and email addresses as input, print each name and email address pair having a valid email address on a new line.\n\nHint: Try using Email.utils() to complete this challenge. For example, this code:\n\nimport email.utils\nprint email.utils.parseaddr('DOSHI <DOSHI@hackerrank.com>')\nprint email.utils.formataddr(('DOSHI', 'DOSHI@hackerrank.com'))\n\nproduces this output:\n\n('DOSHI', 'DOSHI@hackerrank.com')\nDOSHI <DOSHI@hackerrank.com>\n\n=====Input Format=====\nThe first line contains a single integer, n, denoting the number of email address.\nEach line i of the n subsequent lines contains a name and an email address as two space-separated values following this format:\nname <user@email.com>\n\n=====Constraints=====\n0<n<100\n\n=====Output Format=====\nPrint the space-separated name and email address pairs containing valid email addresses only. Each pair must be printed on a new line in the following format:\nname <user@email.com>\n\nYou must print each valid email address in the same order as it was received as input.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef Email := String\ndef validate_emails (emails : List Email) : List Email := sorry\n\ndef isValidEmailFormat (e : Email) : Bool := sorry\n\n/-- For a list of valid email addresses, all should be returned unchanged -/\ntheorem validate_valid_emails (emails : List Email) \n  (h : ∀ e ∈ emails, isValidEmailFormat e) :\n  validate_emails emails = emails :=\nsorry\n\n/-- For a list of invalid email addresses, an empty list should be returned -/\ntheorem validate_invalid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, ¬ isValidEmailFormat e) :\n  validate_emails emails = [] := \nsorry\n\n/-- For a mixed list of valid and invalid emails, only valid ones should be returned -/\ntheorem validate_mixed_emails (emails : List Email)\n  (valid : List Email := emails.filter isValidEmailFormat) :\n  validate_emails emails = valid :=\nsorry\n\n/-- Function should not crash on arbitrary string input -/\ntheorem validate_arbitrary_input (inputs : List String) :\n  ∃ result, validate_emails inputs = result :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2564"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n=====Problem Statement=====\nHere is a sample line of code that can be executed in Python:\nprint(\"Hello, World!\")\n\nYou can just as easily store a string as a variable and then print it to stdout:\nmy_string = \"Hello, World!\"\nprint(my_string)\n\nThe above code will print Hello, World! on your screen. Try it yourself in the editor below!\n\n=====Input Format=====\nYou do not need to read any input in this challenge.\n\n=====Output Format=====\nPrint Hello, World! to stdout.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef hello_world : String := sorry\n\ntheorem hello_world_consistency :\n  hello_world = hello_world := by sorry\n\ntheorem hello_world_is_string (s : String := hello_world) : \n  s = hello_world := by sorry\n\ntheorem hello_world_non_empty :\n  hello_world.length > 0 := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2649", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n=====Problem Statement=====\nHere is a sample line of code that can be executed in Python:\nprint(\"Hello, World!\")\n\nYou can just as easily store a string as a variable and then print it to stdout:\nmy_string = \"Hello, World!\"\nprint(my_string)\n\nThe above code will print Hello, World! on your screen. Try it yourself in the editor below!\n\n=====Input Format=====\nYou do not need to read any input in this challenge.\n\n=====Output Format=====\nPrint Hello, World! to stdout.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef hello_world : String := sorry\n\ntheorem hello_world_consistency :\n  hello_world = hello_world := by sorry\n\ntheorem hello_world_is_string (s : String := hello_world) : \n  s = hello_world := by sorry\n\ntheorem hello_world_non_empty :\n  hello_world.length > 0 := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2649"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nCreate a function that takes a string as a parameter and does the following, in this order:\n\n1. replaces every letter with the letter following it in the alphabet (see note below)\n2. makes any vowels capital\n3. makes any consonants lower case\n\n**Note:** the alphabet should wrap around, so `Z` becomes `A`\n\nSo, for example the string `\"Cat30\"` would return `\"dbU30\"` (`Cat30 --> Dbu30 --> dbU30`)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef String.isAlpha : Char → Bool :=\n  sorry\n\ndef changer : String → String :=\n  sorry\n\ntheorem changer_length (s : String) :\n  s.length = (changer s).length :=\n  sorry\n\ntheorem changer_nonalpha_unchanged {s : String} {i : String.Pos} {c : Char} :\n  c = s.get i → ¬(String.isAlpha c) → (changer s).get i = c :=\n  sorry\n\ntheorem changer_empty :\n  changer \"\" = \"\" :=\n  sorry\n\ntheorem changer_boundary_case :\n  changer \"abcxyz\" = \"bcdyzA\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2686", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nCreate a function that takes a string as a parameter and does the following, in this order:\n\n1. replaces every letter with the letter following it in the alphabet (see note below)\n2. makes any vowels capital\n3. makes any consonants lower case\n\n**Note:** the alphabet should wrap around, so `Z` becomes `A`\n\nSo, for example the string `\"Cat30\"` would return `\"dbU30\"` (`Cat30 --> Dbu30 --> dbU30`)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef String.isAlpha : Char → Bool :=\n  sorry\n\ndef changer : String → String :=\n  sorry\n\ntheorem changer_length (s : String) :\n  s.length = (changer s).length :=\n  sorry\n\ntheorem changer_nonalpha_unchanged {s : String} {i : String.Pos} {c : Char} :\n  c = s.get i → ¬(String.isAlpha c) → (changer s).get i = c :=\n  sorry\n\ntheorem changer_empty :\n  changer \"\" = \"\" :=\n  sorry\n\ntheorem changer_boundary_case :\n  changer \"abcxyz\" = \"bcdyzA\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2686"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a program that, given a word, computes the scrabble score for that word.\n\n## Letter Values\n\nYou'll need these:\n\n```\nLetter                           Value\nA, E, I, O, U, L, N, R, S, T       1\nD, G                               2\nB, C, M, P                         3\nF, H, V, W, Y                      4\nK                                  5\nJ, X                               8\nQ, Z                               10\n```\n\n```if:ruby,javascript,cfml\nThere will be a preloaded hashtable `$dict` with all these values: `$dict[\"E\"] == 1`. \n```\n```if:haskell\nThere will be a preloaded list of `(Char, Int)` tuples called `dict` with all these values.\n```\n```if:python\nThere will be a preloaded dictionary `dict_scores` with all these values: `dict_scores[\"E\"] == 1`\n```\n\n## Examples\n```\n\"cabbage\" --> 14\n```\n\n\"cabbage\" should be scored as worth 14 points:\n\n- 3 points for C\n- 1 point for A, twice\n- 3 points for B, twice\n- 2 points for G\n- 1 point for E\n\nAnd to total:\n\n`3 + 2*1 + 2*3 + 2 + 1` = `3 + 2 + 6 + 3` = `14`\n\n\nEmpty string should return `0`. The string can contain spaces and letters (upper and lower case), you should calculate the scrabble score only of the letters in that string.\n\n```\n\"\"           --> 0\n\"STREET\"    --> 6\n\"st re et\"    --> 6\n\"ca bba g  e\" --> 14\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef scrabble_score : String → Nat \n  | _ => sorry\n\ntheorem scrabble_score_nonnegative (word : String) : \n  scrabble_score word ≥ 0 := sorry\n\n\n\ntheorem scrabble_score_case_insensitive (word : String) :\n  scrabble_score (word.toLower) = scrabble_score (word.toUpper) := sorry\n\n\n\n\n\ntheorem scrabble_score_sum_individual (word : String) :\n  word ≠ \"\" →\n  scrabble_score word = word.data.foldl (fun acc c => acc + scrabble_score s!\"{c}\") 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2710", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a program that, given a word, computes the scrabble score for that word.\n\n## Letter Values\n\nYou'll need these:\n\n```\nLetter                           Value\nA, E, I, O, U, L, N, R, S, T       1\nD, G                               2\nB, C, M, P                         3\nF, H, V, W, Y                      4\nK                                  5\nJ, X                               8\nQ, Z                               10\n```\n\n```if:ruby,javascript,cfml\nThere will be a preloaded hashtable `$dict` with all these values: `$dict[\"E\"] == 1`. \n```\n```if:haskell\nThere will be a preloaded list of `(Char, Int)` tuples called `dict` with all these values.\n```\n```if:python\nThere will be a preloaded dictionary `dict_scores` with all these values: `dict_scores[\"E\"] == 1`\n```\n\n## Examples\n```\n\"cabbage\" --> 14\n```\n\n\"cabbage\" should be scored as worth 14 points:\n\n- 3 points for C\n- 1 point for A, twice\n- 3 points for B, twice\n- 2 points for G\n- 1 point for E\n\nAnd to total:\n\n`3 + 2*1 + 2*3 + 2 + 1` = `3 + 2 + 6 + 3` = `14`\n\n\nEmpty string should return `0`. The string can contain spaces and letters (upper and lower case), you should calculate the scrabble score only of the letters in that string.\n\n```\n\"\"           --> 0\n\"STREET\"    --> 6\n\"st re et\"    --> 6\n\"ca bba g  e\" --> 14\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef scrabble_score : String → Nat \n  | _ => sorry\n\ntheorem scrabble_score_nonnegative (word : String) : \n  scrabble_score word ≥ 0 := sorry\n\n\n\ntheorem scrabble_score_case_insensitive (word : String) :\n  scrabble_score (word.toLower) = scrabble_score (word.toUpper) := sorry\n\n\n\n\n\ntheorem scrabble_score_sum_individual (word : String) :\n  word ≠ \"\" →\n  scrabble_score word = word.data.foldl (fun acc c => acc + scrabble_score s!\"{c}\") 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2710"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an array of integers, return the smallest common factors of all integers in the array.\n\nWhen i say **Smallest Common Factor** i mean the smallest number above 1 that can divide all numbers in the array without a remainder.\n\nIf there are no common factors above 1, return 1 (technically 1 is always a common factor).\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef scf (nums : List Nat) : Nat :=\n  sorry\n\ndef listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => t.foldl min h\n\npartial def minFactor (n : Nat) : Nat :=\n  if n ≤ 1 then 1 else\n  let rec find (k : Nat) : Nat :=\n    if k * k > n then n\n    else if n % k = 0 then k\n    else find (k + 1)\n  find 2\n\ntheorem scf_basic_properties (nums : List Nat) :\n  let result := scf nums\n  (nums ≠ [] → 1 ≤ result ∧ result ≤ listMin nums) ∧\n  (nums = [] → result = 1) ∧\n  (∀ n ∈ nums, n % result = 0) ∧\n  (result > 1 → ¬ ∃ k, 2 ≤ k ∧ k < result ∧ ∀ n ∈ nums, n % k = 0) :=\n  sorry\n\ntheorem scf_identical_numbers (n : Nat) (h : n ≥ 2) :\n  let nums := List.replicate 5 n\n  scf nums = minFactor n :=\n  sorry\n\ntheorem scf_nonpositive_inputs (nums : List Nat) (h : ∀ n ∈ nums, n = 0) :\n  scf nums = 1 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2717", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an array of integers, return the smallest common factors of all integers in the array.\n\nWhen i say **Smallest Common Factor** i mean the smallest number above 1 that can divide all numbers in the array without a remainder.\n\nIf there are no common factors above 1, return 1 (technically 1 is always a common factor).\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef scf (nums : List Nat) : Nat :=\n  sorry\n\ndef listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => t.foldl min h\n\npartial def minFactor (n : Nat) : Nat :=\n  if n ≤ 1 then 1 else\n  let rec find (k : Nat) : Nat :=\n    if k * k > n then n\n    else if n % k = 0 then k\n    else find (k + 1)\n  find 2\n\ntheorem scf_basic_properties (nums : List Nat) :\n  let result := scf nums\n  (nums ≠ [] → 1 ≤ result ∧ result ≤ listMin nums) ∧\n  (nums = [] → result = 1) ∧\n  (∀ n ∈ nums, n % result = 0) ∧\n  (result > 1 → ¬ ∃ k, 2 ≤ k ∧ k < result ∧ ∀ n ∈ nums, n % k = 0) :=\n  sorry\n\ntheorem scf_identical_numbers (n : Nat) (h : n ≥ 2) :\n  let nums := List.replicate 5 n\n  scf nums = minFactor n :=\n  sorry\n\ntheorem scf_nonpositive_inputs (nums : List Nat) (h : ∀ n ∈ nums, n = 0) :\n  scf nums = 1 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2717"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given an array of strings and your task is to remove all consecutive duplicate letters from each string in the array.\n\nFor example: \n\n  * `dup([\"abracadabra\",\"allottee\",\"assessee\"]) = [\"abracadabra\",\"alote\",\"asese\"]`. \n  \n  * `dup([\"kelless\",\"keenness\"]) = [\"keles\",\"kenes\"]`.\n\nStrings will be lowercase only, no spaces. See test cases for more examples.\n\n~~~if:rust\nFor the sake of simplicity you can use the macro 'vec_of_string' to create a Vec with an array of string literals.\n~~~\n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Alternate capitalization](https://www.codewars.com/kata/59cfc000aeb2844d16000075)\n\n[Vowel consonant lexicon](https://www.codewars.com/kata/59cf8bed1a68b75ffb000026)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef dup (strings : List String) : List String := sorry\n\ntheorem dup_same_length (strings : List String) (h : strings ≠ []) : \n  List.length (dup strings) = List.length strings := \nsorry\n\ntheorem dup_no_consecutive_duplicates (strings : List String) (h : strings ≠ []) :\n  ∀ s ∈ dup strings, ∀ i, i + 1 < s.length → \n  s.data[i]? = some c₁ → s.data[i+1]? = some c₂ → c₁ ≠ c₂ :=\nsorry\n\ntheorem dup_chars_from_input (strings : List String) (h : strings ≠ []) :\n  ∀ (out_str : String), out_str ∈ dup strings → \n  ∀ (in_str : String), in_str ∈ strings → \n  ∀ c, c ∈ out_str.data → c ∈ in_str.data :=\nsorry\n\ntheorem dup_preserves_order (strings : List String) (h : strings ≠ []) :\n  ∀ (out_str : String), out_str ∈ dup strings →\n  ∀ (in_str : String), in_str ∈ strings →\n  ∀ i j, i < j → i < out_str.length → j < out_str.length →\n  out_str.data[i]? = out_str.data[j]? → i + 1 < j :=\nsorry\n\ntheorem dup_output_length (strings : List String) (h : strings ≠ []) (h2 : ∀ s ∈ strings, s.length > 0) :\n  ∀ s ∈ dup strings, s.length ≤ List.foldl (fun acc x => max acc x.length) 0 strings :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2790", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given an array of strings and your task is to remove all consecutive duplicate letters from each string in the array.\n\nFor example: \n\n  * `dup([\"abracadabra\",\"allottee\",\"assessee\"]) = [\"abracadabra\",\"alote\",\"asese\"]`. \n  \n  * `dup([\"kelless\",\"keenness\"]) = [\"keles\",\"kenes\"]`.\n\nStrings will be lowercase only, no spaces. See test cases for more examples.\n\n~~~if:rust\nFor the sake of simplicity you can use the macro 'vec_of_string' to create a Vec with an array of string literals.\n~~~\n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Alternate capitalization](https://www.codewars.com/kata/59cfc000aeb2844d16000075)\n\n[Vowel consonant lexicon](https://www.codewars.com/kata/59cf8bed1a68b75ffb000026)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef dup (strings : List String) : List String := sorry\n\ntheorem dup_same_length (strings : List String) (h : strings ≠ []) : \n  List.length (dup strings) = List.length strings := \nsorry\n\ntheorem dup_no_consecutive_duplicates (strings : List String) (h : strings ≠ []) :\n  ∀ s ∈ dup strings, ∀ i, i + 1 < s.length → \n  s.data[i]? = some c₁ → s.data[i+1]? = some c₂ → c₁ ≠ c₂ :=\nsorry\n\ntheorem dup_chars_from_input (strings : List String) (h : strings ≠ []) :\n  ∀ (out_str : String), out_str ∈ dup strings → \n  ∀ (in_str : String), in_str ∈ strings → \n  ∀ c, c ∈ out_str.data → c ∈ in_str.data :=\nsorry\n\ntheorem dup_preserves_order (strings : List String) (h : strings ≠ []) :\n  ∀ (out_str : String), out_str ∈ dup strings →\n  ∀ (in_str : String), in_str ∈ strings →\n  ∀ i j, i < j → i < out_str.length → j < out_str.length →\n  out_str.data[i]? = out_str.data[j]? → i + 1 < j :=\nsorry\n\ntheorem dup_output_length (strings : List String) (h : strings ≠ []) (h2 : ∀ s ∈ strings, s.length > 0) :\n  ∀ s ∈ dup strings, s.length ≤ List.foldl (fun acc x => max acc x.length) 0 strings :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2790"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nTrigrams are a special case of the n-gram, where n is 3. One trigram is a continious sequence of 3 chars in phrase. [Wikipedia](https://en.wikipedia.org/wiki/Trigram)\n\n - return all trigrams for the given phrase \n - replace spaces with \\_ \n - return an empty string for phrases shorter than 3\n\nExample:\n\ntrigrams('the quick red') ==  the he\\_ e\\_q \\_qu qui uic ick ck\\_ k\\_r \\_re red\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef trigrams (s : String) : String := sorry \n\ndef stringToGrams (s : String) : List String := sorry\n\ntheorem trigrams_empty_if_short (s : String) :\n  s.length < 3 → trigrams s = \"\" := sorry \n\ntheorem trigrams_length (s : String) :\n  s.length ≥ 3 → \n  let res := trigrams s\n  res ≠ \"\" →\n  (stringToGrams res).length = s.length - 2 := sorry\n\ntheorem trigrams_no_spaces_in_grams (s : String) :\n  let res := trigrams s\n  let grams := stringToGrams res\n  ∀ g ∈ grams, ¬ g.contains ' ' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2791", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nTrigrams are a special case of the n-gram, where n is 3. One trigram is a continious sequence of 3 chars in phrase. [Wikipedia](https://en.wikipedia.org/wiki/Trigram)\n\n - return all trigrams for the given phrase \n - replace spaces with \\_ \n - return an empty string for phrases shorter than 3\n\nExample:\n\ntrigrams('the quick red') ==  the he\\_ e\\_q \\_qu qui uic ick ck\\_ k\\_r \\_re red\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef trigrams (s : String) : String := sorry \n\ndef stringToGrams (s : String) : List String := sorry\n\ntheorem trigrams_empty_if_short (s : String) :\n  s.length < 3 → trigrams s = \"\" := sorry \n\ntheorem trigrams_length (s : String) :\n  s.length ≥ 3 → \n  let res := trigrams s\n  res ≠ \"\" →\n  (stringToGrams res).length = s.length - 2 := sorry\n\ntheorem trigrams_no_spaces_in_grams (s : String) :\n  let res := trigrams s\n  let grams := stringToGrams res\n  ∀ g ∈ grams, ¬ g.contains ' ' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2791"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a program that prints a chessboard with N rows and M columns with the following rules:\nThe top left cell must be an asterisk (*)\nAny cell touching (left, right, up or down) a cell with an asterisk must be a dot (.)\nAny cell touching (left, right, up or down) a cell with a dot must be an asterisk.\n\nA chessboard of 8 rows and 8 columns printed using these rules would be:\n```\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n```\nInput\n\nA single line with two integers N and M separated by space. The number N will represent the number of rows and M the number of columns.\n\nOutput\n\nReturn N lines each containing M characters with the chessboard pattern.\nEmpty string if N, M or both are 0.\n\n\nFrom: 2016 AIPO National Finals\nhttp://aipo.computing.dcu.ie/2016-aipo-national-finals-problems\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef chessboard (n: Nat) (m: Nat) : String := sorry\n\ndef String.lines (s: String) : List String := sorry\n\ndef String.characterAt (s: String) (i: Nat) : Char := sorry\n\ntheorem chessboard_empty_for_zero_dims {n m: Nat} :\n  (n = 0 ∨ m = 0) → chessboard n m = \"\" := sorry\n\ntheorem chessboard_dimensions {n m: Nat} (h1 : n ≠ 0) (h2 : m ≠ 0) :\n  let lines := (chessboard n m).lines\n  lines.length = n ∧ \n  ∀ l ∈ lines, l.length = m := sorry\n\ntheorem chessboard_alternating_pattern {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let lines := (chessboard n m).lines\n  ∀ i j, i < n → j < m →\n    let line := lines[i]'(by sorry)\n    let char := line.characterAt j\n    ((i + j) % 2 = 0 → char = '*') ∧\n    ((i + j) % 2 ≠ 0 → char = '.') := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2844", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a program that prints a chessboard with N rows and M columns with the following rules:\nThe top left cell must be an asterisk (*)\nAny cell touching (left, right, up or down) a cell with an asterisk must be a dot (.)\nAny cell touching (left, right, up or down) a cell with a dot must be an asterisk.\n\nA chessboard of 8 rows and 8 columns printed using these rules would be:\n```\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n```\nInput\n\nA single line with two integers N and M separated by space. The number N will represent the number of rows and M the number of columns.\n\nOutput\n\nReturn N lines each containing M characters with the chessboard pattern.\nEmpty string if N, M or both are 0.\n\n\nFrom: 2016 AIPO National Finals\nhttp://aipo.computing.dcu.ie/2016-aipo-national-finals-problems\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef chessboard (n: Nat) (m: Nat) : String := sorry\n\ndef String.lines (s: String) : List String := sorry\n\ndef String.characterAt (s: String) (i: Nat) : Char := sorry\n\ntheorem chessboard_empty_for_zero_dims {n m: Nat} :\n  (n = 0 ∨ m = 0) → chessboard n m = \"\" := sorry\n\ntheorem chessboard_dimensions {n m: Nat} (h1 : n ≠ 0) (h2 : m ≠ 0) :\n  let lines := (chessboard n m).lines\n  lines.length = n ∧ \n  ∀ l ∈ lines, l.length = m := sorry\n\ntheorem chessboard_alternating_pattern {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let lines := (chessboard n m).lines\n  ∀ i j, i < n → j < m →\n    let line := lines[i]'(by sorry)\n    let char := line.characterAt j\n    ((i + j) % 2 = 0 → char = '*') ∧\n    ((i + j) % 2 ≠ 0 → char = '.') := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2844"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an integer `n` return `\"odd\"` if the number of its divisors is odd. Otherwise return `\"even\"`.\n\n**Note**: big inputs will be tested.\n\n## Examples:\n\nAll prime numbers have exactly two divisors (hence `\"even\"`).\n\nFor `n = 12` the divisors are `[1, 2, 3, 4, 6, 12]` – `\"even\"`.\n\nFor `n = 4` the divisors are `[1, 2, 4]` – `\"odd\"`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef oddity (n : Nat) : String := sorry\n\ntheorem oddity_returns_valid_value (n : Nat) (h : n > 0) :\n  oddity n = \"odd\" ∨ oddity n = \"even\" := sorry\n\ntheorem oddity_perfect_square_iff_odd (n : Nat) (h : n > 0) :\n  (∃ k, n = k * k) ↔ oddity n = \"odd\" := sorry\n\ntheorem oddity_one :\n  oddity 1 = \"odd\" := sorry\n\ntheorem oddity_two :\n  oddity 2 = \"even\" := sorry\n\ntheorem oddity_four :\n  oddity 4 = \"odd\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2897", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an integer `n` return `\"odd\"` if the number of its divisors is odd. Otherwise return `\"even\"`.\n\n**Note**: big inputs will be tested.\n\n## Examples:\n\nAll prime numbers have exactly two divisors (hence `\"even\"`).\n\nFor `n = 12` the divisors are `[1, 2, 3, 4, 6, 12]` – `\"even\"`.\n\nFor `n = 4` the divisors are `[1, 2, 4]` – `\"odd\"`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef oddity (n : Nat) : String := sorry\n\ntheorem oddity_returns_valid_value (n : Nat) (h : n > 0) :\n  oddity n = \"odd\" ∨ oddity n = \"even\" := sorry\n\ntheorem oddity_perfect_square_iff_odd (n : Nat) (h : n > 0) :\n  (∃ k, n = k * k) ↔ oddity n = \"odd\" := sorry\n\ntheorem oddity_one :\n  oddity 1 = \"odd\" := sorry\n\ntheorem oddity_two :\n  oddity 2 = \"even\" := sorry\n\ntheorem oddity_four :\n  oddity 4 = \"odd\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2897"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nTheory\n This section does not need to be read and can be skipped, but it does provide some clarity into the inspiration behind the problem.\nIn music theory, a major scale consists of seven notes, or scale degrees, in order (with tonic listed twice for demonstrative purposes):\n\nTonic, the base of the scale and the note the scale is named after (for example, C is the tonic note of the C major scale)\nSupertonic, 2 semitones (or one tone) above the tonic\nMediant, 2 semitones above the supertonic and 4 above the tonic\nSubdominant, 1 semitone above the median and 5 above the tonic\nDominant, 2 semitones above the subdominant and 7 above the tonic\nSubmediant, 2 semitones above the dominant and 9 above the tonic\nLeading tone, 2 semitones above the mediant and 11 above the tonic\nTonic (again!), 1 semitone above the leading tone and 12 semitones (or one octave) above the tonic\n\nAn octave is an interval of 12 semitones, and the pitch class of a note consists of any note that is some integer\nnumber of octaves apart from that note. Notes in the same pitch class sound different but share similar properties. If a note is in a major scale, then any note in that note's pitch class is also in that major scale.\n\n Problem  \nUsing integers to represent notes, the major scale of an integer note will be an array (or list) of integers that follows the major scale pattern note, note + 2, note + 4, note + 5, note + 7, note + 9, note + 11. For example, the array of integers [1, 3, 5, 6, 8, 10, 12] is the major scale of  1.\nSecondly, the pitch class of a note will be the set of all integers some multiple of 12 above or below the note. For example, 1, 13, and 25 are all in the same pitch class.\nThirdly, an integer note1 is considered to be in the key of an integer note2 if note1, or some integer in note1's pitch class, is in the major scale of note2.  More mathematically, an integer note1 is in the key of an integer note2 if there exists an integer i such that note1 + i × 12 is in the major scale of note2. For example, 22 is in the key of of 1 because, even though 22 is not in 1's major scale ([1, 3, 5, 6, 8, 10, 12]), 10 is and is also a multiple of 12 away from 22. Likewise, -21 is also in the key of 1 because -21 + (2 × 12) = 3 and 3 is present in the major scale of 1. An array is in the key of an integer if all its elements are in the key of the integer.\n\nYour job is to create a function is_tune that will return whether or not an array (or list) of integers is a tune. An array will be considered a tune if there exists a single integer note all the integers in the array are in the key of. The function will accept an array of integers as its parameter and return True if the array is a tune or False otherwise. Empty and null arrays are not considered to be tunes. Additionally, the function should not change the input array.\n Examples \n\n```python\nis_tune([1, 3, 6, 8, 10, 12]) # Returns True, all the elements are in the major scale  \n    # of 1 ([1, 3, 5, 6, 8, 10, 12]) and so are in the key of 1.\nis_tune([1, 3, 6, 8, 10, 12, 13, 15]) # Returns True, 14 and 15 are also in the key of 1 as \n    # they are in the major scale of 13 which is in the pitch class of 1 (13 = 1 + 12 * 1).\nis_tune([1, 6, 3]) # Returns True, arrays don't need to be sorted.\nis_tune([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) # Returns False, this array is not in the \n    # key of any integer.\nis_tune([2, 4, 7, 9, 11, 13]) # Returns True, the array is in the key of 2 (the arrays\n    #  don't need to be in the key of 1, just some integer)\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef is_tune (notes: List Int) : Bool := sorry\n\ntheorem empty_list_not_tune : \n  ∀ (notes: List Int), \n  notes = [] → ¬ is_tune notes := sorry\n\ntheorem shifted_notes_preserve_tune :\n  ∀ (notes: List Int),\n  notes ≠ [] →\n  is_tune notes = is_tune (notes.map (· + 12)) := sorry\n\ntheorem major_scale_subset_is_tune :\n  ∀ (notes: List Int),\n  notes ≠ [] →\n  (∀ n ∈ notes, n % 12 ∈ [0, 2, 4, 5, 7, 9, 11]) →\n  is_tune notes := sorry\n\ntheorem modulo_12_preserves_tune :\n  ∀ (notes: List Int),\n  notes ≠ [] →\n  is_tune notes = is_tune (notes.map (· % 12)) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2909", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nTheory\n This section does not need to be read and can be skipped, but it does provide some clarity into the inspiration behind the problem.\nIn music theory, a major scale consists of seven notes, or scale degrees, in order (with tonic listed twice for demonstrative purposes):\n\nTonic, the base of the scale and the note the scale is named after (for example, C is the tonic note of the C major scale)\nSupertonic, 2 semitones (or one tone) above the tonic\nMediant, 2 semitones above the supertonic and 4 above the tonic\nSubdominant, 1 semitone above the median and 5 above the tonic\nDominant, 2 semitones above the subdominant and 7 above the tonic\nSubmediant, 2 semitones above the dominant and 9 above the tonic\nLeading tone, 2 semitones above the mediant and 11 above the tonic\nTonic (again!), 1 semitone above the leading tone and 12 semitones (or one octave) above the tonic\n\nAn octave is an interval of 12 semitones, and the pitch class of a note consists of any note that is some integer\nnumber of octaves apart from that note. Notes in the same pitch class sound different but share similar properties. If a note is in a major scale, then any note in that note's pitch class is also in that major scale.\n\n Problem  \nUsing integers to represent notes, the major scale of an integer note will be an array (or list) of integers that follows the major scale pattern note, note + 2, note + 4, note + 5, note + 7, note + 9, note + 11. For example, the array of integers [1, 3, 5, 6, 8, 10, 12] is the major scale of  1.\nSecondly, the pitch class of a note will be the set of all integers some multiple of 12 above or below the note. For example, 1, 13, and 25 are all in the same pitch class.\nThirdly, an integer note1 is considered to be in the key of an integer note2 if note1, or some integer in note1's pitch class, is in the major scale of note2.  More mathematically, an integer note1 is in the key of an integer note2 if there exists an integer i such that note1 + i × 12 is in the major scale of note2. For example, 22 is in the key of of 1 because, even though 22 is not in 1's major scale ([1, 3, 5, 6, 8, 10, 12]), 10 is and is also a multiple of 12 away from 22. Likewise, -21 is also in the key of 1 because -21 + (2 × 12) = 3 and 3 is present in the major scale of 1. An array is in the key of an integer if all its elements are in the key of the integer.\n\nYour job is to create a function is_tune that will return whether or not an array (or list) of integers is a tune. An array will be considered a tune if there exists a single integer note all the integers in the array are in the key of. The function will accept an array of integers as its parameter and return True if the array is a tune or False otherwise. Empty and null arrays are not considered to be tunes. Additionally, the function should not change the input array.\n Examples \n\n```python\nis_tune([1, 3, 6, 8, 10, 12]) # Returns True, all the elements are in the major scale  \n    # of 1 ([1, 3, 5, 6, 8, 10, 12]) and so are in the key of 1.\nis_tune([1, 3, 6, 8, 10, 12, 13, 15]) # Returns True, 14 and 15 are also in the key of 1 as \n    # they are in the major scale of 13 which is in the pitch class of 1 (13 = 1 + 12 * 1).\nis_tune([1, 6, 3]) # Returns True, arrays don't need to be sorted.\nis_tune([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) # Returns False, this array is not in the \n    # key of any integer.\nis_tune([2, 4, 7, 9, 11, 13]) # Returns True, the array is in the key of 2 (the arrays\n    #  don't need to be in the key of 1, just some integer)\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef is_tune (notes: List Int) : Bool := sorry\n\ntheorem empty_list_not_tune : \n  ∀ (notes: List Int), \n  notes = [] → ¬ is_tune notes := sorry\n\ntheorem shifted_notes_preserve_tune :\n  ∀ (notes: List Int),\n  notes ≠ [] →\n  is_tune notes = is_tune (notes.map (· + 12)) := sorry\n\ntheorem major_scale_subset_is_tune :\n  ∀ (notes: List Int),\n  notes ≠ [] →\n  (∀ n ∈ notes, n % 12 ∈ [0, 2, 4, 5, 7, 9, 11]) →\n  is_tune notes := sorry\n\ntheorem modulo_12_preserves_tune :\n  ∀ (notes: List Int),\n  notes ≠ [] →\n  is_tune notes = is_tune (notes.map (· % 12)) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2909"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nI'm afraid you're in a rather unfortunate situation. You've injured your leg, and are unable to walk, and a number of zombies are shuffling towards you, intent on eating your brains. Luckily, you're a crack shot, and have your trusty rifle to hand.\n\nThe zombies start at `range` metres, and move at 0.5 metres per second. Each second, you first shoot one zombie, and then the remaining zombies shamble forwards another 0.5 metres.\n\nIf any zombies manage to get to 0 metres, you get eaten. If you run out of ammo before shooting all the zombies, you'll also get eaten. To keep things simple, we can ignore any time spent reloading.\n\nWrite a function that accepts the total number of zombies, a range in metres, and the number of bullets you have.\n\nIf you shoot all the zombies, return \"You shot all X zombies.\"\nIf you get eaten before killing all the zombies, and before running out of ammo, return \"You shot X zombies before being eaten: overwhelmed.\"\nIf you run out of ammo before shooting all the zombies, return \"You shot X zombies before being eaten: ran out of ammo.\"\n\n(If you run out of ammo at the same time as the remaining zombies reach you, return \"You shot X zombies before being eaten: overwhelmed.\".)\n\nGood luck! (I think you're going to need it.)\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef zombieShootout (zombies ammo : Int) (distance : Float) : String := sorry \n\ndef containsStr (s₁ s₂ : String) : Bool := \n  let s₁chars := s₁.data\n  let s₂chars := s₂.data\n  sorry\n\ntheorem zombieShootout_output_contains_zombies (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ 0) (h3 : ammo ≥ 0) : \n  containsStr (zombieShootout zombies ammo distance).toLower \"zombies\" = true := sorry\n\ntheorem zombieShootout_zero_zombies (ammo : Int) (distance : Float) \n  (h1 : distance ≥ 0) (h2 : ammo ≥ 0) :\n  zombieShootout 0 ammo distance = \"You shot all 0 zombies.\" := sorry\n\ntheorem zombieShootout_zero_distance (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≤ 0) (h3 : ammo ≥ 0) :\n  (zombieShootout zombies ammo distance).endsWith \"overwhelmed.\" := sorry\n\ntheorem zombieShootout_zero_ammo (zombies : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ 0) :\n  (zombieShootout zombies 0 distance).endsWith \"ran out of ammo.\" := sorry\n\ntheorem zombieShootout_all_shot (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ Float.ofInt zombies / 2) \n  (h3 : ammo ≥ zombies) (h4 : distance ≥ 0) (h5 : ammo ≥ 0) :\n  containsStr (zombieShootout zombies ammo distance) \"all\" → \n  zombieShootout zombies ammo distance = s!\"You shot all {zombies} zombies.\" := sorry\n\ntheorem zombieShootout_ran_out_ammo (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ 0) (h3 : ammo ≥ 0)\n  (h4 : zombies > ammo) (h5 : distance > Float.ofInt ammo / 2) :\n  (zombieShootout zombies ammo distance).endsWith \"ran out of ammo.\" ∧\n  containsStr (zombieShootout zombies ammo distance) (toString ammo) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2927", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nI'm afraid you're in a rather unfortunate situation. You've injured your leg, and are unable to walk, and a number of zombies are shuffling towards you, intent on eating your brains. Luckily, you're a crack shot, and have your trusty rifle to hand.\n\nThe zombies start at `range` metres, and move at 0.5 metres per second. Each second, you first shoot one zombie, and then the remaining zombies shamble forwards another 0.5 metres.\n\nIf any zombies manage to get to 0 metres, you get eaten. If you run out of ammo before shooting all the zombies, you'll also get eaten. To keep things simple, we can ignore any time spent reloading.\n\nWrite a function that accepts the total number of zombies, a range in metres, and the number of bullets you have.\n\nIf you shoot all the zombies, return \"You shot all X zombies.\"\nIf you get eaten before killing all the zombies, and before running out of ammo, return \"You shot X zombies before being eaten: overwhelmed.\"\nIf you run out of ammo before shooting all the zombies, return \"You shot X zombies before being eaten: ran out of ammo.\"\n\n(If you run out of ammo at the same time as the remaining zombies reach you, return \"You shot X zombies before being eaten: overwhelmed.\".)\n\nGood luck! (I think you're going to need it.)\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef zombieShootout (zombies ammo : Int) (distance : Float) : String := sorry \n\ndef containsStr (s₁ s₂ : String) : Bool := \n  let s₁chars := s₁.data\n  let s₂chars := s₂.data\n  sorry\n\ntheorem zombieShootout_output_contains_zombies (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ 0) (h3 : ammo ≥ 0) : \n  containsStr (zombieShootout zombies ammo distance).toLower \"zombies\" = true := sorry\n\ntheorem zombieShootout_zero_zombies (ammo : Int) (distance : Float) \n  (h1 : distance ≥ 0) (h2 : ammo ≥ 0) :\n  zombieShootout 0 ammo distance = \"You shot all 0 zombies.\" := sorry\n\ntheorem zombieShootout_zero_distance (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≤ 0) (h3 : ammo ≥ 0) :\n  (zombieShootout zombies ammo distance).endsWith \"overwhelmed.\" := sorry\n\ntheorem zombieShootout_zero_ammo (zombies : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ 0) :\n  (zombieShootout zombies 0 distance).endsWith \"ran out of ammo.\" := sorry\n\ntheorem zombieShootout_all_shot (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ Float.ofInt zombies / 2) \n  (h3 : ammo ≥ zombies) (h4 : distance ≥ 0) (h5 : ammo ≥ 0) :\n  containsStr (zombieShootout zombies ammo distance) \"all\" → \n  zombieShootout zombies ammo distance = s!\"You shot all {zombies} zombies.\" := sorry\n\ntheorem zombieShootout_ran_out_ammo (zombies ammo : Int) (distance : Float)\n  (h1 : zombies ≥ 0) (h2 : distance ≥ 0) (h3 : ammo ≥ 0)\n  (h4 : zombies > ammo) (h5 : distance > Float.ofInt ammo / 2) :\n  (zombieShootout zombies ammo distance).endsWith \"ran out of ammo.\" ∧\n  containsStr (zombieShootout zombies ammo distance) (toString ammo) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2927"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and return who wins the fight. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3\n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3\n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.\n\n# Example\n\n# Alphabet war Collection\n\n\n\nAlphavet war \n\n\nAlphabet war - airstrike - letters massacre\n\n\nAlphabet wars - reinforces massacre\n\n\nAlphabet wars - nuclear strike\n\n\nAlphabet war - Wo lo loooooo priests join the war\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef alphabet_war (s : String) : String := sorry\n\ndef valid_letters := ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']\n\ndef score_map (c : Char) : Int :=\n  match c with\n  | 'w' => 4\n  | 'p' => 3  \n  | 'b' => 2\n  | 's' => 1\n  | 'm' => -4\n  | 'q' => -3\n  | 'd' => -2\n  | 'z' => -1\n  | _ => 0\n\ntheorem alphabet_war_valid_output (s : String) :\n  alphabet_war s = \"Left side wins!\" ∨ \n  alphabet_war s = \"Right side wins!\" ∨\n  alphabet_war s = \"Let's fight again!\" := sorry\n\ntheorem alphabet_war_invalid_chars (s : String) : \n  alphabet_war s = \"Left side wins!\" ∨\n  alphabet_war s = \"Right side wins!\" ∨ \n  alphabet_war s = \"Let's fight again!\" := sorry\n\ntheorem alphabet_war_scoring (s : String) (h : s.all (λ c => c ∈ valid_letters)) :\n  let score := s.foldr (λ c acc => acc + score_map c) 0\n  if score > 0 then \n    alphabet_war s = \"Left side wins!\"\n  else if score < 0 then\n    alphabet_war s = \"Right side wins!\"\n  else\n    alphabet_war s = \"Let's fight again!\" := sorry\n\ntheorem alphabet_war_opposing_sides (left right : String)\n  (h1 : left.all (λ c => c ∈ ['w', 'p', 'b', 's']))\n  (h2 : right.all (λ c => c ∈ ['m', 'q', 'd', 'z'])) :\n  alphabet_war (left ++ right) = \"Left side wins!\" ∨\n  alphabet_war (left ++ right) = \"Right side wins!\" ∨\n  alphabet_war (left ++ right) = \"Let's fight again!\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2928", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and return who wins the fight. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3\n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3\n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.\n\n# Example\n\n# Alphabet war Collection\n\n\n\nAlphavet war \n\n\nAlphabet war - airstrike - letters massacre\n\n\nAlphabet wars - reinforces massacre\n\n\nAlphabet wars - nuclear strike\n\n\nAlphabet war - Wo lo loooooo priests join the war\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef alphabet_war (s : String) : String := sorry\n\ndef valid_letters := ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']\n\ndef score_map (c : Char) : Int :=\n  match c with\n  | 'w' => 4\n  | 'p' => 3  \n  | 'b' => 2\n  | 's' => 1\n  | 'm' => -4\n  | 'q' => -3\n  | 'd' => -2\n  | 'z' => -1\n  | _ => 0\n\ntheorem alphabet_war_valid_output (s : String) :\n  alphabet_war s = \"Left side wins!\" ∨ \n  alphabet_war s = \"Right side wins!\" ∨\n  alphabet_war s = \"Let's fight again!\" := sorry\n\ntheorem alphabet_war_invalid_chars (s : String) : \n  alphabet_war s = \"Left side wins!\" ∨\n  alphabet_war s = \"Right side wins!\" ∨ \n  alphabet_war s = \"Let's fight again!\" := sorry\n\ntheorem alphabet_war_scoring (s : String) (h : s.all (λ c => c ∈ valid_letters)) :\n  let score := s.foldr (λ c acc => acc + score_map c) 0\n  if score > 0 then \n    alphabet_war s = \"Left side wins!\"\n  else if score < 0 then\n    alphabet_war s = \"Right side wins!\"\n  else\n    alphabet_war s = \"Let's fight again!\" := sorry\n\ntheorem alphabet_war_opposing_sides (left right : String)\n  (h1 : left.all (λ c => c ∈ ['w', 'p', 'b', 's']))\n  (h2 : right.all (λ c => c ∈ ['m', 'q', 'd', 'z'])) :\n  alphabet_war (left ++ right) = \"Left side wins!\" ∨\n  alphabet_war (left ++ right) = \"Right side wins!\" ∨\n  alphabet_war (left ++ right) = \"Let's fight again!\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2928"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an array of non-negative integers, your task is to complete the series from 0 to the highest number in the array.\n\nIf the numbers in the sequence provided are not in order you should order them, but if a value repeats, then you must return a sequence with only one item, and the value of that item must be 0. like this:\n```\ninputs        outputs\n[2,1]     ->  [0,1,2]\n[1,4,4,6] ->  [0]\n```\nNotes: all numbers are positive integers.\n\nThis is set of example outputs based on the input sequence.\n```\ninputs        outputs\n[0,1]   ->    [0,1]\n[1,4,6] ->    [0,1,2,3,4,5,6]\n[3,4,5] ->    [0,1,2,3,4,5]\n[0,1,0] ->    [0]\n```\n```\n#####\n\nTo answer this question, you need to replace the 9 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef complete_series (arr : List Nat) : List Nat := sorry\n\ntheorem complete_series_returns_list (arr : List Nat) :\n  ∃ l, complete_series arr = l := by sorry\n\ntheorem complete_series_main_property (arr : List Nat) :\n  (∃ x ∈ arr, ∃ y ∈ arr, x = y ∧ arr.indexOf x ≠ arr.indexOf y) →\n  complete_series arr = [0] := by sorry\n\ntheorem complete_series_complete_sequence (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  complete_series arr = List.range (maxVal + 1) := by sorry \n\ntheorem complete_series_length (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  (complete_series arr).length = maxVal + 1 := by sorry\n\ntheorem complete_series_contains_all_elements (arr : List Nat) : \n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  ∀ i, i ≤ maxVal → i ∈ complete_series arr := by sorry\n\ntheorem complete_series_monotone (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  ∀ i j, i < j → i < (complete_series arr).length → j < (complete_series arr).length →\n  (complete_series arr).get ⟨i, by sorry⟩ ≤ (complete_series arr).get ⟨j, by sorry⟩ := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "2961", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given an array of non-negative integers, your task is to complete the series from 0 to the highest number in the array.\n\nIf the numbers in the sequence provided are not in order you should order them, but if a value repeats, then you must return a sequence with only one item, and the value of that item must be 0. like this:\n```\ninputs        outputs\n[2,1]     ->  [0,1,2]\n[1,4,4,6] ->  [0]\n```\nNotes: all numbers are positive integers.\n\nThis is set of example outputs based on the input sequence.\n```\ninputs        outputs\n[0,1]   ->    [0,1]\n[1,4,6] ->    [0,1,2,3,4,5,6]\n[3,4,5] ->    [0,1,2,3,4,5]\n[0,1,0] ->    [0]\n```\n```\n#####\n\nTo answer this question, you need to replace the 9 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef complete_series (arr : List Nat) : List Nat := sorry\n\ntheorem complete_series_returns_list (arr : List Nat) :\n  ∃ l, complete_series arr = l := by sorry\n\ntheorem complete_series_main_property (arr : List Nat) :\n  (∃ x ∈ arr, ∃ y ∈ arr, x = y ∧ arr.indexOf x ≠ arr.indexOf y) →\n  complete_series arr = [0] := by sorry\n\ntheorem complete_series_complete_sequence (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  complete_series arr = List.range (maxVal + 1) := by sorry \n\ntheorem complete_series_length (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  (complete_series arr).length = maxVal + 1 := by sorry\n\ntheorem complete_series_contains_all_elements (arr : List Nat) : \n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  ∀ i, i ≤ maxVal → i ∈ complete_series arr := by sorry\n\ntheorem complete_series_monotone (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  ∀ i j, i < j → i < (complete_series arr).length → j < (complete_series arr).length →\n  (complete_series arr).get ⟨i, by sorry⟩ ≤ (complete_series arr).get ⟨j, by sorry⟩ := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "2961"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nStory\nJumbo Juice makes a fresh juice out of fruits of your choice.Jumbo Juice charges $5 for regular fruits and $7 for special ones. Regular fruits are Banana, Orange, Apple, Lemon and Grapes. Special ones are Avocado, Strawberry and Mango. Others fruits that are not listed are also available upon request. Those extra special fruits cost $9 per each. There is no limit on how many fruits she/he picks.The price of a cup of juice is the mean of price of chosen fruits. In case of decimal number (ex. $5.99), output should be the nearest integer (use the standard rounding function of your language of choice). \n\nInput\nThe function will receive an array of strings, each with the name of a fruit. The recognition of names should be case insensitive. There is no case of an enmpty array input.  \n\n\nExample\n\n```\n['Mango', 'Banana', 'Avocado'] //the price of this juice bottle is (7+5+7)/3 = $6($6.333333...)\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef mix_fruit (fruits : List String) : Nat :=\n  sorry\n\ntheorem mix_fruit_price_bounds (fruits : List String) \n  (h : fruits.length > 0)\n  (h2 : ∀ f ∈ fruits, f ∈ [\n    \"banana\", \"BANANA\", \"Banana\",\n    \"orange\", \"ORANGE\", \"Orange\",\n    \"apple\", \"APPLE\", \"Apple\", \n    \"lemon\", \"LEMON\", \"Lemon\",\n    \"grapes\", \"GRAPES\", \"Grapes\",\n    \"avocado\", \"AVOCADO\", \"Avocado\",\n    \"strawberry\", \"STRAWBERRY\", \"Strawberry\",\n    \"mango\", \"MANGO\", \"Mango\", \n    \"kiwi\", \"KIWI\", \"Kiwi\",\n    \"melon\", \"MELON\", \"Melon\",\n    \"watermelon\", \"WATERMELON\", \"Watermelon\"\n  ]) :\n  5 ≤ mix_fruit fruits ∧ mix_fruit fruits ≤ 9 :=\n  sorry\n\ntheorem regular_fruits_price (fruits : List String)\n  (h : fruits.length > 0)\n  (h2 : ∀ f ∈ fruits, f ∈ [\"banana\", \"orange\", \"apple\", \"lemon\", \"grapes\"]) :\n  mix_fruit fruits = 5 :=\n  sorry\n\ntheorem special_fruits_price (fruits : List String)\n  (h : fruits.length > 0) \n  (h2 : ∀ f ∈ fruits, f ∈ [\"avocado\", \"strawberry\", \"mango\"]) :\n  mix_fruit fruits = 7 :=\n  sorry\n\ntheorem other_fruits_price (fruits : List String)\n  (h : fruits.length > 0)\n  (h2 : ∀ f ∈ fruits, f = \"kiwi\") :\n  mix_fruit fruits = 9 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3063", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nStory\nJumbo Juice makes a fresh juice out of fruits of your choice.Jumbo Juice charges $5 for regular fruits and $7 for special ones. Regular fruits are Banana, Orange, Apple, Lemon and Grapes. Special ones are Avocado, Strawberry and Mango. Others fruits that are not listed are also available upon request. Those extra special fruits cost $9 per each. There is no limit on how many fruits she/he picks.The price of a cup of juice is the mean of price of chosen fruits. In case of decimal number (ex. $5.99), output should be the nearest integer (use the standard rounding function of your language of choice). \n\nInput\nThe function will receive an array of strings, each with the name of a fruit. The recognition of names should be case insensitive. There is no case of an enmpty array input.  \n\n\nExample\n\n```\n['Mango', 'Banana', 'Avocado'] //the price of this juice bottle is (7+5+7)/3 = $6($6.333333...)\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef mix_fruit (fruits : List String) : Nat :=\n  sorry\n\ntheorem mix_fruit_price_bounds (fruits : List String) \n  (h : fruits.length > 0)\n  (h2 : ∀ f ∈ fruits, f ∈ [\n    \"banana\", \"BANANA\", \"Banana\",\n    \"orange\", \"ORANGE\", \"Orange\",\n    \"apple\", \"APPLE\", \"Apple\", \n    \"lemon\", \"LEMON\", \"Lemon\",\n    \"grapes\", \"GRAPES\", \"Grapes\",\n    \"avocado\", \"AVOCADO\", \"Avocado\",\n    \"strawberry\", \"STRAWBERRY\", \"Strawberry\",\n    \"mango\", \"MANGO\", \"Mango\", \n    \"kiwi\", \"KIWI\", \"Kiwi\",\n    \"melon\", \"MELON\", \"Melon\",\n    \"watermelon\", \"WATERMELON\", \"Watermelon\"\n  ]) :\n  5 ≤ mix_fruit fruits ∧ mix_fruit fruits ≤ 9 :=\n  sorry\n\ntheorem regular_fruits_price (fruits : List String)\n  (h : fruits.length > 0)\n  (h2 : ∀ f ∈ fruits, f ∈ [\"banana\", \"orange\", \"apple\", \"lemon\", \"grapes\"]) :\n  mix_fruit fruits = 5 :=\n  sorry\n\ntheorem special_fruits_price (fruits : List String)\n  (h : fruits.length > 0) \n  (h2 : ∀ f ∈ fruits, f ∈ [\"avocado\", \"strawberry\", \"mango\"]) :\n  mix_fruit fruits = 7 :=\n  sorry\n\ntheorem other_fruits_price (fruits : List String)\n  (h : fruits.length > 0)\n  (h2 : ∀ f ∈ fruits, f = \"kiwi\") :\n  mix_fruit fruits = 9 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3063"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function `insertDash(num)`/`InsertDash(int num)` that will insert dashes ('-') between each two odd numbers in num. For example: if num is 454793 the output should be 4547-9-3. Don't count zero as an odd number.\n\nNote that the number will always be non-negative (>= 0).\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef insert_dash (n : Nat) : String :=\n  sorry\n\ntheorem insert_dash_outputs_string : ∀ n : Nat,\n  ∃ s : String, insert_dash n = s :=\nsorry\n\ntheorem insert_dash_valid_chars : ∀ n : Nat,\n  ∀ c ∈ (insert_dash n).data, c = '-' ∨ ('0'.toNat ≤ c.toNat ∧ c.toNat ≤ '9'.toNat) :=\nsorry \n\ntheorem insert_dash_preserves_digits : ∀ n : Nat,\n  ((insert_dash n).data.filter (λ c => '0'.toNat ≤ c.toNat ∧ c.toNat ≤ '9'.toNat)).length = (toString n).length :=\nsorry\n\ntheorem insert_dash_between_odd : ∀ n : Nat,\n  let parts := (insert_dash n).split (· = '-')\n  ∀ i, i + 1 < parts.length →\n    let last_digit := parts[i]!.data[parts[i]!.length - 1]!\n    let first_digit := parts[i+1]!.data[0]!\n    (last_digit.toNat - '0'.toNat) % 2 = 1 ∧ \n    (first_digit.toNat - '0'.toNat) % 2 = 1 :=\nsorry\n\ntheorem insert_dash_reversible : ∀ n : Nat,\n  (String.toNat! ((insert_dash n).replace \"-\" \"\")) = n :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3093", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function `insertDash(num)`/`InsertDash(int num)` that will insert dashes ('-') between each two odd numbers in num. For example: if num is 454793 the output should be 4547-9-3. Don't count zero as an odd number.\n\nNote that the number will always be non-negative (>= 0).\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef insert_dash (n : Nat) : String :=\n  sorry\n\ntheorem insert_dash_outputs_string : ∀ n : Nat,\n  ∃ s : String, insert_dash n = s :=\nsorry\n\ntheorem insert_dash_valid_chars : ∀ n : Nat,\n  ∀ c ∈ (insert_dash n).data, c = '-' ∨ ('0'.toNat ≤ c.toNat ∧ c.toNat ≤ '9'.toNat) :=\nsorry \n\ntheorem insert_dash_preserves_digits : ∀ n : Nat,\n  ((insert_dash n).data.filter (λ c => '0'.toNat ≤ c.toNat ∧ c.toNat ≤ '9'.toNat)).length = (toString n).length :=\nsorry\n\ntheorem insert_dash_between_odd : ∀ n : Nat,\n  let parts := (insert_dash n).split (· = '-')\n  ∀ i, i + 1 < parts.length →\n    let last_digit := parts[i]!.data[parts[i]!.length - 1]!\n    let first_digit := parts[i+1]!.data[0]!\n    (last_digit.toNat - '0'.toNat) % 2 = 1 ∧ \n    (first_digit.toNat - '0'.toNat) % 2 = 1 :=\nsorry\n\ntheorem insert_dash_reversible : ∀ n : Nat,\n  (String.toNat! ((insert_dash n).replace \"-\" \"\")) = n :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3093"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThere are several (or no) spiders, butterflies, and dragonflies. \n\nIn this kata, a spider has eight legs. A dragonfly or a butterfly has six legs. A __dragonfly__ has __two__ pairs of wings, while a __butterfly__ has __one__ pair of wings. __I am not sure whether they are biologically correct, but the values apply here. __\n\nGiven the number of total heads, legs, and __pairs of__ wings, please calculate numbers of each kind of bugs. Of course they are integers. \n_However, I do not guarantee that they are positive in the test cases. \nPlease regard the minus numbers as cases that does not make sense. _\n\nIf answers make sense, return [n\\_spider, n\\_butterfly, n\\_dragonfly]; \nelse, please return [-1, -1, -1]. \n\nExample: \n\ncal\\_n\\_bug(3, 20, 3) = [1, 1, 1]\nOne spider, one butterfly, one dragonfly in total have three heads, twenty legs (8 for the spider, 6 for the butterfly, and 6 for the dragonfly), and _three pairs_ of wings (1 for the butterfly and 2 for the dragonfly).\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef cal_n_bug (heads : Int) (legs : Int) (wings : Int) : List Int :=\n  sorry\n\ntheorem valid_output_structure_heads_spiders\n  (n : Int) :\n  let result := cal_n_bug n (n*6) n\n  result.length = 3 ∧ \n  (∀ x ∈ result, x ≥ 0 ∨ result = [-1, -1, -1]) :=\nsorry\n\ntheorem total_creatures_match_heads\n  (heads legs wings : Int) :\n  let result := cal_n_bug heads legs wings\n  result ≠ [-1, -1, -1] →\n  result.foldl (init := 0) (·+·) = heads :=\nsorry\n\ntheorem legs_and_wings_match\n  (spider butterfly dragonfly : Int) :\n  let total := spider + butterfly + dragonfly\n  let legs := spider*8 + butterfly*6 + dragonfly*6 \n  let wings := butterfly + dragonfly*2\n  cal_n_bug total legs wings = [spider, butterfly, dragonfly] := \nsorry\n\ntheorem negative_heads_invalid\n  (n : Int) :\n  n < 0 →\n  cal_n_bug n 0 0 = [-1, -1, -1] :=\nsorry\n\ntheorem impossible_combinations\n  (n : Int) :\n  n > 0 →\n  cal_n_bug n 3 n = [-1, -1, -1] ∧\n  cal_n_bug n (n*8) n = [-1, -1, -1] :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3116", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThere are several (or no) spiders, butterflies, and dragonflies. \n\nIn this kata, a spider has eight legs. A dragonfly or a butterfly has six legs. A __dragonfly__ has __two__ pairs of wings, while a __butterfly__ has __one__ pair of wings. __I am not sure whether they are biologically correct, but the values apply here. __\n\nGiven the number of total heads, legs, and __pairs of__ wings, please calculate numbers of each kind of bugs. Of course they are integers. \n_However, I do not guarantee that they are positive in the test cases. \nPlease regard the minus numbers as cases that does not make sense. _\n\nIf answers make sense, return [n\\_spider, n\\_butterfly, n\\_dragonfly]; \nelse, please return [-1, -1, -1]. \n\nExample: \n\ncal\\_n\\_bug(3, 20, 3) = [1, 1, 1]\nOne spider, one butterfly, one dragonfly in total have three heads, twenty legs (8 for the spider, 6 for the butterfly, and 6 for the dragonfly), and _three pairs_ of wings (1 for the butterfly and 2 for the dragonfly).\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef cal_n_bug (heads : Int) (legs : Int) (wings : Int) : List Int :=\n  sorry\n\ntheorem valid_output_structure_heads_spiders\n  (n : Int) :\n  let result := cal_n_bug n (n*6) n\n  result.length = 3 ∧ \n  (∀ x ∈ result, x ≥ 0 ∨ result = [-1, -1, -1]) :=\nsorry\n\ntheorem total_creatures_match_heads\n  (heads legs wings : Int) :\n  let result := cal_n_bug heads legs wings\n  result ≠ [-1, -1, -1] →\n  result.foldl (init := 0) (·+·) = heads :=\nsorry\n\ntheorem legs_and_wings_match\n  (spider butterfly dragonfly : Int) :\n  let total := spider + butterfly + dragonfly\n  let legs := spider*8 + butterfly*6 + dragonfly*6 \n  let wings := butterfly + dragonfly*2\n  cal_n_bug total legs wings = [spider, butterfly, dragonfly] := \nsorry\n\ntheorem negative_heads_invalid\n  (n : Int) :\n  n < 0 →\n  cal_n_bug n 0 0 = [-1, -1, -1] :=\nsorry\n\ntheorem impossible_combinations\n  (n : Int) :\n  n > 0 →\n  cal_n_bug n 3 n = [-1, -1, -1] ∧\n  cal_n_bug n (n*8) n = [-1, -1, -1] :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3116"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n< PREVIOUS KATA\nNEXT KATA >\n\n## Task:\n\nYou have to write a function `pattern` which returns the following Pattern(See Examples) upto desired number of rows. \n\n* Note:`Returning` the pattern is not the same as `Printing` the pattern.\n\n## Parameters:\n    \n    pattern(        n        ,        y        );\n                    ^                 ^         \n                    |                 |         \n             Term upto which   Number of times  \n              Basic Pattern     Basic Pattern   \n                should be         should be     \n                 created          repeated      \n                                 vertically    \n    \n* Note: `Basic Pattern` means what we created in Complete The Pattern #12 i.e. a `simple X`.\n\n## Rules/Note:\n\n* The pattern should be created using only unit digits.\n* If `n < 1` then it should return \"\" i.e. empty string.\n* If `y <= 1` then the basic pattern should not be repeated vertically.\n* `The length of each line is same`, and is equal to the length of longest line in the pattern.\n* Range of Parameters (for the sake of CW Compiler) :\n  + `n ∈ (-∞,50]`\n  + `y ∈ (-∞,25]`\n* If only one argument is passed then the function `pattern` should run as if `y <= 1`.\n* The function `pattern` should work when extra arguments are passed, by ignoring the extra arguments.\n   \n   \n## Examples:\n\n#### Having Two Arguments:\n\n##### pattern(4,3):\n\n        1     1\n         2   2 \n          3 3  \n           4   \n          3 3  \n         2   2 \n        1     1\n         2   2 \n          3 3  \n           4   \n          3 3  \n         2   2 \n        1     1\n         2   2 \n          3 3  \n           4   \n          3 3  \n         2   2 \n        1     1\n       \n##### pattern(10,2):\n\n        1                 1\n         2               2 \n          3             3  \n           4           4   \n            5         5    \n             6       6     \n              7     7      \n               8   8       \n                9 9        \n                 0         \n                9 9        \n               8   8       \n              7     7      \n             6       6     \n            5         5    \n           4           4   \n          3             3  \n         2               2 \n        1                 1\n         2               2 \n          3             3  \n           4           4   \n            5         5    \n             6       6     \n              7     7      \n               8   8       \n                9 9        \n                 0         \n                9 9        \n               8   8       \n              7     7      \n             6       6     \n            5         5    \n           4           4   \n          3             3  \n         2               2 \n        1                 1\n\n\n\n#### Having Only One Argument:\n\n##### pattern(25):\n\n        1                                               1\n         2                                             2 \n          3                                           3  \n           4                                         4   \n            5                                       5    \n             6                                     6     \n              7                                   7      \n               8                                 8       \n                9                               9        \n                 0                             0         \n                  1                           1          \n                   2                         2           \n                    3                       3            \n                     4                     4             \n                      5                   5              \n                       6                 6               \n                        7               7                \n                         8             8                 \n                          9           9                  \n                           0         0                   \n                            1       1                    \n                             2     2                     \n                              3   3                      \n                               4 4                       \n                                5                        \n                               4 4                       \n                              3   3                      \n                             2     2                     \n                            1       1                    \n                           0         0                   \n                          9           9                  \n                         8             8                 \n                        7               7                \n                       6                 6               \n                      5                   5              \n                     4                     4             \n                    3                       3            \n                   2                         2           \n                  1                           1          \n                 0                             0         \n                9                               9        \n               8                                 8       \n              7                                   7      \n             6                                     6     \n            5                                       5    \n           4                                         4   \n          3                                           3  \n         2                                             2 \n        1                                               1\n        \n        \n>>>LIST OF ALL MY KATAS<<<\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef pattern (n : Nat) (y : Nat := 1) : String := sorry\n\ndef stringToNat (s : String) : Nat := sorry\n\ntheorem pattern_empty (n : Nat) :\n  (n = 0 ∨ n < 0) → pattern n = \"\" := sorry\n\ntheorem pattern_basic_properties (n : Nat) (h : 0 < n ∧ n ≤ 9) :\n  let result := pattern n\n  let lines := result.splitOn \"\\n\"\n  (∀ d ∈ (String.join lines).data.filter Char.isDigit, \n    0 ≤ (stringToNat d.toString) ∧ (stringToNat d.toString) ≤ 9) ∧\n  lines.get! 0 = lines.get! (lines.length - 1) ∧\n  (lines.get! 0).contains '1' ∧\n  (lines.get! (n-1)).contains ((toString n).data.get! 0) := sorry\n\ntheorem pattern_repetition (n y : Nat) (h1 : 0 < n ∧ n ≤ 5) (h2 : 0 < y ∧ y ≤ 3) :\n  let result := pattern n y\n  let lines := result.splitOn \"\\n\"\n  let matchingLines := (List.range lines.length).filter (λ i => lines.get! i = lines.get! 0)\n  lines.get! 0 = lines.get! (lines.length - 1) ∧\n  (lines.get! 0).contains '1' ∧\n  matchingLines.length ≥ y := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3119", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n< PREVIOUS KATA\nNEXT KATA >\n\n## Task:\n\nYou have to write a function `pattern` which returns the following Pattern(See Examples) upto desired number of rows. \n\n* Note:`Returning` the pattern is not the same as `Printing` the pattern.\n\n## Parameters:\n    \n    pattern(        n        ,        y        );\n                    ^                 ^         \n                    |                 |         \n             Term upto which   Number of times  \n              Basic Pattern     Basic Pattern   \n                should be         should be     \n                 created          repeated      \n                                 vertically    \n    \n* Note: `Basic Pattern` means what we created in Complete The Pattern #12 i.e. a `simple X`.\n\n## Rules/Note:\n\n* The pattern should be created using only unit digits.\n* If `n < 1` then it should return \"\" i.e. empty string.\n* If `y <= 1` then the basic pattern should not be repeated vertically.\n* `The length of each line is same`, and is equal to the length of longest line in the pattern.\n* Range of Parameters (for the sake of CW Compiler) :\n  + `n ∈ (-∞,50]`\n  + `y ∈ (-∞,25]`\n* If only one argument is passed then the function `pattern` should run as if `y <= 1`.\n* The function `pattern` should work when extra arguments are passed, by ignoring the extra arguments.\n   \n   \n## Examples:\n\n#### Having Two Arguments:\n\n##### pattern(4,3):\n\n        1     1\n         2   2 \n          3 3  \n           4   \n          3 3  \n         2   2 \n        1     1\n         2   2 \n          3 3  \n           4   \n          3 3  \n         2   2 \n        1     1\n         2   2 \n          3 3  \n           4   \n          3 3  \n         2   2 \n        1     1\n       \n##### pattern(10,2):\n\n        1                 1\n         2               2 \n          3             3  \n           4           4   \n            5         5    \n             6       6     \n              7     7      \n               8   8       \n                9 9        \n                 0         \n                9 9        \n               8   8       \n              7     7      \n             6       6     \n            5         5    \n           4           4   \n          3             3  \n         2               2 \n        1                 1\n         2               2 \n          3             3  \n           4           4   \n            5         5    \n             6       6     \n              7     7      \n               8   8       \n                9 9        \n                 0         \n                9 9        \n               8   8       \n              7     7      \n             6       6     \n            5         5    \n           4           4   \n          3             3  \n         2               2 \n        1                 1\n\n\n\n#### Having Only One Argument:\n\n##### pattern(25):\n\n        1                                               1\n         2                                             2 \n          3                                           3  \n           4                                         4   \n            5                                       5    \n             6                                     6     \n              7                                   7      \n               8                                 8       \n                9                               9        \n                 0                             0         \n                  1                           1          \n                   2                         2           \n                    3                       3            \n                     4                     4             \n                      5                   5              \n                       6                 6               \n                        7               7                \n                         8             8                 \n                          9           9                  \n                           0         0                   \n                            1       1                    \n                             2     2                     \n                              3   3                      \n                               4 4                       \n                                5                        \n                               4 4                       \n                              3   3                      \n                             2     2                     \n                            1       1                    \n                           0         0                   \n                          9           9                  \n                         8             8                 \n                        7               7                \n                       6                 6               \n                      5                   5              \n                     4                     4             \n                    3                       3            \n                   2                         2           \n                  1                           1          \n                 0                             0         \n                9                               9        \n               8                                 8       \n              7                                   7      \n             6                                     6     \n            5                                       5    \n           4                                         4   \n          3                                           3  \n         2                                             2 \n        1                                               1\n        \n        \n>>>LIST OF ALL MY KATAS<<<\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef pattern (n : Nat) (y : Nat := 1) : String := sorry\n\ndef stringToNat (s : String) : Nat := sorry\n\ntheorem pattern_empty (n : Nat) :\n  (n = 0 ∨ n < 0) → pattern n = \"\" := sorry\n\ntheorem pattern_basic_properties (n : Nat) (h : 0 < n ∧ n ≤ 9) :\n  let result := pattern n\n  let lines := result.splitOn \"\\n\"\n  (∀ d ∈ (String.join lines).data.filter Char.isDigit, \n    0 ≤ (stringToNat d.toString) ∧ (stringToNat d.toString) ≤ 9) ∧\n  lines.get! 0 = lines.get! (lines.length - 1) ∧\n  (lines.get! 0).contains '1' ∧\n  (lines.get! (n-1)).contains ((toString n).data.get! 0) := sorry\n\ntheorem pattern_repetition (n y : Nat) (h1 : 0 < n ∧ n ≤ 5) (h2 : 0 < y ∧ y ≤ 3) :\n  let result := pattern n y\n  let lines := result.splitOn \"\\n\"\n  let matchingLines := (List.range lines.length).filter (λ i => lines.get! i = lines.get! 0)\n  lines.get! 0 = lines.get! (lines.length - 1) ∧\n  (lines.get! 0).contains '1' ∧\n  matchingLines.length ≥ y := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3119"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou should write a function that takes a string and a positive integer `n`, splits the string into parts of length `n` and returns them in an array. It is ok for the last element to have less than `n` characters.\n\nIf `n` is not a valid size (`> 0`) (or is absent), you should return an empty array.\n\nIf `n` is greater than the length of the string, you should return an array with the only element being the same string.\n\nExamples:\n\n```python\nstring_chunk('codewars', 2) # ['co', 'de', 'wa', 'rs']\nstring_chunk('thiskataeasy', 4) # ['this', 'kata', 'easy']\nstring_chunk('hello world', 3) # ['hel', 'lo ', 'wor', 'ld']\nstring_chunk('sunny day', 0) # []\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef string_chunk (s : String) (n : Nat) : List String := sorry\n\ntheorem string_chunk_length_property (s : String) (n : Nat) (h : n > 0) :\n  s.length > 0 → String.length (String.join (string_chunk s n)) = String.length s := sorry\n\ntheorem string_chunk_size_property (s : String) (n : Nat) (h : n > 0) :\n  let chunks := string_chunk s n\n  chunks.length > 0 →\n  (∀ chunk ∈ chunks, chunk.length ≤ n) ∧\n  (∀ chunk ∈ chunks.dropLast, chunk.length = n) := sorry\n\ntheorem string_chunk_invalid_n (s : String) (n : Nat) :\n  n = 0 → string_chunk s n = [] := sorry\n\ntheorem string_chunk_reconstructs_original (s : String) (n : Nat) (h : n > 0) :\n  String.join (string_chunk s n) = s := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3127", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou should write a function that takes a string and a positive integer `n`, splits the string into parts of length `n` and returns them in an array. It is ok for the last element to have less than `n` characters.\n\nIf `n` is not a valid size (`> 0`) (or is absent), you should return an empty array.\n\nIf `n` is greater than the length of the string, you should return an array with the only element being the same string.\n\nExamples:\n\n```python\nstring_chunk('codewars', 2) # ['co', 'de', 'wa', 'rs']\nstring_chunk('thiskataeasy', 4) # ['this', 'kata', 'easy']\nstring_chunk('hello world', 3) # ['hel', 'lo ', 'wor', 'ld']\nstring_chunk('sunny day', 0) # []\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef string_chunk (s : String) (n : Nat) : List String := sorry\n\ntheorem string_chunk_length_property (s : String) (n : Nat) (h : n > 0) :\n  s.length > 0 → String.length (String.join (string_chunk s n)) = String.length s := sorry\n\ntheorem string_chunk_size_property (s : String) (n : Nat) (h : n > 0) :\n  let chunks := string_chunk s n\n  chunks.length > 0 →\n  (∀ chunk ∈ chunks, chunk.length ≤ n) ∧\n  (∀ chunk ∈ chunks.dropLast, chunk.length = n) := sorry\n\ntheorem string_chunk_invalid_n (s : String) (n : Nat) :\n  n = 0 → string_chunk s n = [] := sorry\n\ntheorem string_chunk_reconstructs_original (s : String) (n : Nat) (h : n > 0) :\n  String.join (string_chunk s n) = s := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3127"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function that removes every lone 9 that is inbetween 7s.\n\n```python\nseven_ate9('79712312') => '7712312'\nseven_ate9('79797') => '777'\n```\n\nInput: String\nOutput: String\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef seven_ate9 (s : String) : String :=\n  sorry\n\ndef countSubstr (s : String) (sub : String) : Nat :=\n  sorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\n  sorry\n\ntheorem output_is_string {s : String} :\n  s.all (fun c => c.isDigit) → \n  (seven_ate9 s).all (fun c => c.isDigit) :=\nsorry\n\ntheorem output_length_correct {s : String} :\n  s.all (fun c => c.isDigit) →\n  (seven_ate9 s).length = s.length - (countSubstr s \"797\") :=\nsorry \n\ntheorem no_797_in_result {s : String} :\n  s.all (fun c => c.isDigit) →\n  ¬(containsSubstr (seven_ate9 s) \"797\") := \nsorry\n\ndef iterativeReplace (s : String) (n : Nat) : String :=\n  match n with\n  | 0 => s\n  | n + 1 => \n    if containsSubstr s \"797\" \n    then iterativeReplace (s.replace \"797\" \"77\") n\n    else s\n\ntheorem only_797_modified {s : String} :\n  s.all (fun c => c.isDigit) →\n  seven_ate9 s = iterativeReplace s s.length :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3142", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function that removes every lone 9 that is inbetween 7s.\n\n```python\nseven_ate9('79712312') => '7712312'\nseven_ate9('79797') => '777'\n```\n\nInput: String\nOutput: String\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef seven_ate9 (s : String) : String :=\n  sorry\n\ndef countSubstr (s : String) (sub : String) : Nat :=\n  sorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\n  sorry\n\ntheorem output_is_string {s : String} :\n  s.all (fun c => c.isDigit) → \n  (seven_ate9 s).all (fun c => c.isDigit) :=\nsorry\n\ntheorem output_length_correct {s : String} :\n  s.all (fun c => c.isDigit) →\n  (seven_ate9 s).length = s.length - (countSubstr s \"797\") :=\nsorry \n\ntheorem no_797_in_result {s : String} :\n  s.all (fun c => c.isDigit) →\n  ¬(containsSubstr (seven_ate9 s) \"797\") := \nsorry\n\ndef iterativeReplace (s : String) (n : Nat) : String :=\n  match n with\n  | 0 => s\n  | n + 1 => \n    if containsSubstr s \"797\" \n    then iterativeReplace (s.replace \"797\" \"77\") n\n    else s\n\ntheorem only_797_modified {s : String} :\n  s.all (fun c => c.isDigit) →\n  seven_ate9 s = iterativeReplace s s.length :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3142"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Introduction \n\nDigital Cypher assigns to each letter of the alphabet unique number. For example:\n\n```\n a  b  c  d  e  f  g  h  i  j  k  l  m\n 1  2  3  4  5  6  7  8  9 10 11 12 13\n n  o  p  q  r  s  t  u  v  w  x  y  z\n14 15 16 17 18 19 20 21 22 23 24 25 26\n```\n\nInstead of letters in encrypted word we write the corresponding number, eg. The word scout:\n\n```\n s  c  o  u  t\n19  3 15 21 20\n```\nThen we add to each obtained digit consecutive digits from the key. For example. In case of key equal to `1939` :\n\n```\n   s  c  o  u  t\n  19  3 15 21 20\n + 1  9  3  9  1\n ---------------\n  20 12 18 30 21\n  \n   m  a  s  t  e  r  p  i  e  c  e\n  13  1 19 20  5 18 16  9  5  3  5\n+  1  9  3  9  1  9  3  9  1  9  3\n  --------------------------------\n  14 10 22 29  6 27 19 18  6  12 8\n```\n\n# Task\n\nWrite a function that accepts an array of integers `code` and a `key` number. As the result, it should return string containg a decoded message from the `code`.\n\n# Input / Output\n\nThe `code` is a array of positive integers.\nThe `key` input is a positive integer.\n\n# Example\n\n``` javascript\ndecode([ 20, 12, 18, 30, 21],1939);  ==> \"scout\"\ndecode([ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8],1939);  ==>  \"masterpiece\"\n```\n\n# Digital cypher series\n- [Digital cypher vol 1](https://www.codewars.com/kata/592e830e043b99888600002d)\n- [Digital cypher vol 2](https://www.codewars.com/kata/592edfda5be407b9640000b2)\n- [Digital cypher vol 3 - missing key](https://www.codewars.com/kata/5930d8a4b8c2d9e11500002a)\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef decode (code : List Nat) (key : Nat) : String := sorry\n\ntheorem decode_type_and_bounds {code : List Nat} {key : Nat} \n  (h1 : ∀ x ∈ code, 1 ≤ x ∧ x ≤ 26)\n  (h2 : 1 ≤ key ∧ key ≤ 9999)\n  (h3 : code.length > 0) :\n  ∃ result : String,\n    (result.length = code.length) ∧ \n    (∀ c ∈ result.data, 'a'.val ≤ c.val ∧ c.val ≤ 'z'.val) := sorry\n\ntheorem decode_wrapping (key : Nat) \n  (h : 1 ≤ key ∧ key ≤ 9999) :\n  ∀ n : Nat,\n    (decode (List.replicate n 1) key).length = n := sorry\n\ntheorem decode_key_zero_equiv {code : List Nat}\n  (h1 : ∀ x ∈ code, 1 ≤ x ∧ x ≤ 26)\n  (h2 : code.length > 0) :\n  decode code 0 = decode code 10000 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3191", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Introduction \n\nDigital Cypher assigns to each letter of the alphabet unique number. For example:\n\n```\n a  b  c  d  e  f  g  h  i  j  k  l  m\n 1  2  3  4  5  6  7  8  9 10 11 12 13\n n  o  p  q  r  s  t  u  v  w  x  y  z\n14 15 16 17 18 19 20 21 22 23 24 25 26\n```\n\nInstead of letters in encrypted word we write the corresponding number, eg. The word scout:\n\n```\n s  c  o  u  t\n19  3 15 21 20\n```\nThen we add to each obtained digit consecutive digits from the key. For example. In case of key equal to `1939` :\n\n```\n   s  c  o  u  t\n  19  3 15 21 20\n + 1  9  3  9  1\n ---------------\n  20 12 18 30 21\n  \n   m  a  s  t  e  r  p  i  e  c  e\n  13  1 19 20  5 18 16  9  5  3  5\n+  1  9  3  9  1  9  3  9  1  9  3\n  --------------------------------\n  14 10 22 29  6 27 19 18  6  12 8\n```\n\n# Task\n\nWrite a function that accepts an array of integers `code` and a `key` number. As the result, it should return string containg a decoded message from the `code`.\n\n# Input / Output\n\nThe `code` is a array of positive integers.\nThe `key` input is a positive integer.\n\n# Example\n\n``` javascript\ndecode([ 20, 12, 18, 30, 21],1939);  ==> \"scout\"\ndecode([ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8],1939);  ==>  \"masterpiece\"\n```\n\n# Digital cypher series\n- [Digital cypher vol 1](https://www.codewars.com/kata/592e830e043b99888600002d)\n- [Digital cypher vol 2](https://www.codewars.com/kata/592edfda5be407b9640000b2)\n- [Digital cypher vol 3 - missing key](https://www.codewars.com/kata/5930d8a4b8c2d9e11500002a)\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef decode (code : List Nat) (key : Nat) : String := sorry\n\ntheorem decode_type_and_bounds {code : List Nat} {key : Nat} \n  (h1 : ∀ x ∈ code, 1 ≤ x ∧ x ≤ 26)\n  (h2 : 1 ≤ key ∧ key ≤ 9999)\n  (h3 : code.length > 0) :\n  ∃ result : String,\n    (result.length = code.length) ∧ \n    (∀ c ∈ result.data, 'a'.val ≤ c.val ∧ c.val ≤ 'z'.val) := sorry\n\ntheorem decode_wrapping (key : Nat) \n  (h : 1 ≤ key ∧ key ≤ 9999) :\n  ∀ n : Nat,\n    (decode (List.replicate n 1) key).length = n := sorry\n\ntheorem decode_key_zero_equiv {code : List Nat}\n  (h1 : ∀ x ∈ code, 1 ≤ x ∧ x ≤ 26)\n  (h2 : code.length > 0) :\n  decode code 0 = decode code 10000 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3191"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nScheduling is how the processor decides which jobs(processes) get to use the processor and for how long. This can cause a lot of problems. Like a really long process taking the entire CPU and freezing all the other processes. One solution is Shortest Job First(SJF), which today you will be implementing.\n\nSJF works by, well, letting the shortest jobs take the CPU first. If the jobs are the same size then it is First In First Out (FIFO). The idea is that the shorter jobs will finish quicker, so theoretically jobs won't get frozen because of large jobs. (In practice they're frozen because of small jobs).\n\nYou will be implementing:\n```python\n  def SJF(jobs, index)\n```\n\nIt takes in:\n\n1. \"jobs\" a non-empty array of positive integers. They represent the clock-cycles(cc) needed to finish the job.\n2. \"index\" a positive integer. That represents the job we're interested in.\n\nSJF returns:\n\n1. A positive integer representing the cc it takes to complete the job at index.\n\nHere's an example:\n```\nSJF([3, 10, 20, 1, 2], 0)\nat 0cc [3, 10, 20, 1, 2] jobs[3] starts\nat 1cc [3, 10, 20, 0, 2] jobs[3] finishes, jobs[4] starts\nat 3cc [3, 10, 20, 0, 0] jobs[4] finishes, jobs[0] starts\nat 6cc [0, 10, 20, 0, 0] jobs[0] finishes\n```\n\nso:\n```\nSJF([3,10,20,1,2], 0) == 6\n```\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef SJF (jobs : List Nat) (index : Nat) : Nat :=\n  sorry\n\nabbrev sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum xs\n\ndef filterWithIndex (l : List Nat) (p : Nat → Nat → Bool) : List Nat :=\n  let rec helper : List Nat → Nat → List Nat\n    | [], _ => []\n    | (x :: xs), i => if p i x then x :: helper xs (i+1) else helper xs (i+1)\n  helper l 0\n\ntheorem single_job_returns_itself {jobs : List Nat} {job : Nat} (h : jobs = [job]) :\n  SJF jobs 0 = job :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3218", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nScheduling is how the processor decides which jobs(processes) get to use the processor and for how long. This can cause a lot of problems. Like a really long process taking the entire CPU and freezing all the other processes. One solution is Shortest Job First(SJF), which today you will be implementing.\n\nSJF works by, well, letting the shortest jobs take the CPU first. If the jobs are the same size then it is First In First Out (FIFO). The idea is that the shorter jobs will finish quicker, so theoretically jobs won't get frozen because of large jobs. (In practice they're frozen because of small jobs).\n\nYou will be implementing:\n```python\n  def SJF(jobs, index)\n```\n\nIt takes in:\n\n1. \"jobs\" a non-empty array of positive integers. They represent the clock-cycles(cc) needed to finish the job.\n2. \"index\" a positive integer. That represents the job we're interested in.\n\nSJF returns:\n\n1. A positive integer representing the cc it takes to complete the job at index.\n\nHere's an example:\n```\nSJF([3, 10, 20, 1, 2], 0)\nat 0cc [3, 10, 20, 1, 2] jobs[3] starts\nat 1cc [3, 10, 20, 0, 2] jobs[3] finishes, jobs[4] starts\nat 3cc [3, 10, 20, 0, 0] jobs[4] finishes, jobs[0] starts\nat 6cc [0, 10, 20, 0, 0] jobs[0] finishes\n```\n\nso:\n```\nSJF([3,10,20,1,2], 0) == 6\n```\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef SJF (jobs : List Nat) (index : Nat) : Nat :=\n  sorry\n\nabbrev sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum xs\n\ndef filterWithIndex (l : List Nat) (p : Nat → Nat → Bool) : List Nat :=\n  let rec helper : List Nat → Nat → List Nat\n    | [], _ => []\n    | (x :: xs), i => if p i x then x :: helper xs (i+1) else helper xs (i+1)\n  helper l 0\n\ntheorem single_job_returns_itself {jobs : List Nat} {job : Nat} (h : jobs = [job]) :\n  SJF jobs 0 = job :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3218"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two integers `a` and `b`, which can be positive or negative, find the sum of all the numbers between including them too and return it. If the two numbers are equal return `a` or `b`.\n\n**Note:** `a` and `b` are not ordered!\n\n## Examples\n\n```python\nget_sum(1, 0) == 1   // 1 + 0 = 1\nget_sum(1, 2) == 3   // 1 + 2 = 3\nget_sum(0, 1) == 1   // 0 + 1 = 1\nget_sum(1, 1) == 1   // 1 Since both are same\nget_sum(-1, 0) == -1 // -1 + 0 = -1\nget_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2\n```\n```C\nget_sum(1, 0) == 1   // 1 + 0 = 1\nget_sum(1, 2) == 3   // 1 + 2 = 3\nget_sum(0, 1) == 1   // 0 + 1 = 1\nget_sum(1, 1) == 1   // 1 Since both are same\nget_sum(-1, 0) == -1 // -1 + 0 = -1\nget_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef get_sum (a b : Int) : Int := sorry\n\ntheorem get_sum_commutative (a b : Int) : \n  get_sum a b = get_sum b a := sorry\n\ntheorem get_sum_same_number (n : Int) :\n  get_sum n n = n := sorry\n\ntheorem get_sum_consecutive (a b : Int) :\n  a ≠ b → get_sum a b = ((a + b) / 2) * (abs (b - a) + 1) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3222", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven two integers `a` and `b`, which can be positive or negative, find the sum of all the numbers between including them too and return it. If the two numbers are equal return `a` or `b`.\n\n**Note:** `a` and `b` are not ordered!\n\n## Examples\n\n```python\nget_sum(1, 0) == 1   // 1 + 0 = 1\nget_sum(1, 2) == 3   // 1 + 2 = 3\nget_sum(0, 1) == 1   // 0 + 1 = 1\nget_sum(1, 1) == 1   // 1 Since both are same\nget_sum(-1, 0) == -1 // -1 + 0 = -1\nget_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2\n```\n```C\nget_sum(1, 0) == 1   // 1 + 0 = 1\nget_sum(1, 2) == 3   // 1 + 2 = 3\nget_sum(0, 1) == 1   // 0 + 1 = 1\nget_sum(1, 1) == 1   // 1 Since both are same\nget_sum(-1, 0) == -1 // -1 + 0 = -1\nget_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef get_sum (a b : Int) : Int := sorry\n\ntheorem get_sum_commutative (a b : Int) : \n  get_sum a b = get_sum b a := sorry\n\ntheorem get_sum_same_number (n : Int) :\n  get_sum n n = n := sorry\n\ntheorem get_sum_consecutive (a b : Int) :\n  a ≠ b → get_sum a b = ((a + b) / 2) * (abs (b - a) + 1) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3222"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n>When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process  --myjinxin2015 said\n\n# Description:\n \n John learns to play poker with his uncle. His uncle told him: Poker to be in accordance with the order of \"2 3 4 5 6 7 8 9 10 J Q K A\". The same suit should be put together. But his uncle did not tell him the order of the four suits. \n \n Give you John's cards and Uncle's cards(two string `john` and `uncle`). Please reference to the order of Uncle's cards, sorting John's cards. \n \n \n# Examples\n\n```\nFor Python:\n\nSuits are defined as S, D, H, C.\n\nsort_poker(\"D6H2S3D5SJCQSKC7D2C5H5H10SA\",\"S2S3S5HJHQHKC8C9C10D4D5D6D7\")\nshould return \"S3SJSKSAH2H5H10C5C7CQD2D5D6\"\nsort_poke(\"D6H2S3D5SJCQSKC7D2C5H5H10SA\",\"C8C9C10D4D5D6D7S2S3S5HJHQHK\") \nshould return \"C5C7CQD2D5D6S3SJSKSAH2H5H10\" \n\n```\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Suit where\n  | Spades | Diamonds | Hearts | Clubs\n\ninductive Rank where\n  | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten\n  | Jack | Queen | King | Ace\n\ndef sort_poker (john: String) (uncle: String) : String :=\n  sorry\n\ntheorem sort_poker_idempotent \n  (john: String) (uncle: String) :\n  uncle = \"S2D2H2C2\" →\n  sort_poker (sort_poker john uncle) uncle = sort_poker john uncle :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3261", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n>When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process  --myjinxin2015 said\n\n# Description:\n \n John learns to play poker with his uncle. His uncle told him: Poker to be in accordance with the order of \"2 3 4 5 6 7 8 9 10 J Q K A\". The same suit should be put together. But his uncle did not tell him the order of the four suits. \n \n Give you John's cards and Uncle's cards(two string `john` and `uncle`). Please reference to the order of Uncle's cards, sorting John's cards. \n \n \n# Examples\n\n```\nFor Python:\n\nSuits are defined as S, D, H, C.\n\nsort_poker(\"D6H2S3D5SJCQSKC7D2C5H5H10SA\",\"S2S3S5HJHQHKC8C9C10D4D5D6D7\")\nshould return \"S3SJSKSAH2H5H10C5C7CQD2D5D6\"\nsort_poke(\"D6H2S3D5SJCQSKC7D2C5H5H10SA\",\"C8C9C10D4D5D6D7S2S3S5HJHQHK\") \nshould return \"C5C7CQD2D5D6S3SJSKSAH2H5H10\" \n\n```\n```\n#####\n\nTo answer this question, you need to replace the 2 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Suit where\n  | Spades | Diamonds | Hearts | Clubs\n\ninductive Rank where\n  | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten\n  | Jack | Queen | King | Ace\n\ndef sort_poker (john: String) (uncle: String) : String :=\n  sorry\n\ntheorem sort_poker_idempotent \n  (john: String) (uncle: String) :\n  uncle = \"S2D2H2C2\" →\n  sort_poker (sort_poker john uncle) uncle = sort_poker john uncle :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3261"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are the best freelancer in the city. Everybody knows you, but what they don't know, is that you are actually offloading your work to other freelancers and and you rarely need to do any work. You're living the life!\n\nTo make this process easier you need to write a method called workNeeded to figure out how much time you need to contribute to a project. \n\nGiving the amount of time in `minutes` needed to complete the project and an array of pair values representing other freelancers' time in `[Hours, Minutes]` format ie. `[[2, 33], [3, 44]]` calculate how much time **you** will need to contribute to the project (if at all) and return a string depending on the case.\n\n\n* If we need to contribute time to the project then return `\"I need to work x hour(s) and y minute(s)\"`\n* If we don't have to contribute any time to the project then return `\"Easy Money!\"`\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Time where\n  hours : Nat\n  minutes : Nat\nderiving Repr\n\ndef work_needed (project_minutes : Nat) (freelancers : List Time) : String :=\n  sorry\n\ntheorem work_needed_output_valid (project_minutes : Nat) (freelancers : List Time) :\n  let result := work_needed project_minutes freelancers\n  (result = \"Easy Money!\" ∨ result.startsWith \"I need to work\") :=\n  sorry\n\ntheorem work_needed_enough_help (project_minutes : Nat) (freelancers : List Time) :\n  let total_available := freelancers.foldl (fun acc t => acc + t.hours * 60 + t.minutes) 0\n  total_available ≥ project_minutes → \n  work_needed project_minutes freelancers = \"Easy Money!\" :=\n  sorry\n\ntheorem work_needed_not_enough_help (project_minutes : Nat) (freelancers : List Time) :\n  let total_available := freelancers.foldl (fun acc t => acc + t.hours * 60 + t.minutes) 0\n  let deficit := project_minutes - total_available\n  let deficit_hours := deficit / 60\n  let deficit_minutes := deficit % 60\n  total_available < project_minutes →\n  work_needed project_minutes freelancers = s!\"I need to work {deficit_hours} hour(s) and {deficit_minutes} minute(s)\" :=\n  sorry\n\ntheorem work_needed_zero_project (freelancers : List Time) :\n  work_needed 0 freelancers = \"Easy Money!\" :=\n  sorry\n\ntheorem work_needed_no_freelancers (project_minutes : Nat) :\n  let hours := project_minutes / 60\n  let minutes := project_minutes % 60\n  work_needed project_minutes [] = s!\"I need to work {hours} hour(s) and {minutes} minute(s)\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3269", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are the best freelancer in the city. Everybody knows you, but what they don't know, is that you are actually offloading your work to other freelancers and and you rarely need to do any work. You're living the life!\n\nTo make this process easier you need to write a method called workNeeded to figure out how much time you need to contribute to a project. \n\nGiving the amount of time in `minutes` needed to complete the project and an array of pair values representing other freelancers' time in `[Hours, Minutes]` format ie. `[[2, 33], [3, 44]]` calculate how much time **you** will need to contribute to the project (if at all) and return a string depending on the case.\n\n\n* If we need to contribute time to the project then return `\"I need to work x hour(s) and y minute(s)\"`\n* If we don't have to contribute any time to the project then return `\"Easy Money!\"`\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Time where\n  hours : Nat\n  minutes : Nat\nderiving Repr\n\ndef work_needed (project_minutes : Nat) (freelancers : List Time) : String :=\n  sorry\n\ntheorem work_needed_output_valid (project_minutes : Nat) (freelancers : List Time) :\n  let result := work_needed project_minutes freelancers\n  (result = \"Easy Money!\" ∨ result.startsWith \"I need to work\") :=\n  sorry\n\ntheorem work_needed_enough_help (project_minutes : Nat) (freelancers : List Time) :\n  let total_available := freelancers.foldl (fun acc t => acc + t.hours * 60 + t.minutes) 0\n  total_available ≥ project_minutes → \n  work_needed project_minutes freelancers = \"Easy Money!\" :=\n  sorry\n\ntheorem work_needed_not_enough_help (project_minutes : Nat) (freelancers : List Time) :\n  let total_available := freelancers.foldl (fun acc t => acc + t.hours * 60 + t.minutes) 0\n  let deficit := project_minutes - total_available\n  let deficit_hours := deficit / 60\n  let deficit_minutes := deficit % 60\n  total_available < project_minutes →\n  work_needed project_minutes freelancers = s!\"I need to work {deficit_hours} hour(s) and {deficit_minutes} minute(s)\" :=\n  sorry\n\ntheorem work_needed_zero_project (freelancers : List Time) :\n  work_needed 0 freelancers = \"Easy Money!\" :=\n  sorry\n\ntheorem work_needed_no_freelancers (project_minutes : Nat) :\n  let hours := project_minutes / 60\n  let minutes := project_minutes % 60\n  work_needed project_minutes [] = s!\"I need to work {hours} hour(s) and {minutes} minute(s)\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3269"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, two players, Alice and Bob, are playing a palindrome game. Alice starts with `string1`, Bob starts with `string2`, and the board starts out as an empty string. Alice and Bob take turns; during a turn, a player selects a letter from his or her string, removes it from the string, and appends it to the board; if the board becomes a palindrome (of length >= 2), the player wins. Alice makes the first move. Since Bob has the disadvantage of playing second, then he wins automatically if letters run out or the board is never a palindrome. Note also that each player can see the other player's letters.\n\nThe problem will be presented as `solve(string1,string2)`. Return 1 if Alice wins and 2 it Bob wins.\n\nFor example:\n```Haskell\nsolve(\"abc\",\"baxy\") = 2 -- There is no way for Alice to win. If she starts with 'a', Bob wins by playing 'a'. The same case with 'b'. If Alice starts with 'c', Bob still wins because a palindrome is not possible. Return 2.\nsolve(\"eyfjy\",\"ooigvo\") = 1 -- Alice plays 'y' and whatever Bob plays, Alice wins by playing another 'y'. Return 1.\nsolve(\"abc\",\"xyz\") = 2 -- No palindrome is possible, so Bob wins; return 2\nsolve(\"gzyqsczkctutjves\",\"hpaqrfwkdntfwnvgs\") = 1 -- If Alice plays 'g', Bob wins by playing 'g'. Alice must be clever. She starts with 'z'. She knows that since she has two 'z', the win is guaranteed. Note that she also has two 's'. But she cannot play that. Can you see why? \nsolve(\"rmevmtw\",\"uavtyft\") = 1 -- Alice wins by playing 'm'. Can you see why? \n```\nPalindrome lengths should be at least `2` characters. More examples in the test cases. \n\nGood luck!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (s1 s2 : String) : Nat :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry\n\ntheorem solve_returns_valid_output (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve s1 s2 = 1 ∨ solve s1 s2 = 2 :=\n  sorry\n\ntheorem solve_identical_chars (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0)\n    (h3 : ∀ (c : Char), s1.data.contains c → c = 'a')\n    (h4 : ∀ (c : Char), s2.data.contains c → c = 'a') :\n  solve s1 s2 = 2 :=\n  sorry\n\ntheorem solve_with_duplicates (s : String) \n    (h1 : s.length ≥ 2) :\n  (∃ (c : Char), s.data.contains c ∧ countChar s c ≥ 2) → solve s \"\" = 1 ∧\n  (∀ (c : Char), s.data.contains c → countChar s c < 2) → solve s \"\" = 2 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3273", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, two players, Alice and Bob, are playing a palindrome game. Alice starts with `string1`, Bob starts with `string2`, and the board starts out as an empty string. Alice and Bob take turns; during a turn, a player selects a letter from his or her string, removes it from the string, and appends it to the board; if the board becomes a palindrome (of length >= 2), the player wins. Alice makes the first move. Since Bob has the disadvantage of playing second, then he wins automatically if letters run out or the board is never a palindrome. Note also that each player can see the other player's letters.\n\nThe problem will be presented as `solve(string1,string2)`. Return 1 if Alice wins and 2 it Bob wins.\n\nFor example:\n```Haskell\nsolve(\"abc\",\"baxy\") = 2 -- There is no way for Alice to win. If she starts with 'a', Bob wins by playing 'a'. The same case with 'b'. If Alice starts with 'c', Bob still wins because a palindrome is not possible. Return 2.\nsolve(\"eyfjy\",\"ooigvo\") = 1 -- Alice plays 'y' and whatever Bob plays, Alice wins by playing another 'y'. Return 1.\nsolve(\"abc\",\"xyz\") = 2 -- No palindrome is possible, so Bob wins; return 2\nsolve(\"gzyqsczkctutjves\",\"hpaqrfwkdntfwnvgs\") = 1 -- If Alice plays 'g', Bob wins by playing 'g'. Alice must be clever. She starts with 'z'. She knows that since she has two 'z', the win is guaranteed. Note that she also has two 's'. But she cannot play that. Can you see why? \nsolve(\"rmevmtw\",\"uavtyft\") = 1 -- Alice wins by playing 'm'. Can you see why? \n```\nPalindrome lengths should be at least `2` characters. More examples in the test cases. \n\nGood luck!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (s1 s2 : String) : Nat :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry\n\ntheorem solve_returns_valid_output (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve s1 s2 = 1 ∨ solve s1 s2 = 2 :=\n  sorry\n\ntheorem solve_identical_chars (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0)\n    (h3 : ∀ (c : Char), s1.data.contains c → c = 'a')\n    (h4 : ∀ (c : Char), s2.data.contains c → c = 'a') :\n  solve s1 s2 = 2 :=\n  sorry\n\ntheorem solve_with_duplicates (s : String) \n    (h1 : s.length ≥ 2) :\n  (∃ (c : Char), s.data.contains c ∧ countChar s c ≥ 2) → solve s \"\" = 1 ∧\n  (∀ (c : Char), s.data.contains c → countChar s c < 2) → solve s \"\" = 2 :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3273"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given a string and your task will be to return the length of the longest prefix that is also a suffix. A prefix is the start of a string while the suffix is the end of a string.  For instance, the prefixes of the string `\"abcd\"` are `[\"a\",\"ab\",\"abc\"]`. The suffixes are `[\"bcd\", \"cd\", \"d\"]`. You should not overlap the prefix and suffix.\n\n```Haskell\nfor example:\nsolve(\"abcd\") = 0, because no prefix == suffix. \nsolve(\"abcda\") = 1, because the longest prefix which == suffix is \"a\".\nsolve(\"abcdabc\") = 3. Longest prefix which == suffix is \"abc\".\nsolve(\"aaaa\") = 2. Longest prefix which == suffix is \"aa\". You should not overlap the prefix and suffix\nsolve(\"aa\") = 1. You should not overlap the prefix and suffix.\nsolve(\"a\") = 0. You should not overlap the prefix and suffix.\n```\n\nAll strings will be lowercase and string lengths are `1 <= length <= 500`\n\nMore examples in test cases. Good luck!\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve : String → Nat := sorry\n\ntheorem solve_length_bound (s : String) : \n  solve s ≤ (s.length / 2) := sorry\n\ntheorem solve_nonnegative (s : String) :\n  solve s ≥ 0 := sorry\n\ntheorem solve_valid_match (s : String) :\n  solve s > 0 → solve s ≤ s.length / 2 ∧ \n  s.take (solve s) = s.takeRight (solve s) := sorry\n\ntheorem solve_concatenation {s1 s2 : String} \n  (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve (s1 ++ s2 ++ s1) ≥ s1.length := sorry\n\ntheorem solve_empty : solve \"\" = 0 := sorry\n\ntheorem solve_single (c : Char) :\n  solve (String.mk [c]) = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3274", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given a string and your task will be to return the length of the longest prefix that is also a suffix. A prefix is the start of a string while the suffix is the end of a string.  For instance, the prefixes of the string `\"abcd\"` are `[\"a\",\"ab\",\"abc\"]`. The suffixes are `[\"bcd\", \"cd\", \"d\"]`. You should not overlap the prefix and suffix.\n\n```Haskell\nfor example:\nsolve(\"abcd\") = 0, because no prefix == suffix. \nsolve(\"abcda\") = 1, because the longest prefix which == suffix is \"a\".\nsolve(\"abcdabc\") = 3. Longest prefix which == suffix is \"abc\".\nsolve(\"aaaa\") = 2. Longest prefix which == suffix is \"aa\". You should not overlap the prefix and suffix\nsolve(\"aa\") = 1. You should not overlap the prefix and suffix.\nsolve(\"a\") = 0. You should not overlap the prefix and suffix.\n```\n\nAll strings will be lowercase and string lengths are `1 <= length <= 500`\n\nMore examples in test cases. Good luck!\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve : String → Nat := sorry\n\ntheorem solve_length_bound (s : String) : \n  solve s ≤ (s.length / 2) := sorry\n\ntheorem solve_nonnegative (s : String) :\n  solve s ≥ 0 := sorry\n\ntheorem solve_valid_match (s : String) :\n  solve s > 0 → solve s ≤ s.length / 2 ∧ \n  s.take (solve s) = s.takeRight (solve s) := sorry\n\ntheorem solve_concatenation {s1 s2 : String} \n  (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve (s1 ++ s2 ++ s1) ≥ s1.length := sorry\n\ntheorem solve_empty : solve \"\" = 0 := sorry\n\ntheorem solve_single (c : Char) :\n  solve (String.mk [c]) = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3274"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given a number in form of a string and an integer `k` and your task is to insert `k` commas into the string and determine which of the partitions is the largest. \n\n```\nFor example:\nsolve('1234',1) = 234 because ('1','234') or ('12','34') or ('123','4').\nsolve('1234',2) = 34 because ('1','2','34') or ('1','23','4') or ('12','3','4'). \nsolve('1234',3) = 4\nsolve('2020',1) = 202\n```\n\nMore examples in test cases. Good luck!\n\nPlease also try [Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (s : String) (k : Nat) : Nat := sorry\n\ntheorem solve_k_zero (num_str : String) (h : num_str.all (fun c => '0' <= c ∧ c <= '9')) :\n  num_str.length > 0 → solve num_str 0 = num_str.toNat! := sorry\n\ntheorem solve_k_bounds (num_str : String) (k : Nat) \n  (h1 : num_str.all (fun c => '0' <= c ∧ c <= '9'))\n  (h2 : num_str.length > 1) :\n  let k' := min k (num_str.length - 1)\n  let result := solve num_str k'\n  toString result |>.length = num_str.length - k' := sorry\n\n\n\ntheorem solve_returns_largest (num_str : String) (k : Nat)\n  (h1 : num_str.all (fun c => '0' <= c ∧ c <= '9'))\n  (h2 : num_str.length > 1) :\n  let k' := min k (num_str.length - 1)\n  let result := solve num_str k'\n  let partition_size := num_str.length - k'\n  ∀ i, i + partition_size ≤ num_str.length →\n    let substr := (num_str.take (i + partition_size)).drop i\n    result ≥ substr.toNat! := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3288", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given a number in form of a string and an integer `k` and your task is to insert `k` commas into the string and determine which of the partitions is the largest. \n\n```\nFor example:\nsolve('1234',1) = 234 because ('1','234') or ('12','34') or ('123','4').\nsolve('1234',2) = 34 because ('1','2','34') or ('1','23','4') or ('12','3','4'). \nsolve('1234',3) = 4\nsolve('2020',1) = 202\n```\n\nMore examples in test cases. Good luck!\n\nPlease also try [Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (s : String) (k : Nat) : Nat := sorry\n\ntheorem solve_k_zero (num_str : String) (h : num_str.all (fun c => '0' <= c ∧ c <= '9')) :\n  num_str.length > 0 → solve num_str 0 = num_str.toNat! := sorry\n\ntheorem solve_k_bounds (num_str : String) (k : Nat) \n  (h1 : num_str.all (fun c => '0' <= c ∧ c <= '9'))\n  (h2 : num_str.length > 1) :\n  let k' := min k (num_str.length - 1)\n  let result := solve num_str k'\n  toString result |>.length = num_str.length - k' := sorry\n\n\n\ntheorem solve_returns_largest (num_str : String) (k : Nat)\n  (h1 : num_str.all (fun c => '0' <= c ∧ c <= '9'))\n  (h2 : num_str.length > 1) :\n  let k' := min k (num_str.length - 1)\n  let result := solve num_str k'\n  let partition_size := num_str.length - k'\n  ∀ i, i + partition_size ≤ num_str.length →\n    let substr := (num_str.take (i + partition_size)).drop i\n    result ≥ substr.toNat! := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3288"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nInspired by the development team at Vooza, write the function `howManyLightsabersDoYouOwn`/`how_many_light_sabers_do_you_own` that \n\n* accepts the name of a programmer, and\n* returns the number of lightsabers owned by that person.\n\nThe only person who owns lightsabers is Zach, by the way. He owns 18, which is an awesome number of lightsabers. Anyone else owns 0.\n\n```if:coffeescript,javascript,php,python,ruby,typescript\n**Note**: your function should have a default parameter.\n```\n\n```c#\nKata.HowManyLightsabersDoYouOwn(\"Adam\") == 0\nKata.HowManyLightsabersDoYouOwn(\"Zach\") == 18\n```\n```python\nhow_many_light_sabers_do_you_own('Zach') == 18\nhow_many_light_sabers_do_you_own('Adam') == 0\nhow_many_light_sabers_do_you_own()       == 0\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef how_many_light_sabers_do_you_own : Option String → Nat\n| none => sorry\n| some s => sorry\n\ntheorem light_sabers_default_zero (name : String) :\n  name ≠ \"Zach\" → how_many_light_sabers_do_you_own (some name) = 0 := by sorry\n\ntheorem zach_has_18 :\n  how_many_light_sabers_do_you_own (some \"Zach\") = 18 := by sorry \n\ntheorem empty_name_zero :\n  how_many_light_sabers_do_you_own none = 0 := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3316", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nInspired by the development team at Vooza, write the function `howManyLightsabersDoYouOwn`/`how_many_light_sabers_do_you_own` that \n\n* accepts the name of a programmer, and\n* returns the number of lightsabers owned by that person.\n\nThe only person who owns lightsabers is Zach, by the way. He owns 18, which is an awesome number of lightsabers. Anyone else owns 0.\n\n```if:coffeescript,javascript,php,python,ruby,typescript\n**Note**: your function should have a default parameter.\n```\n\n```c#\nKata.HowManyLightsabersDoYouOwn(\"Adam\") == 0\nKata.HowManyLightsabersDoYouOwn(\"Zach\") == 18\n```\n```python\nhow_many_light_sabers_do_you_own('Zach') == 18\nhow_many_light_sabers_do_you_own('Adam') == 0\nhow_many_light_sabers_do_you_own()       == 0\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef how_many_light_sabers_do_you_own : Option String → Nat\n| none => sorry\n| some s => sorry\n\ntheorem light_sabers_default_zero (name : String) :\n  name ≠ \"Zach\" → how_many_light_sabers_do_you_own (some name) = 0 := by sorry\n\ntheorem zach_has_18 :\n  how_many_light_sabers_do_you_own (some \"Zach\") = 18 := by sorry \n\ntheorem empty_name_zero :\n  how_many_light_sabers_do_you_own none = 0 := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3316"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Task\n\nYou got a `scratch lottery`, you want to know how much money you win.\n\nThere are `6` sets of characters on the lottery. Each set of characters represents a chance to win. The text has a coating on it. When you buy the lottery ticket and then blow it off, you can see the text information below the coating.\n\nEach set of characters contains three animal names and a number, like this: `\"tiger tiger tiger 100\"`. If the three animal names are the same, Congratulations, you won the prize. You will win the same bonus as the last number.\n\nGiven the `lottery`, returns the total amount of the bonus.\n\n# Input/Output\n\n\n`[input]` string array `lottery`\n\nA string array that contains six sets of characters.\n\n`[output]` an integer\n\nthe total amount of the bonus.\n\n# Example\n\nFor \n```\nlottery = [\n\"tiger tiger tiger 100\",\n\"rabbit dragon snake 100\",\n\"rat ox pig 1000\",\n\"dog cock sheep 10\",\n\"horse monkey rat 5\",\n\"dog dog dog 1000\"\n]```\n\nthe output should be `1100`.\n\n`\"tiger tiger tiger 100\"` win $100, and `\"dog dog dog 1000\"` win $1000. \n\n`100 + 1000 = 1100`\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef split (s : String) : List String := sorry\ndef toNat (s : String) : Option Nat := sorry\n\ndef scratch (tickets : List String) : Nat := sorry\n\ntheorem scratch_non_negative (tickets : List String) : \n  scratch tickets ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3410", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Task\n\nYou got a `scratch lottery`, you want to know how much money you win.\n\nThere are `6` sets of characters on the lottery. Each set of characters represents a chance to win. The text has a coating on it. When you buy the lottery ticket and then blow it off, you can see the text information below the coating.\n\nEach set of characters contains three animal names and a number, like this: `\"tiger tiger tiger 100\"`. If the three animal names are the same, Congratulations, you won the prize. You will win the same bonus as the last number.\n\nGiven the `lottery`, returns the total amount of the bonus.\n\n# Input/Output\n\n\n`[input]` string array `lottery`\n\nA string array that contains six sets of characters.\n\n`[output]` an integer\n\nthe total amount of the bonus.\n\n# Example\n\nFor \n```\nlottery = [\n\"tiger tiger tiger 100\",\n\"rabbit dragon snake 100\",\n\"rat ox pig 1000\",\n\"dog cock sheep 10\",\n\"horse monkey rat 5\",\n\"dog dog dog 1000\"\n]```\n\nthe output should be `1100`.\n\n`\"tiger tiger tiger 100\"` win $100, and `\"dog dog dog 1000\"` win $1000. \n\n`100 + 1000 = 1100`\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef split (s : String) : List String := sorry\ndef toNat (s : String) : Option Nat := sorry\n\ndef scratch (tickets : List String) : Nat := sorry\n\ntheorem scratch_non_negative (tickets : List String) : \n  scratch tickets ≥ 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3410"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn genetics 2 differents DNAs sequences can code for the same protein. \n\nThis is due to the redundancy of the genetic code, in fact 2 different tri-nucleotide can code for the same amino-acid.\nFor example the tri-nucleotide 'TTT' and the tri-nucleotide 'TTC' both code for the amino-acid 'F'. For more information you can take a look [here](https://en.wikipedia.org/wiki/DNA_codon_table).\n\nYour goal in this kata is to define if two differents DNAs sequences code for exactly the same protein. Your function take the 2 sequences you should compare.\nFor some kind of simplicity here the sequences will respect the following rules:\n\n- It is a full protein sequence beginning with a Start codon and finishing by an Stop codon\n- It will only contain valid tri-nucleotide. \n\nThe translation hash is available for you under a translation hash `$codons` [Ruby] or `codons` [Python and JavaScript].\n\nTo better understand this kata you can take a look at this [one](https://www.codewars.com/kata/5708ef48fe2d018413000776), it can help you to start.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef code_for_same_protein (seq1 : String) (seq2 : String) : Bool := sorry\n\ntheorem identical_sequences_match\n  (seq : String) :\n  code_for_same_protein seq seq = true := sorry\n\ndef repeat_str (s : String) (n : Nat) : String :=\nmatch n with\n| 0 => \"\"\n| n+1 => s ++ repeat_str s n\n\ntheorem different_length_no_match\n  (n : Nat) :\n  code_for_same_protein (repeat_str \"ATG\" n) (repeat_str \"ATG\" (n + 1)) = false := sorry\n\ntheorem different_length_sequences_no_match\n  (seq1 seq2 : String) :\n  seq1.length ≠ seq2.length →\n  code_for_same_protein seq1 seq2 = false := sorry \n\ntheorem code_for_same_protein_reflexive\n  (seq : String) :\n  code_for_same_protein seq seq = true := sorry\n\ntheorem code_for_same_protein_symmetric\n  (seq1 seq2 : String) :\n  code_for_same_protein seq1 seq2 = true →\n  code_for_same_protein seq2 seq1 = true := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3442", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn genetics 2 differents DNAs sequences can code for the same protein. \n\nThis is due to the redundancy of the genetic code, in fact 2 different tri-nucleotide can code for the same amino-acid.\nFor example the tri-nucleotide 'TTT' and the tri-nucleotide 'TTC' both code for the amino-acid 'F'. For more information you can take a look [here](https://en.wikipedia.org/wiki/DNA_codon_table).\n\nYour goal in this kata is to define if two differents DNAs sequences code for exactly the same protein. Your function take the 2 sequences you should compare.\nFor some kind of simplicity here the sequences will respect the following rules:\n\n- It is a full protein sequence beginning with a Start codon and finishing by an Stop codon\n- It will only contain valid tri-nucleotide. \n\nThe translation hash is available for you under a translation hash `$codons` [Ruby] or `codons` [Python and JavaScript].\n\nTo better understand this kata you can take a look at this [one](https://www.codewars.com/kata/5708ef48fe2d018413000776), it can help you to start.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef code_for_same_protein (seq1 : String) (seq2 : String) : Bool := sorry\n\ntheorem identical_sequences_match\n  (seq : String) :\n  code_for_same_protein seq seq = true := sorry\n\ndef repeat_str (s : String) (n : Nat) : String :=\nmatch n with\n| 0 => \"\"\n| n+1 => s ++ repeat_str s n\n\ntheorem different_length_no_match\n  (n : Nat) :\n  code_for_same_protein (repeat_str \"ATG\" n) (repeat_str \"ATG\" (n + 1)) = false := sorry\n\ntheorem different_length_sequences_no_match\n  (seq1 seq2 : String) :\n  seq1.length ≠ seq2.length →\n  code_for_same_protein seq1 seq2 = false := sorry \n\ntheorem code_for_same_protein_reflexive\n  (seq : String) :\n  code_for_same_protein seq seq = true := sorry\n\ntheorem code_for_same_protein_symmetric\n  (seq1 seq2 : String) :\n  code_for_same_protein seq1 seq2 = true →\n  code_for_same_protein seq2 seq1 = true := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3442"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n#### Task:\n\nYour job here is to implement a method, `approx_root` in Ruby/Python/Crystal and `approxRoot` in JavaScript/CoffeeScript, that takes one argument, `n`, and returns the approximate square root of that number, rounded to the nearest hundredth and computed in the following manner.\n\n1.      Start with `n = 213` (as an example). \n2.      To approximate the square root of n, we will first find the greatest perfect square that is below or equal to `n`. (In this example, that would be 196, or 14 squared.) We will call the square root of this number (which means sqrt 196, or 14) `base`.\n3.      Then, we will take the lowest perfect square that is greater than or equal to `n`. (In this example, that would be 225, or 15 squared.)\n4.      Next, subtract 196 (greatest perfect square less than or equal to `n`) from `n`. (213 - 196 = **17**) We will call this value `diff_gn`.\n5.      Find the difference between the lowest perfect square greater than or equal to `n` and the greatest perfect square less than or equal to `n`. (225 – 196 = **29**) We will call this value `diff_lg`.\n6.      Your final answer is `base` + (`diff_gn` / `diff_lg`). In this example: 14 + (17 / 29) which is 14.59, rounded to the nearest hundredth.\n\nJust to clarify, if the input is a perfect square itself, you should return the exact square of the input.\n\nIn case you are curious, the approximation (computed like above) for 213 rounded to four decimal places is 14.5862. The actual square root of 213 is 14.5945. \n\nInputs will always be positive whole numbers. If you are having trouble understanding it, let me know with a comment, or take a look at the second group of the example cases.\n\n#### Some examples:\n\n```python\napprox_root(400) #=> 20\napprox_root(401) #=> \n  # smallest perfect square above 401 is 441 or 21 squared\n  # greatest perfect square below 401 is 400 or 20 squared\n  # difference between 441 and 400 is 41\n  # difference between 401 and 400 is 1\n  # answer is 20 + (1 / 41) which becomes 20.02, rounded to the nearest hundredth\n  # final answer = 20.02.\napprox_root(2) #=>\n  # smallest perfect square above 2 is 4 or 2 squared\n  # greatest perfect square below 2 is 1 or 1 squared\n  # difference between 4 and 1 is 3\n  # difference between 2 and 1 is 1\n  # answer is 1 + (1 / 3), which becomes 1.33, rounded to the nearest hundredth\n  # final answer = 1.33.\n\n# math.sqrt() isn't disabled.\n```\n\nAlso check out my other creations — [Square Roots: Simplifying/Desimplifying](https://www.codewars.com/kata/square-roots-simplify-slash-desimplify/), [Square and Cubic Factors](https://www.codewars.com/kata/square-and-cubic-factors), [Keep the Order](https://www.codewars.com/kata/keep-the-order), [Naming Files](https://www.codewars.com/kata/naming-files), [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n\nIf you notice any issues or have any suggestions/comments whatsoever, please don't hesitate to mark an issue or just comment. Thanks!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef approx_root (n : Nat) : Float := sorry\n\ntheorem approx_root_close_to_actual (n : Nat) (h : n ≤ 1000000) : \n  (approx_root n - Float.sqrt (n.toFloat)).abs < 0.1 := sorry\n\ntheorem approx_root_perfect_squares (n : Nat) (h : n ≤ 1000) :\n  approx_root (n * n) = n.toFloat := sorry\n\ntheorem approx_root_bounds (n : Nat) (h : n ≤ 1000000) :\n  Float.floor (Float.sqrt (n.toFloat)) ≤ approx_root n ∧ \n  approx_root n ≤ Float.floor (Float.sqrt (n.toFloat)) + 1 := sorry\n\ntheorem approx_root_precision (n : Nat) (h : n ≤ 1000000) :\n  (approx_root n - approx_root n).abs < 0.00001 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3446", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n#### Task:\n\nYour job here is to implement a method, `approx_root` in Ruby/Python/Crystal and `approxRoot` in JavaScript/CoffeeScript, that takes one argument, `n`, and returns the approximate square root of that number, rounded to the nearest hundredth and computed in the following manner.\n\n1.      Start with `n = 213` (as an example). \n2.      To approximate the square root of n, we will first find the greatest perfect square that is below or equal to `n`. (In this example, that would be 196, or 14 squared.) We will call the square root of this number (which means sqrt 196, or 14) `base`.\n3.      Then, we will take the lowest perfect square that is greater than or equal to `n`. (In this example, that would be 225, or 15 squared.)\n4.      Next, subtract 196 (greatest perfect square less than or equal to `n`) from `n`. (213 - 196 = **17**) We will call this value `diff_gn`.\n5.      Find the difference between the lowest perfect square greater than or equal to `n` and the greatest perfect square less than or equal to `n`. (225 – 196 = **29**) We will call this value `diff_lg`.\n6.      Your final answer is `base` + (`diff_gn` / `diff_lg`). In this example: 14 + (17 / 29) which is 14.59, rounded to the nearest hundredth.\n\nJust to clarify, if the input is a perfect square itself, you should return the exact square of the input.\n\nIn case you are curious, the approximation (computed like above) for 213 rounded to four decimal places is 14.5862. The actual square root of 213 is 14.5945. \n\nInputs will always be positive whole numbers. If you are having trouble understanding it, let me know with a comment, or take a look at the second group of the example cases.\n\n#### Some examples:\n\n```python\napprox_root(400) #=> 20\napprox_root(401) #=> \n  # smallest perfect square above 401 is 441 or 21 squared\n  # greatest perfect square below 401 is 400 or 20 squared\n  # difference between 441 and 400 is 41\n  # difference between 401 and 400 is 1\n  # answer is 20 + (1 / 41) which becomes 20.02, rounded to the nearest hundredth\n  # final answer = 20.02.\napprox_root(2) #=>\n  # smallest perfect square above 2 is 4 or 2 squared\n  # greatest perfect square below 2 is 1 or 1 squared\n  # difference between 4 and 1 is 3\n  # difference between 2 and 1 is 1\n  # answer is 1 + (1 / 3), which becomes 1.33, rounded to the nearest hundredth\n  # final answer = 1.33.\n\n# math.sqrt() isn't disabled.\n```\n\nAlso check out my other creations — [Square Roots: Simplifying/Desimplifying](https://www.codewars.com/kata/square-roots-simplify-slash-desimplify/), [Square and Cubic Factors](https://www.codewars.com/kata/square-and-cubic-factors), [Keep the Order](https://www.codewars.com/kata/keep-the-order), [Naming Files](https://www.codewars.com/kata/naming-files), [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n\nIf you notice any issues or have any suggestions/comments whatsoever, please don't hesitate to mark an issue or just comment. Thanks!\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef approx_root (n : Nat) : Float := sorry\n\ntheorem approx_root_close_to_actual (n : Nat) (h : n ≤ 1000000) : \n  (approx_root n - Float.sqrt (n.toFloat)).abs < 0.1 := sorry\n\ntheorem approx_root_perfect_squares (n : Nat) (h : n ≤ 1000) :\n  approx_root (n * n) = n.toFloat := sorry\n\ntheorem approx_root_bounds (n : Nat) (h : n ≤ 1000000) :\n  Float.floor (Float.sqrt (n.toFloat)) ≤ approx_root n ∧ \n  approx_root n ≤ Float.floor (Float.sqrt (n.toFloat)) + 1 := sorry\n\ntheorem approx_root_precision (n : Nat) (h : n ≤ 1000000) :\n  (approx_root n - approx_root n).abs < 0.00001 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3446"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIntroduction to Disjunctions\nIn logic and mathematics, a disjunction is an operation on 2 or more propositions.  A disjunction is true if and only if 1 or more of its operands is true.  In programming, we typically denote a disjunction using \"||\", but in logic we typically use \"v\".\nExample of disjunction:\np = 1 > 2 = false\nq = 2 < 3 = true\ntherefore p v q is true\nIn a programming language, we might write this as:\nvar p = 1 > 2;        // false\nvar q = 2 < 3;        // true\nvar result = p || q;  // true\nThe above example demonstrates an inclusive disjunction (meaning it includes cases where both operands are true). Disjunctions can also be exlusive. An exclusive disjunction is typically represented by \"⊻\" and is true if and only if both operands have opposite values.\np = 1 < 2 = true\nq = 2 < 3 = true\ntherefore p ⊻ q is false\nThis can become confusing when dealing with more than 2 operands.\nr = 3 < 4 = true\np ⊻ q ⊻ r = ???\nWe handle these situations by evaluating the expression from left to right.\np ⊻ q = false\n(p ⊻ q) ⊻ r = true\nDirections:\nFor this kata, your task is to implement a function that performs a disjunction operation on 2 or more propositions.\n\nShould take a boolean array as its first parameter and a single boolean as its second parameter, which, if true, should indicate that the disjunction should be exclusive as opposed to inclusive.\nShould return true or false.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef disjunction (operands: List Bool) (exclusive: Bool) : Bool := sorry\n\ntheorem disjunction_inclusive_or\n  {operands: List Bool}\n  (h: operands ≠ [])\n  : disjunction operands false = List.any operands id := sorry\n\ntheorem disjunction_exclusive_or\n  {operands: List Bool}\n  (h: operands ≠ [])\n  : disjunction operands true = ((List.countP (· = true) operands).mod 2 = 1) := sorry \n\ntheorem disjunction_empty_error\n  : ¬∃ (b: Bool), ∃ (res: Bool), disjunction [] b = res := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3462", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIntroduction to Disjunctions\nIn logic and mathematics, a disjunction is an operation on 2 or more propositions.  A disjunction is true if and only if 1 or more of its operands is true.  In programming, we typically denote a disjunction using \"||\", but in logic we typically use \"v\".\nExample of disjunction:\np = 1 > 2 = false\nq = 2 < 3 = true\ntherefore p v q is true\nIn a programming language, we might write this as:\nvar p = 1 > 2;        // false\nvar q = 2 < 3;        // true\nvar result = p || q;  // true\nThe above example demonstrates an inclusive disjunction (meaning it includes cases where both operands are true). Disjunctions can also be exlusive. An exclusive disjunction is typically represented by \"⊻\" and is true if and only if both operands have opposite values.\np = 1 < 2 = true\nq = 2 < 3 = true\ntherefore p ⊻ q is false\nThis can become confusing when dealing with more than 2 operands.\nr = 3 < 4 = true\np ⊻ q ⊻ r = ???\nWe handle these situations by evaluating the expression from left to right.\np ⊻ q = false\n(p ⊻ q) ⊻ r = true\nDirections:\nFor this kata, your task is to implement a function that performs a disjunction operation on 2 or more propositions.\n\nShould take a boolean array as its first parameter and a single boolean as its second parameter, which, if true, should indicate that the disjunction should be exclusive as opposed to inclusive.\nShould return true or false.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef disjunction (operands: List Bool) (exclusive: Bool) : Bool := sorry\n\ntheorem disjunction_inclusive_or\n  {operands: List Bool}\n  (h: operands ≠ [])\n  : disjunction operands false = List.any operands id := sorry\n\ntheorem disjunction_exclusive_or\n  {operands: List Bool}\n  (h: operands ≠ [])\n  : disjunction operands true = ((List.countP (· = true) operands).mod 2 = 1) := sorry \n\ntheorem disjunction_empty_error\n  : ¬∃ (b: Bool), ∃ (res: Bool), disjunction [] b = res := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3462"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nCreate a function that will return true if all numbers in the sequence follow the same counting pattern. If the sequence of numbers does not follow the same pattern, the function should return false.\n\nSequences will be presented in an array of varied length. Each array will have a minimum of 3 numbers in it.\n\nThe sequences are all simple and will not step up in varying increments such as a Fibonacci sequence.\n\nJavaScript examples:\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef validate_sequence (seq: List Int) : Bool := sorry\n\ntheorem too_short_sequences_invalid (seq: List Int) :\n  seq.length ≤ 2 → validate_sequence seq = false := sorry\n\ntheorem arithmetic_sequences_valid\n    (start diff: Int) (length: Nat) (h: 0 < length) (h': length ≤ 100) :\n  let seq := (List.range (length + 3)).map (fun i => start + (Int.ofNat i) * diff)\n  validate_sequence seq = true := sorry\n\ntheorem breaking_arithmetic_pattern_invalidates\n    (seq: List Int) (position: Nat) (h: 3 ≤ seq.length) (h': 0 < position) :\n  validate_sequence seq = true →\n  let position' := position % (seq.length - 1)\n  let position'' := if position' = 0 then 1 else position'\n  let modified_seq := seq.set position'' (seq.get! position'' + 1)\n  validate_sequence modified_seq = false := sorry\n\ntheorem common_difference_property (start diff: Int) (length: Nat)\n    (h: 3 ≤ length) (h': length ≤ 100) :\n  let seq := (List.range length).map (fun i => start + (Int.ofNat i) * diff)\n  validate_sequence seq = true →\n  let diffs := (List.range (length - 1)).map (fun i => seq.get! (i+1) - seq.get! i)\n  ∀ i, i < diffs.length → diffs.get! i = diffs.get! 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3514", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nCreate a function that will return true if all numbers in the sequence follow the same counting pattern. If the sequence of numbers does not follow the same pattern, the function should return false.\n\nSequences will be presented in an array of varied length. Each array will have a minimum of 3 numbers in it.\n\nThe sequences are all simple and will not step up in varying increments such as a Fibonacci sequence.\n\nJavaScript examples:\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef validate_sequence (seq: List Int) : Bool := sorry\n\ntheorem too_short_sequences_invalid (seq: List Int) :\n  seq.length ≤ 2 → validate_sequence seq = false := sorry\n\ntheorem arithmetic_sequences_valid\n    (start diff: Int) (length: Nat) (h: 0 < length) (h': length ≤ 100) :\n  let seq := (List.range (length + 3)).map (fun i => start + (Int.ofNat i) * diff)\n  validate_sequence seq = true := sorry\n\ntheorem breaking_arithmetic_pattern_invalidates\n    (seq: List Int) (position: Nat) (h: 3 ≤ seq.length) (h': 0 < position) :\n  validate_sequence seq = true →\n  let position' := position % (seq.length - 1)\n  let position'' := if position' = 0 then 1 else position'\n  let modified_seq := seq.set position'' (seq.get! position'' + 1)\n  validate_sequence modified_seq = false := sorry\n\ntheorem common_difference_property (start diff: Int) (length: Nat)\n    (h: 3 ≤ length) (h': length ≤ 100) :\n  let seq := (List.range length).map (fun i => start + (Int.ofNat i) * diff)\n  validate_sequence seq = true →\n  let diffs := (List.range (length - 1)).map (fun i => seq.get! (i+1) - seq.get! i)\n  ∀ i, i < diffs.length → diffs.get! i = diffs.get! 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3514"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Description:\n\n Count the number of exclamation marks and question marks, return the product.\n\n# Examples\n\n```\nProduct(\"\") == 0\nproduct(\"!\") == 0\nProduct(\"!ab? ?\") == 2\nProduct(\"!!\") == 0\nProduct(\"!??\") == 2\nProduct(\"!???\") == 3\nProduct(\"!!!??\") == 6\nProduct(\"!!!???\") == 9\nProduct(\"!???!!\") == 9\nProduct(\"!????!!!?\") == 20\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count (c : Char) (s : String) : Nat := sorry\ndef product (s : String) : Nat := sorry\n\ntheorem product_non_negative (s : String) : \n  product s ≥ 0 := sorry\n\ntheorem product_commutative (s : String) :\n  let swapped := s.replace \"!\" \"?\" |>.replace \"?\" \"!\"\n  product s = product swapped := sorry\n\ntheorem product_zero_if_missing_char (s : String) :\n  let no_excl := s.replace \"!\" \"\"\n  let no_quest := s.replace \"?\" \"\" \n  product no_excl = 0 ∧ product no_quest = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3623", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Description:\n\n Count the number of exclamation marks and question marks, return the product.\n\n# Examples\n\n```\nProduct(\"\") == 0\nproduct(\"!\") == 0\nProduct(\"!ab? ?\") == 2\nProduct(\"!!\") == 0\nProduct(\"!??\") == 2\nProduct(\"!???\") == 3\nProduct(\"!!!??\") == 6\nProduct(\"!!!???\") == 9\nProduct(\"!???!!\") == 9\nProduct(\"!????!!!?\") == 20\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count (c : Char) (s : String) : Nat := sorry\ndef product (s : String) : Nat := sorry\n\ntheorem product_non_negative (s : String) : \n  product s ≥ 0 := sorry\n\ntheorem product_commutative (s : String) :\n  let swapped := s.replace \"!\" \"?\" |>.replace \"?\" \"!\"\n  product s = product swapped := sorry\n\ntheorem product_zero_if_missing_char (s : String) :\n  let no_excl := s.replace \"!\" \"\"\n  let no_quest := s.replace \"?\" \"\" \n  product no_excl = 0 ∧ product no_quest = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3623"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nBob has a server farm crunching numbers. He has `nodes` servers in his farm. His company has a lot of work to do. \n\nThe work comes as a number `workload` which indicates how many jobs there are. Bob wants his servers to get an equal number of jobs each. If that is impossible, he wants the first servers to receive more jobs. He also wants the jobs sorted, so that the first server receives the first jobs.\n\nThe way this works, Bob wants an array indicating which jobs are going to which servers.\n\nCan you help him distribute all this work as evenly as possible onto his servers?\n\nExample\n-------\n\nBob has `2` servers and `4` jobs. The first server should receive job 0 and 1 while the second should receive 2 and 3.\n\n```\ndistribute(2, 4) # => [[0, 1], [2, 3]]\n```\n\nOn a different occasion Bob has `3` servers and `3` jobs. Each should get just one.\n\n```\ndistribute(3, 3) # => [[0], [1], [2]]\n```\n\nA couple of days go by and Bob sees a spike in jobs. Now there are `10`, but he hasn't got more than `4` servers available. He boots all of them. This time the first and second should get a job more than the third and fourth.\n\n```\ndistribute(4, 10) # => [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]\n```\n\nInput\n-----\n\nDon't worry about invalid inputs. That is, `nodes > 0` and `workload > 0` and both will always be integers.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef distribute (nodes : Nat) (workload : Nat) : List (List Nat) :=\n  sorry\n\ndef listMaximum (l : List Nat) : Nat :=\n  sorry\n\ndef listMinimum (l : List Nat) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry\n\ntheorem distribute_length {nodes workload : Nat} \n  (h : nodes ≤ workload ∨ workload = 0) :\n  (distribute nodes workload).length = nodes :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3643", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nBob has a server farm crunching numbers. He has `nodes` servers in his farm. His company has a lot of work to do. \n\nThe work comes as a number `workload` which indicates how many jobs there are. Bob wants his servers to get an equal number of jobs each. If that is impossible, he wants the first servers to receive more jobs. He also wants the jobs sorted, so that the first server receives the first jobs.\n\nThe way this works, Bob wants an array indicating which jobs are going to which servers.\n\nCan you help him distribute all this work as evenly as possible onto his servers?\n\nExample\n-------\n\nBob has `2` servers and `4` jobs. The first server should receive job 0 and 1 while the second should receive 2 and 3.\n\n```\ndistribute(2, 4) # => [[0, 1], [2, 3]]\n```\n\nOn a different occasion Bob has `3` servers and `3` jobs. Each should get just one.\n\n```\ndistribute(3, 3) # => [[0], [1], [2]]\n```\n\nA couple of days go by and Bob sees a spike in jobs. Now there are `10`, but he hasn't got more than `4` servers available. He boots all of them. This time the first and second should get a job more than the third and fourth.\n\n```\ndistribute(4, 10) # => [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]\n```\n\nInput\n-----\n\nDon't worry about invalid inputs. That is, `nodes > 0` and `workload > 0` and both will always be integers.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef distribute (nodes : Nat) (workload : Nat) : List (List Nat) :=\n  sorry\n\ndef listMaximum (l : List Nat) : Nat :=\n  sorry\n\ndef listMinimum (l : List Nat) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry\n\ntheorem distribute_length {nodes workload : Nat} \n  (h : nodes ≤ workload ∨ workload = 0) :\n  (distribute nodes workload).length = nodes :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3643"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nFind the difference between two collections. The difference means that either the character is present in one collection or it is present in other, but not in both. Return a sorted set with difference.\n\nThe collections can contain any character and can contain duplicates.\n\nFor instance:\n\nA = [a,a,t,e,f,i,j]\n\nB = [t,g,g,i,k,f]\n\ndifference = [a,e,g,j,k]\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.diff : List α → List α → List α \n  | xs, ys => sorry\n\n-- Elements in result must come from input lists\ntheorem diff_elements_from_inputs {α} (a b : List α) (x : α) :\n  x ∈ List.diff a b → x ∈ a ∨ x ∈ b\n  := sorry\n\n-- Elements in result must be unique \ntheorem diff_unique {α} (a b : List α) :\n  List.Nodup (List.diff a b)\n  := sorry\n\n-- If inputs are same (up to permutation), result is empty\ntheorem diff_same {α} (a b : List α) :\n  a = b → List.diff a b = []\n  := sorry\n\n-- Symmetric property\ntheorem diff_symmetric {α} (a b : List α) :\n  List.diff a b = List.diff b a\n  := sorry\n\n-- Identity property\ntheorem diff_identity {α} (xs : List α) :\n  List.diff xs xs = []\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3645", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nFind the difference between two collections. The difference means that either the character is present in one collection or it is present in other, but not in both. Return a sorted set with difference.\n\nThe collections can contain any character and can contain duplicates.\n\nFor instance:\n\nA = [a,a,t,e,f,i,j]\n\nB = [t,g,g,i,k,f]\n\ndifference = [a,e,g,j,k]\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.diff : List α → List α → List α \n  | xs, ys => sorry\n\n-- Elements in result must come from input lists\ntheorem diff_elements_from_inputs {α} (a b : List α) (x : α) :\n  x ∈ List.diff a b → x ∈ a ∨ x ∈ b\n  := sorry\n\n-- Elements in result must be unique \ntheorem diff_unique {α} (a b : List α) :\n  List.Nodup (List.diff a b)\n  := sorry\n\n-- If inputs are same (up to permutation), result is empty\ntheorem diff_same {α} (a b : List α) :\n  a = b → List.diff a b = []\n  := sorry\n\n-- Symmetric property\ntheorem diff_symmetric {α} (a b : List α) :\n  List.diff a b = List.diff b a\n  := sorry\n\n-- Identity property\ntheorem diff_identity {α} (xs : List α) :\n  List.diff xs xs = []\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3645"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are a biologist working on the amino acid  composition of proteins. Every protein consists of a long chain of 20 different amino acids with different properties. \nCurrently, you are collecting data on the percentage, various amino acids make up a protein you are working on. As manually counting the occurences of amino acids takes too long (especially when counting more than one amino acid), you decide to write a program for this task:\n\nWrite a function that takes two arguments,\n 1. A (snippet of a) protein sequence\n 2. A list of amino acid residue codes \n\nand returns the rounded percentage of the protein that the given amino acids make up. \nIf no amino acid list is given, return the percentage of hydrophobic amino acid residues [\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"].\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef aa_percentage (seq : String) (residues : List Char := ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) : Nat := sorry\n\ntheorem default_residues_in_bounds (seq : String) \n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  0 ≤ aa_percentage seq ∧ aa_percentage seq ≤ 100 := sorry\n\ntheorem custom_residues_in_bounds (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  0 ≤ aa_percentage seq residues ∧ aa_percentage seq residues ≤ 100 := sorry\n\ntheorem empty_residues_gives_zero (seq : String) \n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq [] = 0 := sorry\n\ndef sum_list : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum_list xs\n\ntheorem residue_count_matches (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  aa_percentage seq residues = \n    ((sum_list (residues.map (λ r => seq.data.count r))) * 100 + seq.length / 2) / seq.length := sorry\n\ntheorem default_residues_consistent (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq = aa_percentage seq ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V'] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3649", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are a biologist working on the amino acid  composition of proteins. Every protein consists of a long chain of 20 different amino acids with different properties. \nCurrently, you are collecting data on the percentage, various amino acids make up a protein you are working on. As manually counting the occurences of amino acids takes too long (especially when counting more than one amino acid), you decide to write a program for this task:\n\nWrite a function that takes two arguments,\n 1. A (snippet of a) protein sequence\n 2. A list of amino acid residue codes \n\nand returns the rounded percentage of the protein that the given amino acids make up. \nIf no amino acid list is given, return the percentage of hydrophobic amino acid residues [\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"].\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef aa_percentage (seq : String) (residues : List Char := ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) : Nat := sorry\n\ntheorem default_residues_in_bounds (seq : String) \n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  0 ≤ aa_percentage seq ∧ aa_percentage seq ≤ 100 := sorry\n\ntheorem custom_residues_in_bounds (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  0 ≤ aa_percentage seq residues ∧ aa_percentage seq residues ≤ 100 := sorry\n\ntheorem empty_residues_gives_zero (seq : String) \n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq [] = 0 := sorry\n\ndef sum_list : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum_list xs\n\ntheorem residue_count_matches (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  aa_percentage seq residues = \n    ((sum_list (residues.map (λ r => seq.data.count r))) * 100 + seq.length / 2) / seq.length := sorry\n\ntheorem default_residues_consistent (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq = aa_percentage seq ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V'] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3649"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Task\n\nWrite a function that accepts `msg` string and returns local tops of string from the highest to the lowest.  \nThe string's tops are from displaying the string in the below way:\n\n```\n\n                                         7891012\n                             TUWvXY      6     3\n                   ABCDE     S    Z      5\n           lmno    z   F     R    1      4\n     abc   k  p    v   G     Q    2      3\n.34..9 d...j  q....x   H.....P    3......2\n125678 efghi  rstuwy   IJKLMNO    45678901\n\n```\nThe next top is always 1 character higher than the previous one. \nFor the above example, the solution for the `123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123` input string is `7891012TUWvXYABCDElmnoabc34`. \n\n- When the `msg` string is empty, return an empty string.\n- The input strings may be very long. Make sure your solution has good performance.\n- The (.)dots on the sample dispaly of string are only there to help you to understand the pattern  \n\nCheck the test cases for more samples.\n\n# Series\n\n- [String tops](https://www.codewars.com/kata/59b7571bbf10a48c75000070)\n- [Square string tops](https://www.codewars.com/kata/5aa3e2b0373c2e4b420009af)\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef tops (s : String) : String := sorry \n\ntheorem tops_empty_or_short_strings (s : String) :\n  (s = \"\") → (tops s = \"\") ∧ \n  (s.length ≤ 2) → (tops s = \"\") ∧\n  (tops s).length ≤ s.length := by sorry\n\ntheorem tops_result_pattern (s : String) :\n  s.length ≥ 10 →\n  (∀ c, c ∈ (tops s).data.take 2 → c ∈ s.data) ∧ \n  (∀ c, c ∈ ((tops s).data.drop 2).take 3 → c ∈ s.data) ∧\n  (∀ c, c ∈ ((tops s).data.drop 5).take 4 → c ∈ s.data) := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3653", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Task\n\nWrite a function that accepts `msg` string and returns local tops of string from the highest to the lowest.  \nThe string's tops are from displaying the string in the below way:\n\n```\n\n                                         7891012\n                             TUWvXY      6     3\n                   ABCDE     S    Z      5\n           lmno    z   F     R    1      4\n     abc   k  p    v   G     Q    2      3\n.34..9 d...j  q....x   H.....P    3......2\n125678 efghi  rstuwy   IJKLMNO    45678901\n\n```\nThe next top is always 1 character higher than the previous one. \nFor the above example, the solution for the `123456789abcdefghijklmnopqrstuwyxvzABCDEFGHIJKLMNOPQRSTUWvXYZ123456789012345678910123` input string is `7891012TUWvXYABCDElmnoabc34`. \n\n- When the `msg` string is empty, return an empty string.\n- The input strings may be very long. Make sure your solution has good performance.\n- The (.)dots on the sample dispaly of string are only there to help you to understand the pattern  \n\nCheck the test cases for more samples.\n\n# Series\n\n- [String tops](https://www.codewars.com/kata/59b7571bbf10a48c75000070)\n- [Square string tops](https://www.codewars.com/kata/5aa3e2b0373c2e4b420009af)\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef tops (s : String) : String := sorry \n\ntheorem tops_empty_or_short_strings (s : String) :\n  (s = \"\") → (tops s = \"\") ∧ \n  (s.length ≤ 2) → (tops s = \"\") ∧\n  (tops s).length ≤ s.length := by sorry\n\ntheorem tops_result_pattern (s : String) :\n  s.length ≥ 10 →\n  (∀ c, c ∈ (tops s).data.take 2 → c ∈ s.data) ∧ \n  (∀ c, c ∈ ((tops s).data.drop 2).take 3 → c ∈ s.data) ∧\n  (∀ c, c ∈ ((tops s).data.drop 5).take 4 → c ∈ s.data) := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3653"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nMake a function **\"add\"** that will be able to sum elements of **list** continuously and return a new list of sums.\n\nFor example: \n\n```\nadd [1,2,3,4,5] == [1, 3, 6, 10, 15], because it's calculated like \nthis : [1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]\n```\n\nIf you want to learn more see https://en.wikipedia.org/wiki/Prefix_sum\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nnamespace AddSpec\n\ndef add (nums: List Int) : List Int :=\n  sorry\n\n@[simp]\ntheorem add_length_preservation: \n  ∀ (nums: List Int), \n  List.length (add nums) = List.length nums := \n  sorry\n\n@[simp]\ntheorem add_cumulative_property:\n  ∀ (nums: List Int),\n  nums ≠ [] →\n  let result := add nums\n  (List.get! result 0 = List.get! nums 0) ∧ \n  ∀ (i: Nat), 0 < i → i < nums.length → \n    List.get! result i = List.get! result (i-1) + List.get! nums i :=\n  sorry\n\n@[simp]\ntheorem add_monotonic_for_nonnegative:\n  ∀ (nums: List Int),\n  (∀ x, x ∈ nums → 0 ≤ x) →\n  let result := add nums\n  ∀ (i j: Nat), i < j → j < result.length → \n    List.get! result i ≤ List.get! result j :=\n  sorry\n\n@[simp]\ntheorem add_invalid_input:\n  ∀ (s: String), add [] = [] :=\n  sorry\n\nend AddSpec\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3696", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nMake a function **\"add\"** that will be able to sum elements of **list** continuously and return a new list of sums.\n\nFor example: \n\n```\nadd [1,2,3,4,5] == [1, 3, 6, 10, 15], because it's calculated like \nthis : [1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]\n```\n\nIf you want to learn more see https://en.wikipedia.org/wiki/Prefix_sum\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nnamespace AddSpec\n\ndef add (nums: List Int) : List Int :=\n  sorry\n\n@[simp]\ntheorem add_length_preservation: \n  ∀ (nums: List Int), \n  List.length (add nums) = List.length nums := \n  sorry\n\n@[simp]\ntheorem add_cumulative_property:\n  ∀ (nums: List Int),\n  nums ≠ [] →\n  let result := add nums\n  (List.get! result 0 = List.get! nums 0) ∧ \n  ∀ (i: Nat), 0 < i → i < nums.length → \n    List.get! result i = List.get! result (i-1) + List.get! nums i :=\n  sorry\n\n@[simp]\ntheorem add_monotonic_for_nonnegative:\n  ∀ (nums: List Int),\n  (∀ x, x ∈ nums → 0 ≤ x) →\n  let result := add nums\n  ∀ (i j: Nat), i < j → j < result.length → \n    List.get! result i ≤ List.get! result j :=\n  sorry\n\n@[simp]\ntheorem add_invalid_input:\n  ∀ (s: String), add [] = [] :=\n  sorry\n\nend AddSpec\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3696"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nComplete the method that takes a boolean value and return a `\"Yes\"` string for `true`, or a `\"No\"` string for `false`.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef bool_to_word (b : Bool) : String := sorry\n\ntheorem bool_to_word_returns_string (b : Bool) :\n  toString (bool_to_word b) = bool_to_word b := sorry\n\ntheorem bool_to_word_returns_yes_or_no (b : Bool) :\n  bool_to_word b = \"Yes\" ∨ bool_to_word b = \"No\" := sorry\n\ntheorem bool_to_word_matches_input (b : Bool) :\n  bool_to_word b = if b then \"Yes\" else \"No\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3751", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nComplete the method that takes a boolean value and return a `\"Yes\"` string for `true`, or a `\"No\"` string for `false`.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef bool_to_word (b : Bool) : String := sorry\n\ntheorem bool_to_word_returns_string (b : Bool) :\n  toString (bool_to_word b) = bool_to_word b := sorry\n\ntheorem bool_to_word_returns_yes_or_no (b : Bool) :\n  bool_to_word b = \"Yes\" ∨ bool_to_word b = \"No\" := sorry\n\ntheorem bool_to_word_matches_input (b : Bool) :\n  bool_to_word b = if b then \"Yes\" else \"No\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3751"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nClock shows 'h' hours, 'm' minutes and 's' seconds after midnight.\n\nYour task is to make 'Past' function which returns time converted to milliseconds.\n\n## Example:\n\n```python\npast(0, 1, 1) == 61000\n```\n\nInput constraints: `0 <= h <= 23`, `0 <= m <= 59`, `0 <= s <= 59`\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef past (h: Nat) (m: Nat) (s: Nat) : Nat :=\n  sorry\n\ntheorem past_valid_time {h m s: Nat} \n  (hh: h ≤ 23) (hm: m ≤ 59) (hs: s ≤ 59) : \n  past h m s = (h * 3600 + m * 60 + s) * 1000 \n  ∧ past h m s < 24 * 60 * 60 * 1000 :=\nsorry\n\ntheorem past_zero_seconds {h m: Nat}\n  (hh: h ≤ 23) (hm: m ≤ 59) :\n  past h m 0 = (h * 3600 + m * 60) * 1000 :=\nsorry \n\ntheorem past_midnight :\n  past 0 0 0 = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3779", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nClock shows 'h' hours, 'm' minutes and 's' seconds after midnight.\n\nYour task is to make 'Past' function which returns time converted to milliseconds.\n\n## Example:\n\n```python\npast(0, 1, 1) == 61000\n```\n\nInput constraints: `0 <= h <= 23`, `0 <= m <= 59`, `0 <= s <= 59`\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef past (h: Nat) (m: Nat) (s: Nat) : Nat :=\n  sorry\n\ntheorem past_valid_time {h m s: Nat} \n  (hh: h ≤ 23) (hm: m ≤ 59) (hs: s ≤ 59) : \n  past h m s = (h * 3600 + m * 60 + s) * 1000 \n  ∧ past h m s < 24 * 60 * 60 * 1000 :=\nsorry\n\ntheorem past_zero_seconds {h m: Nat}\n  (hh: h ≤ 23) (hm: m ≤ 59) :\n  past h m 0 = (h * 3600 + m * 60) * 1000 :=\nsorry \n\ntheorem past_midnight :\n  past 0 0 0 = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3779"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n#Sorting on planet Twisted-3-7\n\nThere is a planet... in a galaxy far far away. It is exactly like our planet, but it has one difference:\n#The values of the digits 3 and 7 are twisted.\nOur 3 means 7 on the planet Twisted-3-7. And 7 means 3.\n\nYour task is to create a method, that can sort an array the way it would be sorted on Twisted-3-7.\n\n7 Examples from a friend from Twisted-3-7:\n```\n[1,2,3,4,5,6,7,8,9] -> [1,2,7,4,5,6,3,8,9]\n[12,13,14] -> [12,14,13]\n[9,2,4,7,3] -> [2,7,4,3,9]\n```\n\nThere is no need for a precheck. The array will always be not null and will always contain at least one number.\n\nYou should not modify the input array!\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have also created other katas. Take a look if you enjoyed this kata!\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sort_twisted37 (arr : List Int) : List Int := sorry\n\ndef twist37 (n : Int) : Int := sorry\n\ntheorem sort_twisted37_invariants {arr : List Int} :\n  let result := sort_twisted37 arr\n  (List.length result = List.length arr) ∧ \n  (∀ x, x ∈ result ↔ x ∈ arr) ∧\n  (∀ i j, i < j → j < result.length → \n    let i' : Fin result.length := ⟨i, by sorry⟩\n    let j' : Fin result.length := ⟨j, by sorry⟩\n    twist37 (result.get i') ≤ twist37 (result.get j')) :=\nsorry\n\ntheorem sort_twisted37_no_changes {arr : List Int} \n  (h : ∀ x ∈ arr, ¬ (toString x).contains '3' ∧ ¬ (toString x).contains '7') :\n  sort_twisted37 arr = arr :=\nsorry\n\ntheorem sort_twisted37_idempotent {arr : List Int} :\n  sort_twisted37 (sort_twisted37 arr) = sort_twisted37 arr :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3874", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n#Sorting on planet Twisted-3-7\n\nThere is a planet... in a galaxy far far away. It is exactly like our planet, but it has one difference:\n#The values of the digits 3 and 7 are twisted.\nOur 3 means 7 on the planet Twisted-3-7. And 7 means 3.\n\nYour task is to create a method, that can sort an array the way it would be sorted on Twisted-3-7.\n\n7 Examples from a friend from Twisted-3-7:\n```\n[1,2,3,4,5,6,7,8,9] -> [1,2,7,4,5,6,3,8,9]\n[12,13,14] -> [12,14,13]\n[9,2,4,7,3] -> [2,7,4,3,9]\n```\n\nThere is no need for a precheck. The array will always be not null and will always contain at least one number.\n\nYou should not modify the input array!\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have also created other katas. Take a look if you enjoyed this kata!\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sort_twisted37 (arr : List Int) : List Int := sorry\n\ndef twist37 (n : Int) : Int := sorry\n\ntheorem sort_twisted37_invariants {arr : List Int} :\n  let result := sort_twisted37 arr\n  (List.length result = List.length arr) ∧ \n  (∀ x, x ∈ result ↔ x ∈ arr) ∧\n  (∀ i j, i < j → j < result.length → \n    let i' : Fin result.length := ⟨i, by sorry⟩\n    let j' : Fin result.length := ⟨j, by sorry⟩\n    twist37 (result.get i') ≤ twist37 (result.get j')) :=\nsorry\n\ntheorem sort_twisted37_no_changes {arr : List Int} \n  (h : ∀ x ∈ arr, ¬ (toString x).contains '3' ∧ ¬ (toString x).contains '7') :\n  sort_twisted37 arr = arr :=\nsorry\n\ntheorem sort_twisted37_idempotent {arr : List Int} :\n  sort_twisted37 (sort_twisted37 arr) = sort_twisted37 arr :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3874"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on: \n\n* make as few changes as possible. \n* if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase. \n\nFor example:\n```Haskell\nsolve(\"coDe\") = \"code\". Lowercase characters > uppercase. Change only the \"D\" to lowercase.\nsolve(\"CODe\") = \"CODE\". Uppercase characters > lowecase. Change only the \"e\" to uppercase.\nsolve(\"coDE\") = \"code\". Upper == lowercase. Change all to lowercase.\n```\n\nMore examples in test cases. Good luck!\n\nPlease also try:\n \n[Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n\n[Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (s : String) : String := sorry\n\ndef isUpper (s : String) : Bool := sorry\ndef isLower (s : String) : Bool := sorry\n\ntheorem solve_returns_either_upper_or_lower (s : String) : \n  (solve s = s.toUpper) ∨ (solve s = s.toLower) := sorry\n\ntheorem solve_preserves_uppercase (s : String) : \n  isUpper s = true → solve s = s.toUpper := sorry \n\ntheorem solve_preserves_lowercase (s : String) :\n  isLower s = true → solve s = s.toLower := sorry\n\ntheorem solve_preserves_length (s : String) :\n  (solve s).length = s.length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3894", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on: \n\n* make as few changes as possible. \n* if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase. \n\nFor example:\n```Haskell\nsolve(\"coDe\") = \"code\". Lowercase characters > uppercase. Change only the \"D\" to lowercase.\nsolve(\"CODe\") = \"CODE\". Uppercase characters > lowecase. Change only the \"e\" to uppercase.\nsolve(\"coDE\") = \"code\". Upper == lowercase. Change all to lowercase.\n```\n\nMore examples in test cases. Good luck!\n\nPlease also try:\n \n[Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n\n[Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef solve (s : String) : String := sorry\n\ndef isUpper (s : String) : Bool := sorry\ndef isLower (s : String) : Bool := sorry\n\ntheorem solve_returns_either_upper_or_lower (s : String) : \n  (solve s = s.toUpper) ∨ (solve s = s.toLower) := sorry\n\ntheorem solve_preserves_uppercase (s : String) : \n  isUpper s = true → solve s = s.toUpper := sorry \n\ntheorem solve_preserves_lowercase (s : String) :\n  isLower s = true → solve s = s.toLower := sorry\n\ntheorem solve_preserves_length (s : String) :\n  (solve s).length = s.length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3894"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an array containing only integers, add all the elements and return the binary equivalent of that sum.\n\nIf the array contains any non-integer element (e.g. an object, a float, a string and so on), return false.\n\n**Note:** The sum of an empty array is zero.\n\n```python\narr2bin([1,2]) == '11'\narr2bin([1,2,'a']) == False\n```\n```\n#####\n\nTo answer this question, you need to replace the 11 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef arr2bin (arr : List α) : String := sorry\n\ndef sumList (l : List Int) : Int := sorry\n\ndef toBinaryString (n : Int) : String := sorry\n\ntheorem arr2bin_all_ints {arr : List Int} :\n  arr2bin arr = toBinaryString (sumList arr) := sorry\n\ntheorem arr2bin_empty : \n  arr2bin ([] : List α) = \"0\" := sorry\n\ndef allBinary (s : String) : Bool := sorry\ndef stringToNat (s : String) : Nat := sorry\n\ntheorem arr2bin_positive_ints {arr : List Nat} :\n  let result := arr2bin arr\n  allBinary result ∧\n  stringToNat result = arr.foldl (init := 0) (·+·) := sorry\n\ndef isAllInts (arr : List α) : Bool := sorry\ndef listToInts (arr : List α) : List Int := sorry\n\ntheorem arr2bin_mixed_types {α} {arr : List α} :\n  (¬isAllInts arr → arr2bin arr = \"\") ∧\n  (isAllInts arr → arr2bin arr = toBinaryString (sumList (listToInts arr))) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3912", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven an array containing only integers, add all the elements and return the binary equivalent of that sum.\n\nIf the array contains any non-integer element (e.g. an object, a float, a string and so on), return false.\n\n**Note:** The sum of an empty array is zero.\n\n```python\narr2bin([1,2]) == '11'\narr2bin([1,2,'a']) == False\n```\n```\n#####\n\nTo answer this question, you need to replace the 11 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef arr2bin (arr : List α) : String := sorry\n\ndef sumList (l : List Int) : Int := sorry\n\ndef toBinaryString (n : Int) : String := sorry\n\ntheorem arr2bin_all_ints {arr : List Int} :\n  arr2bin arr = toBinaryString (sumList arr) := sorry\n\ntheorem arr2bin_empty : \n  arr2bin ([] : List α) = \"0\" := sorry\n\ndef allBinary (s : String) : Bool := sorry\ndef stringToNat (s : String) : Nat := sorry\n\ntheorem arr2bin_positive_ints {arr : List Nat} :\n  let result := arr2bin arr\n  allBinary result ∧\n  stringToNat result = arr.foldl (init := 0) (·+·) := sorry\n\ndef isAllInts (arr : List α) : Bool := sorry\ndef listToInts (arr : List α) : List Int := sorry\n\ntheorem arr2bin_mixed_types {α} {arr : List α} :\n  (¬isAllInts arr → arr2bin arr = \"\") ∧\n  (isAllInts arr → arr2bin arr = toBinaryString (sumList (listToInts arr))) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3912"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nA zero-indexed array ```arr``` consisting of n integers is given. The dominator of array ```arr``` is the value that occurs in more than half of the elements of ```arr```.\nFor example, consider array ```arr``` such that ```arr = [3,4,3,2,3,1,3,3]``` The dominator of ```arr``` is 3 because it occurs in 5 out of 8 elements of ```arr``` and 5 is more than a half of 8.\nWrite a function ```dominator(arr)``` that, given a zero-indexed array ```arr``` consisting of n integers, returns the dominator of ```arr```. The function should return −1 if array does not have a dominator. All values in ```arr``` will be >=0.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef dominator (arr : List Int) : Int := sorry\n\ntheorem dominator_empty_list :\n  dominator [] = -1 := sorry\n\ntheorem dominator_singleton (x : Int) :\n  dominator [x] = x := sorry\n\ntheorem dominator_majority {base : List Int} {dom_value : Int} {repeats : Nat}\n  (h_repeats : repeats > base.length) :\n  dominator (base ++ List.replicate repeats dom_value) = dom_value := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3914", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nA zero-indexed array ```arr``` consisting of n integers is given. The dominator of array ```arr``` is the value that occurs in more than half of the elements of ```arr```.\nFor example, consider array ```arr``` such that ```arr = [3,4,3,2,3,1,3,3]``` The dominator of ```arr``` is 3 because it occurs in 5 out of 8 elements of ```arr``` and 5 is more than a half of 8.\nWrite a function ```dominator(arr)``` that, given a zero-indexed array ```arr``` consisting of n integers, returns the dominator of ```arr```. The function should return −1 if array does not have a dominator. All values in ```arr``` will be >=0.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef dominator (arr : List Int) : Int := sorry\n\ntheorem dominator_empty_list :\n  dominator [] = -1 := sorry\n\ntheorem dominator_singleton (x : Int) :\n  dominator [x] = x := sorry\n\ntheorem dominator_majority {base : List Int} {dom_value : Int} {repeats : Nat}\n  (h_repeats : repeats > base.length) :\n  dominator (base ++ List.replicate repeats dom_value) = dom_value := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3914"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYour task in this Kata is to emulate text justify right in monospace font. You will be given a single-lined text and the expected justification width. The longest word will never be greater than this width.\n\nHere are the rules:\n\n- Use spaces to fill in the gaps on the left side of the words.\n- Each line should contain as many words as possible.\n- Use '\\n' to separate lines.\n- Gap between words can't differ by more than one space.\n- Lines should end with a word not a space.\n- '\\n' is not included in the length of a line.\n- Last line should not contain '\\n'\n\nExample with width=30:\n\n```\n        Bacon ipsum dolor amet\nexcepteur ut kevin burgdoggen,\n   shankle cupim dolor officia\n       ground round id ullamco\n   deserunt nisi. Commodo tail\n    qui salami, brisket boudin \ntri-tip. Labore flank laboris,\n  cow enim proident aliqua sed\n      hamburger consequat. Sed\n     consequat ut non bresaola\n   capicola shoulder excepteur\n veniam, bacon kevin. Pastrami\n   shank laborum est excepteur\n non eiusmod bresaola flank in\nnostrud. Corned beef ex pig do\n   kevin filet mignon in irure\n deserunt ipsum qui duis short\n        loin. Beef ribs dolore\n  meatball officia rump fugiat\n  in enim corned beef non est.\n```\n\nIf you enjoyed this one and want more of a challenge try https://www.codewars.com/kata/text-align-justify/python\n\nIf you like bacon ipsum https://baconipsum.com\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef align_right (text : String) (width : Nat) : String := sorry\n\ntheorem width_equal_to_content (text : String) (line : String) : \n  line ≠ \"\" →\n  line ∈ (text.split (· = '\\n')) →\n  align_right line (line.length) = line := sorry\n\ntheorem basic_properties_nonempty (text : String) (width : Nat) :\n  text.trim ≠ \"\" →\n  width ≥ 10 →\n  (align_right text width).trim ≠ \"\" := sorry\n\ntheorem basic_properties_width (text : String) (width : Nat) : \n  text.trim ≠ \"\" →\n  width ≥ 10 →\n  ∀ line ∈ (align_right text width).split (· = '\\n'), \n    line.length ≤ width := sorry\n\ntheorem basic_properties_alignment (text : String) (width : Nat) :\n  text.trim ≠ \"\" →\n  width ≥ 10 →\n  ∀ line ∈ (align_right text width).split (· = '\\n'),\n    !line.startsWith line.trim ∨ line.trim = line := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3960", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYour task in this Kata is to emulate text justify right in monospace font. You will be given a single-lined text and the expected justification width. The longest word will never be greater than this width.\n\nHere are the rules:\n\n- Use spaces to fill in the gaps on the left side of the words.\n- Each line should contain as many words as possible.\n- Use '\\n' to separate lines.\n- Gap between words can't differ by more than one space.\n- Lines should end with a word not a space.\n- '\\n' is not included in the length of a line.\n- Last line should not contain '\\n'\n\nExample with width=30:\n\n```\n        Bacon ipsum dolor amet\nexcepteur ut kevin burgdoggen,\n   shankle cupim dolor officia\n       ground round id ullamco\n   deserunt nisi. Commodo tail\n    qui salami, brisket boudin \ntri-tip. Labore flank laboris,\n  cow enim proident aliqua sed\n      hamburger consequat. Sed\n     consequat ut non bresaola\n   capicola shoulder excepteur\n veniam, bacon kevin. Pastrami\n   shank laborum est excepteur\n non eiusmod bresaola flank in\nnostrud. Corned beef ex pig do\n   kevin filet mignon in irure\n deserunt ipsum qui duis short\n        loin. Beef ribs dolore\n  meatball officia rump fugiat\n  in enim corned beef non est.\n```\n\nIf you enjoyed this one and want more of a challenge try https://www.codewars.com/kata/text-align-justify/python\n\nIf you like bacon ipsum https://baconipsum.com\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef align_right (text : String) (width : Nat) : String := sorry\n\ntheorem width_equal_to_content (text : String) (line : String) : \n  line ≠ \"\" →\n  line ∈ (text.split (· = '\\n')) →\n  align_right line (line.length) = line := sorry\n\ntheorem basic_properties_nonempty (text : String) (width : Nat) :\n  text.trim ≠ \"\" →\n  width ≥ 10 →\n  (align_right text width).trim ≠ \"\" := sorry\n\ntheorem basic_properties_width (text : String) (width : Nat) : \n  text.trim ≠ \"\" →\n  width ≥ 10 →\n  ∀ line ∈ (align_right text width).split (· = '\\n'), \n    line.length ≤ width := sorry\n\ntheorem basic_properties_alignment (text : String) (width : Nat) :\n  text.trim ≠ \"\" →\n  width ≥ 10 →\n  ∀ line ∈ (align_right text width).split (· = '\\n'),\n    !line.startsWith line.trim ∨ line.trim = line := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3960"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a method that returns true if a given parameter is a power of 4, and false if it's not. If parameter is not an Integer (eg String, Array) method should return false as well.\n\n(In C# Integer means all integer Types like Int16,Int32,.....)\n\n### Examples\n\n```python\nisPowerOf4 1024 #should return True\nisPowerOf4  102 #should return False\nisPowerOf4   64 #should return True\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef powerof4 {α : Type} (x : α) : Bool := sorry\n\ntheorem powerof4_positive_integers (n : Nat) :\n  n ≥ 1 ∧ n ≤ 1000000 →\n  powerof4 n = true ↔ (n = 1 ∨ (∃ k : Nat, n = 4 * 4^k)) := sorry\n\ntheorem powerof4_float_property (n : Float) :\n  n > 0 ∧ n ≤ 1000000 →\n  powerof4 n = true → \n  ∃ k : Nat, n = Float.ofNat (4 * 4^k) := sorry\n\ntheorem powerof4_string_false (s : String) :\n  powerof4 s = false := sorry\n\ntheorem powerof4_nonpositive_false (n : Int) :\n  n ≤ 0 → powerof4 n = false := sorry\n\ntheorem powerof4_other_types_false (x : Unit ⊕ List Nat ⊕ Array Nat) :\n  powerof4 x = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3965", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a method that returns true if a given parameter is a power of 4, and false if it's not. If parameter is not an Integer (eg String, Array) method should return false as well.\n\n(In C# Integer means all integer Types like Int16,Int32,.....)\n\n### Examples\n\n```python\nisPowerOf4 1024 #should return True\nisPowerOf4  102 #should return False\nisPowerOf4   64 #should return True\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef powerof4 {α : Type} (x : α) : Bool := sorry\n\ntheorem powerof4_positive_integers (n : Nat) :\n  n ≥ 1 ∧ n ≤ 1000000 →\n  powerof4 n = true ↔ (n = 1 ∨ (∃ k : Nat, n = 4 * 4^k)) := sorry\n\ntheorem powerof4_float_property (n : Float) :\n  n > 0 ∧ n ≤ 1000000 →\n  powerof4 n = true → \n  ∃ k : Nat, n = Float.ofNat (4 * 4^k) := sorry\n\ntheorem powerof4_string_false (s : String) :\n  powerof4 s = false := sorry\n\ntheorem powerof4_nonpositive_false (n : Int) :\n  n ≤ 0 → powerof4 n = false := sorry\n\ntheorem powerof4_other_types_false (x : Unit ⊕ List Nat ⊕ Array Nat) :\n  powerof4 x = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3965"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nA happy number is a number defined by the following process: starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\nThose numbers for which this process ends in 1 are **happy numbers**, while those that do not end in 1 are unhappy numbers (or sad numbers) (Wikipedia).\n\nWrite a function that takes `n` as parameter and return `true` if and only if `n` is an happy number, `false` otherwise.\n\n\n## Examples\n\nFor example number `7` is happy because after a number of steps the computed sequence ends up with a 1: `7, 49, 97, 130, 10, 1 `\n\nWhile `3` is not, and would give us an infinite sequence: `3, 9, 81, 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, 58, 89, 145, 42, 20, 4, 16, 37, ...`\n\n\nHappy coding!\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef is_happy (n : Nat) : Bool := sorry\n\ndef sum_of_squares_digits (n : Nat) : Nat := sorry\n\ntheorem happy_number_is_bool (n : Nat) : \n  n > 0 → is_happy n = true ∨ is_happy n = false := sorry \n\ntheorem happy_number_squares_property (n : Nat) : \n  n > 0 → is_happy n = true → is_happy (sum_of_squares_digits n) = true := sorry\n\ntheorem happy_number_squares_property_false (n : Nat) :\n  n > 0 → is_happy n = false → is_happy (sum_of_squares_digits n) = false := sorry\n\ntheorem known_happy_numbers :\n  is_happy 1 = true ∧ \n  is_happy 7 = true ∧\n  is_happy 10 = true ∧\n  is_happy 13 = true ∧ \n  is_happy 19 = true ∧\n  is_happy 23 = true ∧\n  is_happy 28 = true ∧\n  is_happy 31 = true := sorry\n\ntheorem happy_number_terminates (n : Nat) :\n  n > 0 → ∃ result, is_happy n = result := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "3992", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nA happy number is a number defined by the following process: starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\nThose numbers for which this process ends in 1 are **happy numbers**, while those that do not end in 1 are unhappy numbers (or sad numbers) (Wikipedia).\n\nWrite a function that takes `n` as parameter and return `true` if and only if `n` is an happy number, `false` otherwise.\n\n\n## Examples\n\nFor example number `7` is happy because after a number of steps the computed sequence ends up with a 1: `7, 49, 97, 130, 10, 1 `\n\nWhile `3` is not, and would give us an infinite sequence: `3, 9, 81, 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, 58, 89, 145, 42, 20, 4, 16, 37, ...`\n\n\nHappy coding!\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef is_happy (n : Nat) : Bool := sorry\n\ndef sum_of_squares_digits (n : Nat) : Nat := sorry\n\ntheorem happy_number_is_bool (n : Nat) : \n  n > 0 → is_happy n = true ∨ is_happy n = false := sorry \n\ntheorem happy_number_squares_property (n : Nat) : \n  n > 0 → is_happy n = true → is_happy (sum_of_squares_digits n) = true := sorry\n\ntheorem happy_number_squares_property_false (n : Nat) :\n  n > 0 → is_happy n = false → is_happy (sum_of_squares_digits n) = false := sorry\n\ntheorem known_happy_numbers :\n  is_happy 1 = true ∧ \n  is_happy 7 = true ∧\n  is_happy 10 = true ∧\n  is_happy 13 = true ∧ \n  is_happy 19 = true ∧\n  is_happy 23 = true ∧\n  is_happy 28 = true ∧\n  is_happy 31 = true := sorry\n\ntheorem happy_number_terminates (n : Nat) :\n  n > 0 → ∃ result, is_happy n = result := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "3992"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a string S.\nYou have to return another string such that even-indexed and odd-indexed characters of S are grouped and groups are space-separated (see sample below)\n\nNote: \n0 is considered to be an even index. \nAll input strings are valid with no spaces\n\n\ninput:\n'CodeWars'\n\noutput\n'CdWr oeas'\n\nS[0] = 'C'\nS[1] = 'o'\nS[2] = 'd'\nS[3] = 'e'\nS[4] = 'W'\nS[5] = 'a'\nS[6] = 'r'\nS[7] = 's'\n\n\nEven indices 0, 2, 4, 6, so we have 'CdWr' as the first group\nodd ones are 1, 3, 5, 7, so the second group is 'oeas'\nAnd the final string to return is 'Cdwr oeas'\n\nEnjoy.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sort_my_string (s : String) : String := sorry\n\ntheorem sort_my_string_preserves_length (s : String) (h : s.length > 0) :\n  let result := sort_my_string s\n  let result_no_spaces := result.replace \" \" \"\"\n  result_no_spaces.length = s.length := sorry\n\ntheorem sort_my_string_splits_even_indexed (s : String) (h : s.length > 0) :\n  let result := sort_my_string s\n  let parts := result.split (fun x => decide (x = ' '))\n  parts.length > 0 → \n  (parts.get? 0).isSome := sorry\n\ntheorem sort_my_string_splits_odd_indexed (s : String) (h : s.length > 1) :\n  let result := sort_my_string s\n  let parts := result.split (fun x => decide (x = ' '))\n  parts.length > 1 → \n  (parts.get? 1).isSome := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4041", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a string S.\nYou have to return another string such that even-indexed and odd-indexed characters of S are grouped and groups are space-separated (see sample below)\n\nNote: \n0 is considered to be an even index. \nAll input strings are valid with no spaces\n\n\ninput:\n'CodeWars'\n\noutput\n'CdWr oeas'\n\nS[0] = 'C'\nS[1] = 'o'\nS[2] = 'd'\nS[3] = 'e'\nS[4] = 'W'\nS[5] = 'a'\nS[6] = 'r'\nS[7] = 's'\n\n\nEven indices 0, 2, 4, 6, so we have 'CdWr' as the first group\nodd ones are 1, 3, 5, 7, so the second group is 'oeas'\nAnd the final string to return is 'Cdwr oeas'\n\nEnjoy.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sort_my_string (s : String) : String := sorry\n\ntheorem sort_my_string_preserves_length (s : String) (h : s.length > 0) :\n  let result := sort_my_string s\n  let result_no_spaces := result.replace \" \" \"\"\n  result_no_spaces.length = s.length := sorry\n\ntheorem sort_my_string_splits_even_indexed (s : String) (h : s.length > 0) :\n  let result := sort_my_string s\n  let parts := result.split (fun x => decide (x = ' '))\n  parts.length > 0 → \n  (parts.get? 0).isSome := sorry\n\ntheorem sort_my_string_splits_odd_indexed (s : String) (h : s.length > 1) :\n  let result := sort_my_string s\n  let parts := result.split (fun x => decide (x = ' '))\n  parts.length > 1 → \n  (parts.get? 1).isSome := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4041"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThis challenge is based on [the kata](https://www.codewars.com/kata/n-smallest-elements-in-original-order) by GiacomoSorbi. Before doing this one it is advisable to complete the non-performance version first.\n\n___\n\n# Task\n\nYou will be given an array of random integers and a number `n`. You have to extract `n` smallest integers out of it **preserving the original order**.\n\n# Examples\n\n```python\nperformant_smallest([1, 2, 3, 4, 5], 3)     ==   [1, 2, 3]\nperformant_smallest([5, 4, 3, 2, 1], 3)     ==   [3, 2, 1]\nperformant_smallest([1, 2, 3, 4, 1], 3)     ==   [1, 2, 1]\nperformant_smallest([2, 1, 3, 2, 3], 3)     ==   [2, 1, 2]\n```\n\n# Notes\n\n* There will be duplicates in the array, and they have to be returned in the order of their each separate appearence.\n* This kata is an example of the \"know your data\" principle. Remember this while searching for the correct approach.\n\n# Performance tests\n\n```python\nTests: 15\nArray size: 800,000\nValues range: [1; 50]\nNumber of elements to return: 25-50% of the array\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef performant_smallest (arr : List Int) (n : Nat) : List Int :=\n  sorry\n\ntheorem performant_smallest_length_eq_n {arr : List Int} {n : Nat} \n  (h : 0 < arr.length) (h2 : n ≤ arr.length) :\n  (performant_smallest arr n).length = n :=\nsorry\n\ntheorem performant_smallest_elements_from_arr {arr : List Int} {n : Nat} \n  (h : 0 < arr.length) (h2 : n ≤ arr.length) :\n  ∀ x, x ∈ performant_smallest arr n → x ∈ arr :=\nsorry\n\n\n\ntheorem performant_smallest_full_list {arr : List Int} (h : 0 < arr.length) :\n  performant_smallest arr arr.length = arr :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4083", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThis challenge is based on [the kata](https://www.codewars.com/kata/n-smallest-elements-in-original-order) by GiacomoSorbi. Before doing this one it is advisable to complete the non-performance version first.\n\n___\n\n# Task\n\nYou will be given an array of random integers and a number `n`. You have to extract `n` smallest integers out of it **preserving the original order**.\n\n# Examples\n\n```python\nperformant_smallest([1, 2, 3, 4, 5], 3)     ==   [1, 2, 3]\nperformant_smallest([5, 4, 3, 2, 1], 3)     ==   [3, 2, 1]\nperformant_smallest([1, 2, 3, 4, 1], 3)     ==   [1, 2, 1]\nperformant_smallest([2, 1, 3, 2, 3], 3)     ==   [2, 1, 2]\n```\n\n# Notes\n\n* There will be duplicates in the array, and they have to be returned in the order of their each separate appearence.\n* This kata is an example of the \"know your data\" principle. Remember this while searching for the correct approach.\n\n# Performance tests\n\n```python\nTests: 15\nArray size: 800,000\nValues range: [1; 50]\nNumber of elements to return: 25-50% of the array\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef performant_smallest (arr : List Int) (n : Nat) : List Int :=\n  sorry\n\ntheorem performant_smallest_length_eq_n {arr : List Int} {n : Nat} \n  (h : 0 < arr.length) (h2 : n ≤ arr.length) :\n  (performant_smallest arr n).length = n :=\nsorry\n\ntheorem performant_smallest_elements_from_arr {arr : List Int} {n : Nat} \n  (h : 0 < arr.length) (h2 : n ≤ arr.length) :\n  ∀ x, x ∈ performant_smallest arr n → x ∈ arr :=\nsorry\n\n\n\ntheorem performant_smallest_full_list {arr : List Int} (h : 0 < arr.length) :\n  performant_smallest arr arr.length = arr :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4083"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nOne of the first chain emails I ever received was about a supposed Cambridge  University study that suggests your brain can read words no matter what order the letters are in, as long as the first and last letters of each word are correct.\n\nYour task is to **create a function that can take any string and randomly jumble the letters within each word while leaving the first and last letters of the word in place.**\n\nFor example,\n    \n    mixwords('Winter is coming') // returns 'Wntier is cminog' or 'Wtiner is conimg'\n    mixwords('Hey, friends!') // returns 'Hey, fierdns!' or 'Hey, fernids!'\n\n* All punctuation should remain in place\n* Words smaller than 3 letters should not change\n* Letters must be randomly moved (and so calling the function multiple times with the same string should return different values\n* Parameters that are not strings should return undefined\n\nThe tests do the following things to ensure a valid string is returned:\n    \n1. Check that the string returned is not equal to the string passed (you may have to revalidate the solution if your function randomly returns the same string)\n2. Check that first and last letters of words remain in place\n3. Check that punctuation remains in place\n4. Checks string length remains the same\n5. Checks the function returns `undefined` for non-strings\n6. Checks that word interiors (the letters between the first and last) maintain the same letters, albeit in a different order\n7. Checks that letters are randomly assigned.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef mix_words (s : String) : Option String := sorry\n\ndef is_properly_scrambled (original scrambled : String) : Bool := sorry\n\ntheorem output_length_matches_input (s : String) :\n  ∀ res, mix_words s = some res → res.length = s.length := sorry\n\ntheorem non_letter_strings_unchanged (s : String) :\n  (∀ c ∈ s.data, !c.isAlpha) → mix_words s = some s := sorry\n\ntheorem word_boundaries_preserved (s : String) (res : String) :\n  s.length ≥ 4 → \n  mix_words s = some res →\n  res.front = s.front ∧ \n  res.back = s.back := sorry\n\ntheorem preserve_chars (s : String) (res : String) :\n  mix_words s = some res →\n  s.data.toArray = res.data.toArray := sorry\n\ntheorem words_properly_scrambled (words : List String) (text : String) (res : String) :\n  words ≠ [] →\n  (∀ w ∈ words, w ≠ \"\") →\n  text = String.intercalate \" \" words →\n  mix_words text = some res →\n  let result_words := res.split (· = ' ')\n  words.length = result_words.length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4085", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nOne of the first chain emails I ever received was about a supposed Cambridge  University study that suggests your brain can read words no matter what order the letters are in, as long as the first and last letters of each word are correct.\n\nYour task is to **create a function that can take any string and randomly jumble the letters within each word while leaving the first and last letters of the word in place.**\n\nFor example,\n    \n    mixwords('Winter is coming') // returns 'Wntier is cminog' or 'Wtiner is conimg'\n    mixwords('Hey, friends!') // returns 'Hey, fierdns!' or 'Hey, fernids!'\n\n* All punctuation should remain in place\n* Words smaller than 3 letters should not change\n* Letters must be randomly moved (and so calling the function multiple times with the same string should return different values\n* Parameters that are not strings should return undefined\n\nThe tests do the following things to ensure a valid string is returned:\n    \n1. Check that the string returned is not equal to the string passed (you may have to revalidate the solution if your function randomly returns the same string)\n2. Check that first and last letters of words remain in place\n3. Check that punctuation remains in place\n4. Checks string length remains the same\n5. Checks the function returns `undefined` for non-strings\n6. Checks that word interiors (the letters between the first and last) maintain the same letters, albeit in a different order\n7. Checks that letters are randomly assigned.\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef mix_words (s : String) : Option String := sorry\n\ndef is_properly_scrambled (original scrambled : String) : Bool := sorry\n\ntheorem output_length_matches_input (s : String) :\n  ∀ res, mix_words s = some res → res.length = s.length := sorry\n\ntheorem non_letter_strings_unchanged (s : String) :\n  (∀ c ∈ s.data, !c.isAlpha) → mix_words s = some s := sorry\n\ntheorem word_boundaries_preserved (s : String) (res : String) :\n  s.length ≥ 4 → \n  mix_words s = some res →\n  res.front = s.front ∧ \n  res.back = s.back := sorry\n\ntheorem preserve_chars (s : String) (res : String) :\n  mix_words s = some res →\n  s.data.toArray = res.data.toArray := sorry\n\ntheorem words_properly_scrambled (words : List String) (text : String) (res : String) :\n  words ≠ [] →\n  (∀ w ∈ words, w ≠ \"\") →\n  text = String.intercalate \" \" words →\n  mix_words text = some res →\n  let result_words := res.split (· = ' ')\n  words.length = result_words.length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4085"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWe have the first value of a certain sequence, we will name it ```initVal```.\nWe define  pattern list, ```patternL```, an array that has the differences between contiguous terms of the sequence.\n``` E.g: patternL = [k1, k2, k3, k4]``` \n\nThe terms of the sequence will be such values that:\n```python\nterm1 = initVal\nterm2 - term1 = k1\nterm3 - term2 = k2\nterm4 - term3 = k3\nterm5 - term4 = k4\nterm6 - term5 = k1\nterm7 - term6 = k2\nterm8 - term7 = k3\nterm9 - term8 = k4\n....  - ..... = ...\n....  - ..... = ...\n ``` \nSo the values of the differences between contiguous terms are cyclical and are  repeated as the differences values of the pattern list stablishes.\n\nLet's see an example with numbers:\n```python\ninitVal = 10\npatternL = [2, 1, 3]\nterm1 = 10\nterm2 = 12\nterm3 = 13\nterm4 = 16\nterm5 = 18\nterm6 = 19\nterm7 = 22  # and so on...\n```\nWe can easily obtain the next terms of the sequence following the values in the pattern list.\nWe see that the sixth term of the sequence, ```19```, has the sum of its digits ```10```.\n\nMake a function ```sumDig_nthTerm()```, that receives three arguments in this order \n\n ```sumDig_nthTerm(initVal, patternL, nthTerm(ordinal number of the term in the sequence)) ```\n\nThis function will output the sum of the digits of the n-th term of the sequence.\n\nLet's see some cases for this function:\n```python\nsumDig_nthTerm(10, [2, 1, 3], 6) -----> 10 # because the sixth term is 19 sum of Dig = 1 + 9 = 10. The sequence up to the sixth-Term is: 10, 12, 13, 16, 18, 19\n\nsumDig_nthTerm(10, [1, 2, 3], 15) ----> 10 # 37 is the 15-th term, and 3 + 7 = 10\n```\nEnjoy it and happy coding!!\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sumDig_nthTerm (initVal : Nat) (patternL : List Nat) (nthTerm : Nat) : Nat := sorry\n\ndef numDigits (n : Nat) : Nat := \n  if n < 10 then 1\n  else 1 + numDigits (n / 10)\n\ndef listSum : List Nat → Nat \n  | [] => 0\n  | (h::t) => h + listSum t\n\ntheorem sumDig_nthTerm_bounds {initVal : Nat} {patternL : List Nat} {nthTerm : Nat}\n  (h1 : initVal ≤ 50)\n  (h2 : ∀ x ∈ patternL, x ≤ 5)\n  (h3 : 1 ≤ patternL.length) \n  (h4 : patternL.length ≤ 3)\n  (h5 : 2 ≤ nthTerm)\n  (h6 : nthTerm ≤ 10) :\n  0 ≤ sumDig_nthTerm initVal patternL nthTerm ∧ \n  sumDig_nthTerm initVal patternL nthTerm ≤ 9 * numDigits (initVal + (listSum patternL * nthTerm)) := sorry\n\ntheorem sumDig_nthTerm_deterministic {initVal : Nat} {patternL : List Nat} {nthTerm : Nat} :\n  sumDig_nthTerm initVal patternL nthTerm = sumDig_nthTerm initVal patternL nthTerm := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4105", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWe have the first value of a certain sequence, we will name it ```initVal```.\nWe define  pattern list, ```patternL```, an array that has the differences between contiguous terms of the sequence.\n``` E.g: patternL = [k1, k2, k3, k4]``` \n\nThe terms of the sequence will be such values that:\n```python\nterm1 = initVal\nterm2 - term1 = k1\nterm3 - term2 = k2\nterm4 - term3 = k3\nterm5 - term4 = k4\nterm6 - term5 = k1\nterm7 - term6 = k2\nterm8 - term7 = k3\nterm9 - term8 = k4\n....  - ..... = ...\n....  - ..... = ...\n ``` \nSo the values of the differences between contiguous terms are cyclical and are  repeated as the differences values of the pattern list stablishes.\n\nLet's see an example with numbers:\n```python\ninitVal = 10\npatternL = [2, 1, 3]\nterm1 = 10\nterm2 = 12\nterm3 = 13\nterm4 = 16\nterm5 = 18\nterm6 = 19\nterm7 = 22  # and so on...\n```\nWe can easily obtain the next terms of the sequence following the values in the pattern list.\nWe see that the sixth term of the sequence, ```19```, has the sum of its digits ```10```.\n\nMake a function ```sumDig_nthTerm()```, that receives three arguments in this order \n\n ```sumDig_nthTerm(initVal, patternL, nthTerm(ordinal number of the term in the sequence)) ```\n\nThis function will output the sum of the digits of the n-th term of the sequence.\n\nLet's see some cases for this function:\n```python\nsumDig_nthTerm(10, [2, 1, 3], 6) -----> 10 # because the sixth term is 19 sum of Dig = 1 + 9 = 10. The sequence up to the sixth-Term is: 10, 12, 13, 16, 18, 19\n\nsumDig_nthTerm(10, [1, 2, 3], 15) ----> 10 # 37 is the 15-th term, and 3 + 7 = 10\n```\nEnjoy it and happy coding!!\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sumDig_nthTerm (initVal : Nat) (patternL : List Nat) (nthTerm : Nat) : Nat := sorry\n\ndef numDigits (n : Nat) : Nat := \n  if n < 10 then 1\n  else 1 + numDigits (n / 10)\n\ndef listSum : List Nat → Nat \n  | [] => 0\n  | (h::t) => h + listSum t\n\ntheorem sumDig_nthTerm_bounds {initVal : Nat} {patternL : List Nat} {nthTerm : Nat}\n  (h1 : initVal ≤ 50)\n  (h2 : ∀ x ∈ patternL, x ≤ 5)\n  (h3 : 1 ≤ patternL.length) \n  (h4 : patternL.length ≤ 3)\n  (h5 : 2 ≤ nthTerm)\n  (h6 : nthTerm ≤ 10) :\n  0 ≤ sumDig_nthTerm initVal patternL nthTerm ∧ \n  sumDig_nthTerm initVal patternL nthTerm ≤ 9 * numDigits (initVal + (listSum patternL * nthTerm)) := sorry\n\ntheorem sumDig_nthTerm_deterministic {initVal : Nat} {patternL : List Nat} {nthTerm : Nat} :\n  sumDig_nthTerm initVal patternL nthTerm = sumDig_nthTerm initVal patternL nthTerm := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4105"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou're fed up about changing the version of your software manually. Instead, you will create a little script that will make it for you.\n\n# Exercice\n\nCreate a function `nextVersion`, that will take a string in parameter, and will return a string containing the next version number.\n\nFor example:\n\n# Rules\n\nAll numbers, except the first one, must be lower than 10: if there are, you have to set them to 0 and increment the next number in sequence.\n\nYou can assume all tests inputs to be valid.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Version where\n  nums : List Nat\n\ndef splitVersion (v : String) : Version := sorry\ndef joinVersion (v : Version) : String := sorry\ndef nextVersion (v : String) : String := sorry\n\ntheorem nextVersion_outputs_valid_version (v : String) \n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8) :\n  ∀ n ∈ (splitVersion (nextVersion v)).nums, n ≥ 0 := sorry\n\ntheorem nextVersion_preserves_length (v : String)\n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8) :\n  (splitVersion (nextVersion v)).nums.length = (splitVersion v).nums.length := sorry\n\ntheorem nextVersion_preserves_prefix_parts (v : String)\n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8)\n    (h2 : (splitVersion v).nums ≠ [])\n    (h3 : ((splitVersion v).nums.getLast h2) < 9) : \n  (splitVersion (nextVersion v)).nums.dropLast = (splitVersion v).nums.dropLast ∧ \n  ((splitVersion (nextVersion v)).nums.getLast h2 = (splitVersion v).nums.getLast h2 + 1) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4194", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou're fed up about changing the version of your software manually. Instead, you will create a little script that will make it for you.\n\n# Exercice\n\nCreate a function `nextVersion`, that will take a string in parameter, and will return a string containing the next version number.\n\nFor example:\n\n# Rules\n\nAll numbers, except the first one, must be lower than 10: if there are, you have to set them to 0 and increment the next number in sequence.\n\nYou can assume all tests inputs to be valid.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Version where\n  nums : List Nat\n\ndef splitVersion (v : String) : Version := sorry\ndef joinVersion (v : Version) : String := sorry\ndef nextVersion (v : String) : String := sorry\n\ntheorem nextVersion_outputs_valid_version (v : String) \n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8) :\n  ∀ n ∈ (splitVersion (nextVersion v)).nums, n ≥ 0 := sorry\n\ntheorem nextVersion_preserves_length (v : String)\n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8) :\n  (splitVersion (nextVersion v)).nums.length = (splitVersion v).nums.length := sorry\n\ntheorem nextVersion_preserves_prefix_parts (v : String)\n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8)\n    (h2 : (splitVersion v).nums ≠ [])\n    (h3 : ((splitVersion v).nums.getLast h2) < 9) : \n  (splitVersion (nextVersion v)).nums.dropLast = (splitVersion v).nums.dropLast ∧ \n  ((splitVersion (nextVersion v)).nums.getLast h2 = (splitVersion v).nums.getLast h2 + 1) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4194"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou get a \"text\" and have to shift the vowels by \"n\" positions to the right.\n(Negative value for n should shift to the left.)\n\"Position\" means the vowel's position if taken as one item in a list of all vowels within the string.\nA shift by 1 would mean, that every vowel shifts to the place of the next vowel.\nShifting over the edges of the text should continue at the other edge.\n\nExample:\n\ntext = \"This is a test!\"\nn = 1\noutput = \"Thes is i tast!\"\n\ntext = \"This is a test!\"\nn = 3\noutput = \"This as e tist!\"\n\nIf text is null or empty return exactly this value.\nVowels are \"a,e,i,o,u\".\n\n\n\nHave fun coding it and please don't forget to vote and rank this kata! :-)\n\nI have created other katas. Have a look if you like coding and challenges.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n-- Function signature with placeholders\ndef vowel_shift (s : Option String) (n : Int) : Option String := sorry\n\ntheorem empty_cases (n : Int) : \n  vowel_shift none n = none ∧ \n  vowel_shift (some \"\") n = some \"\" := sorry\n\ntheorem zero_shift (s : String) :\n  vowel_shift (some s) 0 = some s := sorry\n\ntheorem full_rotation {s : String} (h : s ≠ \"\") :\n  let vowel_count := (s.data.filter (fun c => ['a', 'e', 'i', 'o', 'u'].contains c.toLower)).length\n  vowel_count > 0 → \n  vowel_shift (some s) vowel_count = some s := sorry\n\ntheorem shift_composition {s : String} (h : s ≠ \"\") (n1 n2 : Int) \n  (h1 : n1 ≥ -100) (h2 : n1 ≤ 100) (h3 : n2 ≥ -100) (h4 : n2 ≤ 100) :\n  match vowel_shift (some s) n1 with\n  | none => True\n  | some s1 => \n    match vowel_shift (some s1) n2 with\n    | none => True\n    | some s2 => s2 = (vowel_shift (some s) (n1 + n2)).get!\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4200", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou get a \"text\" and have to shift the vowels by \"n\" positions to the right.\n(Negative value for n should shift to the left.)\n\"Position\" means the vowel's position if taken as one item in a list of all vowels within the string.\nA shift by 1 would mean, that every vowel shifts to the place of the next vowel.\nShifting over the edges of the text should continue at the other edge.\n\nExample:\n\ntext = \"This is a test!\"\nn = 1\noutput = \"Thes is i tast!\"\n\ntext = \"This is a test!\"\nn = 3\noutput = \"This as e tist!\"\n\nIf text is null or empty return exactly this value.\nVowels are \"a,e,i,o,u\".\n\n\n\nHave fun coding it and please don't forget to vote and rank this kata! :-)\n\nI have created other katas. Have a look if you like coding and challenges.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\n-- Function signature with placeholders\ndef vowel_shift (s : Option String) (n : Int) : Option String := sorry\n\ntheorem empty_cases (n : Int) : \n  vowel_shift none n = none ∧ \n  vowel_shift (some \"\") n = some \"\" := sorry\n\ntheorem zero_shift (s : String) :\n  vowel_shift (some s) 0 = some s := sorry\n\ntheorem full_rotation {s : String} (h : s ≠ \"\") :\n  let vowel_count := (s.data.filter (fun c => ['a', 'e', 'i', 'o', 'u'].contains c.toLower)).length\n  vowel_count > 0 → \n  vowel_shift (some s) vowel_count = some s := sorry\n\ntheorem shift_composition {s : String} (h : s ≠ \"\") (n1 n2 : Int) \n  (h1 : n1 ≥ -100) (h2 : n1 ≤ 100) (h3 : n2 ≥ -100) (h4 : n2 ≤ 100) :\n  match vowel_shift (some s) n1 with\n  | none => True\n  | some s1 => \n    match vowel_shift (some s1) n2 with\n    | none => True\n    | some s2 => s2 = (vowel_shift (some s) (n1 + n2)).get!\n  := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4200"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nFrom Wikipedia : \"The n-back task is a continuous performance task that is commonly used as an assessment in cognitive neuroscience to measure a part of working memory and working memory capacity. [...] The subject is presented with a sequence of stimuli, and the task consists of indicating when the current stimulus matches the one from n steps earlier in the sequence. The load factor n can be adjusted to make the task more or less difficult.\"\n\nIn this kata, your task is to \"teach\" your computer to do the n-back task. Specifically, you will be implementing a function that counts the number of \"targets\" (stimuli that match the one from n steps earlier) in a sequence of digits. Your function will take two parameters :\n\nn, a positive integer equal to the number of steps to look back to find a match\nsequence, a sequence of digits containing 0 or more targets\n\nA few hints :\n\nThe first digit in a sequence can never be a target\nTargets can be \"chained\" together (e.g., for n = 1 and sequence = [1, 1, 1], there are 2 targets)\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_targets (n : Nat) (lst : List Int) : Nat := sorry\n\ntheorem count_targets_non_negative (n : Nat) (lst : List Int) : \n  count_targets n lst ≥ 0 := sorry \n\ntheorem count_targets_upper_bound (n : Nat) (lst : List Int) :\n  count_targets n lst ≤ max 0 (lst.length - n) := sorry\n\ntheorem count_targets_empty_list (n : Nat) :\n  count_targets n [] = 0 := sorry\n\ntheorem count_targets_n_geq_length (n : Nat) (lst : List Int) :\n  n ≥ lst.length → count_targets n lst = 0 := sorry \n\ntheorem count_targets_shift_zero (lst : List Int) :\n  count_targets 0 lst = lst.length := sorry\n\ntheorem count_targets_shift_one (lst : List Int) :\n  lst ≠ [] →\n  count_targets 1 lst = \n    ((lst.zip (lst.drop 1)).filter (fun p => p.1 = p.2)).length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4221", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nFrom Wikipedia : \"The n-back task is a continuous performance task that is commonly used as an assessment in cognitive neuroscience to measure a part of working memory and working memory capacity. [...] The subject is presented with a sequence of stimuli, and the task consists of indicating when the current stimulus matches the one from n steps earlier in the sequence. The load factor n can be adjusted to make the task more or less difficult.\"\n\nIn this kata, your task is to \"teach\" your computer to do the n-back task. Specifically, you will be implementing a function that counts the number of \"targets\" (stimuli that match the one from n steps earlier) in a sequence of digits. Your function will take two parameters :\n\nn, a positive integer equal to the number of steps to look back to find a match\nsequence, a sequence of digits containing 0 or more targets\n\nA few hints :\n\nThe first digit in a sequence can never be a target\nTargets can be \"chained\" together (e.g., for n = 1 and sequence = [1, 1, 1], there are 2 targets)\n```\n#####\n\nTo answer this question, you need to replace the 7 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_targets (n : Nat) (lst : List Int) : Nat := sorry\n\ntheorem count_targets_non_negative (n : Nat) (lst : List Int) : \n  count_targets n lst ≥ 0 := sorry \n\ntheorem count_targets_upper_bound (n : Nat) (lst : List Int) :\n  count_targets n lst ≤ max 0 (lst.length - n) := sorry\n\ntheorem count_targets_empty_list (n : Nat) :\n  count_targets n [] = 0 := sorry\n\ntheorem count_targets_n_geq_length (n : Nat) (lst : List Int) :\n  n ≥ lst.length → count_targets n lst = 0 := sorry \n\ntheorem count_targets_shift_zero (lst : List Int) :\n  count_targets 0 lst = lst.length := sorry\n\ntheorem count_targets_shift_one (lst : List Int) :\n  lst ≠ [] →\n  count_targets 1 lst = \n    ((lst.zip (lst.drop 1)).filter (fun p => p.1 = p.2)).length := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4221"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given two positive integers ```a``` and ```b```.\n\nYou can perform the following operations on ```a``` so as to obtain ```b``` :\n```\n(a-1)/2   (if (a-1) is divisible by 2)\na/2       (if a is divisible by 2)\na*2\n```\n```b``` will always be a power of 2.\n\nYou are to write a function ```operation(a,b)``` that efficiently returns the minimum number of operations required to transform ```a``` into ```b```.\n\nFor example :\n```\noperation(2,8) -> 2\n2*2 = 4\n4*2 = 8\n\noperation(9,2) -> 2\n(9-1)/2 = 4\n4/2 = 2\n\noperation(1024,1024) -> 0\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef operation (a b : Nat) : Nat := sorry\n\ndef isPowerOf2 (n : Nat) : Bool := sorry\n\n-- Operations are symmetric between powers of 2\ntheorem operation_symmetry (a b : Nat) :\n  a ≠ 0 → b ≠ 0 → isPowerOf2 a → isPowerOf2 b → \n  operation a b = operation b a := sorry\n\n-- Number of operations is non-negative\ntheorem operation_positive (n target : Nat) : \n  n ≠ 0 → operation n target ≥ 0 := sorry\n\n-- Triangle inequality through power of 2\ntheorem operation_triangle_inequality (a b power2 : Nat) :\n  a ≠ 0 → b ≠ 0 → isPowerOf2 power2 →\n  operation a b ≤ operation a power2 + operation power2 b := sorry\n\n-- Self operation vs through power of 2\ntheorem operation_with_self (n pow2 : Nat) :\n  n ≠ 0 → isPowerOf2 pow2 →\n  operation n n ≤ 2 * operation n pow2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4264", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou are given two positive integers ```a``` and ```b```.\n\nYou can perform the following operations on ```a``` so as to obtain ```b``` :\n```\n(a-1)/2   (if (a-1) is divisible by 2)\na/2       (if a is divisible by 2)\na*2\n```\n```b``` will always be a power of 2.\n\nYou are to write a function ```operation(a,b)``` that efficiently returns the minimum number of operations required to transform ```a``` into ```b```.\n\nFor example :\n```\noperation(2,8) -> 2\n2*2 = 4\n4*2 = 8\n\noperation(9,2) -> 2\n(9-1)/2 = 4\n4/2 = 2\n\noperation(1024,1024) -> 0\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef operation (a b : Nat) : Nat := sorry\n\ndef isPowerOf2 (n : Nat) : Bool := sorry\n\n-- Operations are symmetric between powers of 2\ntheorem operation_symmetry (a b : Nat) :\n  a ≠ 0 → b ≠ 0 → isPowerOf2 a → isPowerOf2 b → \n  operation a b = operation b a := sorry\n\n-- Number of operations is non-negative\ntheorem operation_positive (n target : Nat) : \n  n ≠ 0 → operation n target ≥ 0 := sorry\n\n-- Triangle inequality through power of 2\ntheorem operation_triangle_inequality (a b power2 : Nat) :\n  a ≠ 0 → b ≠ 0 → isPowerOf2 power2 →\n  operation a b ≤ operation a power2 + operation power2 b := sorry\n\n-- Self operation vs through power of 2\ntheorem operation_with_self (n pow2 : Nat) :\n  n ≠ 0 → isPowerOf2 pow2 →\n  operation n n ≤ 2 * operation n pow2 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4264"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYour company, [Congo Pizza](http://interesting-africa-facts.com/Africa-Landforms/Congo-Rainforest-Facts.html), is the second-largest online frozen pizza retailer. You own a number of international warehouses that you use to store your frozen pizzas, and you need to figure out how many crates of pizzas you can store at each location.\n\nCongo recently standardized its storage containers: all pizzas fit inside a *cubic crate, 16-inchs on a side*. The crates are super tough so you can stack them as high as you want.\n\nWrite a function `box_capacity()` that figures out how many crates you can store in a given warehouse. The function should take three arguments: the length, width, and height of your warehouse (in feet) and should return an integer representing the number of boxes you can store in that space.\n\nFor example: a warehouse 32 feet long, 64 feet wide, and 16 feet high can hold 13,824 boxes because you can fit 24 boxes across, 48 boxes deep, and 12 boxes high, so `box_capacity(32, 64, 16)` should return `13824`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef box_capacity (length width height : Nat) : Nat := sorry\n\ntheorem box_capacity_nonneg (l w h : Nat) :\n  box_capacity l w h ≥ 0 := sorry\n\ntheorem box_capacity_monotonic_length (l w h : Nat) :\n  box_capacity (l + 1) w h ≥ box_capacity l w h := sorry\n\ntheorem box_capacity_monotonic_width (l w h : Nat) :\n  box_capacity l (w + 1) h ≥ box_capacity l w h := sorry\n\ntheorem box_capacity_monotonic_height (l w h : Nat) :\n  box_capacity l w (h + 1) ≥ box_capacity l w h := sorry\n\ntheorem box_capacity_small_dim (w h : Nat) :\n  box_capacity 1 w h = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4313", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYour company, [Congo Pizza](http://interesting-africa-facts.com/Africa-Landforms/Congo-Rainforest-Facts.html), is the second-largest online frozen pizza retailer. You own a number of international warehouses that you use to store your frozen pizzas, and you need to figure out how many crates of pizzas you can store at each location.\n\nCongo recently standardized its storage containers: all pizzas fit inside a *cubic crate, 16-inchs on a side*. The crates are super tough so you can stack them as high as you want.\n\nWrite a function `box_capacity()` that figures out how many crates you can store in a given warehouse. The function should take three arguments: the length, width, and height of your warehouse (in feet) and should return an integer representing the number of boxes you can store in that space.\n\nFor example: a warehouse 32 feet long, 64 feet wide, and 16 feet high can hold 13,824 boxes because you can fit 24 boxes across, 48 boxes deep, and 12 boxes high, so `box_capacity(32, 64, 16)` should return `13824`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef box_capacity (length width height : Nat) : Nat := sorry\n\ntheorem box_capacity_nonneg (l w h : Nat) :\n  box_capacity l w h ≥ 0 := sorry\n\ntheorem box_capacity_monotonic_length (l w h : Nat) :\n  box_capacity (l + 1) w h ≥ box_capacity l w h := sorry\n\ntheorem box_capacity_monotonic_width (l w h : Nat) :\n  box_capacity l (w + 1) h ≥ box_capacity l w h := sorry\n\ntheorem box_capacity_monotonic_height (l w h : Nat) :\n  box_capacity l w (h + 1) ≥ box_capacity l w h := sorry\n\ntheorem box_capacity_small_dim (w h : Nat) :\n  box_capacity 1 w h = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4313"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nDo you have in mind the good old TicTacToe?\n\nAssuming that you get all the data in one array, you put a space around each value, `|` as a columns separator and multiple `-` as rows separator, with something like `[\"O\", \"X\", \" \", \" \", \"X\", \" \", \"X\", \"O\", \" \"]` you should be returning this structure (inclusive of new lines):\n\n```\n O | X |   \n-----------\n   | X |   \n-----------\n X | O |   \n```\n\nNow, to spice up things a bit, we are going to expand our board well beyond a trivial `3` x `3` square and we will accept rectangles of big sizes, still all as a long linear array.\n\nFor example, for `\"O\", \"X\", \" \", \" \", \"X\", \" \", \"X\", \"O\", \" \", \"O\"]` (same as above, just one extra `\"O\"`) and knowing that the length of each row is `5`, you will be returning\n\n```\n O | X |   |   | X \n-------------------\n   | X | O |   | O \n```\n\nAnd worry not about missing elements, as the array/list/vector length is always going to be a multiple of the width.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef display_board (board : List String) (width : Nat) : String := sorry\n\ndef getEvenElements (xs : List α) : List α :=\n  xs.enum.filter (fun (i, _) => i % 2 = 0) |>.map Prod.snd\n\ndef getOddElements (xs : List α) : List α :=\n  xs.enum.filter (fun (i, _) => i % 2 = 1) |>.map Prod.snd\n\ntheorem display_board_properties {board : List String} {width : Nat} \n  (h1 : ∀ x, x ∈ board → (x = \"X\" ∨ x = \"O\" ∨ x = \" \"))\n  (h2 : 0 < width)\n  (h3 : width ≤ 10) \n  (h4 : board.length % width = 0) :\n  let result := display_board board width\n  let lines := result.splitOn \"\\n\"\n  let content_lines := getEvenElements lines\n  ∃ line_length : Nat,\n    -- All content lines have same width\n    (∀ l ∈ content_lines, l.length = line_length) ∧\n    -- Correct number of separators between cells \n    (∀ l ∈ content_lines, (l.toList.filter (· = '|')).length = width - 1) ∧\n    -- Each cell is at most 3 chars wide\n    (∀ l ∈ content_lines, ∀ cell ∈ (l.splitOn \"|\").map String.trim, cell.length ≤ 3) ∧\n    -- Separator lines are correct length\n    (lines.length > 1 → \n      ∀ l ∈ getOddElements lines, l = String.mk (List.replicate (4*width - 1) '-')) := sorry\n\ntheorem width_one_no_pipes {board : List String}\n  (h1 : ∀ x, x ∈ board → (x = \"X\" ∨ x = \"O\" ∨ x = \" \"))\n  (h2 : 0 < board.length) :\n  ¬(display_board board 1).contains '|' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4324", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nDo you have in mind the good old TicTacToe?\n\nAssuming that you get all the data in one array, you put a space around each value, `|` as a columns separator and multiple `-` as rows separator, with something like `[\"O\", \"X\", \" \", \" \", \"X\", \" \", \"X\", \"O\", \" \"]` you should be returning this structure (inclusive of new lines):\n\n```\n O | X |   \n-----------\n   | X |   \n-----------\n X | O |   \n```\n\nNow, to spice up things a bit, we are going to expand our board well beyond a trivial `3` x `3` square and we will accept rectangles of big sizes, still all as a long linear array.\n\nFor example, for `\"O\", \"X\", \" \", \" \", \"X\", \" \", \"X\", \"O\", \" \", \"O\"]` (same as above, just one extra `\"O\"`) and knowing that the length of each row is `5`, you will be returning\n\n```\n O | X |   |   | X \n-------------------\n   | X | O |   | O \n```\n\nAnd worry not about missing elements, as the array/list/vector length is always going to be a multiple of the width.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef display_board (board : List String) (width : Nat) : String := sorry\n\ndef getEvenElements (xs : List α) : List α :=\n  xs.enum.filter (fun (i, _) => i % 2 = 0) |>.map Prod.snd\n\ndef getOddElements (xs : List α) : List α :=\n  xs.enum.filter (fun (i, _) => i % 2 = 1) |>.map Prod.snd\n\ntheorem display_board_properties {board : List String} {width : Nat} \n  (h1 : ∀ x, x ∈ board → (x = \"X\" ∨ x = \"O\" ∨ x = \" \"))\n  (h2 : 0 < width)\n  (h3 : width ≤ 10) \n  (h4 : board.length % width = 0) :\n  let result := display_board board width\n  let lines := result.splitOn \"\\n\"\n  let content_lines := getEvenElements lines\n  ∃ line_length : Nat,\n    -- All content lines have same width\n    (∀ l ∈ content_lines, l.length = line_length) ∧\n    -- Correct number of separators between cells \n    (∀ l ∈ content_lines, (l.toList.filter (· = '|')).length = width - 1) ∧\n    -- Each cell is at most 3 chars wide\n    (∀ l ∈ content_lines, ∀ cell ∈ (l.splitOn \"|\").map String.trim, cell.length ≤ 3) ∧\n    -- Separator lines are correct length\n    (lines.length > 1 → \n      ∀ l ∈ getOddElements lines, l = String.mk (List.replicate (4*width - 1) '-')) := sorry\n\ntheorem width_one_no_pipes {board : List String}\n  (h1 : ∀ x, x ∈ board → (x = \"X\" ∨ x = \"O\" ∨ x = \" \"))\n  (h2 : 0 < board.length) :\n  ¬(display_board board 1).contains '|' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4324"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n#It's show time!\nArchers have gathered from all around the world to participate in the Arrow Function Faire. But the faire will only start if there are archers signed and if they all have enough arrows in their quivers - at least 5 is the requirement! Are all the archers ready?\n\n#Reference\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n\n#Argument\n`archers` is an array of integers, in which each element corresponds to the number of arrows each archer has.\n\n#Return\nYour function must return `true` if the requirements are met or `false` otherwise.\n\n#Examples\n`archersReady([1, 2, 3, 4, 5, 6, 7, 8])` returns `false` because there are archers with not enough arrows.\n\n`archersReady([5, 6, 7, 8])` returns `true`.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef archers_ready (archers : List Int) : Bool := sorry\n\ntheorem empty_list_false : \n  ∀ (archers : List Int), archers = [] → archers_ready archers = false := sorry\n\ntheorem all_above_five_true :\n  ∀ (archers : List Int), \n    archers ≠ [] → \n    (∀ x ∈ archers, x ≥ 5) → \n    archers_ready archers = true := sorry\n\ntheorem any_below_five_false :\n  ∀ (archers : List Int),\n    archers ≠ [] →\n    (∀ x ∈ archers, x ≤ 4) →\n    archers_ready archers = false := sorry\n\ntheorem any_below_five_makes_false :\n  ∀ (archers : List Int),\n    (∃ x ∈ archers, x < 5) →\n    archers_ready archers = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4366", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n#It's show time!\nArchers have gathered from all around the world to participate in the Arrow Function Faire. But the faire will only start if there are archers signed and if they all have enough arrows in their quivers - at least 5 is the requirement! Are all the archers ready?\n\n#Reference\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n\n#Argument\n`archers` is an array of integers, in which each element corresponds to the number of arrows each archer has.\n\n#Return\nYour function must return `true` if the requirements are met or `false` otherwise.\n\n#Examples\n`archersReady([1, 2, 3, 4, 5, 6, 7, 8])` returns `false` because there are archers with not enough arrows.\n\n`archersReady([5, 6, 7, 8])` returns `true`.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef archers_ready (archers : List Int) : Bool := sorry\n\ntheorem empty_list_false : \n  ∀ (archers : List Int), archers = [] → archers_ready archers = false := sorry\n\ntheorem all_above_five_true :\n  ∀ (archers : List Int), \n    archers ≠ [] → \n    (∀ x ∈ archers, x ≥ 5) → \n    archers_ready archers = true := sorry\n\ntheorem any_below_five_false :\n  ∀ (archers : List Int),\n    archers ≠ [] →\n    (∀ x ∈ archers, x ≤ 4) →\n    archers_ready archers = false := sorry\n\ntheorem any_below_five_makes_false :\n  ∀ (archers : List Int),\n    (∃ x ∈ archers, x < 5) →\n    archers_ready archers = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4366"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nPlease write a function that sums a list, but ignores any duplicate items in the list.\n\nFor instance, for the list [3, 4, 3, 6] , the function should return 10.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sum_no_duplicates (nums : List Int) : Int :=\nsorry\n\ntheorem sum_no_duplicates_empty :\n  sum_no_duplicates [] = 0 :=\nsorry\n\ntheorem sum_no_duplicates_singles (nums : List Int) :\n  let count := nums.foldl (fun acc n => \n    match acc.find? (fun p => p.1 = n) with\n    | none => (n, 1) :: acc\n    | some _ => acc.map (fun p => if p.1 = n then (p.1, p.2 + 1) else p)\n    ) []\n  let singles := count.filter (fun p => p.2 = 1)\n  sum_no_duplicates nums = singles.foldl (fun acc p => acc + p.1) 0 :=\nsorry \n\ntheorem sum_no_duplicates_none (nums : List Int) :\n  let count := nums.foldl (fun acc n => \n    match acc.find? (fun p => p.1 = n) with\n    | none => (n, 1) :: acc\n    | some _ => acc.map (fun p => if p.1 = n then (p.1, p.2 + 1) else p)\n    ) []\n  count.filter (fun p => p.2 = 1) = [] →\n  sum_no_duplicates nums = 0 :=\nsorry\n\ntheorem sum_no_duplicates_all_duplicates (nums : List Int) :\n  nums.length > 1 →\n  sum_no_duplicates (nums ++ nums) = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4387", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nPlease write a function that sums a list, but ignores any duplicate items in the list.\n\nFor instance, for the list [3, 4, 3, 6] , the function should return 10.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef sum_no_duplicates (nums : List Int) : Int :=\nsorry\n\ntheorem sum_no_duplicates_empty :\n  sum_no_duplicates [] = 0 :=\nsorry\n\ntheorem sum_no_duplicates_singles (nums : List Int) :\n  let count := nums.foldl (fun acc n => \n    match acc.find? (fun p => p.1 = n) with\n    | none => (n, 1) :: acc\n    | some _ => acc.map (fun p => if p.1 = n then (p.1, p.2 + 1) else p)\n    ) []\n  let singles := count.filter (fun p => p.2 = 1)\n  sum_no_duplicates nums = singles.foldl (fun acc p => acc + p.1) 0 :=\nsorry \n\ntheorem sum_no_duplicates_none (nums : List Int) :\n  let count := nums.foldl (fun acc n => \n    match acc.find? (fun p => p.1 = n) with\n    | none => (n, 1) :: acc\n    | some _ => acc.map (fun p => if p.1 = n then (p.1, p.2 + 1) else p)\n    ) []\n  count.filter (fun p => p.2 = 1) = [] →\n  sum_no_duplicates nums = 0 :=\nsorry\n\ntheorem sum_no_duplicates_all_duplicates (nums : List Int) :\n  nums.length > 1 →\n  sum_no_duplicates (nums ++ nums) = 0 :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4387"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nSection numbers are strings of dot-separated integers. The highest level sections (chapters) are numbered 1, 2, 3, etc. Second level sections are numbered 1.1, 1.2, 1.3, 2.1, 2.2, 2.3, etc. Next level sections are numbered 1.1.1, 1.1.2, 1.1.2, 1.2.1, 1.2.2, erc. There is no bound on the number of sections a document may have, nor is there any bound on the number of levels. \n\nA section of a certain level may appear directly inside a section several levels higher without the levels between. For example, section 1.0.1 may appear directly under section 1, without there being any level 2 section. Section 1.1 comes after section 1.0.1. Sections with trailing \".0\" are considered to be the same as the section with the trailing \".0\" truncated. Thus, section 1.0 is the same as section 1, and section 1.2.0.0 is the same as section 1.2. \n\n```if:python\nWrite a function `compare(section1, section2)` that returns `-1`, `0`, or `1` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```if:javascript\nWrite a function `cmp(section1, section2)` that returns `-1`, `0`, or `1` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```if:haskell\nWrite a function `cmp section1 section2` that returns `LT`, `EQ` or `GT` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nnamespace VersionCompare\n\ndef compare (v1 v2 : String) : Int := sorry\n\n@[simp] theorem compare_symmetry {v1 v2 : String} :\n  VersionCompare.compare v1 v2 = -(VersionCompare.compare v2 v1) := sorry\n\n@[simp] theorem compare_identity {v : String} :\n  VersionCompare.compare v v = 0 := sorry\n\ntheorem trailing_zeros_ignored {v : String} :\n  VersionCompare.compare v (v ++ \".0\") = 0 ∧ \n  VersionCompare.compare v (v ++ \".0.0\") = 0 := sorry\n\ntheorem compare_transitivity {v1 v2 v3 : String} :\n  VersionCompare.compare v1 v2 ≥ 0 → \n  VersionCompare.compare v2 v3 ≥ 0 → \n  VersionCompare.compare v1 v3 ≥ 0 := sorry\n\ntheorem compare_returns_valid {v1 v2 : String} :\n  VersionCompare.compare v1 v2 = -1 ∨ \n  VersionCompare.compare v1 v2 = 0 ∨ \n  VersionCompare.compare v1 v2 = 1 := sorry\n\nend VersionCompare\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4404", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nSection numbers are strings of dot-separated integers. The highest level sections (chapters) are numbered 1, 2, 3, etc. Second level sections are numbered 1.1, 1.2, 1.3, 2.1, 2.2, 2.3, etc. Next level sections are numbered 1.1.1, 1.1.2, 1.1.2, 1.2.1, 1.2.2, erc. There is no bound on the number of sections a document may have, nor is there any bound on the number of levels. \n\nA section of a certain level may appear directly inside a section several levels higher without the levels between. For example, section 1.0.1 may appear directly under section 1, without there being any level 2 section. Section 1.1 comes after section 1.0.1. Sections with trailing \".0\" are considered to be the same as the section with the trailing \".0\" truncated. Thus, section 1.0 is the same as section 1, and section 1.2.0.0 is the same as section 1.2. \n\n```if:python\nWrite a function `compare(section1, section2)` that returns `-1`, `0`, or `1` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```if:javascript\nWrite a function `cmp(section1, section2)` that returns `-1`, `0`, or `1` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```if:haskell\nWrite a function `cmp section1 section2` that returns `LT`, `EQ` or `GT` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nnamespace VersionCompare\n\ndef compare (v1 v2 : String) : Int := sorry\n\n@[simp] theorem compare_symmetry {v1 v2 : String} :\n  VersionCompare.compare v1 v2 = -(VersionCompare.compare v2 v1) := sorry\n\n@[simp] theorem compare_identity {v : String} :\n  VersionCompare.compare v v = 0 := sorry\n\ntheorem trailing_zeros_ignored {v : String} :\n  VersionCompare.compare v (v ++ \".0\") = 0 ∧ \n  VersionCompare.compare v (v ++ \".0.0\") = 0 := sorry\n\ntheorem compare_transitivity {v1 v2 v3 : String} :\n  VersionCompare.compare v1 v2 ≥ 0 → \n  VersionCompare.compare v2 v3 ≥ 0 → \n  VersionCompare.compare v1 v3 ≥ 0 := sorry\n\ntheorem compare_returns_valid {v1 v2 : String} :\n  VersionCompare.compare v1 v2 = -1 ∨ \n  VersionCompare.compare v1 v2 = 0 ∨ \n  VersionCompare.compare v1 v2 = 1 := sorry\n\nend VersionCompare\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4404"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYour task is very simple. Given an input string s, case\\_sensitive(s), check whether all letters are lowercase or not. Return True/False and a list of all the entries that are not lowercase in order of their appearance in s.\n\nFor example, case\\_sensitive('codewars') returns [True, []], but case\\_sensitive('codeWaRs') returns [False, ['W', 'R']].\n\n\nGoodluck :)\n\nHave a look at my other katas!\n\nAlphabetically ordered \nFind Nearest square number \nNot prime numbers\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef case_sensitive (s : String) : Bool × List String := sorry\n\ntheorem case_sensitive_returns_valid_output (s : String) : \n  let res := case_sensitive s\n  (res.1 = true ∨ res.1 = false) ∧\n  (∀ x ∈ res.2, String.length x = 1) := sorry\n\ntheorem case_sensitive_lowercase_only (s : String) :\n  (∀ c ∈ s.data, 'a' ≤ c ∧ c ≤ 'z') →\n  case_sensitive s = (true, []) := sorry\n\ntheorem case_sensitive_uppercase_only (s : String) :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, 'A' ≤ c ∧ c ≤ 'Z') →\n  let res := case_sensitive s\n  res.1 = false ∧ \n  (∀ c ∈ s.data, (c.toString) ∈ res.2) ∧\n  (∀ x ∈ res.2, ∃ c ∈ s.data, x = c.toString) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4442", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYour task is very simple. Given an input string s, case\\_sensitive(s), check whether all letters are lowercase or not. Return True/False and a list of all the entries that are not lowercase in order of their appearance in s.\n\nFor example, case\\_sensitive('codewars') returns [True, []], but case\\_sensitive('codeWaRs') returns [False, ['W', 'R']].\n\n\nGoodluck :)\n\nHave a look at my other katas!\n\nAlphabetically ordered \nFind Nearest square number \nNot prime numbers\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef case_sensitive (s : String) : Bool × List String := sorry\n\ntheorem case_sensitive_returns_valid_output (s : String) : \n  let res := case_sensitive s\n  (res.1 = true ∨ res.1 = false) ∧\n  (∀ x ∈ res.2, String.length x = 1) := sorry\n\ntheorem case_sensitive_lowercase_only (s : String) :\n  (∀ c ∈ s.data, 'a' ≤ c ∧ c ≤ 'z') →\n  case_sensitive s = (true, []) := sorry\n\ntheorem case_sensitive_uppercase_only (s : String) :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, 'A' ≤ c ∧ c ≤ 'Z') →\n  let res := case_sensitive s\n  res.1 = false ∧ \n  (∀ c ∈ s.data, (c.toString) ∈ res.2) ∧\n  (∀ x ∈ res.2, ∃ c ∈ s.data, x = c.toString) := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4442"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata you are a game developer and have programmed the #1 MMORPG(Massively Multiplayer Online Role Playing Game) worldwide!!! Many suggestions came across you to make the game better, one of which you are interested in and will start working on at once.\n\nPlayers in the game have levels from 1 to 170, XP(short for experience) is required to increase the player's level and is obtained by doing all sorts of things in the game, a new player starts at level 1 with 0 XP. You want to add a feature that would enable the player to input a target level and the output would be how much XP the player must obtain in order for him/her to reach the target level...simple huh.\n\nCreate a function called ```xp_to_target_lvl``` that takes 2 arguments(```current_xp``` and ```target_lvl```, both as integer) and returns the remaining XP for the player to reach the ```target_lvl``` formatted as a rounded down integer.\n\nLeveling up from level 1 to level 2 requires 314 XP, at first each level up requires 25% XP more than the previous level up, every 10 levels the percentage increase reduces by 1. See the examples for a better understanding.\n\nKeep in mind that when players reach level 170 they stop leveling up but they continue gaining experience.\n\nIf one or both of the arguments are invalid(not given,  not in correct format, not in range...etc) return \"Input is invalid.\".\n\nIf the player has already reached the ```target_lvl``` return ```\"You have already reached level target_lvl.\"```.\n\nExamples:\n```\nxp_to_target_lvl(0,5) => XP from lvl1 to lvl2 = 314\n                         XP from lvl2 to lvl3 = 314 + (314*0.25) = 392\n                         XP from lvl3 to lvl4 = 392 + (392*0.25) = 490\n                         XP from lvl4 to lvl5 = 490 + (490*0.25) = 612\n                         XP from lvl1 to target_lvl = 314 + 392 + 490 + 612 = 1808\n                         XP from current_xp to target_lvl = 1808 - 0 = 1808\n\nxp_to_target_lvl(12345,17) => XP from lvl1 to lvl2 = 314                   \n                               XP from lvl2 to lvl3 = 314 + (314*0.25) = 392\n                               XP from lvl3 to lvl4 = 392 + (392*0.25) = 490\n                               ...\n                               XP from lvl9 to lvl10 = 1493 + (1493*0.25) = 1866 \n                               XP from lvl10 to lvl11 = 1866 + (1866*0.24) = 2313 << percentage increase is \n                               ...                                                   reduced by 1 (25 - 1 = 24)\n                               XP from lvl16 to lvl17 = 6779 + (6779*0.24) = 8405\n                               XP from lvl1 to target_lvl = 314 + 392 + 490 + 612 + ... + 8405 = 41880\n                               XP from current_xp to target_lvl = 41880 - 12345 = 29535\n\nxp_to_target_lvl() => \"Input is invalid.\"             }\nxp_to_target_lvl(-31428.7,'47') => \"Input is invalid.\" }> Invalid input\nxp_to_target_lvl(83749,0) => \"Input is invalid.\"   }\n\nxp_to_target_lvl(2017,4) => \"You have already reached level 4.\"\nxp_to_target_lvl(0,1) => 'You have already reached level 1.'\n```\n\nMake sure you round down the XP required for each level up, rounding up will result in the output being slightly wrong.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef xp_to_target_lvl (current_xp : Int) (target_lvl : Int) : String ⊕ Int :=\n  sorry\n\ntheorem xp_to_target_lvl_invalid_input\n  (current_xp : Int)\n  (target_lvl : Int)\n  (h1 : target_lvl ≤ 0 ∨ target_lvl ≥ 171 ∨ current_xp < 0) :\n  xp_to_target_lvl current_xp target_lvl = Sum.inl \"Input is invalid.\" :=\n  sorry\n\ntheorem xp_to_target_lvl_result_positive\n  (current_xp : Int)\n  (target_lvl : Int)\n  (h1 : target_lvl > 0)\n  (h2 : target_lvl < 171)\n  (h3 : current_xp ≥ 0)\n  (h4 : ∃ n : Int, xp_to_target_lvl current_xp target_lvl = Sum.inr n) :\n  ∃ n : Int, xp_to_target_lvl current_xp target_lvl = Sum.inr n ∧ n > 0 :=\n  sorry\n\ntheorem xp_progression_monotonic\n  (target_lvl : Int)\n  (h1 : target_lvl > 1)\n  (h2 : target_lvl < 171)\n  (h3 : ∃ x y : Int, \n    xp_to_target_lvl 0 (target_lvl - 1) = Sum.inr x ∧\n    xp_to_target_lvl 0 target_lvl = Sum.inr y) :\n  ∃ x y : Int,\n    xp_to_target_lvl 0 (target_lvl - 1) = Sum.inr x ∧\n    xp_to_target_lvl 0 target_lvl = Sum.inr y ∧\n    y > x :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4473", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata you are a game developer and have programmed the #1 MMORPG(Massively Multiplayer Online Role Playing Game) worldwide!!! Many suggestions came across you to make the game better, one of which you are interested in and will start working on at once.\n\nPlayers in the game have levels from 1 to 170, XP(short for experience) is required to increase the player's level and is obtained by doing all sorts of things in the game, a new player starts at level 1 with 0 XP. You want to add a feature that would enable the player to input a target level and the output would be how much XP the player must obtain in order for him/her to reach the target level...simple huh.\n\nCreate a function called ```xp_to_target_lvl``` that takes 2 arguments(```current_xp``` and ```target_lvl```, both as integer) and returns the remaining XP for the player to reach the ```target_lvl``` formatted as a rounded down integer.\n\nLeveling up from level 1 to level 2 requires 314 XP, at first each level up requires 25% XP more than the previous level up, every 10 levels the percentage increase reduces by 1. See the examples for a better understanding.\n\nKeep in mind that when players reach level 170 they stop leveling up but they continue gaining experience.\n\nIf one or both of the arguments are invalid(not given,  not in correct format, not in range...etc) return \"Input is invalid.\".\n\nIf the player has already reached the ```target_lvl``` return ```\"You have already reached level target_lvl.\"```.\n\nExamples:\n```\nxp_to_target_lvl(0,5) => XP from lvl1 to lvl2 = 314\n                         XP from lvl2 to lvl3 = 314 + (314*0.25) = 392\n                         XP from lvl3 to lvl4 = 392 + (392*0.25) = 490\n                         XP from lvl4 to lvl5 = 490 + (490*0.25) = 612\n                         XP from lvl1 to target_lvl = 314 + 392 + 490 + 612 = 1808\n                         XP from current_xp to target_lvl = 1808 - 0 = 1808\n\nxp_to_target_lvl(12345,17) => XP from lvl1 to lvl2 = 314                   \n                               XP from lvl2 to lvl3 = 314 + (314*0.25) = 392\n                               XP from lvl3 to lvl4 = 392 + (392*0.25) = 490\n                               ...\n                               XP from lvl9 to lvl10 = 1493 + (1493*0.25) = 1866 \n                               XP from lvl10 to lvl11 = 1866 + (1866*0.24) = 2313 << percentage increase is \n                               ...                                                   reduced by 1 (25 - 1 = 24)\n                               XP from lvl16 to lvl17 = 6779 + (6779*0.24) = 8405\n                               XP from lvl1 to target_lvl = 314 + 392 + 490 + 612 + ... + 8405 = 41880\n                               XP from current_xp to target_lvl = 41880 - 12345 = 29535\n\nxp_to_target_lvl() => \"Input is invalid.\"             }\nxp_to_target_lvl(-31428.7,'47') => \"Input is invalid.\" }> Invalid input\nxp_to_target_lvl(83749,0) => \"Input is invalid.\"   }\n\nxp_to_target_lvl(2017,4) => \"You have already reached level 4.\"\nxp_to_target_lvl(0,1) => 'You have already reached level 1.'\n```\n\nMake sure you round down the XP required for each level up, rounding up will result in the output being slightly wrong.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef xp_to_target_lvl (current_xp : Int) (target_lvl : Int) : String ⊕ Int :=\n  sorry\n\ntheorem xp_to_target_lvl_invalid_input\n  (current_xp : Int)\n  (target_lvl : Int)\n  (h1 : target_lvl ≤ 0 ∨ target_lvl ≥ 171 ∨ current_xp < 0) :\n  xp_to_target_lvl current_xp target_lvl = Sum.inl \"Input is invalid.\" :=\n  sorry\n\ntheorem xp_to_target_lvl_result_positive\n  (current_xp : Int)\n  (target_lvl : Int)\n  (h1 : target_lvl > 0)\n  (h2 : target_lvl < 171)\n  (h3 : current_xp ≥ 0)\n  (h4 : ∃ n : Int, xp_to_target_lvl current_xp target_lvl = Sum.inr n) :\n  ∃ n : Int, xp_to_target_lvl current_xp target_lvl = Sum.inr n ∧ n > 0 :=\n  sorry\n\ntheorem xp_progression_monotonic\n  (target_lvl : Int)\n  (h1 : target_lvl > 1)\n  (h2 : target_lvl < 171)\n  (h3 : ∃ x y : Int, \n    xp_to_target_lvl 0 (target_lvl - 1) = Sum.inr x ∧\n    xp_to_target_lvl 0 target_lvl = Sum.inr y) :\n  ∃ x y : Int,\n    xp_to_target_lvl 0 (target_lvl - 1) = Sum.inr x ∧\n    xp_to_target_lvl 0 target_lvl = Sum.inr y ∧\n    y > x :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4473"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nMr. Khalkhoul, an amazing teacher, likes to answer questions sent by his students via e-mail, but he often doesn't have the time to answer all of them. In this kata you will help him by making a program that finds\nsome of the answers.\n\nYou are given a `question` which is a string containing the question and some `information` which is a list of strings representing potential answers.\n\nYour task is to find among `information` the UNIQUE string that has the highest number of words in common with `question`. We shall consider words to be separated by a single space.\n\nYou can assume that:\n\n* all strings given contain at least one word and have no leading or trailing spaces,\n* words are composed with alphanumeric characters only\n\nYou must also consider the case in which you get no matching words (again, ignoring the case): in such a case return `None/nil/null`.\n\nMr. Khalkhoul is countin' on you :)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef answer (question : String) (info_list : List String) : Option String :=\n  sorry\n\ntheorem answer_none_on_empty_list (q : String) :\n  answer q [] = none := by sorry\n\ntheorem result_in_info_list (q : String) (info_list : List String) :\n  let r := answer q info_list\n  match r with\n  | none => True\n  | some result => result ∈ info_list\n  := by sorry\n\ntheorem result_shares_words (q : String) (info_list : List String) :\n  let r := answer q info_list\n  match r with\n  | none => True\n  | some result =>\n    ∃ word ∈ (String.splitOn q \" \").map String.toLower,\n    word ∈ String.splitOn result.toLower \" \"\n  := by sorry\n\ntheorem result_has_max_overlap (q : String) (info_list : List String) :\n  let r := answer q info_list\n  match r with\n  | none => True\n  | some result =>\n    let qwords := String.splitOn q.toLower \" \"\n    let score (s : String) := (qwords.filter (λ w => w ∈ String.splitOn s.toLower \" \")).length\n    ∀ info ∈ info_list, score result ≥ score info\n  := by sorry\n\ntheorem single_answer_behavior (q : String) (info : String) :\n  let qwords := String.splitOn q.toLower \" \"\n  let iwords := String.splitOn info.toLower \" \"\n  let shares_words := ∃ w ∈ qwords, w ∈ iwords\n  answer q [info] = if shares_words then some info else none\n  := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4560", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nMr. Khalkhoul, an amazing teacher, likes to answer questions sent by his students via e-mail, but he often doesn't have the time to answer all of them. In this kata you will help him by making a program that finds\nsome of the answers.\n\nYou are given a `question` which is a string containing the question and some `information` which is a list of strings representing potential answers.\n\nYour task is to find among `information` the UNIQUE string that has the highest number of words in common with `question`. We shall consider words to be separated by a single space.\n\nYou can assume that:\n\n* all strings given contain at least one word and have no leading or trailing spaces,\n* words are composed with alphanumeric characters only\n\nYou must also consider the case in which you get no matching words (again, ignoring the case): in such a case return `None/nil/null`.\n\nMr. Khalkhoul is countin' on you :)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef answer (question : String) (info_list : List String) : Option String :=\n  sorry\n\ntheorem answer_none_on_empty_list (q : String) :\n  answer q [] = none := by sorry\n\ntheorem result_in_info_list (q : String) (info_list : List String) :\n  let r := answer q info_list\n  match r with\n  | none => True\n  | some result => result ∈ info_list\n  := by sorry\n\ntheorem result_shares_words (q : String) (info_list : List String) :\n  let r := answer q info_list\n  match r with\n  | none => True\n  | some result =>\n    ∃ word ∈ (String.splitOn q \" \").map String.toLower,\n    word ∈ String.splitOn result.toLower \" \"\n  := by sorry\n\ntheorem result_has_max_overlap (q : String) (info_list : List String) :\n  let r := answer q info_list\n  match r with\n  | none => True\n  | some result =>\n    let qwords := String.splitOn q.toLower \" \"\n    let score (s : String) := (qwords.filter (λ w => w ∈ String.splitOn s.toLower \" \")).length\n    ∀ info ∈ info_list, score result ≥ score info\n  := by sorry\n\ntheorem single_answer_behavior (q : String) (info : String) :\n  let qwords := String.splitOn q.toLower \" \"\n  let iwords := String.splitOn info.toLower \" \"\n  let shares_words := ∃ w ∈ qwords, w ∈ iwords\n  answer q [info] = if shares_words then some info else none\n  := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4560"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata you are a builder and you are assigned a job of building a wall with a specific size (God knows why...).\n\nCreate a function called `build_a_wall` (or `buildAWall` in JavaScript) that takes `x` and `y` as integer arguments (which represent the number of rows of bricks for the wall and the number of bricks in each row respectively) and outputs the wall as a string with the following symbols:\n\n`■■` => One full brick (2 of `■`)\n\n`■` => Half a brick\n\n`|` => Mortar (between bricks on same row)\n\nThere has to be a `|` between every two bricks on the same row. For more stability each row's bricks cannot be aligned vertically with the bricks of the row above it or below it meaning at every 2 rows you will have to make the furthest brick on both sides of the row at the size of half a brick (`■`) while the first row from the bottom will only consist of full bricks. Starting from the top, every new row is to be represented with `\\n` except from the bottom row. See the examples for a better understanding.\n\nIf one or both of the arguments aren't valid (less than 1, isn't integer, isn't given...etc) return `None` in Python.\n\nIf the number of bricks required to build the wall is greater than 10000 return `\"Naah, too much...here's my resignation.\"`\n\nExamples, based on Python:\n```\nbuild_a_wall(5,5) => '■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■'\n\nbuild_a_wall(10,7) => '■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■'\n\nbuild_a_wall(\"eight\",[3]) => None  }\n                                   }> Invalid input\nbuild_a_wall(12,-4) => None        }\n\nbuild_a_wall(123,987) => \"Naah, too much...here's my resignation.\"\n123 * 987 = 121401 > 10000\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef build_a_wall (x y : Int) : Option String := sorry\n\ntheorem invalid_input_returns_none {x y : Int} :\n  x ≤ 0 ∨ y ≤ 0 → build_a_wall x y = none := sorry\n\ntheorem large_input_returns_resignation {x y : Int} :\n  x > 100 ∨ y > 100 → \n  build_a_wall x y = some \"Naah, too much...here's my resignation.\" := sorry\n\ntheorem basic_wall_properties {x y : Int} (h1: x > 0) (h2: y > 0) (h3: x * y ≤ 10000) :\n  match build_a_wall x y with\n  | none => False \n  | some wall => \n    -- Wall is a string with x lines\n    let lines := String.split wall (· = '\\n')\n    lines.length = x ∧\n    -- Each line contains the block character\n    ∀ line ∈ lines, String.contains line '■'\n  := sorry\n\ntheorem too_large_wall_returns_resignation {x y : Int} (h1: x > 0) (h2: y > 0) :\n  x * y > 10000 →\n  build_a_wall x y = some \"Naah, too much...here's my resignation.\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4574", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nIn this Kata you are a builder and you are assigned a job of building a wall with a specific size (God knows why...).\n\nCreate a function called `build_a_wall` (or `buildAWall` in JavaScript) that takes `x` and `y` as integer arguments (which represent the number of rows of bricks for the wall and the number of bricks in each row respectively) and outputs the wall as a string with the following symbols:\n\n`■■` => One full brick (2 of `■`)\n\n`■` => Half a brick\n\n`|` => Mortar (between bricks on same row)\n\nThere has to be a `|` between every two bricks on the same row. For more stability each row's bricks cannot be aligned vertically with the bricks of the row above it or below it meaning at every 2 rows you will have to make the furthest brick on both sides of the row at the size of half a brick (`■`) while the first row from the bottom will only consist of full bricks. Starting from the top, every new row is to be represented with `\\n` except from the bottom row. See the examples for a better understanding.\n\nIf one or both of the arguments aren't valid (less than 1, isn't integer, isn't given...etc) return `None` in Python.\n\nIf the number of bricks required to build the wall is greater than 10000 return `\"Naah, too much...here's my resignation.\"`\n\nExamples, based on Python:\n```\nbuild_a_wall(5,5) => '■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■'\n\nbuild_a_wall(10,7) => '■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■\\n■|■■|■■|■■|■■|■■|■■|■\\n■■|■■|■■|■■|■■|■■|■■'\n\nbuild_a_wall(\"eight\",[3]) => None  }\n                                   }> Invalid input\nbuild_a_wall(12,-4) => None        }\n\nbuild_a_wall(123,987) => \"Naah, too much...here's my resignation.\"\n123 * 987 = 121401 > 10000\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef build_a_wall (x y : Int) : Option String := sorry\n\ntheorem invalid_input_returns_none {x y : Int} :\n  x ≤ 0 ∨ y ≤ 0 → build_a_wall x y = none := sorry\n\ntheorem large_input_returns_resignation {x y : Int} :\n  x > 100 ∨ y > 100 → \n  build_a_wall x y = some \"Naah, too much...here's my resignation.\" := sorry\n\ntheorem basic_wall_properties {x y : Int} (h1: x > 0) (h2: y > 0) (h3: x * y ≤ 10000) :\n  match build_a_wall x y with\n  | none => False \n  | some wall => \n    -- Wall is a string with x lines\n    let lines := String.split wall (· = '\\n')\n    lines.length = x ∧\n    -- Each line contains the block character\n    ∀ line ∈ lines, String.contains line '■'\n  := sorry\n\ntheorem too_large_wall_returns_resignation {x y : Int} (h1: x > 0) (h2: y > 0) :\n  x * y > 10000 →\n  build_a_wall x y = some \"Naah, too much...here's my resignation.\" := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4574"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n## Task\n\nYou are given three non negative integers `a`, `b` and `n`, and making an infinite sequence just like fibonacci sequence, use the following rules:\n\n- step 1: use `ab` as the initial sequence.\n- step 2: calculate the sum of the last two digits of the sequence, and append it to the end of sequence.\n- repeat step 2 until you have enough digits\n\nYour task is to complete the function which returns the `n`th digit (0-based) of the sequence.\n\n### Notes:\n\n- `0 <= a, b <= 9`, `0 <= n <= 10^10`\n- `16` fixed testcases\n- `100` random testcases, testing for correctness of solution\n- `100` random testcases, testing for performance of code\n- All inputs are valid.\n- Pay attention to code performance.\n\n\n## Examples\n\nFor `a = 7, b = 8 and n = 9` the output should be `5`, because the sequence is:\n```\n78 -> 7815 -> 78156 -> 7815611 -> 78156112 -> 781561123 -> 7815611235 -> ...\n``` \n\nand the 9th digit of the sequence is `5`.\n\n---\n\nFor `a = 0, b = 0 and n = 100000000` the output should be `0`, because all the digits in this sequence are `0`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_nth_digit (a b n : Nat) : Nat :=\n  sorry\n\ntheorem find_nth_digit_result_is_digit (a b n : Nat) \n    (h1 : a ≤ 9) (h2 : b ≤ 9) : \n    find_nth_digit a b n ≤ 9 :=\n  sorry\n\ntheorem find_nth_digit_first_pos (a b : Nat)\n    (h1 : a ≤ 9) (h2 : b ≤ 9) :\n    find_nth_digit a b 0 = a :=\n  sorry\n\ntheorem find_nth_digit_second_pos (a b : Nat) \n    (h1 : a ≤ 9) (h2 : b ≤ 9) :\n    find_nth_digit a b 1 = b :=\n  sorry\n\ntheorem find_nth_digit_zero_sequence (n : Nat) :\n    find_nth_digit 0 0 n = 0 :=\n  sorry\n\ntheorem find_nth_digit_cycle (a b i : Nat)\n    (h1 : a ≤ 9) (h2 : b ≤ 9) :\n    find_nth_digit a b (20 + i) = find_nth_digit a b (40 + i) :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4585", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n## Task\n\nYou are given three non negative integers `a`, `b` and `n`, and making an infinite sequence just like fibonacci sequence, use the following rules:\n\n- step 1: use `ab` as the initial sequence.\n- step 2: calculate the sum of the last two digits of the sequence, and append it to the end of sequence.\n- repeat step 2 until you have enough digits\n\nYour task is to complete the function which returns the `n`th digit (0-based) of the sequence.\n\n### Notes:\n\n- `0 <= a, b <= 9`, `0 <= n <= 10^10`\n- `16` fixed testcases\n- `100` random testcases, testing for correctness of solution\n- `100` random testcases, testing for performance of code\n- All inputs are valid.\n- Pay attention to code performance.\n\n\n## Examples\n\nFor `a = 7, b = 8 and n = 9` the output should be `5`, because the sequence is:\n```\n78 -> 7815 -> 78156 -> 7815611 -> 78156112 -> 781561123 -> 7815611235 -> ...\n``` \n\nand the 9th digit of the sequence is `5`.\n\n---\n\nFor `a = 0, b = 0 and n = 100000000` the output should be `0`, because all the digits in this sequence are `0`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_nth_digit (a b n : Nat) : Nat :=\n  sorry\n\ntheorem find_nth_digit_result_is_digit (a b n : Nat) \n    (h1 : a ≤ 9) (h2 : b ≤ 9) : \n    find_nth_digit a b n ≤ 9 :=\n  sorry\n\ntheorem find_nth_digit_first_pos (a b : Nat)\n    (h1 : a ≤ 9) (h2 : b ≤ 9) :\n    find_nth_digit a b 0 = a :=\n  sorry\n\ntheorem find_nth_digit_second_pos (a b : Nat) \n    (h1 : a ≤ 9) (h2 : b ≤ 9) :\n    find_nth_digit a b 1 = b :=\n  sorry\n\ntheorem find_nth_digit_zero_sequence (n : Nat) :\n    find_nth_digit 0 0 n = 0 :=\n  sorry\n\ntheorem find_nth_digit_cycle (a b i : Nat)\n    (h1 : a ≤ 9) (h2 : b ≤ 9) :\n    find_nth_digit a b (20 + i) = find_nth_digit a b (40 + i) :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4585"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a certain number, how many multiples of three could you obtain with its digits?\n\nSuposse that you have the number 362. The numbers that can be generated from it are:\n```\n362 ----> 3, 6, 2, 36, 63, 62, 26, 32, 23, 236, 263, 326, 362, 623, 632 \n```\nBut only:\n\n```3, 6, 36, 63``` are multiple of three.\n\nWe need a function that can receive a number ann may output in the following order:\n\n- the amount of multiples\n\n- the maximum multiple\n\nLet's see a case the number has a the digit 0 and repeated digits:\n```\n6063 ----> 0, 3, 6, 30, 36, 60, 63, 66, 306, 360, 366, 603, 606, 630, 636, 660, 663, 3066, 3606, 3660, 6036, 6063, 6306, 6360, 6603, 6630\n```\nIn this case the multiples of three will be all except 0\n\n```\n6063 ----> 3, 6, 30, 36, 60, 63, 66, 306, 360, 366, 603, 606, 630, 636, 660, 663, 3066, 3606, 3660, 6036, 6063, 6306, 6360, 6603, 6630\n```\n\nThe cases above for the function:\n```python\nfind_mult_3(362) == [4, 63]\n\nfind_mult_3(6063) == [25, 6630]\n```\nIn Javascript ```findMult_3()```.\nThe function will receive only positive integers (num > 0), and you don't have to worry for validating the entries.\n\nFeatures of the random tests:\n```\nNumber of test = 100\n1000 ≤ num ≤ 100000000\n```\nEnjoy it!!\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_mult_3 (n : Nat) : List Nat := sorry\n\ntheorem find_mult_3_correct_for_362 :\n  find_mult_3 362 = [4, 63] := sorry\n\ntheorem find_mult_3_correct_for_6063 :\n  find_mult_3 6063 = [25, 6630] := sorry\n\ntheorem find_mult_3_correct_for_7766553322 :\n  find_mult_3 7766553322 = [55510, 766553322] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4607", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven a certain number, how many multiples of three could you obtain with its digits?\n\nSuposse that you have the number 362. The numbers that can be generated from it are:\n```\n362 ----> 3, 6, 2, 36, 63, 62, 26, 32, 23, 236, 263, 326, 362, 623, 632 \n```\nBut only:\n\n```3, 6, 36, 63``` are multiple of three.\n\nWe need a function that can receive a number ann may output in the following order:\n\n- the amount of multiples\n\n- the maximum multiple\n\nLet's see a case the number has a the digit 0 and repeated digits:\n```\n6063 ----> 0, 3, 6, 30, 36, 60, 63, 66, 306, 360, 366, 603, 606, 630, 636, 660, 663, 3066, 3606, 3660, 6036, 6063, 6306, 6360, 6603, 6630\n```\nIn this case the multiples of three will be all except 0\n\n```\n6063 ----> 3, 6, 30, 36, 60, 63, 66, 306, 360, 366, 603, 606, 630, 636, 660, 663, 3066, 3606, 3660, 6036, 6063, 6306, 6360, 6603, 6630\n```\n\nThe cases above for the function:\n```python\nfind_mult_3(362) == [4, 63]\n\nfind_mult_3(6063) == [25, 6630]\n```\nIn Javascript ```findMult_3()```.\nThe function will receive only positive integers (num > 0), and you don't have to worry for validating the entries.\n\nFeatures of the random tests:\n```\nNumber of test = 100\n1000 ≤ num ≤ 100000000\n```\nEnjoy it!!\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef find_mult_3 (n : Nat) : List Nat := sorry\n\ntheorem find_mult_3_correct_for_362 :\n  find_mult_3 362 = [4, 63] := sorry\n\ntheorem find_mult_3_correct_for_6063 :\n  find_mult_3 6063 = [25, 6630] := sorry\n\ntheorem find_mult_3_correct_for_7766553322 :\n  find_mult_3 7766553322 = [55510, 766553322] := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4607"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Task\nTwo players - `\"black\"` and `\"white\"` are playing a game. The game consists of several rounds. If a player wins in a round, he is to move again during the next round. If a player loses a round, it's the other player who moves on the next round. Given whose turn it was on the previous round and whether he won, determine whose turn it is on the next round.\n\n\n\n# Input/Output\n\n\n`[input]` string `lastPlayer`/`$last_player`\n\n`\"black\"` or `\"white\"` - whose move it was during the previous round.\n\n`[input]` boolean `win`/`$win`\n\n`true` if the player who made a move during the previous round won, `false` otherwise.\n\n`[output]` a string\n\nReturn `\"white\"` if white is to move on the next round, and `\"black\"` otherwise.\n\n# Example\n\nFor `lastPlayer = \"black\" and win = false`, the output should be `\"white\"`.\n\nFor `lastPlayer = \"white\" and win = true`, the output should be `\"white\"`.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Player where\n  | black\n  | white\nderiving Repr, BEq\n\ndef opposite : Player → Player \n  | Player.black => Player.white\n  | Player.white => Player.black\n\ndef whoseMove (player : Player) (win : Bool) : Player := sorry\n\ntheorem whoseMove_valid (player : Player) (win : Bool) :\n  whoseMove player win = player ∨ whoseMove player win = opposite player := by sorry\n\ntheorem whoseMove_win (player : Player) (win : Bool) :\n  win = true → whoseMove player win = player := by sorry\n\ntheorem whoseMove_lose (player : Player) (win : Bool) :\n  win = false → whoseMove player win = opposite player := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4619", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Task\nTwo players - `\"black\"` and `\"white\"` are playing a game. The game consists of several rounds. If a player wins in a round, he is to move again during the next round. If a player loses a round, it's the other player who moves on the next round. Given whose turn it was on the previous round and whether he won, determine whose turn it is on the next round.\n\n\n\n# Input/Output\n\n\n`[input]` string `lastPlayer`/`$last_player`\n\n`\"black\"` or `\"white\"` - whose move it was during the previous round.\n\n`[input]` boolean `win`/`$win`\n\n`true` if the player who made a move during the previous round won, `false` otherwise.\n\n`[output]` a string\n\nReturn `\"white\"` if white is to move on the next round, and `\"black\"` otherwise.\n\n# Example\n\nFor `lastPlayer = \"black\" and win = false`, the output should be `\"white\"`.\n\nFor `lastPlayer = \"white\" and win = true`, the output should be `\"white\"`.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Player where\n  | black\n  | white\nderiving Repr, BEq\n\ndef opposite : Player → Player \n  | Player.black => Player.white\n  | Player.white => Player.black\n\ndef whoseMove (player : Player) (win : Bool) : Player := sorry\n\ntheorem whoseMove_valid (player : Player) (win : Bool) :\n  whoseMove player win = player ∨ whoseMove player win = opposite player := by sorry\n\ntheorem whoseMove_win (player : Player) (win : Bool) :\n  win = true → whoseMove player win = player := by sorry\n\ntheorem whoseMove_lose (player : Player) (win : Bool) :\n  win = false → whoseMove player win = opposite player := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4619"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nComplete the function `power_of_two`/`powerOfTwo` (or equivalent, depending on your language) that determines if a given non-negative integer is a [power of two](https://en.wikipedia.org/wiki/Power_of_two).  From the corresponding Wikipedia entry:\n\n> *a power of two is a number of the form 2^(n) where **n** is an integer, i.e. the result of exponentiation with number two as the base and integer **n** as the exponent.*\n\nYou may assume the input is always valid.\n\n## Examples\n\n~~~if-not:nasm\n```python\npower_of_two(1024) ==> True\npower_of_two(4096) ==> True\npower_of_two(333)  ==> False\n```\n~~~\n~~~if:nasm\n```\nmov edi, 0\ncall power_of_two    ; returns false (zero)\nmov edi, 16\ncall power_of_two    ; returns true (non-zero)\nmov edi, 100\ncall power_of_two    ; returns false\nmov edi, 1024\ncall power_of_two    ; returns true\nmov edi, 20000\ncall power_of_two    ; returns false\n```\n~~~\n\nBeware of certain edge cases - for example, `1` is a power of `2` since `2^0 = 1` and `0` is not a power of `2`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef power_of_two (n : Nat) : Bool := sorry\n\ntheorem power_of_two_positive (n : Nat) :\n  power_of_two n = true → n > 0 := sorry\n\ntheorem power_of_two_div_two (n : Nat) :\n  power_of_two n = true →\n  ∃ k, n = 2^k := sorry\n\ntheorem power_of_two_single_bit (n : Nat) :\n  power_of_two n = true →\n  ∃ k, (n = 2^k ∧ ∀ m, n = 2^m → m = k) := sorry\n\ntheorem power_of_two_bitwise (n : Nat) :\n  n > 0 →\n  power_of_two n = true ↔ n &&& (n - 1) = 0 := sorry\n\ntheorem power_of_two_zero :\n  power_of_two 0 = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4639", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nComplete the function `power_of_two`/`powerOfTwo` (or equivalent, depending on your language) that determines if a given non-negative integer is a [power of two](https://en.wikipedia.org/wiki/Power_of_two).  From the corresponding Wikipedia entry:\n\n> *a power of two is a number of the form 2^(n) where **n** is an integer, i.e. the result of exponentiation with number two as the base and integer **n** as the exponent.*\n\nYou may assume the input is always valid.\n\n## Examples\n\n~~~if-not:nasm\n```python\npower_of_two(1024) ==> True\npower_of_two(4096) ==> True\npower_of_two(333)  ==> False\n```\n~~~\n~~~if:nasm\n```\nmov edi, 0\ncall power_of_two    ; returns false (zero)\nmov edi, 16\ncall power_of_two    ; returns true (non-zero)\nmov edi, 100\ncall power_of_two    ; returns false\nmov edi, 1024\ncall power_of_two    ; returns true\nmov edi, 20000\ncall power_of_two    ; returns false\n```\n~~~\n\nBeware of certain edge cases - for example, `1` is a power of `2` since `2^0 = 1` and `0` is not a power of `2`.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef power_of_two (n : Nat) : Bool := sorry\n\ntheorem power_of_two_positive (n : Nat) :\n  power_of_two n = true → n > 0 := sorry\n\ntheorem power_of_two_div_two (n : Nat) :\n  power_of_two n = true →\n  ∃ k, n = 2^k := sorry\n\ntheorem power_of_two_single_bit (n : Nat) :\n  power_of_two n = true →\n  ∃ k, (n = 2^k ∧ ∀ m, n = 2^m → m = k) := sorry\n\ntheorem power_of_two_bitwise (n : Nat) :\n  n > 0 →\n  power_of_two n = true ↔ n &&& (n - 1) = 0 := sorry\n\ntheorem power_of_two_zero :\n  power_of_two 0 = false := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4639"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nThis kata is the second part of a series: [Neighbourhood kata collection](https://www.codewars.com/collections/5b2f4db591c746349d0000ce). If this one is to easy you can try out the harder Katas.;)\n\n___\nThe neighbourhood of a cell (in a matrix) are cells that are near to it. There are two popular types:\n- The [Moore neighborhood](https://en.wikipedia.org/wiki/Moore_neighborhood) are eight cells which surround a given cell.\n- The [Von Neumann neighborhood](https://en.wikipedia.org/wiki/Von_Neumann_neighborhood) are four cells which share a border with the given cell.\n\n___\n\n# Task\nGiven a neighbourhood type (`\"moore\"` or `\"von_neumann\"`), a 2D matrix (a list of lists) and a pair of coordinates, return the list of neighbours of the given cell.\n\nNotes:\n- The order of the elements in the output list is not important. \n- If the input indexes are outside the matrix, return an empty list.\n- If the the matrix is empty, return an empty list.\n- Order of the indices: The first index should be applied for the outer/first matrix layer. The last index for the most inner/last layer. `coordinates = (m, n)` should be apllied like `mat[m][n]`\n\n___\n\n## Examples\n```\n\\ n   0    1    2    3    4\nm  --------------------------\n0  |  0 |  1 |  2 |  3 |  4 |\n1  |  5 |  6 |  7 |  8 |  9 |\n2  | 10 | 11 | 12 | 13 | 14 |\n3  | 15 | 16 | 17 | 18 | 19 |\n4  | 20 | 21 | 22 | 23 | 24 |\n   --------------------------\n\nget_neighborhood(\"moore\", mat, (1,1)) == [0, 1, 2, 5, 7, 10, 11, 12]\nget_neighborhood(\"moore\", mat, (0,0)) == [1, 6, 5]\nget_neighborhood(\"moore\", mat, (4,2)) == [21, 16, 17, 18, 23]\nget_neighborhood(\"von_neumann\", mat, (1,1)) == [1, 5, 7, 11]\nget_neighborhood(\"von_neumann\", mat, (0,0)) == [1, 5]\nget_neighborhood(\"von_neumann\", mat, (4,2)) == [21, 17, 23]\n```\n___\n\nTranslations are appreciated.^^\n\nIf you like chess take a look at [Chess Aesthetics](https://www.codewars.com/kata/5b574980578c6a6bac0000dc)\n\nIf you like puzzles and take a look at [Rubik's cube](https://www.codewars.com/kata/5b3bec086be5d8893000002e)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef get_neighbourhood (typ : String) (arr : List (List Int)) (coords : Int × Int) : List Int :=\n  sorry\n\n-- For non-empty valid arrays, moore neighborhood should have at most 8 neighbors\ntheorem moore_neighborhood_size\n  (arr : List (List Int))\n  (x y : Nat)\n  (h1 : x < arr.length)\n  (h2 : y < (arr[x]'h1).length) :\n  (get_neighbourhood \"moore\" arr (x,y)).length ≤ 8 :=\nsorry\n\n-- For non-empty valid arrays, von Neumann neighborhood should have at most 4 neighbors\ntheorem von_neumann_neighborhood_size\n  (arr : List (List Int))\n  (x y : Nat)\n  (h1 : x < arr.length)\n  (h2 : y < (arr[x]'h1).length) :\n  (get_neighbourhood \"von_neumann\" arr (x,y)).length ≤ 4 :=\nsorry\n\n-- Empty array should return empty result\ntheorem empty_array_empty_result\n  (typ : String)\n  (coords : Int × Int) :\n  get_neighbourhood typ [] coords = [] :=\nsorry\n\n-- Array with empty inner list should return empty result\ntheorem empty_inner_list_empty_result\n  (typ : String)\n  (coords : Int × Int) :\n  get_neighbourhood typ [[]] coords = [] :=\nsorry\n\n-- Invalid coordinates should return empty result\ntheorem invalid_coords_empty_result\n  (arr : List (List Int))\n  (typ : String)\n  (x y : Nat)\n  (h : ¬(x < arr.length ∧ (arr[x]?.getD (List.nil)).length > y)) :\n  get_neighbourhood typ arr (x,y) = [] :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4647", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nThis kata is the second part of a series: [Neighbourhood kata collection](https://www.codewars.com/collections/5b2f4db591c746349d0000ce). If this one is to easy you can try out the harder Katas.;)\n\n___\nThe neighbourhood of a cell (in a matrix) are cells that are near to it. There are two popular types:\n- The [Moore neighborhood](https://en.wikipedia.org/wiki/Moore_neighborhood) are eight cells which surround a given cell.\n- The [Von Neumann neighborhood](https://en.wikipedia.org/wiki/Von_Neumann_neighborhood) are four cells which share a border with the given cell.\n\n___\n\n# Task\nGiven a neighbourhood type (`\"moore\"` or `\"von_neumann\"`), a 2D matrix (a list of lists) and a pair of coordinates, return the list of neighbours of the given cell.\n\nNotes:\n- The order of the elements in the output list is not important. \n- If the input indexes are outside the matrix, return an empty list.\n- If the the matrix is empty, return an empty list.\n- Order of the indices: The first index should be applied for the outer/first matrix layer. The last index for the most inner/last layer. `coordinates = (m, n)` should be apllied like `mat[m][n]`\n\n___\n\n## Examples\n```\n\\ n   0    1    2    3    4\nm  --------------------------\n0  |  0 |  1 |  2 |  3 |  4 |\n1  |  5 |  6 |  7 |  8 |  9 |\n2  | 10 | 11 | 12 | 13 | 14 |\n3  | 15 | 16 | 17 | 18 | 19 |\n4  | 20 | 21 | 22 | 23 | 24 |\n   --------------------------\n\nget_neighborhood(\"moore\", mat, (1,1)) == [0, 1, 2, 5, 7, 10, 11, 12]\nget_neighborhood(\"moore\", mat, (0,0)) == [1, 6, 5]\nget_neighborhood(\"moore\", mat, (4,2)) == [21, 16, 17, 18, 23]\nget_neighborhood(\"von_neumann\", mat, (1,1)) == [1, 5, 7, 11]\nget_neighborhood(\"von_neumann\", mat, (0,0)) == [1, 5]\nget_neighborhood(\"von_neumann\", mat, (4,2)) == [21, 17, 23]\n```\n___\n\nTranslations are appreciated.^^\n\nIf you like chess take a look at [Chess Aesthetics](https://www.codewars.com/kata/5b574980578c6a6bac0000dc)\n\nIf you like puzzles and take a look at [Rubik's cube](https://www.codewars.com/kata/5b3bec086be5d8893000002e)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef get_neighbourhood (typ : String) (arr : List (List Int)) (coords : Int × Int) : List Int :=\n  sorry\n\n-- For non-empty valid arrays, moore neighborhood should have at most 8 neighbors\ntheorem moore_neighborhood_size\n  (arr : List (List Int))\n  (x y : Nat)\n  (h1 : x < arr.length)\n  (h2 : y < (arr[x]'h1).length) :\n  (get_neighbourhood \"moore\" arr (x,y)).length ≤ 8 :=\nsorry\n\n-- For non-empty valid arrays, von Neumann neighborhood should have at most 4 neighbors\ntheorem von_neumann_neighborhood_size\n  (arr : List (List Int))\n  (x y : Nat)\n  (h1 : x < arr.length)\n  (h2 : y < (arr[x]'h1).length) :\n  (get_neighbourhood \"von_neumann\" arr (x,y)).length ≤ 4 :=\nsorry\n\n-- Empty array should return empty result\ntheorem empty_array_empty_result\n  (typ : String)\n  (coords : Int × Int) :\n  get_neighbourhood typ [] coords = [] :=\nsorry\n\n-- Array with empty inner list should return empty result\ntheorem empty_inner_list_empty_result\n  (typ : String)\n  (coords : Int × Int) :\n  get_neighbourhood typ [[]] coords = [] :=\nsorry\n\n-- Invalid coordinates should return empty result\ntheorem invalid_coords_empty_result\n  (arr : List (List Int))\n  (typ : String)\n  (x y : Nat)\n  (h : ¬(x < arr.length ∧ (arr[x]?.getD (List.nil)).length > y)) :\n  get_neighbourhood typ arr (x,y) = [] :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4647"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Story\n\nWell, here I am stuck in another traffic jam.\n\n\n*Damn all those courteous people!*\n\nCars are trying to enter the main road from side-streets somewhere ahead of me and people keep letting them cut in.\n\nEach time somebody is let in the effect ripples back down the road, so pretty soon I am not moving at all.\n\n(Sigh... late again...)\n\n\n\n## Visually\n\nThe diagram below shows lots of cars all attempting to go North.\n* the `a`,`b`,`c`... cars are on the main road with me (`X`)\n* the `B` cars and `C` cars are merging from side streets\n\n\n\n          |  a  |   \n          |  b  | ↑  \n  --------+  c  |  \n     BBBBBB  d  |   \n  --------+  e  |  \n          |  f  | ↑\n          |  g  |   \n  --------+  h  |\n      CCCCC  i  |\n  --------+  j  | ↑\n          |  k  |\n          |  l  |\n          |  m  |\n          |  X  | \n           \n\n\nThis can be represented as\n\n* `mainRoad` = `\"abcdefghijklmX\"`\n* `sideStreets` = `[\"\",\"\",\"\",\"BBBBBB\",\"\",\"\",\"\",\"\",\"CCCCC\"]`\n\n# Kata Task\n\nAssume every car on the main road will \"give way\" to 1 car entering from each side street.\n\nReturn a string representing the cars (up to and including me) in the order they exit off the top of the diagram.\n\n## Notes\n\n* My car is the only `X`, and I am always on the main road\n* Other cars may be any alpha-numeric character (except `X` of course)\n* There are no \"gaps\" between cars\n* Assume side streets are always on the left (as in the diagram)\n* The `sideStreets` array length may vary but is never more than the length of the main road\n* A pre-loaded `Util.display(mainRoad,sideStreets)` method is provided which may help to visualise the data\n * (Util.Display for C#)\n\n## Example\nHere are the first few iterations of my example, showing that I am hardly moving at all...\n\n\nInitialIter 1Iter 2Iter 3Iter 4Iter 5Iter 6Iter 7\n\n\n\n      a   \n      b\n      c  \nBBBBBBd   \n      e  \n      f\n      g   \n      h\n CCCCCi\n      j\n      k\n      l\n      m\n      X \n\n\n\n      b   \n      c\n      d \n BBBBBB   \n      e  \n      f\n      g   \n      h\n CCCCCi\n      j\n      k\n      l\n      m\n      X\n\n\n\n      c   \n      d\n      B\n BBBBBe\n      f  \n      g\n      h   \n      i\n  CCCCC\n      j\n      k\n      l\n      m\n      X\n\n\n\n       d\n       B\n       e\n   BBBBB\n       f\n       g\n       h\n       i\n   CCCCC\n       j\n       k\n       l\n       m\n       X\n\n\n\n     B\n     e\n     B\n BBBBf\n     g\n     h\n     i\n     C\n CCCCj\n     k\n     l\n     m\n     X\n    \n\n\n\n     e\n     B\n     f\n  BBBB\n     g\n     h\n     i\n     C\n CCCCj\n     k\n     l\n     m\n     X\n\n\n\n\n     B\n     f\n     B\n  BBBg\n     h\n     i\n     C\n     j\n  CCCC\n     k\n     l\n     m\n     X\n\n\n\n\n     f\n     B\n     g\n   BBB\n     h\n     i\n     C\n     j\n  CCCC\n     k\n     l\n     m\n     X\n\n\n\n\n\n:-) \n\nDM\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef trafficJam (road: String) (sides: List String) : String := sorry \n\ntheorem trafficJam_endsWith_X (road: String) (sides: List String) \n  (h1: ∃ i, road.get i = 'X') :\n  ∃ j, (trafficJam road sides).get j = 'X' := sorry\n\ntheorem trafficJam_result_length \n  (road: String) (sides: List String) \n  (h1: ∃ i, road.get i = 'X')\n  (h2: road.length > 0) :\n  (trafficJam road sides).length ≥ road.length := sorry\n\ntheorem trafficJam_preserve_first_char\n  (road: String) (sides: List String)\n  (h1: sides.length > 0)\n  (h2: sides[0] = \"\") \n  (h3: road.length > 0) :\n  (trafficJam road sides).front = road.front := sorry\n\ntheorem trafficJam_minimal_case :\n  trafficJam \"X\" [] = \"X\" := sorry\n\ntheorem trafficJam_single_char\n  (road: String) (sides: List String)\n  (h1: road.length = 2)\n  (h2: road.back = 'X')\n  (h3: sides = [\"\"]) :\n  (trafficJam road sides).length ≥ 2 ∧\n  ∃ i, (trafficJam road sides).get i = 'X' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4667", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Story\n\nWell, here I am stuck in another traffic jam.\n\n\n*Damn all those courteous people!*\n\nCars are trying to enter the main road from side-streets somewhere ahead of me and people keep letting them cut in.\n\nEach time somebody is let in the effect ripples back down the road, so pretty soon I am not moving at all.\n\n(Sigh... late again...)\n\n\n\n## Visually\n\nThe diagram below shows lots of cars all attempting to go North.\n* the `a`,`b`,`c`... cars are on the main road with me (`X`)\n* the `B` cars and `C` cars are merging from side streets\n\n\n\n          |  a  |   \n          |  b  | ↑  \n  --------+  c  |  \n     BBBBBB  d  |   \n  --------+  e  |  \n          |  f  | ↑\n          |  g  |   \n  --------+  h  |\n      CCCCC  i  |\n  --------+  j  | ↑\n          |  k  |\n          |  l  |\n          |  m  |\n          |  X  | \n           \n\n\nThis can be represented as\n\n* `mainRoad` = `\"abcdefghijklmX\"`\n* `sideStreets` = `[\"\",\"\",\"\",\"BBBBBB\",\"\",\"\",\"\",\"\",\"CCCCC\"]`\n\n# Kata Task\n\nAssume every car on the main road will \"give way\" to 1 car entering from each side street.\n\nReturn a string representing the cars (up to and including me) in the order they exit off the top of the diagram.\n\n## Notes\n\n* My car is the only `X`, and I am always on the main road\n* Other cars may be any alpha-numeric character (except `X` of course)\n* There are no \"gaps\" between cars\n* Assume side streets are always on the left (as in the diagram)\n* The `sideStreets` array length may vary but is never more than the length of the main road\n* A pre-loaded `Util.display(mainRoad,sideStreets)` method is provided which may help to visualise the data\n * (Util.Display for C#)\n\n## Example\nHere are the first few iterations of my example, showing that I am hardly moving at all...\n\n\nInitialIter 1Iter 2Iter 3Iter 4Iter 5Iter 6Iter 7\n\n\n\n      a   \n      b\n      c  \nBBBBBBd   \n      e  \n      f\n      g   \n      h\n CCCCCi\n      j\n      k\n      l\n      m\n      X \n\n\n\n      b   \n      c\n      d \n BBBBBB   \n      e  \n      f\n      g   \n      h\n CCCCCi\n      j\n      k\n      l\n      m\n      X\n\n\n\n      c   \n      d\n      B\n BBBBBe\n      f  \n      g\n      h   \n      i\n  CCCCC\n      j\n      k\n      l\n      m\n      X\n\n\n\n       d\n       B\n       e\n   BBBBB\n       f\n       g\n       h\n       i\n   CCCCC\n       j\n       k\n       l\n       m\n       X\n\n\n\n     B\n     e\n     B\n BBBBf\n     g\n     h\n     i\n     C\n CCCCj\n     k\n     l\n     m\n     X\n    \n\n\n\n     e\n     B\n     f\n  BBBB\n     g\n     h\n     i\n     C\n CCCCj\n     k\n     l\n     m\n     X\n\n\n\n\n     B\n     f\n     B\n  BBBg\n     h\n     i\n     C\n     j\n  CCCC\n     k\n     l\n     m\n     X\n\n\n\n\n     f\n     B\n     g\n   BBB\n     h\n     i\n     C\n     j\n  CCCC\n     k\n     l\n     m\n     X\n\n\n\n\n\n:-) \n\nDM\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef trafficJam (road: String) (sides: List String) : String := sorry \n\ntheorem trafficJam_endsWith_X (road: String) (sides: List String) \n  (h1: ∃ i, road.get i = 'X') :\n  ∃ j, (trafficJam road sides).get j = 'X' := sorry\n\ntheorem trafficJam_result_length \n  (road: String) (sides: List String) \n  (h1: ∃ i, road.get i = 'X')\n  (h2: road.length > 0) :\n  (trafficJam road sides).length ≥ road.length := sorry\n\ntheorem trafficJam_preserve_first_char\n  (road: String) (sides: List String)\n  (h1: sides.length > 0)\n  (h2: sides[0] = \"\") \n  (h3: road.length > 0) :\n  (trafficJam road sides).front = road.front := sorry\n\ntheorem trafficJam_minimal_case :\n  trafficJam \"X\" [] = \"X\" := sorry\n\ntheorem trafficJam_single_char\n  (road: String) (sides: List String)\n  (h1: road.length = 2)\n  (h2: road.back = 'X')\n  (h3: sides = [\"\"]) :\n  (trafficJam road sides).length ≥ 2 ∧\n  ∃ i, (trafficJam road sides).get i = 'X' := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4667"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nBorn a misinterpretation of [this kata](https://www.codewars.com/kata/simple-fun-number-334-two-beggars-and-gold/), your task here is pretty simple: given an array of values and an amount of beggars, you are supposed to return an array with the sum of what each beggar brings home, assuming they all take regular turns, from the first to the last.\n\nFor example: `[1,2,3,4,5]` for `2` beggars will return a result of `[9,6]`, as the first one takes `[1,3,5]`, the second collects `[2,4]`.\n\nThe same array with `3` beggars would have in turn have produced a better out come for the second beggar: `[5,7,3]`, as they will respectively take `[1,4]`, `[2,5]` and `[3]`.\n\nAlso note that not all beggars have to take the same amount of \"offers\", meaning that the length of the array is not necessarily a multiple of `n`; length can be even shorter, in which case the last beggars will of course take nothing (`0`).\n\n***Note:*** in case you don't get why this kata is about *English* beggars, then you are not familiar on how religiously queues are taken in the kingdom ;)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs\n\ndef beggars (values : List Int) (n : Nat) : List Int := sorry\n\ndef getNth (values : List Int) (n i : Nat) : Int :=\n  match values with\n  | [] => 0\n  | x::xs => if i % n = 0 then x + getNth xs n (i+1) else getNth xs n (i+1)\n\ntheorem beggars_empty_for_zero_n \n  (values : List Int) :\n  beggars values 0 = [] := sorry\n\ntheorem beggars_length_property \n  (values : List Int) (n : Nat) : \n  n > 0 → (beggars values n).length = n := sorry \n\ntheorem beggars_sum_property \n  (values : List Int) (n : Nat) :\n  n > 0 → List.sum values = List.sum (beggars values n) := sorry\n\ntheorem beggars_single_beggar_property\n  (values : List Int) :\n  values.length > 0 → beggars values 1 = [List.sum values] := sorry\n\ntheorem beggars_more_beggars_property\n  (values : List Int) (n : Nat) :\n  n > values.length →\n  beggars values n = \n    beggars values values.length ++ List.replicate (n - values.length) 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4669", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nBorn a misinterpretation of [this kata](https://www.codewars.com/kata/simple-fun-number-334-two-beggars-and-gold/), your task here is pretty simple: given an array of values and an amount of beggars, you are supposed to return an array with the sum of what each beggar brings home, assuming they all take regular turns, from the first to the last.\n\nFor example: `[1,2,3,4,5]` for `2` beggars will return a result of `[9,6]`, as the first one takes `[1,3,5]`, the second collects `[2,4]`.\n\nThe same array with `3` beggars would have in turn have produced a better out come for the second beggar: `[5,7,3]`, as they will respectively take `[1,4]`, `[2,5]` and `[3]`.\n\nAlso note that not all beggars have to take the same amount of \"offers\", meaning that the length of the array is not necessarily a multiple of `n`; length can be even shorter, in which case the last beggars will of course take nothing (`0`).\n\n***Note:*** in case you don't get why this kata is about *English* beggars, then you are not familiar on how religiously queues are taken in the kingdom ;)\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs\n\ndef beggars (values : List Int) (n : Nat) : List Int := sorry\n\ndef getNth (values : List Int) (n i : Nat) : Int :=\n  match values with\n  | [] => 0\n  | x::xs => if i % n = 0 then x + getNth xs n (i+1) else getNth xs n (i+1)\n\ntheorem beggars_empty_for_zero_n \n  (values : List Int) :\n  beggars values 0 = [] := sorry\n\ntheorem beggars_length_property \n  (values : List Int) (n : Nat) : \n  n > 0 → (beggars values n).length = n := sorry \n\ntheorem beggars_sum_property \n  (values : List Int) (n : Nat) :\n  n > 0 → List.sum values = List.sum (beggars values n) := sorry\n\ntheorem beggars_single_beggar_property\n  (values : List Int) :\n  values.length > 0 → beggars values 1 = [List.sum values] := sorry\n\ntheorem beggars_more_beggars_property\n  (values : List Int) (n : Nat) :\n  n > values.length →\n  beggars values n = \n    beggars values values.length ++ List.replicate (n - values.length) 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4669"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nNote: This kata is inspired by [Convert a Number to a String!](http://www.codewars.com/kata/convert-a-number-to-a-string/). Try that one too.\n\n## Description\n\nWe need a function that can transform a string into a number. What ways of achieving this do you know?\n\nNote: Don't worry, all inputs will be strings, and every string is a perfectly valid representation of an integral number.\n\n## Examples\n\n```python\nstringToNumber(\"1234\") == 1234\nstringToNumber(\"605\" ) == 605\nstringToNumber(\"1405\") == 1405\nstringToNumber(\"-7\"  ) == -7\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef string_to_number (s : String) : Int := sorry\n\ntheorem string_to_number_roundtrip (n : Int) : \n  string_to_number (toString n) = n := sorry\n\n\n\n\n\ntheorem string_to_number_invalid_empty :\n  ∀ s : String, s = \"\" → string_to_number s = 0 := sorry\n\ntheorem string_to_number_invalid_nondigit (s : String)\n  (h: ∃ c ∈ s.data, c < '0' ∨ c > '9') :\n  string_to_number s = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4670", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nNote: This kata is inspired by [Convert a Number to a String!](http://www.codewars.com/kata/convert-a-number-to-a-string/). Try that one too.\n\n## Description\n\nWe need a function that can transform a string into a number. What ways of achieving this do you know?\n\nNote: Don't worry, all inputs will be strings, and every string is a perfectly valid representation of an integral number.\n\n## Examples\n\n```python\nstringToNumber(\"1234\") == 1234\nstringToNumber(\"605\" ) == 605\nstringToNumber(\"1405\") == 1405\nstringToNumber(\"-7\"  ) == -7\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef string_to_number (s : String) : Int := sorry\n\ntheorem string_to_number_roundtrip (n : Int) : \n  string_to_number (toString n) = n := sorry\n\n\n\n\n\ntheorem string_to_number_invalid_empty :\n  ∀ s : String, s = \"\" → string_to_number s = 0 := sorry\n\ntheorem string_to_number_invalid_nondigit (s : String)\n  (h: ∃ c ∈ s.data, c < '0' ∨ c > '9') :\n  string_to_number s = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4670"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function ```x(n)``` that takes in a number ```n``` and returns an ```nxn``` array with an ```X``` in the middle. The ```X``` will be represented by ```1's``` and the rest will be ```0's```. \nE.g.\n```python\nx(5) ==  [[1, 0, 0, 0, 1],\n          [0, 1, 0, 1, 0],\n          [0, 0, 1, 0, 0],\n          [0, 1, 0, 1, 0],\n          [1, 0, 0, 0, 1]];\n          \nx(6) ==  [[1, 0, 0, 0, 0, 1],\n          [0, 1, 0, 0, 1, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 1, 0, 0, 1, 0],\n          [1, 0, 0, 0, 0, 1]];\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef x (n : Nat) : List (List Nat) := sorry\n\ntheorem square_matrix (n : Nat) (h: n > 0) :\n  let result := x n\n  List.length result = n ∧\n  ∀ row ∈ result, List.length row = n :=\nsorry\n\ntheorem diagonal_ones (n : Nat) (h: n > 0) :\n  let result := x n\n  (∀ i, i < n → List.get! (List.get! result i) i = 1) ∧\n  (∀ i, i < n → List.get! (List.get! result i) (n-1-i) = 1) :=\nsorry\n\ntheorem non_diagonal_zeros (n : Nat) (h: n > 0) :\n  let result := x n\n  ∀ i j, i < n → j < n → i ≠ j → j ≠ (n-1-i) →\n    List.get! (List.get! result i) j = 0 :=\nsorry\n\ntheorem symmetry (n : Nat) (h: n > 0) :\n  let result := x n\n  (∀ i j, i < n → j < n → List.get! (List.get! result i) j = \n              List.get! (List.get! result (n-1-i)) (n-1-j)) ∧\n  (∀ i j, i < n → j < n → List.get! (List.get! result i) j = \n              List.get! (List.get! result j) i) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4718", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function ```x(n)``` that takes in a number ```n``` and returns an ```nxn``` array with an ```X``` in the middle. The ```X``` will be represented by ```1's``` and the rest will be ```0's```. \nE.g.\n```python\nx(5) ==  [[1, 0, 0, 0, 1],\n          [0, 1, 0, 1, 0],\n          [0, 0, 1, 0, 0],\n          [0, 1, 0, 1, 0],\n          [1, 0, 0, 0, 1]];\n          \nx(6) ==  [[1, 0, 0, 0, 0, 1],\n          [0, 1, 0, 0, 1, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 1, 0, 0, 1, 0],\n          [1, 0, 0, 0, 0, 1]];\n```\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef x (n : Nat) : List (List Nat) := sorry\n\ntheorem square_matrix (n : Nat) (h: n > 0) :\n  let result := x n\n  List.length result = n ∧\n  ∀ row ∈ result, List.length row = n :=\nsorry\n\ntheorem diagonal_ones (n : Nat) (h: n > 0) :\n  let result := x n\n  (∀ i, i < n → List.get! (List.get! result i) i = 1) ∧\n  (∀ i, i < n → List.get! (List.get! result i) (n-1-i) = 1) :=\nsorry\n\ntheorem non_diagonal_zeros (n : Nat) (h: n > 0) :\n  let result := x n\n  ∀ i j, i < n → j < n → i ≠ j → j ≠ (n-1-i) →\n    List.get! (List.get! result i) j = 0 :=\nsorry\n\ntheorem symmetry (n : Nat) (h: n > 0) :\n  let result := x n\n  (∀ i j, i < n → j < n → List.get! (List.get! result i) j = \n              List.get! (List.get! result (n-1-i)) (n-1-j)) ∧\n  (∀ i j, i < n → j < n → List.get! (List.get! result i) j = \n              List.get! (List.get! result j) i) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4718"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function ```convert_temp(temp, from_scale, to_scale)``` converting temperature from one scale to another. \nReturn converted temp value. \n\nRound converted temp value to an integer(!).\n\nReading: http://en.wikipedia.org/wiki/Conversion_of_units_of_temperature\n\n```\npossible scale inputs:\n    \"C\"  for Celsius\n    \"F\"  for Fahrenheit\n    \"K\"  for Kelvin\n    \"R\"  for Rankine\n    \"De\" for Delisle\n    \"N\"  for Newton\n    \"Re\" for Réaumur\n    \"Ro\" for Rømer\n```\n\n```temp``` is a number, ```from_scale``` and ```to_scale``` are strings. \n\n```python\nconvert_temp(   100, \"C\",  \"F\") # => 212\nconvert_temp(    40, \"Re\", \"C\") # => 50\nconvert_temp(    60, \"De\", \"F\") # => 140\nconvert_temp(373.15, \"K\",  \"N\") # => 33\nconvert_temp(   666, \"K\",  \"K\") # => 666\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef convert_temp (temp : Float) (from_scale : String) (to_scale : String) : Int :=\n  sorry\n\ndef round (x : Float) : Int :=\n  sorry\n\ndef int_to_float (n : Int) : Float :=\n  sorry\n\ntheorem convert_temp_identity {temp : Float} {scale : String} \n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  convert_temp temp scale scale = round temp := by\n  sorry\n\ntheorem convert_temp_returns_int {temp : Float} {from_scale to_scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  ∃ n : Int, convert_temp temp from_scale to_scale = n := by\n  sorry\n\ntheorem convert_temp_kelvin_roundtrip {temp : Float} {scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) (h3 : scale ≠ \"K\") :\n  let kelvin := int_to_float (convert_temp temp scale \"K\")\n  let back := convert_temp kelvin \"K\" scale\n  (back - round temp) ≤ 2 ∧ (round temp - back) ≤ 2 := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4721", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function ```convert_temp(temp, from_scale, to_scale)``` converting temperature from one scale to another. \nReturn converted temp value. \n\nRound converted temp value to an integer(!).\n\nReading: http://en.wikipedia.org/wiki/Conversion_of_units_of_temperature\n\n```\npossible scale inputs:\n    \"C\"  for Celsius\n    \"F\"  for Fahrenheit\n    \"K\"  for Kelvin\n    \"R\"  for Rankine\n    \"De\" for Delisle\n    \"N\"  for Newton\n    \"Re\" for Réaumur\n    \"Ro\" for Rømer\n```\n\n```temp``` is a number, ```from_scale``` and ```to_scale``` are strings. \n\n```python\nconvert_temp(   100, \"C\",  \"F\") # => 212\nconvert_temp(    40, \"Re\", \"C\") # => 50\nconvert_temp(    60, \"De\", \"F\") # => 140\nconvert_temp(373.15, \"K\",  \"N\") # => 33\nconvert_temp(   666, \"K\",  \"K\") # => 666\n```\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef convert_temp (temp : Float) (from_scale : String) (to_scale : String) : Int :=\n  sorry\n\ndef round (x : Float) : Int :=\n  sorry\n\ndef int_to_float (n : Int) : Float :=\n  sorry\n\ntheorem convert_temp_identity {temp : Float} {scale : String} \n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  convert_temp temp scale scale = round temp := by\n  sorry\n\ntheorem convert_temp_returns_int {temp : Float} {from_scale to_scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  ∃ n : Int, convert_temp temp from_scale to_scale = n := by\n  sorry\n\ntheorem convert_temp_kelvin_roundtrip {temp : Float} {scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) (h3 : scale ≠ \"K\") :\n  let kelvin := int_to_float (convert_temp temp scale \"K\")\n  let back := convert_temp kelvin \"K\" scale\n  (back - round temp) ≤ 2 ∧ (round temp - back) ≤ 2 := by\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4721"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nLet's just place tokens on a connect four board.\n\n\n\n** INPUT **\n\nProvided as input the list of columns where a token is placed, from 0 to 6 included.\nThe first player starting is the yellow one (marked with `Y`), then the red (marked with `R`); the other cells might be empty and marked with `-`.\n\n** OUTPUT **\n\nThe output is the state of the board after all the tokens in input have been placed.\n\n** ASSUMPTIONS **\n\n- The board is the standard 7x6;\n- Of course you'll need to deal with gravity;\n- You don't need to hassle with wrong input, wrong column numbers, checking for full column or going off the board;\n- the columns list will always include proper column numbers;\n- Notice: when you read the results in tests, the highest row appears first and the lowest row appears last; debugging using `\\n` after each row might help (check example);\n\n** EXAMPLES **\n\n1.\n```\nMoves = [0,1,2,5,6]\n\nResult:\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['Y', 'R', 'Y', '-', '-', 'R', 'Y']\n```\n2.\n```\nMoves = [0,1,2,5,6,2,0,0]\n\nResult:\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['R', '-', '-', '-', '-', '-', '-']\n['Y', '-', 'R', '-', '-', '-', '-']\n['Y', 'R', 'Y', '-', '-', 'R', 'Y']\n```\n\nSee test cases for better details.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Cell where\n  | Empty : Cell\n  | Yellow : Cell\n  | Red : Cell\nderiving Repr, BEq, Inhabited, DecidableEq\n\ndef Board := List (List Cell)\n\ndef connect_four_place (moves: List Nat) : Board :=\n  sorry\n\ndef countCells (b: Board) (p: Cell → Bool) : Nat :=\n  b.join.foldl (fun acc c => if p c then acc + 1 else acc) 0\n\ntheorem board_dimensions {moves : List Nat} \n  (h : ∀ m ∈ moves, m ≤ 6) : \n  let board := connect_four_place moves\n  board.length = 6 ∧ List.all board (fun row => row.length = 7) :=\nsorry\n\ntheorem alternating_players {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  let yellow_count := countCells board (fun c => c == Cell.Yellow)\n  let red_count := countCells board (fun c => c == Cell.Red)\n  yellow_count ≤ red_count + 1 ∧ red_count ≤ yellow_count + 1 :=\nsorry\n\ntheorem gravity_effect {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  ∀ col, col < 7 → \n  ∀ row₁ row₂, row₁ < row₂ → row₂ < 6 →\n    Option.isSome ((board.get? row₂).bind (·.get? col)) →\n    (board.get? row₂).bind (·.get? col) = some Cell.Empty → \n    (board.get? row₁).bind (·.get? col) = some Cell.Empty :=\nsorry\n\ntheorem valid_pieces {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  board.join.all (fun cell => \n    cell == Cell.Empty || cell == Cell.Yellow || cell == Cell.Red) :=\nsorry\n\ntheorem empty_board :\n  connect_four_place [] = \n    List.replicate 6 (List.replicate 7 Cell.Empty) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4758", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nLet's just place tokens on a connect four board.\n\n\n\n** INPUT **\n\nProvided as input the list of columns where a token is placed, from 0 to 6 included.\nThe first player starting is the yellow one (marked with `Y`), then the red (marked with `R`); the other cells might be empty and marked with `-`.\n\n** OUTPUT **\n\nThe output is the state of the board after all the tokens in input have been placed.\n\n** ASSUMPTIONS **\n\n- The board is the standard 7x6;\n- Of course you'll need to deal with gravity;\n- You don't need to hassle with wrong input, wrong column numbers, checking for full column or going off the board;\n- the columns list will always include proper column numbers;\n- Notice: when you read the results in tests, the highest row appears first and the lowest row appears last; debugging using `\\n` after each row might help (check example);\n\n** EXAMPLES **\n\n1.\n```\nMoves = [0,1,2,5,6]\n\nResult:\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['Y', 'R', 'Y', '-', '-', 'R', 'Y']\n```\n2.\n```\nMoves = [0,1,2,5,6,2,0,0]\n\nResult:\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['R', '-', '-', '-', '-', '-', '-']\n['Y', '-', 'R', '-', '-', '-', '-']\n['Y', 'R', 'Y', '-', '-', 'R', 'Y']\n```\n\nSee test cases for better details.\n```\n#####\n\nTo answer this question, you need to replace the 6 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive Cell where\n  | Empty : Cell\n  | Yellow : Cell\n  | Red : Cell\nderiving Repr, BEq, Inhabited, DecidableEq\n\ndef Board := List (List Cell)\n\ndef connect_four_place (moves: List Nat) : Board :=\n  sorry\n\ndef countCells (b: Board) (p: Cell → Bool) : Nat :=\n  b.join.foldl (fun acc c => if p c then acc + 1 else acc) 0\n\ntheorem board_dimensions {moves : List Nat} \n  (h : ∀ m ∈ moves, m ≤ 6) : \n  let board := connect_four_place moves\n  board.length = 6 ∧ List.all board (fun row => row.length = 7) :=\nsorry\n\ntheorem alternating_players {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  let yellow_count := countCells board (fun c => c == Cell.Yellow)\n  let red_count := countCells board (fun c => c == Cell.Red)\n  yellow_count ≤ red_count + 1 ∧ red_count ≤ yellow_count + 1 :=\nsorry\n\ntheorem gravity_effect {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  ∀ col, col < 7 → \n  ∀ row₁ row₂, row₁ < row₂ → row₂ < 6 →\n    Option.isSome ((board.get? row₂).bind (·.get? col)) →\n    (board.get? row₂).bind (·.get? col) = some Cell.Empty → \n    (board.get? row₁).bind (·.get? col) = some Cell.Empty :=\nsorry\n\ntheorem valid_pieces {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  board.join.all (fun cell => \n    cell == Cell.Empty || cell == Cell.Yellow || cell == Cell.Red) :=\nsorry\n\ntheorem empty_board :\n  connect_four_place [] = \n    List.replicate 6 (List.replicate 7 Cell.Empty) :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4758"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nEverybody loves **pi**, but what if **pi** were a square? Given a number of digits ```digits```, find the smallest integer whose square is greater or equal to the sum of the squares of the first ```digits``` digits of pi, including the ```3``` before the decimal point.\n\n**Note:** Test cases will not extend beyond 100 digits; the first 100 digits of pi are pasted here for your convenience:\n```\n31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\n```\n\n\n## Examples\n\n```\ndigits   = 1   #  [3]\nexpected = 3   #  sqrt(3^2) = 3\n\n\ndigits   = 3   #  [3, 1, 4]\nexpected = 6   #  sqrt(3^2 + 1^2 + 4^2) = 5.099 --> 6\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef maxLen : Nat :=\nsorry\n\ndef sum_squares (n : Nat) : Nat :=\nsorry\n\ndef square_pi (n : Nat) : Nat :=\nsorry\n\n\n\ntheorem square_pi_monotone {n₁ n₂ : Nat} (h : n₁ ≤ n₂) (h2 : n₂ ≤ maxLen) :\n  square_pi n₁ ≤ square_pi n₂ :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4780", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nEverybody loves **pi**, but what if **pi** were a square? Given a number of digits ```digits```, find the smallest integer whose square is greater or equal to the sum of the squares of the first ```digits``` digits of pi, including the ```3``` before the decimal point.\n\n**Note:** Test cases will not extend beyond 100 digits; the first 100 digits of pi are pasted here for your convenience:\n```\n31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\n```\n\n\n## Examples\n\n```\ndigits   = 1   #  [3]\nexpected = 3   #  sqrt(3^2) = 3\n\n\ndigits   = 3   #  [3, 1, 4]\nexpected = 6   #  sqrt(3^2 + 1^2 + 4^2) = 5.099 --> 6\n```\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef maxLen : Nat :=\nsorry\n\ndef sum_squares (n : Nat) : Nat :=\nsorry\n\ndef square_pi (n : Nat) : Nat :=\nsorry\n\n\n\ntheorem square_pi_monotone {n₁ n₂ : Nat} (h : n₁ ≤ n₂) (h2 : n₂ ≤ maxLen) :\n  square_pi n₁ ≤ square_pi n₂ :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4780"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function that takes a string and returns an array containing binary numbers equivalent to the ASCII codes of the characters of the string. The binary strings should be eight digits long.\n\nExample: `'man'` should return `[ '01101101', '01100001', '01101110' ]`\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef word_to_bin (s : String) : List String := sorry\n\ntheorem word_to_bin_length {s : String} (h : s.length > 0) : \n  (word_to_bin s).length = s.length := sorry\n\ntheorem word_to_bin_binary_format {s : String} (h : s.length > 0) :\n  ∀ x ∈ word_to_bin s,\n    x.length = 8 ∧ \n    ∀ c ∈ x.data, c = '0' ∨ c = '1' := sorry\n\ntheorem word_to_bin_roundtrip {s : String} (h : s.length > 0) :\n  let binList := word_to_bin s\n  let decoded := binList.map (fun x => String.toNat! x)\n  String.mk (decoded.map Char.ofNat) = s := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4791", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nWrite a function that takes a string and returns an array containing binary numbers equivalent to the ASCII codes of the characters of the string. The binary strings should be eight digits long.\n\nExample: `'man'` should return `[ '01101101', '01100001', '01101110' ]`\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef word_to_bin (s : String) : List String := sorry\n\ntheorem word_to_bin_length {s : String} (h : s.length > 0) : \n  (word_to_bin s).length = s.length := sorry\n\ntheorem word_to_bin_binary_format {s : String} (h : s.length > 0) :\n  ∀ x ∈ word_to_bin s,\n    x.length = 8 ∧ \n    ∀ c ∈ x.data, c = '0' ∨ c = '1' := sorry\n\ntheorem word_to_bin_roundtrip {s : String} (h : s.length > 0) :\n  let binList := word_to_bin s\n  let decoded := binList.map (fun x => String.toNat! x)\n  String.mk (decoded.map Char.ofNat) = s := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4791"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nGiven 2 strings, `a` and `b`, return a string of the form: `shorter+reverse(longer)+shorter.`\n\n\nIn other words, the shortest string has to be put as prefix and as suffix of the reverse of the longest.\n\nStrings `a` and `b` may be empty, but not null (In C# strings may also be null. Treat them as if they are empty.).  \nIf `a` and `b` have the same length treat `a` as the longer producing `b+reverse(a)+b`\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef shorter_reverse_longer (a b : String) : String := sorry\n\ndef reverse (s : String) : String := sorry\n\ntheorem shorter_reverse_longer_length (a b : String) : \n  let result := shorter_reverse_longer a b\n  String.length result = 2 * min (String.length a) (String.length b) + max (String.length a) (String.length b)\n  := sorry\n\ntheorem shorter_reverse_longer_empty_left (s : String) :\n  shorter_reverse_longer \"\" s = reverse s := sorry\n\ntheorem shorter_reverse_longer_empty_right (s : String) :\n  shorter_reverse_longer s \"\" = reverse s := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4797", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nGiven 2 strings, `a` and `b`, return a string of the form: `shorter+reverse(longer)+shorter.`\n\n\nIn other words, the shortest string has to be put as prefix and as suffix of the reverse of the longest.\n\nStrings `a` and `b` may be empty, but not null (In C# strings may also be null. Treat them as if they are empty.).  \nIf `a` and `b` have the same length treat `a` as the longer producing `b+reverse(a)+b`\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef shorter_reverse_longer (a b : String) : String := sorry\n\ndef reverse (s : String) : String := sorry\n\ntheorem shorter_reverse_longer_length (a b : String) : \n  let result := shorter_reverse_longer a b\n  String.length result = 2 * min (String.length a) (String.length b) + max (String.length a) (String.length b)\n  := sorry\n\ntheorem shorter_reverse_longer_empty_left (s : String) :\n  shorter_reverse_longer \"\" s = reverse s := sorry\n\ntheorem shorter_reverse_longer_empty_right (s : String) :\n  shorter_reverse_longer s \"\" = reverse s := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4797"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Introduction\n\n\nMastermind or Master Mind is a code-breaking game for two players. The modern game with pegs was invented in 1970 by Mordecai Meirowitz, an Israeli postmaster and telecommunications expert. It resembles an earlier pencil and paper game called Bulls and Cows that may date back a century or more. (Source Wikipedia)\n\n\n\n# Rules\n\n\n1. The Mastermind (computer) will select 4 colours. The colours are randomly selected from [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]. Colours can be duplicated but there will always be exactly 4.\n\n2. The Mastermind will return an array back to you. For every correctly positioned colour in the array an element of “Black” is returned. For every correct colour but in the wrong position an element of “White” will be returned.\n\n3. Passing the correct array will pass the Kata test and return \"WON!\".\n\n4. Passing an invalid colour will fail the test with the error \"Error: you have given an invalid colour!\"\n\n5. Passing an invalid array length will fail the test with the error \"Error: you must pass 4 colours!\"\n\n6. Guessing more than 60 times will fail the test with the error \"Error: you have had more than 60 tries!\"\n\n7. All colours are capitalised\n\n8. The return array will be shuffled!\n\n\n# Task\n\n\nYour task is to create a method called mastermind() that will take an object called  game. The object has already been preloaded so you do not need to worry about it.\n\nWithin your method you must pass an array into the game object method .check(). This will evoke the object to check your array to see if it is correct.\n\n\n# Example\n\nIf the Mastermind selected the following colours\n\nThen the array you are trying to solve is `[\"Red\", \"Blue\", \"Green\", \"Yellow\"]`\nSo you guess with \n\n`[\"Red\", \"Orange\", \"Yellow\", \"Orange\"]`\n\nYour method would look like this.\n```python\ndef mastermind(game):\n  answer = game.check([\"Red\", \"Orange\", \"Yellow\", \"Orange\"])\n```\nThe element `0 => Red` is at the correct index so `Black` is added to the return array. Element `2 => Yellow` is in the array but at the wrong index possition so `White` is added to the return array.\n\nThe Mastermind would then return `[\"Black\", \"White\"]` (But not necessarily in that order as the return array is shuffled my the Mastermind).\n\nKeep guessing until you pass the correct solution which will pass the Kata.\n\n# Check result\nTo check the Masterminds return value\n```python\n  answer = game.check([\"Red\", \"Orange\", \"Yellow\", \"Orange\"])\n  print (answer)\n```\n\nGood luck and enjoy!\n\n# Kata Series\nIf you enjoyed this, then please try one of my other Katas. Any feedback, translations and grading of beta Katas are greatly appreciated. Thank you.\n\n Maze Runner\n Scooby Doo Puzzle\n Driving License\n Connect 4\n Vending Machine\n Snakes and Ladders\n Mastermind\n Guess Who?\n Am I safe to drive?\n Mexican Wave\n Pigs in a Pen\n Hungry Hippos\n Plenty of Fish in the Pond\n Fruit Machine\n Car Park Escape\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef VALID_COLORS := [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]\n\nstructure Game where\n  solution : List String := []\n  tries : Nat := 0\n  deriving Repr\n\ndef Game.check (g : Game) (guess : List String) : List String := sorry\n\ndef matches_result (code guess result : List String) : Bool := sorry\n\ndef mastermind (g : Game) : Unit := sorry\n\ntheorem mastermind_always_solves {solution : List String} \n  (h1 : solution.length = 4)\n  (h2 : ∀ x ∈ solution, x ∈ VALID_COLORS) :\n  ∀ g : Game, g.solution = solution → g.tries ≤ 60 := sorry\n\ntheorem matches_result_symmetric {code guess : List String} \n  (h1 : code.length = 4) \n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ code, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result code guess (List.replicate 4 \"Black\") = \n  matches_result guess code (List.replicate 4 \"Black\") := sorry\n\ntheorem matches_result_self {guess : List String}\n  (h1 : guess.length = 4)\n  (h2 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result guess guess (List.replicate 4 \"Black\") = true := sorry\n\ntheorem game_check_invalid_inputs (g : Game) :\n  (∀ guess : List String, guess.length ≠ 4 → g.check guess = []) ∧\n  (∀ guess : List String, (∃ x ∈ guess, x ∉ VALID_COLORS) → g.check guess = []) ∧\n  (g.tries ≥ 60 → ∀ guess : List String, g.check guess = []) := sorry\n\ntheorem check_result_length {solution guess : List String} \n  (h1 : solution.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ solution, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS)\n  (g : Game)\n  (h5 : g.solution = solution) :\n  let result := g.check guess\n  (result.length ≤ 4 ∧ ∀ x ∈ result, x = \"Black\" ∨ x = \"White\") := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4822", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Introduction\n\n\nMastermind or Master Mind is a code-breaking game for two players. The modern game with pegs was invented in 1970 by Mordecai Meirowitz, an Israeli postmaster and telecommunications expert. It resembles an earlier pencil and paper game called Bulls and Cows that may date back a century or more. (Source Wikipedia)\n\n\n\n# Rules\n\n\n1. The Mastermind (computer) will select 4 colours. The colours are randomly selected from [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]. Colours can be duplicated but there will always be exactly 4.\n\n2. The Mastermind will return an array back to you. For every correctly positioned colour in the array an element of “Black” is returned. For every correct colour but in the wrong position an element of “White” will be returned.\n\n3. Passing the correct array will pass the Kata test and return \"WON!\".\n\n4. Passing an invalid colour will fail the test with the error \"Error: you have given an invalid colour!\"\n\n5. Passing an invalid array length will fail the test with the error \"Error: you must pass 4 colours!\"\n\n6. Guessing more than 60 times will fail the test with the error \"Error: you have had more than 60 tries!\"\n\n7. All colours are capitalised\n\n8. The return array will be shuffled!\n\n\n# Task\n\n\nYour task is to create a method called mastermind() that will take an object called  game. The object has already been preloaded so you do not need to worry about it.\n\nWithin your method you must pass an array into the game object method .check(). This will evoke the object to check your array to see if it is correct.\n\n\n# Example\n\nIf the Mastermind selected the following colours\n\nThen the array you are trying to solve is `[\"Red\", \"Blue\", \"Green\", \"Yellow\"]`\nSo you guess with \n\n`[\"Red\", \"Orange\", \"Yellow\", \"Orange\"]`\n\nYour method would look like this.\n```python\ndef mastermind(game):\n  answer = game.check([\"Red\", \"Orange\", \"Yellow\", \"Orange\"])\n```\nThe element `0 => Red` is at the correct index so `Black` is added to the return array. Element `2 => Yellow` is in the array but at the wrong index possition so `White` is added to the return array.\n\nThe Mastermind would then return `[\"Black\", \"White\"]` (But not necessarily in that order as the return array is shuffled my the Mastermind).\n\nKeep guessing until you pass the correct solution which will pass the Kata.\n\n# Check result\nTo check the Masterminds return value\n```python\n  answer = game.check([\"Red\", \"Orange\", \"Yellow\", \"Orange\"])\n  print (answer)\n```\n\nGood luck and enjoy!\n\n# Kata Series\nIf you enjoyed this, then please try one of my other Katas. Any feedback, translations and grading of beta Katas are greatly appreciated. Thank you.\n\n Maze Runner\n Scooby Doo Puzzle\n Driving License\n Connect 4\n Vending Machine\n Snakes and Ladders\n Mastermind\n Guess Who?\n Am I safe to drive?\n Mexican Wave\n Pigs in a Pen\n Hungry Hippos\n Plenty of Fish in the Pond\n Fruit Machine\n Car Park Escape\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef VALID_COLORS := [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]\n\nstructure Game where\n  solution : List String := []\n  tries : Nat := 0\n  deriving Repr\n\ndef Game.check (g : Game) (guess : List String) : List String := sorry\n\ndef matches_result (code guess result : List String) : Bool := sorry\n\ndef mastermind (g : Game) : Unit := sorry\n\ntheorem mastermind_always_solves {solution : List String} \n  (h1 : solution.length = 4)\n  (h2 : ∀ x ∈ solution, x ∈ VALID_COLORS) :\n  ∀ g : Game, g.solution = solution → g.tries ≤ 60 := sorry\n\ntheorem matches_result_symmetric {code guess : List String} \n  (h1 : code.length = 4) \n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ code, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result code guess (List.replicate 4 \"Black\") = \n  matches_result guess code (List.replicate 4 \"Black\") := sorry\n\ntheorem matches_result_self {guess : List String}\n  (h1 : guess.length = 4)\n  (h2 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result guess guess (List.replicate 4 \"Black\") = true := sorry\n\ntheorem game_check_invalid_inputs (g : Game) :\n  (∀ guess : List String, guess.length ≠ 4 → g.check guess = []) ∧\n  (∀ guess : List String, (∃ x ∈ guess, x ∉ VALID_COLORS) → g.check guess = []) ∧\n  (g.tries ≥ 60 → ∀ guess : List String, g.check guess = []) := sorry\n\ntheorem check_result_length {solution guess : List String} \n  (h1 : solution.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ solution, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS)\n  (g : Game)\n  (h5 : g.solution = solution) :\n  let result := g.check guess\n  (result.length ≤ 4 ∧ ∀ x ∈ result, x = \"Black\" ∨ x = \"White\") := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4822"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\n# Description:\n\nRemove the minimum number of exclamation marks from the start/end of each word in the sentence to make their amount equal on both sides.\n\n### Notes:\n* Words are separated with spaces\n* Each word will include at least 1 letter\n* There will be no exclamation marks in the middle of a word\n\n___\n\n## Examples\n\n```\nremove(\"Hi!\") === \"Hi\"\nremove(\"!Hi! Hi!\") === \"!Hi! Hi\"\nremove(\"!!Hi! !Hi!!\") === \"!Hi! !Hi!\"\nremove(\"!!!!Hi!! !!!!Hi !Hi!!!\") === \"!!Hi!! Hi !Hi!\"\n```\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef removeEqualExclamations (s : String) : String :=\n  sorry\n\ntheorem word_count_preserved (words : List String) (h : words ≠ []) :\n  let text := String.intercalate \" \" words\n  let result := removeEqualExclamations text\n  List.length (text.split (· = ' ')) = List.length (result.split (· = ' '))\n  := by sorry\n\ntheorem preserves_no_exclamation_text (s : String) (h : ∀ c ∈ s.data, c ≠ '!') : \n  removeEqualExclamations s = s := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4864", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\n# Description:\n\nRemove the minimum number of exclamation marks from the start/end of each word in the sentence to make their amount equal on both sides.\n\n### Notes:\n* Words are separated with spaces\n* Each word will include at least 1 letter\n* There will be no exclamation marks in the middle of a word\n\n___\n\n## Examples\n\n```\nremove(\"Hi!\") === \"Hi\"\nremove(\"!Hi! Hi!\") === \"!Hi! Hi\"\nremove(\"!!Hi! !Hi!!\") === \"!Hi! !Hi!\"\nremove(\"!!!!Hi!! !!!!Hi !Hi!!!\") === \"!!Hi!! Hi !Hi!\"\n```\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef removeEqualExclamations (s : String) : String :=\n  sorry\n\ntheorem word_count_preserved (words : List String) (h : words ≠ []) :\n  let text := String.intercalate \" \" words\n  let result := removeEqualExclamations text\n  List.length (text.split (· = ' ')) = List.length (result.split (· = ' '))\n  := by sorry\n\ntheorem preserves_no_exclamation_text (s : String) (h : ∀ c ∈ s.data, c ≠ '!') : \n  removeEqualExclamations s = s := by sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4864"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nImplement a function which multiplies two numbers.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef multiply (x y : Int) : Int := sorry\n\ntheorem multiply_commutative (x y : Int) : multiply x y = multiply y x := sorry\n\ntheorem multiply_identity_right (x : Int) : multiply x 1 = x := sorry\n\ntheorem multiply_zero_right (x : Int) : multiply x 0 = 0 := sorry\n\ntheorem multiply_negative_one (x : Int) : multiply x (-1) = -x := sorry\n\ntheorem multiply_distributive (x y z : Int) :\n  multiply x (y + z) = multiply x y + multiply x z := sorry\n\ntheorem multiply_identity_left (x : Int) : multiply 1 x = x := sorry\n\ntheorem multiply_zero_left (x : Int) : multiply 0 x = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4865", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nImplement a function which multiplies two numbers.\n```\n#####\n\nTo answer this question, you need to replace the 8 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef multiply (x y : Int) : Int := sorry\n\ntheorem multiply_commutative (x y : Int) : multiply x y = multiply y x := sorry\n\ntheorem multiply_identity_right (x : Int) : multiply x 1 = x := sorry\n\ntheorem multiply_zero_right (x : Int) : multiply x 0 = 0 := sorry\n\ntheorem multiply_negative_one (x : Int) : multiply x (-1) = -x := sorry\n\ntheorem multiply_distributive (x y z : Int) :\n  multiply x (y + z) = multiply x y + multiply x z := sorry\n\ntheorem multiply_identity_left (x : Int) : multiply 1 x = x := sorry\n\ntheorem multiply_zero_left (x : Int) : multiply 0 x = 0 := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4865"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nLinked lists are data structures composed of nested or chained objects, each containing a single value and a reference to the next object. \n\nHere's an example of a list:\n\n```python\nclass LinkedList:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n        \nLinkedList(1, LinkedList(2, LinkedList(3)))\n\n```\n\nWrite a function listToArray (or list\\_to\\_array in Python) that converts a list to an array, like this:\n\n```\n[1, 2, 3]\n```\n\nAssume all inputs are valid lists with at least one value. For the purpose of simplicity, all values will be either numbers, strings, or Booleans.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive LinkedList (α : Type)\n  | nil : LinkedList α\n  | cons : α → LinkedList α → LinkedList α\n\ndef list_to_array {α : Type} : LinkedList α → List α\n  | _ => sorry\n\ntheorem list_to_array_preserves_values {α : Type} (l : LinkedList α) :\n  list_to_array l = LinkedList.rec [] (fun head tail arr => head :: arr) l :=\nsorry\n\ntheorem list_to_array_maintains_order {α : Type} [Inhabited α] (l : LinkedList α) :\n  ∀ i < (list_to_array l).length,\n    (list_to_array l).get ⟨i, by sorry⟩ = LinkedList.rec default (fun head tail res => head) l :=\nsorry\n\ntheorem list_to_array_empty {α : Type} :\n  list_to_array (@LinkedList.nil α) = @List.nil α :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4922", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nLinked lists are data structures composed of nested or chained objects, each containing a single value and a reference to the next object. \n\nHere's an example of a list:\n\n```python\nclass LinkedList:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n        \nLinkedList(1, LinkedList(2, LinkedList(3)))\n\n```\n\nWrite a function listToArray (or list\\_to\\_array in Python) that converts a list to an array, like this:\n\n```\n[1, 2, 3]\n```\n\nAssume all inputs are valid lists with at least one value. For the purpose of simplicity, all values will be either numbers, strings, or Booleans.\n```\n#####\n\nTo answer this question, you need to replace the 5 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ninductive LinkedList (α : Type)\n  | nil : LinkedList α\n  | cons : α → LinkedList α → LinkedList α\n\ndef list_to_array {α : Type} : LinkedList α → List α\n  | _ => sorry\n\ntheorem list_to_array_preserves_values {α : Type} (l : LinkedList α) :\n  list_to_array l = LinkedList.rec [] (fun head tail arr => head :: arr) l :=\nsorry\n\ntheorem list_to_array_maintains_order {α : Type} [Inhabited α] (l : LinkedList α) :\n  ∀ i < (list_to_array l).length,\n    (list_to_array l).get ⟨i, by sorry⟩ = LinkedList.rec default (fun head tail res => head) l :=\nsorry\n\ntheorem list_to_array_empty {α : Type} :\n  list_to_array (@LinkedList.nil α) = @List.nil α :=\nsorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4922"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nYou have two arguments: ```string``` - a string of random letters(only lowercase) and ```array``` - an array of strings(feelings). Your task is to return how many specific feelings are in the ```array```. \n\nFor example: \n\n```\nstring -> 'yliausoenvjw'\narray -> ['anger', 'awe', 'joy', 'love', 'grief']\noutput -> '3 feelings.' // 'awe', 'joy', 'love'\n\n\nstring -> 'griefgriefgrief'\narray -> ['anger', 'awe', 'joy', 'love', 'grief']\noutput -> '1 feeling.' // 'grief'\n\n\nstring -> 'abcdkasdfvkadf'\narray -> ['desire', 'joy', 'shame', 'longing', 'fear']\noutput -> '0 feelings.'\n```\n\nIf the feeling can be formed once - plus one to the answer.\n\nIf the feeling can be formed several times from different letters - plus one to the answer.\n\nEeach letter in ```string``` participates in the formation of all feelings. 'angerw' -> 2 feelings: 'anger' and 'awe'.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_feelings (input : String) (feelings : List String) : String :=\n  sorry\n\n\n\ntheorem count_feelings_bounds\n  {input : String}\n  {feelings : List String}\n  (h1 : input.length > 0)\n  (h2 : feelings ≠ [])\n  : let result := count_feelings input feelings\n    let count := String.toNat! (result.take (result.length - (if result.startsWith \"1 \" then 9 else 10)))\n    count ≥ 0 ∧ count ≤ feelings.length :=\n  sorry\n\ntheorem count_feelings_exact_match\n  {feeling : String}\n  (h : feeling.length > 0)\n  : count_feelings feeling [feeling] = \"1 feeling.\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4923", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nYou have two arguments: ```string``` - a string of random letters(only lowercase) and ```array``` - an array of strings(feelings). Your task is to return how many specific feelings are in the ```array```. \n\nFor example: \n\n```\nstring -> 'yliausoenvjw'\narray -> ['anger', 'awe', 'joy', 'love', 'grief']\noutput -> '3 feelings.' // 'awe', 'joy', 'love'\n\n\nstring -> 'griefgriefgrief'\narray -> ['anger', 'awe', 'joy', 'love', 'grief']\noutput -> '1 feeling.' // 'grief'\n\n\nstring -> 'abcdkasdfvkadf'\narray -> ['desire', 'joy', 'shame', 'longing', 'fear']\noutput -> '0 feelings.'\n```\n\nIf the feeling can be formed once - plus one to the answer.\n\nIf the feeling can be formed several times from different letters - plus one to the answer.\n\nEeach letter in ```string``` participates in the formation of all feelings. 'angerw' -> 2 feelings: 'anger' and 'awe'.\n```\n#####\n\nTo answer this question, you need to replace the 3 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\ndef count_feelings (input : String) (feelings : List String) : String :=\n  sorry\n\n\n\ntheorem count_feelings_bounds\n  {input : String}\n  {feelings : List String}\n  (h1 : input.length > 0)\n  (h2 : feelings ≠ [])\n  : let result := count_feelings input feelings\n    let count := String.toNat! (result.take (result.length - (if result.startsWith \"1 \" then 9 else 10)))\n    count ≥ 0 ∧ count ≤ feelings.length :=\n  sorry\n\ntheorem count_feelings_exact_match\n  {feeling : String}\n  (h : feeling.length > 0)\n  : count_feelings feeling [feeling] = \"1 feeling.\" :=\n  sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4923"}}}}
{"data_source": "FVAPPS", "prompt": [{"role": "user", "content": "The question I need to answer in Lean 4 is as follows: \n```\nTeach snoopy and scooby doo how to bark using object methods. \nCurrently only snoopy can bark and not scooby doo. \n\n```python\nsnoopy.bark() #return \"Woof\"\nscoobydoo.bark() #undefined\n```\nUse method prototypes to enable all Dogs to bark.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Dog where\n  breed : String\n  deriving Repr\n\ndef Dog.bark (d : Dog) : String := sorry\n\ntheorem dog_breed_property {breed : String} :\n  (Dog.mk breed).breed = breed := sorry\n\ntheorem dog_bark_property (d : Dog) :\n  d.bark = \"Woof\" := sorry\n\ntheorem dog_state_independence {breed1 breed2 : String} (h : breed1 ≠ breed2) :\n  let d1 := Dog.mk breed1\n  let d2 := Dog.mk breed2\n  d1.breed ≠ d2.breed ∧ d1.bark = d2.bark := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features."}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "4957", "prompt": "The question I need to answer in Lean 4 is as follows: \n```\nTeach snoopy and scooby doo how to bark using object methods. \nCurrently only snoopy can bark and not scooby doo. \n\n```python\nsnoopy.bark() #return \"Woof\"\nscoobydoo.bark() #undefined\n```\nUse method prototypes to enable all Dogs to bark.\n```\n#####\n\nTo answer this question, you need to replace the 4 \"sorry\" keywords in the following Lean spec with Lean proofs that make the resulting Lean executable work: \n```\nstructure Dog where\n  breed : String\n  deriving Repr\n\ndef Dog.bark (d : Dog) : String := sorry\n\ntheorem dog_breed_property {breed : String} :\n  (Dog.mk breed).breed = breed := sorry\n\ntheorem dog_bark_property (d : Dog) :\n  d.bark = \"Woof\" := sorry\n\ntheorem dog_state_independence {breed1 breed2 : String} (h : breed1 ≠ breed2) :\n  let d1 := Dog.mk breed1\n  let d2 := Dog.mk breed2\n  d1.breed ≠ d2.breed ∧ d1.bark = d2.bark := sorry\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features.", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "4957"}}}}
