{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the single number in a non-empty list of integers, where every element appears exactly twice except for one element that appears only once. The function \nshould return the integer that appears only once.\n\n-----Input-----\nThe input is a non-empty list of integers:\n- nums: A list in which each integer appears exactly twice except for one element that appears only once.\n\n-----Output-----\nThe output is a single integer:\nReturns the unique integer that appears exactly once in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem FindSingleNumber_spec_satisfied (nums: List Int) (h_precond : FindSingleNumber_precond (nums)) :\n    FindSingleNumber_postcond (nums) (FindSingleNumber (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef filterlist (x : Int) (nums : List Int) : List Int :=\n  let rec aux (lst : List Int) : List Int :=\n    match lst with\n    | []      => []\n    | y :: ys => if y = x then y :: aux ys else aux ys\n  aux nums\n\n@[reducible]\ndef FindSingleNumber_precond (nums : List Int) : Prop :=\n  let numsCount := nums.map (fun x => nums.count x)\n  numsCount.all (fun count => count = 1 ∨ count = 2) ∧ numsCount.count 1 = 1\n\ndef FindSingleNumber (nums : List Int) (h_precond : FindSingleNumber_precond (nums)) : Int :=\n  let rec findUnique (remaining : List Int) : Int :=\n    match remaining with\n    | [] =>\n      0\n    | x :: xs =>\n      let filtered : List Int :=\n        filterlist x nums\n      let count : Nat :=\n        filtered.length\n      if count = 1 then\n        x\n      else\n        findUnique xs\n  findUnique nums\n\n@[reducible]\ndef FindSingleNumber_postcond (nums : List Int) (result: Int) (h_precond : FindSingleNumber_precond (nums)) : Prop :=\n  (nums.length > 0)\n  ∧\n  ((filterlist result nums).length = 1)\n  ∧\n  (∀ (x : Int),\n    x ∈ nums →\n    (x = result) ∨ ((filterlist x nums).length = 2))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem FindSingleNumber_spec_satisfied (nums: List Int) (h_precond : FindSingleNumber_precond (nums)) :\n    FindSingleNumber_postcond (nums) (FindSingleNumber (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_1", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the single number in a non-empty list of integers, where every element appears exactly twice except for one element that appears only once. The function \nshould return the integer that appears only once.\n\n-----Input-----\nThe input is a non-empty list of integers:\n- nums: A list in which each integer appears exactly twice except for one element that appears only once.\n\n-----Output-----\nThe output is a single integer:\nReturns the unique integer that appears exactly once in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem FindSingleNumber_spec_satisfied (nums: List Int) (h_precond : FindSingleNumber_precond (nums)) :\n    FindSingleNumber_postcond (nums) (FindSingleNumber (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef filterlist (x : Int) (nums : List Int) : List Int :=\n  let rec aux (lst : List Int) : List Int :=\n    match lst with\n    | []      => []\n    | y :: ys => if y = x then y :: aux ys else aux ys\n  aux nums\n\n@[reducible]\ndef FindSingleNumber_precond (nums : List Int) : Prop :=\n  let numsCount := nums.map (fun x => nums.count x)\n  numsCount.all (fun count => count = 1 ∨ count = 2) ∧ numsCount.count 1 = 1\n\ndef FindSingleNumber (nums : List Int) (h_precond : FindSingleNumber_precond (nums)) : Int :=\n  let rec findUnique (remaining : List Int) : Int :=\n    match remaining with\n    | [] =>\n      0\n    | x :: xs =>\n      let filtered : List Int :=\n        filterlist x nums\n      let count : Nat :=\n        filtered.length\n      if count = 1 then\n        x\n      else\n        findUnique xs\n  findUnique nums\n\n@[reducible]\ndef FindSingleNumber_postcond (nums : List Int) (result: Int) (h_precond : FindSingleNumber_precond (nums)) : Prop :=\n  (nums.length > 0)\n  ∧\n  ((filterlist result nums).length = 1)\n  ∧\n  (∀ (x : Int),\n    x ∈ nums →\n    (x = result) ∨ ((filterlist x nums).length = 2))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem FindSingleNumber_spec_satisfied (nums: List Int) (h_precond : FindSingleNumber_precond (nums)) :\n    FindSingleNumber_postcond (nums) (FindSingleNumber (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_1"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nhis task requires writing a Lean 4 method decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:\n\\[ n = \\prod p^e \\]\nIn other words, it determines the exponent e for each prime p.\n\n-----Input-----  \nThe input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.\nn: The natural number to be factorized.  \nprimes: A list of primes to decompose n into.  \n\n-----Output-----  \nThe output is `List (Nat × Nat)`:\nReturn a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findExponents_spec_satisfied (n: Nat) (primes: List Nat) (h_precond : findExponents_precond (n) (primes)) :\n    findExponents_postcond (n) (primes) (findExponents (n) (primes) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.Nat.Prime.Defs\n\n@[reducible]\ndef findExponents_precond (n : Nat) (primes : List Nat) : Prop :=\n  primes.all (fun p => Nat.Prime p)\n\ndef findExponents (n : Nat) (primes : List Nat) (h_precond : findExponents_precond (n) (primes)) : List (Nat × Nat) :=\n  let rec countFactors (n : Nat) (primes : List Nat) : List (Nat × Nat) :=\n    match primes with\n    | [] => []\n    | p :: ps =>\n      let (count, n') :=\n        countFactor n p 0\n      (p, count) :: countFactors n' ps\n\n  countFactors n primes\n  where\n\n  countFactor : Nat → Nat → Nat → Nat × Nat\n  | 0, _, count =>\n    (count, 0)\n  | n, p, count =>\n    if h : n > 0 ∧ p > 1 then\n      have : n / p < n :=\n        Nat.div_lt_self h.1 h.2\n      if n % p == 0 then\n        countFactor (n / p) p (count + 1)\n      else\n        (count, n)\n    else\n      (count, n)\n  termination_by n _ _ => n\n\n@[reducible]\ndef findExponents_postcond (n : Nat) (primes : List Nat) (result: List (Nat × Nat)) (h_precond : findExponents_precond (n) (primes)) : Prop :=\n  (n = result.foldl (fun acc (p, e) => acc * p ^ e) 1) ∧\n  result.all (fun (p, _) => p ∈ primes) ∧\n  primes.all (fun p => result.any (fun pair => pair.1 = p))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findExponents_spec_satisfied (n: Nat) (primes: List Nat) (h_precond : findExponents_precond (n) (primes)) :\n    findExponents_postcond (n) (primes) (findExponents (n) (primes) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_10", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nhis task requires writing a Lean 4 method decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:\n\\[ n = \\prod p^e \\]\nIn other words, it determines the exponent e for each prime p.\n\n-----Input-----  \nThe input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.\nn: The natural number to be factorized.  \nprimes: A list of primes to decompose n into.  \n\n-----Output-----  \nThe output is `List (Nat × Nat)`:\nReturn a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findExponents_spec_satisfied (n: Nat) (primes: List Nat) (h_precond : findExponents_precond (n) (primes)) :\n    findExponents_postcond (n) (primes) (findExponents (n) (primes) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.Nat.Prime.Defs\n\n@[reducible]\ndef findExponents_precond (n : Nat) (primes : List Nat) : Prop :=\n  primes.all (fun p => Nat.Prime p)\n\ndef findExponents (n : Nat) (primes : List Nat) (h_precond : findExponents_precond (n) (primes)) : List (Nat × Nat) :=\n  let rec countFactors (n : Nat) (primes : List Nat) : List (Nat × Nat) :=\n    match primes with\n    | [] => []\n    | p :: ps =>\n      let (count, n') :=\n        countFactor n p 0\n      (p, count) :: countFactors n' ps\n\n  countFactors n primes\n  where\n\n  countFactor : Nat → Nat → Nat → Nat × Nat\n  | 0, _, count =>\n    (count, 0)\n  | n, p, count =>\n    if h : n > 0 ∧ p > 1 then\n      have : n / p < n :=\n        Nat.div_lt_self h.1 h.2\n      if n % p == 0 then\n        countFactor (n / p) p (count + 1)\n      else\n        (count, n)\n    else\n      (count, n)\n  termination_by n _ _ => n\n\n@[reducible]\ndef findExponents_postcond (n : Nat) (primes : List Nat) (result: List (Nat × Nat)) (h_precond : findExponents_precond (n) (primes)) : Prop :=\n  (n = result.foldl (fun acc (p, e) => acc * p ^ e) 1) ∧\n  result.all (fun (p, _) => p ∈ primes) ∧\n  primes.all (fun p => result.any (fun pair => pair.1 = p))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findExponents_spec_satisfied (n: Nat) (primes: List Nat) (h_precond : findExponents_precond (n) (primes)) :\n    findExponents_postcond (n) (primes) (findExponents (n) (primes) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_10"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that finds the **majority element** in a list of integers. A majority element is defined as an element that appears **strictly more than half** the number of times in the list.\n\nIf such an element exists, the method should return that element. Otherwise, it should return `-1`. The implementation must ensure that the result is either the majority element (if one exists) or `-1` (when no such element appears more than ⌊n/2⌋ times).\n\n-----Input-----  \nThe input consists of a list of integers:\n- lst: A list of integers, which may include duplicates and negative numbers. The list may also be empty.\n\n-----Output-----  \nThe output is a single integer:\n- If a majority element exists in the input list, return that element.\n- If no majority element exists, return `-1`.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findMajorityElement_spec_satisfied (lst: List Int) (h_precond : findMajorityElement_precond (lst)) :\n    findMajorityElement_postcond (lst) (findMajorityElement (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef findMajorityElement_precond (lst : List Int) : Prop :=\n  True\n\ndef countOccurrences (n : Int) (lst : List Int) : Nat :=\n  lst.foldl (fun acc x => if x = n then acc + 1 else acc) 0\n\ndef findMajorityElement (lst : List Int) (h_precond : findMajorityElement_precond (lst)) : Int :=\n  let n := lst.length\n  let majority := lst.find? (fun x => countOccurrences x lst > n / 2)\n  match majority with\n  | some x => x\n  | none => -1\n\n@[reducible, simp]\ndef findMajorityElement_postcond (lst : List Int) (result: Int) (h_precond : findMajorityElement_precond (lst)) : Prop :=\n  let count := fun x => (lst.filter (fun y => y = x)).length\n  let n := lst.length\n  let majority := count result > n / 2 ∧ lst.all (fun x => count x ≤ n / 2 ∨ x = result)\n  (result = -1 → lst.all (count · ≤ n / 2) ∨ majority) ∧\n  (result ≠ -1 → majority)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findMajorityElement_spec_satisfied (lst: List Int) (h_precond : findMajorityElement_precond (lst)) :\n    findMajorityElement_postcond (lst) (findMajorityElement (lst) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_11", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that finds the **majority element** in a list of integers. A majority element is defined as an element that appears **strictly more than half** the number of times in the list.\n\nIf such an element exists, the method should return that element. Otherwise, it should return `-1`. The implementation must ensure that the result is either the majority element (if one exists) or `-1` (when no such element appears more than ⌊n/2⌋ times).\n\n-----Input-----  \nThe input consists of a list of integers:\n- lst: A list of integers, which may include duplicates and negative numbers. The list may also be empty.\n\n-----Output-----  \nThe output is a single integer:\n- If a majority element exists in the input list, return that element.\n- If no majority element exists, return `-1`.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findMajorityElement_spec_satisfied (lst: List Int) (h_precond : findMajorityElement_precond (lst)) :\n    findMajorityElement_postcond (lst) (findMajorityElement (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef findMajorityElement_precond (lst : List Int) : Prop :=\n  True\n\ndef countOccurrences (n : Int) (lst : List Int) : Nat :=\n  lst.foldl (fun acc x => if x = n then acc + 1 else acc) 0\n\ndef findMajorityElement (lst : List Int) (h_precond : findMajorityElement_precond (lst)) : Int :=\n  let n := lst.length\n  let majority := lst.find? (fun x => countOccurrences x lst > n / 2)\n  match majority with\n  | some x => x\n  | none => -1\n\n@[reducible, simp]\ndef findMajorityElement_postcond (lst : List Int) (result: Int) (h_precond : findMajorityElement_precond (lst)) : Prop :=\n  let count := fun x => (lst.filter (fun y => y = x)).length\n  let n := lst.length\n  let majority := count result > n / 2 ∧ lst.all (fun x => count x ≤ n / 2 ∨ x = result)\n  (result = -1 → lst.all (count · ≤ n / 2) ∨ majority) ∧\n  (result ≠ -1 → majority)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findMajorityElement_spec_satisfied (lst: List Int) (h_precond : findMajorityElement_precond (lst)) :\n    findMajorityElement_postcond (lst) (findMajorityElement (lst) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_11"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nWrite a Lean 4 function that returns the first duplicate integer found in a list. The function should return the value of the first duplicate it encounters, scanning from left to right. If no duplicates exist, return -1.\n\n-----Input-----\nlst: A list of integers.\n\n-----Output-----\nAn integer representing the first duplicated value if any exists, otherwise -1.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem firstDuplicate_spec_satisfied (lst: List Int) (h_precond : firstDuplicate_precond (lst)) :\n    firstDuplicate_postcond (lst) (firstDuplicate (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef firstDuplicate_precond (lst : List Int) : Prop :=\n  True\n\ndef firstDuplicate (lst : List Int) (h_precond : firstDuplicate_precond (lst)) : Int :=\n  let rec helper (seen : List Int) (rem : List Int) : Int :=\n    match rem with\n    | [] => -1\n    | h :: t => if seen.contains h then h else helper (h :: seen) t\n  helper [] lst\n\n@[reducible]\ndef firstDuplicate_postcond (lst : List Int) (result: Int) (h_precond : firstDuplicate_precond (lst)) : Prop :=\n  (result = -1 → List.Nodup lst) ∧\n  (result ≠ -1 →\n    lst.count result > 1 ∧\n    (lst.filter (fun x => lst.count x > 1)).head? = some result\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem firstDuplicate_spec_satisfied (lst: List Int) (h_precond : firstDuplicate_precond (lst)) :\n    firstDuplicate_postcond (lst) (firstDuplicate (lst) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_12", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nWrite a Lean 4 function that returns the first duplicate integer found in a list. The function should return the value of the first duplicate it encounters, scanning from left to right. If no duplicates exist, return -1.\n\n-----Input-----\nlst: A list of integers.\n\n-----Output-----\nAn integer representing the first duplicated value if any exists, otherwise -1.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem firstDuplicate_spec_satisfied (lst: List Int) (h_precond : firstDuplicate_precond (lst)) :\n    firstDuplicate_postcond (lst) (firstDuplicate (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef firstDuplicate_precond (lst : List Int) : Prop :=\n  True\n\ndef firstDuplicate (lst : List Int) (h_precond : firstDuplicate_precond (lst)) : Int :=\n  let rec helper (seen : List Int) (rem : List Int) : Int :=\n    match rem with\n    | [] => -1\n    | h :: t => if seen.contains h then h else helper (h :: seen) t\n  helper [] lst\n\n@[reducible]\ndef firstDuplicate_postcond (lst : List Int) (result: Int) (h_precond : firstDuplicate_precond (lst)) : Prop :=\n  (result = -1 → List.Nodup lst) ∧\n  (result ≠ -1 →\n    lst.count result > 1 ∧\n    (lst.filter (fun x => lst.count x > 1)).head? = some result\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem firstDuplicate_spec_satisfied (lst: List Int) (h_precond : firstDuplicate_precond (lst)) :\n    firstDuplicate_postcond (lst) (firstDuplicate (lst) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_12"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines whether there are any intersections between chords on a circle. The method should return true if at least one pair of chords intersects, and false otherwise.\n\nA chord is defined as a line segment connecting two distinct points on a circle. Two chords intersect if they cross each other inside the circle. The points are numbered from 1 to 2N in a clockwise direction, where N is the number of chords.\n\nConstraints\n\n\n- 2\\leq N \\leq 2\\times 10^5\n- 1\\leq A_i,B_i \\leq 2N\n- A_1,\\dots,A_N,B_1,\\dots,B_N are all distinct\n- All input values are integers\n\n-----Input-----\nThe input consists of two parameters:\nN: A natural number representing the number of chords (2 ≤ N ≤ 2×10^5).\nchords: A list of N pairs of natural numbers, where each pair represents the endpoints of a chord. All endpoint values are distinct and range from 1 to 2N.\n\n-----Output-----\nThe output is a boolean value:\n- Returns true if there exists at least one pair of intersecting chords.\n- Returns false if no chords intersect.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasChordIntersection_spec_satisfied (N: Nat) (chords: List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) :\n    hasChordIntersection_postcond (N) (chords) (hasChordIntersection (N) (chords) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef hasChordIntersection_precond (N : Nat) (chords : List (List Nat)) : Prop :=\n  N ≥ 2 ∧\n  chords.all (fun chord => chord.length = 2 ∧ chord[0]! ≥ 1 ∧ chord[0]! ≤ 2 * N ∧ chord[1]! ≥ 1 ∧ chord[1]! ≤ 2 * N) ∧\n  List.Nodup (chords.flatMap id)\n\ndef hasChordIntersection (N : Nat) (chords : List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) : Bool :=\n  let sortedChords := chords.map (fun chord =>\n    let a := chord[0]!\n    let b := chord[1]!\n    if a > b then [b, a] else [a, b]\n  )\n\n  let rec checkIntersection (stack : List (List Nat)) (remaining : List (List Nat)) : Bool :=\n    match remaining with\n    | [] => false\n    | chord :: rest =>\n      let a := chord[0]!\n      let b := chord[1]!\n      let newStack := stack.dropWhile (fun c => (c)[1]! < a)\n      match newStack with\n      | [] => checkIntersection (chord :: newStack) rest\n      | top :: _ =>\n        if top[1]! > a && top[1]! < b then\n          true\n        else\n          checkIntersection (chord :: newStack) rest\n\n  let rec insert (x : List Nat) (xs : List (List Nat)) : List (List Nat) :=\n    match xs with\n    | [] => [x]\n    | y :: ys => if x[0]! < y[0]! then x :: xs else y :: insert x ys\n\n  let rec sort (xs : List (List Nat)) : List (List Nat) :=\n    match xs with\n    | [] => []\n    | x :: xs => insert x (sort xs)\n\n  let sortedChords := sort sortedChords\n  checkIntersection [] sortedChords\n\n@[reducible]\ndef hasChordIntersection_postcond (N : Nat) (chords : List (List Nat)) (result: Bool) (h_precond : hasChordIntersection_precond (N) (chords)) : Prop :=\n  let sortedChords := chords.map (fun chord =>\n    let a := chord[0]!\n    let b := chord[1]!\n    if a > b then [b, a] else [a, b]\n  )\n\n  let rec hasIntersection (chord1 : List Nat) (chord2 : List Nat) : Bool :=\n    let a1 := chord1[0]!\n    let b1 := chord1[1]!\n    let a2 := chord2[0]!\n    let b2 := chord2[1]!\n    (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)\n\n  let rec checkAllPairs (chords : List (List Nat)) : Bool :=\n    match chords with\n    | [] => false\n    | x :: xs =>\n      if xs.any (fun y => hasIntersection x y) then true\n      else checkAllPairs xs\n\n  ((List.Pairwise (fun x y => !hasIntersection x y) sortedChords) → ¬ result) ∧\n  ((sortedChords.any (fun x => chords.any (fun y => hasIntersection x y))) → result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasChordIntersection_spec_satisfied (N: Nat) (chords: List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) :\n    hasChordIntersection_postcond (N) (chords) (hasChordIntersection (N) (chords) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_13", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines whether there are any intersections between chords on a circle. The method should return true if at least one pair of chords intersects, and false otherwise.\n\nA chord is defined as a line segment connecting two distinct points on a circle. Two chords intersect if they cross each other inside the circle. The points are numbered from 1 to 2N in a clockwise direction, where N is the number of chords.\n\nConstraints\n\n\n- 2\\leq N \\leq 2\\times 10^5\n- 1\\leq A_i,B_i \\leq 2N\n- A_1,\\dots,A_N,B_1,\\dots,B_N are all distinct\n- All input values are integers\n\n-----Input-----\nThe input consists of two parameters:\nN: A natural number representing the number of chords (2 ≤ N ≤ 2×10^5).\nchords: A list of N pairs of natural numbers, where each pair represents the endpoints of a chord. All endpoint values are distinct and range from 1 to 2N.\n\n-----Output-----\nThe output is a boolean value:\n- Returns true if there exists at least one pair of intersecting chords.\n- Returns false if no chords intersect.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasChordIntersection_spec_satisfied (N: Nat) (chords: List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) :\n    hasChordIntersection_postcond (N) (chords) (hasChordIntersection (N) (chords) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef hasChordIntersection_precond (N : Nat) (chords : List (List Nat)) : Prop :=\n  N ≥ 2 ∧\n  chords.all (fun chord => chord.length = 2 ∧ chord[0]! ≥ 1 ∧ chord[0]! ≤ 2 * N ∧ chord[1]! ≥ 1 ∧ chord[1]! ≤ 2 * N) ∧\n  List.Nodup (chords.flatMap id)\n\ndef hasChordIntersection (N : Nat) (chords : List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) : Bool :=\n  let sortedChords := chords.map (fun chord =>\n    let a := chord[0]!\n    let b := chord[1]!\n    if a > b then [b, a] else [a, b]\n  )\n\n  let rec checkIntersection (stack : List (List Nat)) (remaining : List (List Nat)) : Bool :=\n    match remaining with\n    | [] => false\n    | chord :: rest =>\n      let a := chord[0]!\n      let b := chord[1]!\n      let newStack := stack.dropWhile (fun c => (c)[1]! < a)\n      match newStack with\n      | [] => checkIntersection (chord :: newStack) rest\n      | top :: _ =>\n        if top[1]! > a && top[1]! < b then\n          true\n        else\n          checkIntersection (chord :: newStack) rest\n\n  let rec insert (x : List Nat) (xs : List (List Nat)) : List (List Nat) :=\n    match xs with\n    | [] => [x]\n    | y :: ys => if x[0]! < y[0]! then x :: xs else y :: insert x ys\n\n  let rec sort (xs : List (List Nat)) : List (List Nat) :=\n    match xs with\n    | [] => []\n    | x :: xs => insert x (sort xs)\n\n  let sortedChords := sort sortedChords\n  checkIntersection [] sortedChords\n\n@[reducible]\ndef hasChordIntersection_postcond (N : Nat) (chords : List (List Nat)) (result: Bool) (h_precond : hasChordIntersection_precond (N) (chords)) : Prop :=\n  let sortedChords := chords.map (fun chord =>\n    let a := chord[0]!\n    let b := chord[1]!\n    if a > b then [b, a] else [a, b]\n  )\n\n  let rec hasIntersection (chord1 : List Nat) (chord2 : List Nat) : Bool :=\n    let a1 := chord1[0]!\n    let b1 := chord1[1]!\n    let a2 := chord2[0]!\n    let b2 := chord2[1]!\n    (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)\n\n  let rec checkAllPairs (chords : List (List Nat)) : Bool :=\n    match chords with\n    | [] => false\n    | x :: xs =>\n      if xs.any (fun y => hasIntersection x y) then true\n      else checkAllPairs xs\n\n  ((List.Pairwise (fun x y => !hasIntersection x y) sortedChords) → ¬ result) ∧\n  ((sortedChords.any (fun x => chords.any (fun y => hasIntersection x y))) → result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasChordIntersection_spec_satisfied (N: Nat) (chords: List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) :\n    hasChordIntersection_postcond (N) (chords) (hasChordIntersection (N) (chords) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_13"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a natural number is a power of four. The method should return a boolean value that indicates whether the given natural number is a power of four. An integer n is a power of four, if there exists an natural number x such that n = 4^x. \n\n-----Input-----\nThe input consists of one natural number:\nn: A natural number.\n\n-----Output-----\nThe output is a boolean value:\nReturn a boolean value that indicates whether the given natural number is a power of four. Return \"true\" if it is a power of four. Otherwise, return \"false\". \n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ifPowerOfFour_spec_satisfied (n: Nat) (h_precond : ifPowerOfFour_precond (n)) :\n    ifPowerOfFour_postcond (n) (ifPowerOfFour (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef ifPowerOfFour_precond (n : Nat) : Prop :=\n  True\n\ndef ifPowerOfFour (n : Nat) (h_precond : ifPowerOfFour_precond (n)) : Bool :=\n  let rec helper (n : Nat) : Bool :=\n    match n with\n    | 0 =>\n      false\n    | Nat.succ m =>\n      match m with\n      | 0 =>\n        true\n      | Nat.succ l =>\n        if (l+2)%4=0 then\n          helper ((l+2)/4)\n        else\n          false\n  helper n\n\n@[reducible]\ndef ifPowerOfFour_postcond (n : Nat) (result: Bool) (h_precond : ifPowerOfFour_precond (n)) : Prop :=\n  result ↔ (∃ m:Nat, n=4^m)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ifPowerOfFour_spec_satisfied (n: Nat) (h_precond : ifPowerOfFour_precond (n)) :\n    ifPowerOfFour_postcond (n) (ifPowerOfFour (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_14", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a natural number is a power of four. The method should return a boolean value that indicates whether the given natural number is a power of four. An integer n is a power of four, if there exists an natural number x such that n = 4^x. \n\n-----Input-----\nThe input consists of one natural number:\nn: A natural number.\n\n-----Output-----\nThe output is a boolean value:\nReturn a boolean value that indicates whether the given natural number is a power of four. Return \"true\" if it is a power of four. Otherwise, return \"false\". \n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ifPowerOfFour_spec_satisfied (n: Nat) (h_precond : ifPowerOfFour_precond (n)) :\n    ifPowerOfFour_postcond (n) (ifPowerOfFour (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef ifPowerOfFour_precond (n : Nat) : Prop :=\n  True\n\ndef ifPowerOfFour (n : Nat) (h_precond : ifPowerOfFour_precond (n)) : Bool :=\n  let rec helper (n : Nat) : Bool :=\n    match n with\n    | 0 =>\n      false\n    | Nat.succ m =>\n      match m with\n      | 0 =>\n        true\n      | Nat.succ l =>\n        if (l+2)%4=0 then\n          helper ((l+2)/4)\n        else\n          false\n  helper n\n\n@[reducible]\ndef ifPowerOfFour_postcond (n : Nat) (result: Bool) (h_precond : ifPowerOfFour_precond (n)) : Prop :=\n  result ↔ (∃ m:Nat, n=4^m)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ifPowerOfFour_spec_satisfied (n: Nat) (h_precond : ifPowerOfFour_precond (n)) :\n    ifPowerOfFour_postcond (n) (ifPowerOfFour (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_14"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists a triplet (i, j, k) where i < j < k and nums[i] < nums[j] < nums[k]; otherwise, returns false.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem increasingTriplet_spec_satisfied (nums: List Int) (h_precond : increasingTriplet_precond (nums)) :\n    increasingTriplet_postcond (nums) (increasingTriplet (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef increasingTriplet_precond (nums : List Int) : Prop :=\n  True\n\ndef increasingTriplet (nums : List Int) (h_precond : increasingTriplet_precond (nums)) : Bool :=\n  let rec lengthCheck : List Int → Nat → Nat\n    | [], acc => acc\n    | _ :: rest, acc => lengthCheck rest (acc + 1)\n\n  let len := lengthCheck nums 0\n\n  if len < 3 then\n    false\n  else\n    let rec loop (xs : List Int) (first : Int) (second : Int) : Bool :=\n      match xs with\n      | [] => false\n      | x :: rest =>\n        let nextFirst := if x ≤ first then x else first\n        let nextSecond := if x > first ∧ x ≤ second then x else second\n        if x ≤ first then\n          loop rest nextFirst second\n        else if x ≤ second then\n          loop rest first nextSecond\n        else\n          true  -- found triplet\n    match nums with\n    | [] => false\n    | _ :: rest1 =>\n      match rest1 with\n      | [] => false\n      | _ :: rest2 =>\n        match rest2 with\n        | [] => false\n        | _ =>\n          loop nums 2147483647 2147483647\n\n@[reducible]\ndef increasingTriplet_postcond (nums : List Int) (result: Bool) (h_precond : increasingTriplet_precond (nums)) : Prop :=\n  let nums' := nums.zipIdx\n  (result →\n    nums'.any (fun (x, i) =>\n      nums'.any (fun (y, j) =>\n        nums'.any (fun (z, k) =>\n          i < j ∧ j < k ∧ x < y ∧ y < z\n        )\n      )\n    ))\n  ∧\n  (¬ result → nums'.all (fun (x, i) =>\n    nums'.all (fun (y, j) =>\n      nums'.all (fun (z, k) =>\n        i ≥ j ∨ j ≥ k ∨ x ≥ y ∨ y ≥ z\n      )\n    )\n  ))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem increasingTriplet_spec_satisfied (nums: List Int) (h_precond : increasingTriplet_precond (nums)) :\n    increasingTriplet_postcond (nums) (increasingTriplet (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_15", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists a triplet (i, j, k) where i < j < k and nums[i] < nums[j] < nums[k]; otherwise, returns false.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem increasingTriplet_spec_satisfied (nums: List Int) (h_precond : increasingTriplet_precond (nums)) :\n    increasingTriplet_postcond (nums) (increasingTriplet (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef increasingTriplet_precond (nums : List Int) : Prop :=\n  True\n\ndef increasingTriplet (nums : List Int) (h_precond : increasingTriplet_precond (nums)) : Bool :=\n  let rec lengthCheck : List Int → Nat → Nat\n    | [], acc => acc\n    | _ :: rest, acc => lengthCheck rest (acc + 1)\n\n  let len := lengthCheck nums 0\n\n  if len < 3 then\n    false\n  else\n    let rec loop (xs : List Int) (first : Int) (second : Int) : Bool :=\n      match xs with\n      | [] => false\n      | x :: rest =>\n        let nextFirst := if x ≤ first then x else first\n        let nextSecond := if x > first ∧ x ≤ second then x else second\n        if x ≤ first then\n          loop rest nextFirst second\n        else if x ≤ second then\n          loop rest first nextSecond\n        else\n          true  -- found triplet\n    match nums with\n    | [] => false\n    | _ :: rest1 =>\n      match rest1 with\n      | [] => false\n      | _ :: rest2 =>\n        match rest2 with\n        | [] => false\n        | _ =>\n          loop nums 2147483647 2147483647\n\n@[reducible]\ndef increasingTriplet_postcond (nums : List Int) (result: Bool) (h_precond : increasingTriplet_precond (nums)) : Prop :=\n  let nums' := nums.zipIdx\n  (result →\n    nums'.any (fun (x, i) =>\n      nums'.any (fun (y, j) =>\n        nums'.any (fun (z, k) =>\n          i < j ∧ j < k ∧ x < y ∧ y < z\n        )\n      )\n    ))\n  ∧\n  (¬ result → nums'.all (fun (x, i) =>\n    nums'.all (fun (y, j) =>\n      nums'.all (fun (z, k) =>\n        i ≥ j ∨ j ≥ k ∨ x ≥ y ∨ y ≥ z\n      )\n    )\n  ))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem increasingTriplet_spec_satisfied (nums: List Int) (h_precond : increasingTriplet_precond (nums)) :\n    increasingTriplet_postcond (nums) (increasingTriplet (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_15"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement the insertion sort algorithm in Lean 4. The function takes a single list of integers\nas input and returns a new list that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting list must be sorted in ascending order.\nThe returned list must be a permutation of the input list (i.e., contain exactly the same elements).\n\n-----Input-----\nA single list of integers, denoted as xs.\n\n-----Output-----\nA list of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem insertionSort_spec_satisfied (xs: List Int) (h_precond : insertionSort_precond (xs)) :\n    insertionSort_postcond (xs) (insertionSort (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef insertionSort_precond (xs : List Int) : Prop :=\n  True\n\ndef insertionSort (xs : List Int) (h_precond : insertionSort_precond (xs)) : List Int :=\n    let rec insert (x : Int) (ys : List Int) : List Int :=\n      match ys with\n      | []      => [x]\n      | y :: ys' =>\n        if x <= y then\n          x :: y :: ys'\n        else\n          y :: insert x ys'\n\n    let rec sort (arr : List Int) : List Int :=\n      match arr with\n      | []      => []\n      | x :: xs => insert x (sort xs)\n\n    sort xs\n\n@[reducible]\ndef insertionSort_postcond (xs : List Int) (result: List Int) (h_precond : insertionSort_precond (xs)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm xs result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem insertionSort_spec_satisfied (xs: List Int) (h_precond : insertionSort_precond (xs)) :\n    insertionSort_postcond (xs) (insertionSort (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_16", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement the insertion sort algorithm in Lean 4. The function takes a single list of integers\nas input and returns a new list that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting list must be sorted in ascending order.\nThe returned list must be a permutation of the input list (i.e., contain exactly the same elements).\n\n-----Input-----\nA single list of integers, denoted as xs.\n\n-----Output-----\nA list of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem insertionSort_spec_satisfied (xs: List Int) (h_precond : insertionSort_precond (xs)) :\n    insertionSort_postcond (xs) (insertionSort (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef insertionSort_precond (xs : List Int) : Prop :=\n  True\n\ndef insertionSort (xs : List Int) (h_precond : insertionSort_precond (xs)) : List Int :=\n    let rec insert (x : Int) (ys : List Int) : List Int :=\n      match ys with\n      | []      => [x]\n      | y :: ys' =>\n        if x <= y then\n          x :: y :: ys'\n        else\n          y :: insert x ys'\n\n    let rec sort (arr : List Int) : List Int :=\n      match arr with\n      | []      => []\n      | x :: xs => insert x (sort xs)\n\n    sort xs\n\n@[reducible]\ndef insertionSort_postcond (xs : List Int) (result: List Int) (h_precond : insertionSort_precond (xs)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm xs result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem insertionSort_spec_satisfied (xs: List Int) (h_precond : insertionSort_precond (xs)) :\n    insertionSort_postcond (xs) (insertionSort (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_16"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing the insertion sort algorithm to sort a list of integers in ascending order. The function should take a list of integers as input and return a new list containing the same elements sorted in non-decreasing order.\n\n-----Input----- \nThe input is:\n\nl: A list of integers to be sorted.\n\n-----Output----- \nThe output is:\n\nA list of integers that is sorted in non-decreasing order and is a permutation of the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem insertionSort_spec_satisfied (l: List Int) (h_precond : insertionSort_precond (l)) :\n    insertionSort_postcond (l) (insertionSort (l) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef insertionSort_precond (l : List Int) : Prop :=\n  True\n\ndef insertElement (x : Int) (l : List Int) : List Int :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n      if x <= y then\n        x :: y :: ys\n      else\n        y :: insertElement x ys\n\ndef sortList (l : List Int) : List Int :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      insertElement x (sortList xs)\n\ndef insertionSort (l : List Int) (h_precond : insertionSort_precond (l)) : List Int :=\n  let result := sortList l\n  result\n\n@[reducible]\ndef insertionSort_postcond (l : List Int) (result: List Int) (h_precond : insertionSort_precond (l)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm l result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem insertionSort_spec_satisfied (l: List Int) (h_precond : insertionSort_precond (l)) :\n    insertionSort_postcond (l) (insertionSort (l) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_17", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing the insertion sort algorithm to sort a list of integers in ascending order. The function should take a list of integers as input and return a new list containing the same elements sorted in non-decreasing order.\n\n-----Input----- \nThe input is:\n\nl: A list of integers to be sorted.\n\n-----Output----- \nThe output is:\n\nA list of integers that is sorted in non-decreasing order and is a permutation of the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem insertionSort_spec_satisfied (l: List Int) (h_precond : insertionSort_precond (l)) :\n    insertionSort_postcond (l) (insertionSort (l) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef insertionSort_precond (l : List Int) : Prop :=\n  True\n\ndef insertElement (x : Int) (l : List Int) : List Int :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n      if x <= y then\n        x :: y :: ys\n      else\n        y :: insertElement x ys\n\ndef sortList (l : List Int) : List Int :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      insertElement x (sortList xs)\n\ndef insertionSort (l : List Int) (h_precond : insertionSort_precond (l)) : List Int :=\n  let result := sortList l\n  result\n\n@[reducible]\ndef insertionSort_postcond (l : List Int) (result: List Int) (h_precond : insertionSort_precond (l)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm l result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem insertionSort_spec_satisfied (l: List Int) (h_precond : insertionSort_precond (l)) :\n    insertionSort_postcond (l) (insertionSort (l) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_17"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given number `n` is an Armstrong number (also known as a Narcissistic number). An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits.\n\n-----Input-----\nThe input consists of one natural number:\n- `n: Nat`: The number to check if it satisfies the Armstrong property.\n\n-----Output-----\nThe output is a boolean value:\n- `Bool`: Return `true` if `n` is an Armstrong number, otherwise return `false`.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isArmstrong_spec_satisfied (n: Nat) (h_precond : isArmstrong_precond (n)) :\n    isArmstrong_postcond (n) (isArmstrong (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef countDigits (n : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else go (n / 10) (acc + 1)\n  go n (if n = 0 then 1 else 0)\n\n@[reducible]\ndef isArmstrong_precond (n : Nat) : Prop :=\n  True\n\ndef sumPowers (n : Nat) (k : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else\n      let digit := n % 10\n      go (n / 10) (acc + digit ^ k)\n  go n 0\n\ndef isArmstrong (n : Nat) (h_precond : isArmstrong_precond (n)) : Bool :=\n  let k := countDigits n\n  sumPowers n k = n\n\n@[reducible]\ndef isArmstrong_postcond (n : Nat) (result: Bool) (h_precond : isArmstrong_precond (n)) : Prop :=\n  let n' := List.foldl (fun acc d => acc + d ^ countDigits n) 0 (List.map (fun c => c.toNat - '0'.toNat) (toString n).toList)\n  (result → (n = n')) ∧\n  (¬ result → (n ≠ n'))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isArmstrong_spec_satisfied (n: Nat) (h_precond : isArmstrong_precond (n)) :\n    isArmstrong_postcond (n) (isArmstrong (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_18", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given number `n` is an Armstrong number (also known as a Narcissistic number). An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits.\n\n-----Input-----\nThe input consists of one natural number:\n- `n: Nat`: The number to check if it satisfies the Armstrong property.\n\n-----Output-----\nThe output is a boolean value:\n- `Bool`: Return `true` if `n` is an Armstrong number, otherwise return `false`.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isArmstrong_spec_satisfied (n: Nat) (h_precond : isArmstrong_precond (n)) :\n    isArmstrong_postcond (n) (isArmstrong (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef countDigits (n : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else go (n / 10) (acc + 1)\n  go n (if n = 0 then 1 else 0)\n\n@[reducible]\ndef isArmstrong_precond (n : Nat) : Prop :=\n  True\n\ndef sumPowers (n : Nat) (k : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else\n      let digit := n % 10\n      go (n / 10) (acc + digit ^ k)\n  go n 0\n\ndef isArmstrong (n : Nat) (h_precond : isArmstrong_precond (n)) : Bool :=\n  let k := countDigits n\n  sumPowers n k = n\n\n@[reducible]\ndef isArmstrong_postcond (n : Nat) (result: Bool) (h_precond : isArmstrong_precond (n)) : Prop :=\n  let n' := List.foldl (fun acc d => acc + d ^ countDigits n) 0 (List.map (fun c => c.toNat - '0'.toNat) (toString n).toList)\n  (result → (n = n')) ∧\n  (¬ result → (n ≠ n'))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isArmstrong_spec_satisfied (n: Nat) (h_precond : isArmstrong_precond (n)) :\n    isArmstrong_postcond (n) (isArmstrong (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_18"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function should ignore whitespace, punctuation, and capitalization when checking for palindromes.\n\n-----Input-----\nThe input consists of:\ns: A string to be checked.\n\n-----Output-----\nThe output is a boolean:\nReturns true if the input string is a palindrome when non-alphabetic characters are removed and letters are treated case-insensitively, and false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isCleanPalindrome_spec_satisfied (s: String) (h_precond : isCleanPalindrome_precond (s)) :\n    isCleanPalindrome_postcond (s) (isCleanPalindrome (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isUpperAlpha (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\ndef isLowerAlpha (c : Char) : Bool :=\n  'a' ≤ c ∧ c ≤ 'z'\n\ndef isAlpha (c : Char) : Bool :=\n  isUpperAlpha c ∨ isLowerAlpha c\n\ndef toLower (c : Char) : Char :=\n  if isUpperAlpha c then Char.ofNat (c.toNat + 32) else c\n\ndef normalizeChar (c : Char) : Option Char :=\n  if isAlpha c then some (toLower c) else none\n\ndef normalizeString (s : String) : List Char :=\n  s.toList.foldr (fun c acc =>\n    match normalizeChar c with\n    | some c' => c' :: acc\n    | none    => acc\n  ) []\n\n@[reducible]\ndef isCleanPalindrome_precond (s : String) : Prop :=\n  True\n\ndef reverseList (xs : List Char) : List Char :=\n  xs.reverse\n\ndef isCleanPalindrome (s : String) (h_precond : isCleanPalindrome_precond (s)) : Bool :=\n  let norm := normalizeString s\n  norm = reverseList norm\n\n@[reducible]\ndef isCleanPalindrome_postcond (s : String) (result: Bool) (h_precond : isCleanPalindrome_precond (s)) : Prop :=\n  let norm := normalizeString s\n  (result = true → norm = norm.reverse) ∧\n  (result = false → norm ≠ norm.reverse)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isCleanPalindrome_spec_satisfied (s: String) (h_precond : isCleanPalindrome_precond (s)) :\n    isCleanPalindrome_postcond (s) (isCleanPalindrome (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_19", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function should ignore whitespace, punctuation, and capitalization when checking for palindromes.\n\n-----Input-----\nThe input consists of:\ns: A string to be checked.\n\n-----Output-----\nThe output is a boolean:\nReturns true if the input string is a palindrome when non-alphabetic characters are removed and letters are treated case-insensitively, and false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isCleanPalindrome_spec_satisfied (s: String) (h_precond : isCleanPalindrome_precond (s)) :\n    isCleanPalindrome_postcond (s) (isCleanPalindrome (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isUpperAlpha (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\ndef isLowerAlpha (c : Char) : Bool :=\n  'a' ≤ c ∧ c ≤ 'z'\n\ndef isAlpha (c : Char) : Bool :=\n  isUpperAlpha c ∨ isLowerAlpha c\n\ndef toLower (c : Char) : Char :=\n  if isUpperAlpha c then Char.ofNat (c.toNat + 32) else c\n\ndef normalizeChar (c : Char) : Option Char :=\n  if isAlpha c then some (toLower c) else none\n\ndef normalizeString (s : String) : List Char :=\n  s.toList.foldr (fun c acc =>\n    match normalizeChar c with\n    | some c' => c' :: acc\n    | none    => acc\n  ) []\n\n@[reducible]\ndef isCleanPalindrome_precond (s : String) : Prop :=\n  True\n\ndef reverseList (xs : List Char) : List Char :=\n  xs.reverse\n\ndef isCleanPalindrome (s : String) (h_precond : isCleanPalindrome_precond (s)) : Bool :=\n  let norm := normalizeString s\n  norm = reverseList norm\n\n@[reducible]\ndef isCleanPalindrome_postcond (s : String) (result: Bool) (h_precond : isCleanPalindrome_precond (s)) : Prop :=\n  let norm := normalizeString s\n  (result = true → norm = norm.reverse) ∧\n  (result = false → norm ≠ norm.reverse)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isCleanPalindrome_spec_satisfied (s: String) (h_precond : isCleanPalindrome_precond (s)) :\n    isCleanPalindrome_postcond (s) (isCleanPalindrome (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_19"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the logest common subsequence of two input arrays.\n\n-----Input-----\nThe input consists of two arrays:\na: The first array.\nb: The second array.\n\n\n-----Output-----\nThe output is an integer:\nReturns the length of array a and b's longest common subsequence.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LongestCommonSubsequence_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef intMax (x y : Int) : Int :=\n  if x < y then y else x\n\ndef LongestCommonSubsequence (a : Array Int) (b : Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Int :=\n  let m := a.size\n  let n := b.size\n\n  let dp := Id.run do\n    let mut dp := Array.mkArray (m + 1) (Array.mkArray (n + 1) 0)\n    for i in List.range (m + 1) do\n      for j in List.range (n + 1) do\n        if i = 0 ∨ j = 0 then\n          ()\n        else if a[i - 1]! = b[j - 1]! then\n          let newVal := ((dp[i - 1]!)[j - 1]!) + 1\n          dp := dp.set! i (dp[i]!.set! j newVal)\n        else\n          let newVal := intMax ((dp[i - 1]!)[j]!) ((dp[i]!)[j - 1]!)\n          dp := dp.set! i (dp[i]!.set! j newVal)\n    return dp\n  (dp[m]!)[n]!\n\n@[reducible, simp]\ndef LongestCommonSubsequence_postcond (a : Array Int) (b : Array Int) (result: Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Prop :=\n  let allSubseq (arr : Array Int) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq a\n  let subseqB := allSubseq b\n  let commonSubseqLens := subseqA.filter (fun l => subseqB.contains l) |>.map (·.length)\n  commonSubseqLens.contains result ∧ commonSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_2", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the logest common subsequence of two input arrays.\n\n-----Input-----\nThe input consists of two arrays:\na: The first array.\nb: The second array.\n\n\n-----Output-----\nThe output is an integer:\nReturns the length of array a and b's longest common subsequence.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LongestCommonSubsequence_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef intMax (x y : Int) : Int :=\n  if x < y then y else x\n\ndef LongestCommonSubsequence (a : Array Int) (b : Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Int :=\n  let m := a.size\n  let n := b.size\n\n  let dp := Id.run do\n    let mut dp := Array.mkArray (m + 1) (Array.mkArray (n + 1) 0)\n    for i in List.range (m + 1) do\n      for j in List.range (n + 1) do\n        if i = 0 ∨ j = 0 then\n          ()\n        else if a[i - 1]! = b[j - 1]! then\n          let newVal := ((dp[i - 1]!)[j - 1]!) + 1\n          dp := dp.set! i (dp[i]!.set! j newVal)\n        else\n          let newVal := intMax ((dp[i - 1]!)[j]!) ((dp[i]!)[j - 1]!)\n          dp := dp.set! i (dp[i]!.set! j newVal)\n    return dp\n  (dp[m]!)[n]!\n\n@[reducible, simp]\ndef LongestCommonSubsequence_postcond (a : Array Int) (b : Array Int) (result: Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Prop :=\n  let allSubseq (arr : Array Int) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq a\n  let subseqB := allSubseq b\n  let commonSubseqLens := subseqA.filter (fun l => subseqB.contains l) |>.map (·.length)\n  commonSubseqLens.contains result ∧ commonSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_2"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that returns true if the input n is divisible by 8 or has 8 as one of it's digits.\n\n-----Input-----\nThe input consists of one integer:\nn: The main integer.\n\n-----Output-----\nThe output is an boolean:\nReturns true if the input is divisible by 8 or has 8 as one of it's digits.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isItEight_spec_satisfied (n: Int) (h_precond : isItEight_precond (n)) :\n    isItEight_postcond (n) (isItEight (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef isItEight_precond (n : Int) : Prop :=\n  True\n\ndef isItEight (n : Int) (h_precond : isItEight_precond (n)) : Bool :=\n  let rec hasDigitEight (m : Nat) : Bool :=\n    if m <= 0 then false\n    else if m % 10 == 8 then true\n    else hasDigitEight (m / 10)\n    termination_by m\n\n  let absN := Int.natAbs n\n  n % 8 == 0 || hasDigitEight absN\n\n@[reducible]\ndef isItEight_postcond (n : Int) (result: Bool) (h_precond : isItEight_precond (n)) : Prop :=\n  let absN := Int.natAbs n;\n  (n % 8 == 0 ∨ ∃ i, absN / (10^i) % 10 == 8) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isItEight_spec_satisfied (n: Int) (h_precond : isItEight_precond (n)) :\n    isItEight_postcond (n) (isItEight (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_20", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that returns true if the input n is divisible by 8 or has 8 as one of it's digits.\n\n-----Input-----\nThe input consists of one integer:\nn: The main integer.\n\n-----Output-----\nThe output is an boolean:\nReturns true if the input is divisible by 8 or has 8 as one of it's digits.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isItEight_spec_satisfied (n: Int) (h_precond : isItEight_precond (n)) :\n    isItEight_postcond (n) (isItEight (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef isItEight_precond (n : Int) : Prop :=\n  True\n\ndef isItEight (n : Int) (h_precond : isItEight_precond (n)) : Bool :=\n  let rec hasDigitEight (m : Nat) : Bool :=\n    if m <= 0 then false\n    else if m % 10 == 8 then true\n    else hasDigitEight (m / 10)\n    termination_by m\n\n  let absN := Int.natAbs n\n  n % 8 == 0 || hasDigitEight absN\n\n@[reducible]\ndef isItEight_postcond (n : Int) (result: Bool) (h_precond : isItEight_precond (n)) : Prop :=\n  let absN := Int.natAbs n;\n  (n % 8 == 0 ∨ ∃ i, absN / (10^i) % 10 == 8) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isItEight_spec_satisfied (n: Int) (h_precond : isItEight_precond (n)) :\n    isItEight_postcond (n) (isItEight (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_20"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement a Lean 4 function that checks if a given string is a palindrome. A string is considered a palindrome\nif it reads the same forward and backward.\n\n-----Input-----\nThe input consists of a single string:\ns: A string\n\n-----Output-----\nThe output is a boolean:\nReturns true if s is a palindrome, false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPalindrome_spec_satisfied (s: String) (h_precond : isPalindrome_precond (s)) :\n    isPalindrome_postcond (s) (isPalindrome (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isPalindrome_precond (s : String) : Prop :=\n  True\n\ndef isPalindrome (s : String) (h_precond : isPalindrome_precond (s)) : Bool :=\n  let length := s.length\n\nif length <= 1 then\n  true\nelse\n  let arr := s.toList\n\n  let rec checkIndices (left : Nat) (right : Nat) (chars : List Char) : Bool :=\n    if left >= right then\n      true\n    else\n      match chars[left]?, chars[right]? with\n      | some cLeft, some cRight =>\n        if cLeft == cRight then\n          checkIndices (left + 1) (right - 1) chars\n        else\n          false\n      | _, _ => false\n  let approach1 := checkIndices 0 (length - 1) arr\n\n  let rec reverseList (acc : List Char) (xs : List Char) : List Char :=\n    match xs with\n    | []      => acc\n    | h :: t  => reverseList (h :: acc) t\n  let reversed := reverseList [] arr\n  let approach2 := (arr == reversed)\n\n  approach1 && approach2\n\n@[reducible, simp]\ndef isPalindrome_postcond (s : String) (result: Bool) (h_precond : isPalindrome_precond (s)) : Prop :=\n  (result → (s.toList == s.toList.reverse)) ∧\n  (¬ result → (s.toList ≠ [] ∧ s.toList != s.toList.reverse))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPalindrome_spec_satisfied (s: String) (h_precond : isPalindrome_precond (s)) :\n    isPalindrome_postcond (s) (isPalindrome (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_21", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement a Lean 4 function that checks if a given string is a palindrome. A string is considered a palindrome\nif it reads the same forward and backward.\n\n-----Input-----\nThe input consists of a single string:\ns: A string\n\n-----Output-----\nThe output is a boolean:\nReturns true if s is a palindrome, false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPalindrome_spec_satisfied (s: String) (h_precond : isPalindrome_precond (s)) :\n    isPalindrome_postcond (s) (isPalindrome (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isPalindrome_precond (s : String) : Prop :=\n  True\n\ndef isPalindrome (s : String) (h_precond : isPalindrome_precond (s)) : Bool :=\n  let length := s.length\n\nif length <= 1 then\n  true\nelse\n  let arr := s.toList\n\n  let rec checkIndices (left : Nat) (right : Nat) (chars : List Char) : Bool :=\n    if left >= right then\n      true\n    else\n      match chars[left]?, chars[right]? with\n      | some cLeft, some cRight =>\n        if cLeft == cRight then\n          checkIndices (left + 1) (right - 1) chars\n        else\n          false\n      | _, _ => false\n  let approach1 := checkIndices 0 (length - 1) arr\n\n  let rec reverseList (acc : List Char) (xs : List Char) : List Char :=\n    match xs with\n    | []      => acc\n    | h :: t  => reverseList (h :: acc) t\n  let reversed := reverseList [] arr\n  let approach2 := (arr == reversed)\n\n  approach1 && approach2\n\n@[reducible, simp]\ndef isPalindrome_postcond (s : String) (result: Bool) (h_precond : isPalindrome_precond (s)) : Prop :=\n  (result → (s.toList == s.toList.reverse)) ∧\n  (¬ result → (s.toList ≠ [] ∧ s.toList != s.toList.reverse))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPalindrome_spec_satisfied (s: String) (h_precond : isPalindrome_precond (s)) :\n    isPalindrome_postcond (s) (isPalindrome (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_21"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a list of integers follows a peak-valley pattern.\n\nA list follows this pattern if:\nA. It strictly increases at first,\nB. Then strictly decreases,\nC. Both parts are non-empty.\n\nExamples:\n- [1, 3, 5, 4, 2] -> true\n- [1, 2, 3] -> false\n- [5, 4, 3] -> false\n- [1, 2, 2, 1] -> false\n\n-----Input-----\nThe input consists of a list of integers:\n\n-----Output-----\nThe output is an integer:\nReturns true if the list has a peak-valley structure, false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPeakValley_spec_satisfied (lst: List Int) (h_precond : isPeakValley_precond (lst)) :\n    isPeakValley_postcond (lst) (isPeakValley (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isPeakValley_precond (lst : List Int) : Prop :=\n  True\n\ndef isPeakValley (lst : List Int) (h_precond : isPeakValley_precond (lst)) : Bool :=\n  let rec aux (l : List Int) (increasing : Bool) (startedDecreasing : Bool) : Bool :=\n    match l with\n    | x :: y :: rest =>\n      if x < y then\n        if startedDecreasing then false\n        else aux (y :: rest) true startedDecreasing\n      else if x > y then\n        if increasing then aux (y :: rest) increasing true\n        else false\n      else false\n    | _ => increasing && startedDecreasing\n  aux lst false false\n\n@[reducible, simp]\ndef isPeakValley_postcond (lst : List Int) (result: Bool) (h_precond : isPeakValley_precond (lst)) : Prop :=\n  let len := lst.length\n  let validPeaks :=\n    List.range len |>.filter (fun p =>\n      1 ≤ p ∧ p < len - 1 ∧\n\n      (List.range p).all (fun i =>\n        lst[i]! < lst[i + 1]!\n      ) ∧\n\n      (List.range (len - 1 - p)).all (fun i =>\n        lst[p + i]! > lst[p + i + 1]!\n      )\n    )\n  (validPeaks != [] → result) ∧\n  (validPeaks.length = 0 → ¬ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPeakValley_spec_satisfied (lst: List Int) (h_precond : isPeakValley_precond (lst)) :\n    isPeakValley_postcond (lst) (isPeakValley (lst) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_22", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a list of integers follows a peak-valley pattern.\n\nA list follows this pattern if:\nA. It strictly increases at first,\nB. Then strictly decreases,\nC. Both parts are non-empty.\n\nExamples:\n- [1, 3, 5, 4, 2] -> true\n- [1, 2, 3] -> false\n- [5, 4, 3] -> false\n- [1, 2, 2, 1] -> false\n\n-----Input-----\nThe input consists of a list of integers:\n\n-----Output-----\nThe output is an integer:\nReturns true if the list has a peak-valley structure, false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPeakValley_spec_satisfied (lst: List Int) (h_precond : isPeakValley_precond (lst)) :\n    isPeakValley_postcond (lst) (isPeakValley (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isPeakValley_precond (lst : List Int) : Prop :=\n  True\n\ndef isPeakValley (lst : List Int) (h_precond : isPeakValley_precond (lst)) : Bool :=\n  let rec aux (l : List Int) (increasing : Bool) (startedDecreasing : Bool) : Bool :=\n    match l with\n    | x :: y :: rest =>\n      if x < y then\n        if startedDecreasing then false\n        else aux (y :: rest) true startedDecreasing\n      else if x > y then\n        if increasing then aux (y :: rest) increasing true\n        else false\n      else false\n    | _ => increasing && startedDecreasing\n  aux lst false false\n\n@[reducible, simp]\ndef isPeakValley_postcond (lst : List Int) (result: Bool) (h_precond : isPeakValley_precond (lst)) : Prop :=\n  let len := lst.length\n  let validPeaks :=\n    List.range len |>.filter (fun p =>\n      1 ≤ p ∧ p < len - 1 ∧\n\n      (List.range p).all (fun i =>\n        lst[i]! < lst[i + 1]!\n      ) ∧\n\n      (List.range (len - 1 - p)).all (fun i =>\n        lst[p + i]! > lst[p + i + 1]!\n      )\n    )\n  (validPeaks != [] → result) ∧\n  (validPeaks.length = 0 → ¬ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPeakValley_spec_satisfied (lst: List Int) (h_precond : isPeakValley_precond (lst)) :\n    isPeakValley_postcond (lst) (isPeakValley (lst) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_22"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given integer is a power of two.\nAn integer n is a power of two if there exists an integer x such that n = 2^x.\nThe method should return true if n is a power of two, and false otherwise.\nNote that negative numbers and zero are not powers of two.\n\n-----Input-----\nThe input consists of one integer:\nn: The integer to be tested.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists an integer x such that n = 2^x (with n > 0), otherwise false.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPowerOfTwo_spec_satisfied (n: Int) (h_precond : isPowerOfTwo_precond (n)) :\n    isPowerOfTwo_postcond (n) (isPowerOfTwo (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef isPowerOfTwo_precond (n : Int) : Prop :=\n  True\n\ndef isPowerOfTwo (n : Int) (h_precond : isPowerOfTwo_precond (n)) : Bool :=\n  if n <= 0 then false\n  else\n    let rec aux (m : Int) (fuel : Nat) : Bool :=\n      if fuel = 0 then false\n      else if m = 1 then true\n      else if m % 2 ≠ 0 then false\n      else aux (m / 2) (fuel - 1)\n    aux n n.natAbs\n\ndef pow (base : Int) (exp : Nat) : Int :=\n  match exp with\n  | 0 => 1\n  | n+1 => base * pow base n\n\n@[reducible]\ndef isPowerOfTwo_postcond (n : Int) (result: Bool) (h_precond : isPowerOfTwo_precond (n)) : Prop :=\n  if result then ∃ (x : Nat), (pow 2 x = n) ∧ (n > 0)\n  else ¬ (∃ (x : Nat), (pow 2 x = n) ∧ (n > 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPowerOfTwo_spec_satisfied (n: Int) (h_precond : isPowerOfTwo_precond (n)) :\n    isPowerOfTwo_postcond (n) (isPowerOfTwo (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_23", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given integer is a power of two.\nAn integer n is a power of two if there exists an integer x such that n = 2^x.\nThe method should return true if n is a power of two, and false otherwise.\nNote that negative numbers and zero are not powers of two.\n\n-----Input-----\nThe input consists of one integer:\nn: The integer to be tested.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists an integer x such that n = 2^x (with n > 0), otherwise false.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPowerOfTwo_spec_satisfied (n: Int) (h_precond : isPowerOfTwo_precond (n)) :\n    isPowerOfTwo_postcond (n) (isPowerOfTwo (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef isPowerOfTwo_precond (n : Int) : Prop :=\n  True\n\ndef isPowerOfTwo (n : Int) (h_precond : isPowerOfTwo_precond (n)) : Bool :=\n  if n <= 0 then false\n  else\n    let rec aux (m : Int) (fuel : Nat) : Bool :=\n      if fuel = 0 then false\n      else if m = 1 then true\n      else if m % 2 ≠ 0 then false\n      else aux (m / 2) (fuel - 1)\n    aux n n.natAbs\n\ndef pow (base : Int) (exp : Nat) : Int :=\n  match exp with\n  | 0 => 1\n  | n+1 => base * pow base n\n\n@[reducible]\ndef isPowerOfTwo_postcond (n : Int) (result: Bool) (h_precond : isPowerOfTwo_precond (n)) : Prop :=\n  if result then ∃ (x : Nat), (pow 2 x = n) ∧ (n > 0)\n  else ¬ (∃ (x : Nat), (pow 2 x = n) ∧ (n > 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPowerOfTwo_spec_satisfied (n: Int) (h_precond : isPowerOfTwo_precond (n)) :\n    isPowerOfTwo_postcond (n) (isPowerOfTwo (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_23"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines the length of the longest strictly increasing subsequence in a given array of integers.\n\nA subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The subsequence must be strictly increasing, meaning each element must be greater than the one before it.\n\nThe goal is to find the length of the longest such subsequence that can be formed from the input array.\n\n-----Input-----\nThe input consists of one array:\n\nnums: An array of integers where nums[i] represents the ith element of the input sequence.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest strictly increasing subsequence in the input array.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef lengthOfLIS_precond (nums : List Int) : Prop :=\n  True\n\ndef lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Int :=\n  let rec lisHelper (dp : List Int) (x : Int) : List Int :=\n    let rec replace (l : List Int) (acc : List Int) : List Int :=\n      match l with\n      | [] => (acc.reverse ++ [x])\n      | y :: ys => if x ≤ y then acc.reverse ++ (x :: ys) else replace ys (y :: acc)\n    replace dp []\n\n  let finalDP := nums.foldl lisHelper []\n  finalDP.length\n\n@[reducible, simp]\ndef lengthOfLIS_postcond (nums : List Int) (result: Int) (h_precond : lengthOfLIS_precond (nums)) : Prop :=\n  let rec isStrictlyIncreasing (l : List Int) : Bool :=\n    match l with\n    | [] | [_] => true\n    | x :: y :: rest => x < y && isStrictlyIncreasing (y :: rest)\n\n  let rec subsequences (xs : List Int) : List (List Int) :=\n    match xs with\n    | [] => [[]]\n    | x :: xs' =>\n      let rest := subsequences xs'\n      rest ++ rest.map (fun r => x :: r)\n\n  let allIncreasing := subsequences nums |>.filter (fun l => isStrictlyIncreasing l)\n\n  allIncreasing.any (fun l => l.length = result) ∧\n  allIncreasing.all (fun l => l.length ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_24", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines the length of the longest strictly increasing subsequence in a given array of integers.\n\nA subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The subsequence must be strictly increasing, meaning each element must be greater than the one before it.\n\nThe goal is to find the length of the longest such subsequence that can be formed from the input array.\n\n-----Input-----\nThe input consists of one array:\n\nnums: An array of integers where nums[i] represents the ith element of the input sequence.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest strictly increasing subsequence in the input array.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef lengthOfLIS_precond (nums : List Int) : Prop :=\n  True\n\ndef lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Int :=\n  let rec lisHelper (dp : List Int) (x : Int) : List Int :=\n    let rec replace (l : List Int) (acc : List Int) : List Int :=\n      match l with\n      | [] => (acc.reverse ++ [x])\n      | y :: ys => if x ≤ y then acc.reverse ++ (x :: ys) else replace ys (y :: acc)\n    replace dp []\n\n  let finalDP := nums.foldl lisHelper []\n  finalDP.length\n\n@[reducible, simp]\ndef lengthOfLIS_postcond (nums : List Int) (result: Int) (h_precond : lengthOfLIS_precond (nums)) : Prop :=\n  let rec isStrictlyIncreasing (l : List Int) : Bool :=\n    match l with\n    | [] | [_] => true\n    | x :: y :: rest => x < y && isStrictlyIncreasing (y :: rest)\n\n  let rec subsequences (xs : List Int) : List (List Int) :=\n    match xs with\n    | [] => [[]]\n    | x :: xs' =>\n      let rest := subsequences xs'\n      rest ++ rest.map (fun r => x :: r)\n\n  let allIncreasing := subsequences nums |>.filter (fun l => isStrictlyIncreasing l)\n\n  allIncreasing.any (fun l => l.length = result) ∧\n  allIncreasing.all (fun l => l.length ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_24"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing a Lean 4 method that finds the length of the longest strictly increasing subsequence in an array of integers. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\n\n-----Input-----\nThe input consists of one parameter:\nnums: A list of integers representing the input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest strictly increasing subsequence in the input array. \n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible]\ndef lengthOfLIS_precond (nums : List Int) : Prop :=\n  True\n\ndef maxInArray (arr : Array Nat) : Nat :=\n  arr.foldl (fun a b => if a ≥ b then a else b) 0\n\ndef lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Nat :=\n  if nums.isEmpty then 0\n  else\n    let n := nums.length\n    Id.run do\n      let mut dp : Array Nat := Array.mkArray n 1\n\n      for i in [1:n] do\n        for j in [0:i] do\n          if nums[j]! < nums[i]! && dp[j]! + 1 > dp[i]! then\n            dp := dp.set! i (dp[j]! + 1)\n\n      maxInArray dp\n\n@[reducible]\ndef lengthOfLIS_postcond (nums : List Int) (result: Nat) (h_precond : lengthOfLIS_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_25", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing a Lean 4 method that finds the length of the longest strictly increasing subsequence in an array of integers. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\n\n-----Input-----\nThe input consists of one parameter:\nnums: A list of integers representing the input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest strictly increasing subsequence in the input array. \n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible]\ndef lengthOfLIS_precond (nums : List Int) : Prop :=\n  True\n\ndef maxInArray (arr : Array Nat) : Nat :=\n  arr.foldl (fun a b => if a ≥ b then a else b) 0\n\ndef lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Nat :=\n  if nums.isEmpty then 0\n  else\n    let n := nums.length\n    Id.run do\n      let mut dp : Array Nat := Array.mkArray n 1\n\n      for i in [1:n] do\n        for j in [0:i] do\n          if nums[j]! < nums[i]! && dp[j]! + 1 > dp[i]! then\n            dp := dp.set! i (dp[j]! + 1)\n\n      maxInArray dp\n\n@[reducible]\ndef lengthOfLIS_postcond (nums : List Int) (result: Nat) (h_precond : lengthOfLIS_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_25"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that generates all possible letter combinations from a string of digits based on the traditional telephone keypad letter mappings.\n\n-----Input-----\nThe input consists of a string (String). The string may be empty.\n\n-----Output-----\nThe output is a list of strings (List String) where each string represents a unique combination of letters corresponding to the input digits. If the input string is empty, the output is an empty list.\n\n-----Note-----\n\nHere is the mapping from the number to possible letters:\n2: a or b or c\n3: d or e or f\n4: g or h or i\n5: j or k or l\n6: m or n or o\n7: p or q or r or s\n8: t or u or v\n9: w or x or y or z\nother number or not a number: no letters\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem letterCombinations_spec_satisfied (digits: String) (h_precond : letterCombinations_precond (digits)) :\n    letterCombinations_postcond (digits) (letterCombinations (digits) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef digitToLetters (c : Char) : List Char :=\n  match c with\n  | '2' => ['a', 'b', 'c']\n  | '3' => ['d', 'e', 'f']\n  | '4' => ['g', 'h', 'i']\n  | '5' => ['j', 'k', 'l']\n  | '6' => ['m', 'n', 'o']\n  | '7' => ['p', 'q', 'r', 's']\n  | '8' => ['t', 'u', 'v']\n  | '9' => ['w', 'x', 'y', 'z']\n  | _ => []\n\n@[reducible]\ndef letterCombinations_precond (digits : String) : Prop :=\n  True\n\ndef letterCombinations (digits : String) (h_precond : letterCombinations_precond (digits)) : List String :=\n  let chars := digits.toList\n  go chars\n  where\n    go : List Char → List String\n    | [] => []\n    | (d :: ds) =>\n      let restCombinations := go ds\n      let currentLetters := digitToLetters d\n      match restCombinations with\n      | [] => currentLetters.map (λ c => String.singleton c)\n      | _ => currentLetters.flatMap (λ c => restCombinations.map (λ s => String.singleton c ++ s))\n\n@[reducible]\ndef letterCombinations_postcond (digits : String) (result: List String) (h_precond : letterCombinations_precond (digits)) : Prop :=\n  if digits.isEmpty then\n    result = []\n  else if digits.toList.any (λ c => ¬(c ∈ ['2','3','4','5','6','7','8','9'])) then\n    result = []\n  else\n    let expected := digits.toList.map digitToLetters |>.foldl (λ acc ls => acc.flatMap (λ s => ls.map (λ c => s ++ String.singleton c)) ) [\"\"]\n    result.length = expected.length ∧ result.all (λ s => s ∈ expected) ∧ expected.all (λ s => s ∈ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem letterCombinations_spec_satisfied (digits: String) (h_precond : letterCombinations_precond (digits)) :\n    letterCombinations_postcond (digits) (letterCombinations (digits) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_26", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that generates all possible letter combinations from a string of digits based on the traditional telephone keypad letter mappings.\n\n-----Input-----\nThe input consists of a string (String). The string may be empty.\n\n-----Output-----\nThe output is a list of strings (List String) where each string represents a unique combination of letters corresponding to the input digits. If the input string is empty, the output is an empty list.\n\n-----Note-----\n\nHere is the mapping from the number to possible letters:\n2: a or b or c\n3: d or e or f\n4: g or h or i\n5: j or k or l\n6: m or n or o\n7: p or q or r or s\n8: t or u or v\n9: w or x or y or z\nother number or not a number: no letters\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem letterCombinations_spec_satisfied (digits: String) (h_precond : letterCombinations_precond (digits)) :\n    letterCombinations_postcond (digits) (letterCombinations (digits) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef digitToLetters (c : Char) : List Char :=\n  match c with\n  | '2' => ['a', 'b', 'c']\n  | '3' => ['d', 'e', 'f']\n  | '4' => ['g', 'h', 'i']\n  | '5' => ['j', 'k', 'l']\n  | '6' => ['m', 'n', 'o']\n  | '7' => ['p', 'q', 'r', 's']\n  | '8' => ['t', 'u', 'v']\n  | '9' => ['w', 'x', 'y', 'z']\n  | _ => []\n\n@[reducible]\ndef letterCombinations_precond (digits : String) : Prop :=\n  True\n\ndef letterCombinations (digits : String) (h_precond : letterCombinations_precond (digits)) : List String :=\n  let chars := digits.toList\n  go chars\n  where\n    go : List Char → List String\n    | [] => []\n    | (d :: ds) =>\n      let restCombinations := go ds\n      let currentLetters := digitToLetters d\n      match restCombinations with\n      | [] => currentLetters.map (λ c => String.singleton c)\n      | _ => currentLetters.flatMap (λ c => restCombinations.map (λ s => String.singleton c ++ s))\n\n@[reducible]\ndef letterCombinations_postcond (digits : String) (result: List String) (h_precond : letterCombinations_precond (digits)) : Prop :=\n  if digits.isEmpty then\n    result = []\n  else if digits.toList.any (λ c => ¬(c ∈ ['2','3','4','5','6','7','8','9'])) then\n    result = []\n  else\n    let expected := digits.toList.map digitToLetters |>.foldl (λ acc ls => acc.flatMap (λ s => ls.map (λ c => s ++ String.singleton c)) ) [\"\"]\n    result.length = expected.length ∧ result.all (λ s => s ∈ expected) ∧ expected.all (λ s => s ∈ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem letterCombinations_spec_satisfied (digits: String) (h_precond : letterCombinations_precond (digits)) :\n    letterCombinations_postcond (digits) (letterCombinations (digits) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_26"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that computes the longest common subsequence (LCS) of two input strings.\nA subsequence of a string is a sequence that can be derived from the original string by deleting zero or more characters (not necessarily contiguous) without changing the order of the remaining characters.\nThe function should return a string that is:\n1) A subsequence of both input strings.\n2) As long as possible among all such common subsequences.\n\nIf multiple LCS answers exist (with the same maximum length), returning any one of them is acceptable.\n\n-----Input-----\ns1: The first input string.\ns2: The second input string.\n\n-----Output-----\nA string representing a longest common subsequence of s1 and s2.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestCommonSubsequence_spec_satisfied (s1: String) (s2: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) :\n    longestCommonSubsequence_postcond (s1) (s2) (longestCommonSubsequence (s1) (s2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef longestCommonSubsequence_precond (s1 : String) (s2 : String) : Prop :=\n  True\n\npartial def toCharList (s : String) : List Char :=\n  s.data\n\npartial def fromCharList (cs : List Char) : String :=\n  cs.foldl (fun acc c => acc.push c) \"\"\n\npartial def lcsAux (xs : List Char) (ys : List Char) : List Char :=\n  match xs, ys with\n  | [], _ => []\n  | _, [] => []\n  | x :: xs', y :: ys' =>\n    if x == y then\n      x :: lcsAux xs' ys'\n    else\n      let left  := lcsAux xs' (y :: ys')\n      let right := lcsAux (x :: xs') ys'\n      if left.length >= right.length then left else right\n\ndef longestCommonSubsequence (s1 : String) (s2 : String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : String :=\n  let xs := toCharList s1\n  let ys := toCharList s2\n  let resultList := lcsAux xs ys\n  fromCharList resultList\n\n@[reducible]\ndef longestCommonSubsequence_postcond (s1 : String) (s2 : String) (result: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : Prop :=\n  let allSubseq (arr : List Char) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq s1.toList\n  let subseqB := allSubseq s2.toList\n  let commonSubseq := subseqA.filter (fun l => subseqB.contains l)\n  commonSubseq.contains result.toList ∧ commonSubseq.all (fun l => l.length ≤ result.length)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestCommonSubsequence_spec_satisfied (s1: String) (s2: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) :\n    longestCommonSubsequence_postcond (s1) (s2) (longestCommonSubsequence (s1) (s2) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_27", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that computes the longest common subsequence (LCS) of two input strings.\nA subsequence of a string is a sequence that can be derived from the original string by deleting zero or more characters (not necessarily contiguous) without changing the order of the remaining characters.\nThe function should return a string that is:\n1) A subsequence of both input strings.\n2) As long as possible among all such common subsequences.\n\nIf multiple LCS answers exist (with the same maximum length), returning any one of them is acceptable.\n\n-----Input-----\ns1: The first input string.\ns2: The second input string.\n\n-----Output-----\nA string representing a longest common subsequence of s1 and s2.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestCommonSubsequence_spec_satisfied (s1: String) (s2: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) :\n    longestCommonSubsequence_postcond (s1) (s2) (longestCommonSubsequence (s1) (s2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef longestCommonSubsequence_precond (s1 : String) (s2 : String) : Prop :=\n  True\n\npartial def toCharList (s : String) : List Char :=\n  s.data\n\npartial def fromCharList (cs : List Char) : String :=\n  cs.foldl (fun acc c => acc.push c) \"\"\n\npartial def lcsAux (xs : List Char) (ys : List Char) : List Char :=\n  match xs, ys with\n  | [], _ => []\n  | _, [] => []\n  | x :: xs', y :: ys' =>\n    if x == y then\n      x :: lcsAux xs' ys'\n    else\n      let left  := lcsAux xs' (y :: ys')\n      let right := lcsAux (x :: xs') ys'\n      if left.length >= right.length then left else right\n\ndef longestCommonSubsequence (s1 : String) (s2 : String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : String :=\n  let xs := toCharList s1\n  let ys := toCharList s2\n  let resultList := lcsAux xs ys\n  fromCharList resultList\n\n@[reducible]\ndef longestCommonSubsequence_postcond (s1 : String) (s2 : String) (result: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : Prop :=\n  let allSubseq (arr : List Char) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq s1.toList\n  let subseqB := allSubseq s2.toList\n  let commonSubseq := subseqA.filter (fun l => subseqB.contains l)\n  commonSubseq.contains result.toList ∧ commonSubseq.all (fun l => l.length ≤ result.length)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestCommonSubsequence_spec_satisfied (s1: String) (s2: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) :\n    longestCommonSubsequence_postcond (s1) (s2) (longestCommonSubsequence (s1) (s2) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_27"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest sequence of consecutive integers present in a given list. The numbers do not need to appear in order. The elements are unique.\n\nA consecutive sequence consists of integers that can be arranged in increasing order with no gaps. Your function should find the longest such streak.\n\n-----Input-----\n- nums: A list of integers (no duplicates).\n\n-----Output-----\n- A natural number: the length of the longest consecutive sequence.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestConsecutive_spec_satisfied (nums: List Int) (h_precond : longestConsecutive_precond (nums)) :\n    longestConsecutive_postcond (nums) (longestConsecutive (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\nimport Mathlib\nopen Std\n\n@[reducible, simp]\ndef longestConsecutive_precond (nums : List Int) : Prop :=\n  List.Nodup nums\n\ndef longestConsecutive (nums : List Int) (h_precond : longestConsecutive_precond (nums)) : Nat :=\n  Id.run do\n    let mut set := HashSet.empty\n    for x in nums do\n      set := set.insert x\n\n    let mut maxLen := 0\n\n    for x in nums do\n      if !set.contains (x - 1) then\n        let mut curr := x\n        let mut length := 1\n        while set.contains (curr + 1) do\n          curr := curr + 1\n          length := length + 1\n        maxLen := Nat.max maxLen length\n\n    return maxLen\n\ndef isConsecutive (seq : List Int) : Bool :=\n  seq.length = 0 ∨ seq.zipIdx.all (fun (x, i) => x = i + seq[0]!)\n\n@[reducible, simp]\ndef longestConsecutive_postcond (nums : List Int) (result: Nat) (h_precond : longestConsecutive_precond (nums)) : Prop :=\n  let sorted_nums := nums.mergeSort\n  let consec_sublist_lens := List.range nums.length |>.flatMap (fun start =>\n    List.range (nums.length - start + 1) |>.map (fun len => sorted_nums.extract start (start + len))) |>.filter isConsecutive |>.map (·.length)\n\n  (nums = [] → result = 0) ∧\n  (nums ≠ [] → consec_sublist_lens.contains result ∧ consec_sublist_lens.all (· ≤ result))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestConsecutive_spec_satisfied (nums: List Int) (h_precond : longestConsecutive_precond (nums)) :\n    longestConsecutive_postcond (nums) (longestConsecutive (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_28", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest sequence of consecutive integers present in a given list. The numbers do not need to appear in order. The elements are unique.\n\nA consecutive sequence consists of integers that can be arranged in increasing order with no gaps. Your function should find the longest such streak.\n\n-----Input-----\n- nums: A list of integers (no duplicates).\n\n-----Output-----\n- A natural number: the length of the longest consecutive sequence.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestConsecutive_spec_satisfied (nums: List Int) (h_precond : longestConsecutive_precond (nums)) :\n    longestConsecutive_postcond (nums) (longestConsecutive (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\nimport Mathlib\nopen Std\n\n@[reducible, simp]\ndef longestConsecutive_precond (nums : List Int) : Prop :=\n  List.Nodup nums\n\ndef longestConsecutive (nums : List Int) (h_precond : longestConsecutive_precond (nums)) : Nat :=\n  Id.run do\n    let mut set := HashSet.empty\n    for x in nums do\n      set := set.insert x\n\n    let mut maxLen := 0\n\n    for x in nums do\n      if !set.contains (x - 1) then\n        let mut curr := x\n        let mut length := 1\n        while set.contains (curr + 1) do\n          curr := curr + 1\n          length := length + 1\n        maxLen := Nat.max maxLen length\n\n    return maxLen\n\ndef isConsecutive (seq : List Int) : Bool :=\n  seq.length = 0 ∨ seq.zipIdx.all (fun (x, i) => x = i + seq[0]!)\n\n@[reducible, simp]\ndef longestConsecutive_postcond (nums : List Int) (result: Nat) (h_precond : longestConsecutive_precond (nums)) : Prop :=\n  let sorted_nums := nums.mergeSort\n  let consec_sublist_lens := List.range nums.length |>.flatMap (fun start =>\n    List.range (nums.length - start + 1) |>.map (fun len => sorted_nums.extract start (start + len))) |>.filter isConsecutive |>.map (·.length)\n\n  (nums = [] → result = 0) ∧\n  (nums ≠ [] → consec_sublist_lens.contains result ∧ consec_sublist_lens.all (· ≤ result))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestConsecutive_spec_satisfied (nums: List Int) (h_precond : longestConsecutive_precond (nums)) :\n    longestConsecutive_postcond (nums) (longestConsecutive (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_28"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nYou are given a natural number array nums and a natural number k.\nThe frequency of an element x is the number of times it occurs in an array.\nAn array is called good if the frequency of each element in this array is less than or equal to k.\nReturn the length of the longest good subarray of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n-----Input-----\nThe input consists of an array of natural numbers nums and a natural number k:\nnums: an array of natural numbers.\nk: a natural number\n\n-----Output-----\nThe output is a natural number:\nReturn the length of the longest good subarray of nums.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestGoodSubarray_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) :\n    longestGoodSubarray_postcond (nums) (k) (longestGoodSubarray (nums) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef longestGoodSubarray_precond (nums : List Nat) (k : Nat) : Prop :=\n  True\n\ndef longestGoodSubarray (nums : List Nat) (k : Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Nat :=\n  Id.run do\n    let arr := nums.toArray\n    let mut left := 0\n    let mut maxLen := 0\n    let mut freq : HashMap Nat Nat := {}\n\n    for right in [0:arr.size] do\n      let num := arr[right]!\n      let count := freq.getD num 0\n      freq := freq.insert num (count + 1)\n\n      while freq.toList.any (fun (_, v) => v > k) do\n        let lnum := arr[left]!\n        let lcount := freq.getD lnum 0\n        if lcount = 1 then\n          freq := freq.erase lnum\n        else\n          freq := freq.insert lnum (lcount - 1)\n        left := left + 1\n\n      maxLen := max maxLen (right - left + 1)\n\n    return maxLen\n\n@[reducible]\ndef longestGoodSubarray_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Prop :=\n  let subArrays :=\n    List.range (nums.length + 1) |>.flatMap (fun start =>\n      List.range (nums.length - start + 1) |>.map (fun len =>\n        nums.drop start |>.take len))\n  let subArrayFreqs := subArrays.map (fun arr => arr.map (fun x => arr.count x))\n  let validSubArrays := subArrayFreqs.filter (fun arr => arr.all (fun x => x ≤ k))\n\n  (nums = [] ∧ result = 0) ∨\n  (nums ≠ [] ∧\n    validSubArrays.any (fun arr => arr.length = result) ∧\n    validSubArrays.all (fun arr => arr.length ≤ result))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestGoodSubarray_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) :\n    longestGoodSubarray_postcond (nums) (k) (longestGoodSubarray (nums) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_29", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nYou are given a natural number array nums and a natural number k.\nThe frequency of an element x is the number of times it occurs in an array.\nAn array is called good if the frequency of each element in this array is less than or equal to k.\nReturn the length of the longest good subarray of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n-----Input-----\nThe input consists of an array of natural numbers nums and a natural number k:\nnums: an array of natural numbers.\nk: a natural number\n\n-----Output-----\nThe output is a natural number:\nReturn the length of the longest good subarray of nums.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestGoodSubarray_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) :\n    longestGoodSubarray_postcond (nums) (k) (longestGoodSubarray (nums) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef longestGoodSubarray_precond (nums : List Nat) (k : Nat) : Prop :=\n  True\n\ndef longestGoodSubarray (nums : List Nat) (k : Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Nat :=\n  Id.run do\n    let arr := nums.toArray\n    let mut left := 0\n    let mut maxLen := 0\n    let mut freq : HashMap Nat Nat := {}\n\n    for right in [0:arr.size] do\n      let num := arr[right]!\n      let count := freq.getD num 0\n      freq := freq.insert num (count + 1)\n\n      while freq.toList.any (fun (_, v) => v > k) do\n        let lnum := arr[left]!\n        let lcount := freq.getD lnum 0\n        if lcount = 1 then\n          freq := freq.erase lnum\n        else\n          freq := freq.insert lnum (lcount - 1)\n        left := left + 1\n\n      maxLen := max maxLen (right - left + 1)\n\n    return maxLen\n\n@[reducible]\ndef longestGoodSubarray_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Prop :=\n  let subArrays :=\n    List.range (nums.length + 1) |>.flatMap (fun start =>\n      List.range (nums.length - start + 1) |>.map (fun len =>\n        nums.drop start |>.take len))\n  let subArrayFreqs := subArrays.map (fun arr => arr.map (fun x => arr.count x))\n  let validSubArrays := subArrayFreqs.filter (fun arr => arr.all (fun x => x ≤ k))\n\n  (nums = [] ∧ result = 0) ∨\n  (nums ≠ [] ∧\n    validSubArrays.any (fun arr => arr.length = result) ∧\n    validSubArrays.all (fun arr => arr.length ≤ result))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestGoodSubarray_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) :\n    longestGoodSubarray_postcond (nums) (k) (longestGoodSubarray (nums) (k) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_29"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the logest common subsequence of two input arrays.\n\n-----Input-----\nThe input consists of two arrays:\na: The first array.\nb: The second array.\n\n\n-----Output-----\nThe output is an integer:\nReturns the length of array a and b's longest common subsequence.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef LongestCommonSubsequence_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef intMax (x y : Int) : Int :=\n  if x < y then y else x\n\ndef LongestCommonSubsequence (a : Array Int) (b : Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Int :=\n  let m := a.size\n  let n := b.size\n\n  let dp := Id.run do\n    let mut dp := Array.mkArray (m + 1) (Array.mkArray (n + 1) 0)\n    for i in List.range (m + 1) do\n      for j in List.range (n + 1) do\n        if i = 0 ∨ j = 0 then\n          ()\n        else if a[i - 1]! = b[j - 1]! then\n          let newVal := ((dp[i - 1]!)[j - 1]!) + 1\n          dp := dp.set! i (dp[i]!.set! j newVal)\n        else\n          let newVal := intMax ((dp[i - 1]!)[j]!) ((dp[i]!)[j - 1]!)\n          dp := dp.set! i (dp[i]!.set! j newVal)\n    return dp\n  (dp[m]!)[n]!\n\n@[reducible]\ndef LongestCommonSubsequence_postcond (a : Array Int) (b : Array Int) (result: Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Prop :=\n  let allSubseq (arr : Array Int) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq a\n  let subseqB := allSubseq b\n  let commonSubseqLens := subseqA.filter (fun l => subseqB.contains l) |>.map (·.length)\n  commonSubseqLens.contains result ∧ commonSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_3", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the logest common subsequence of two input arrays.\n\n-----Input-----\nThe input consists of two arrays:\na: The first array.\nb: The second array.\n\n\n-----Output-----\nThe output is an integer:\nReturns the length of array a and b's longest common subsequence.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef LongestCommonSubsequence_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef intMax (x y : Int) : Int :=\n  if x < y then y else x\n\ndef LongestCommonSubsequence (a : Array Int) (b : Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Int :=\n  let m := a.size\n  let n := b.size\n\n  let dp := Id.run do\n    let mut dp := Array.mkArray (m + 1) (Array.mkArray (n + 1) 0)\n    for i in List.range (m + 1) do\n      for j in List.range (n + 1) do\n        if i = 0 ∨ j = 0 then\n          ()\n        else if a[i - 1]! = b[j - 1]! then\n          let newVal := ((dp[i - 1]!)[j - 1]!) + 1\n          dp := dp.set! i (dp[i]!.set! j newVal)\n        else\n          let newVal := intMax ((dp[i - 1]!)[j]!) ((dp[i]!)[j - 1]!)\n          dp := dp.set! i (dp[i]!.set! j newVal)\n    return dp\n  (dp[m]!)[n]!\n\n@[reducible]\ndef LongestCommonSubsequence_postcond (a : Array Int) (b : Array Int) (result: Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Prop :=\n  let allSubseq (arr : Array Int) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq a\n  let subseqB := allSubseq b\n  let commonSubseqLens := subseqA.filter (fun l => subseqB.contains l) |>.map (·.length)\n  commonSubseqLens.contains result ∧ commonSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_3"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that computes the length of the longest strictly increasing contiguous subarray in a list of integers. A subarray is a sequence of consecutive elements, and it is strictly increasing if each element is greater than the previous one.\n\nThe function should correctly handle empty lists, lists with all equal elements, and long stretches of increasing numbers.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing contiguous subarray. If the list is empty, the function should return 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingStreak_spec_satisfied (nums: List Int) (h_precond : longestIncreasingStreak_precond (nums)) :\n    longestIncreasingStreak_postcond (nums) (longestIncreasingStreak (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef longestIncreasingStreak_precond (nums : List Int) : Prop :=\n  True\n\ndef longestIncreasingStreak (nums : List Int) (h_precond : longestIncreasingStreak_precond (nums)) : Nat :=\n  let rec aux (lst : List Int) (prev : Option Int) (currLen : Nat) (maxLen : Nat) : Nat :=\n    match lst with\n    | [] => max currLen maxLen\n    | x :: xs =>\n      match prev with\n      | none => aux xs (some x) 1 (max 1 maxLen)\n      | some p =>\n        if x > p then aux xs (some x) (currLen + 1) (max (currLen + 1) maxLen)\n        else aux xs (some x) 1 (max currLen maxLen)\n  aux nums none 0 0\n\n@[reducible]\ndef longestIncreasingStreak_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingStreak_precond (nums)) : Prop :=\n  (nums = [] → result = 0) ∧\n\n  (result > 0 →\n    (List.range (nums.length - result + 1) |>.any (fun start =>\n      start + result ≤ nums.length ∧\n      (List.range (result - 1) |>.all (fun i =>\n        nums[start + i]! < nums[start + i + 1]!)) ∧\n      (start = 0 ∨ nums[start - 1]! ≥ nums[start]!) ∧\n      (start + result = nums.length ∨ nums[start + result - 1]! ≥ nums[start + result]!)))) ∧\n\n  (List.range (nums.length - result) |>.all (fun start =>\n    List.range result |>.any (fun i =>\n      start + i + 1 ≥ nums.length ∨ nums[start + i]! ≥ nums[start + i + 1]!)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingStreak_spec_satisfied (nums: List Int) (h_precond : longestIncreasingStreak_precond (nums)) :\n    longestIncreasingStreak_postcond (nums) (longestIncreasingStreak (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_30", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that computes the length of the longest strictly increasing contiguous subarray in a list of integers. A subarray is a sequence of consecutive elements, and it is strictly increasing if each element is greater than the previous one.\n\nThe function should correctly handle empty lists, lists with all equal elements, and long stretches of increasing numbers.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing contiguous subarray. If the list is empty, the function should return 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingStreak_spec_satisfied (nums: List Int) (h_precond : longestIncreasingStreak_precond (nums)) :\n    longestIncreasingStreak_postcond (nums) (longestIncreasingStreak (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef longestIncreasingStreak_precond (nums : List Int) : Prop :=\n  True\n\ndef longestIncreasingStreak (nums : List Int) (h_precond : longestIncreasingStreak_precond (nums)) : Nat :=\n  let rec aux (lst : List Int) (prev : Option Int) (currLen : Nat) (maxLen : Nat) : Nat :=\n    match lst with\n    | [] => max currLen maxLen\n    | x :: xs =>\n      match prev with\n      | none => aux xs (some x) 1 (max 1 maxLen)\n      | some p =>\n        if x > p then aux xs (some x) (currLen + 1) (max (currLen + 1) maxLen)\n        else aux xs (some x) 1 (max currLen maxLen)\n  aux nums none 0 0\n\n@[reducible]\ndef longestIncreasingStreak_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingStreak_precond (nums)) : Prop :=\n  (nums = [] → result = 0) ∧\n\n  (result > 0 →\n    (List.range (nums.length - result + 1) |>.any (fun start =>\n      start + result ≤ nums.length ∧\n      (List.range (result - 1) |>.all (fun i =>\n        nums[start + i]! < nums[start + i + 1]!)) ∧\n      (start = 0 ∨ nums[start - 1]! ≥ nums[start]!) ∧\n      (start + result = nums.length ∨ nums[start + result - 1]! ≥ nums[start + result]!)))) ∧\n\n  (List.range (nums.length - result) |>.all (fun start =>\n    List.range result |>.any (fun i =>\n      start + i + 1 ≥ nums.length ∨ nums[start + i]! ≥ nums[start + i + 1]!)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingStreak_spec_satisfied (nums: List Int) (h_precond : longestIncreasingStreak_precond (nums)) :\n    longestIncreasingStreak_postcond (nums) (longestIncreasingStreak (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_30"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.\n\n-----Input-----\nThe input consists of a single value:\nxs: A list of integers of type `List Int`.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing subsequence found in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubseqLength_spec_satisfied (xs: List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) :\n    longestIncreasingSubseqLength_postcond (xs) (longestIncreasingSubseqLength (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible]\ndef longestIncreasingSubseqLength_precond (xs : List Int) : Prop :=\n  True\n\ndef subsequences {α : Type} : List α → List (List α)\n  | [] => [[]]\n  | x :: xs =>\n    let subs := subsequences xs\n    subs ++ subs.map (fun s => x :: s)\n\ndef isStrictlyIncreasing : List Int → Bool\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => if x < y then isStrictlyIncreasing (y :: rest) else false\n\ndef longestIncreasingSubseqLength (xs : List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Nat :=\n  let subs := subsequences xs\n  let increasing := subs.filter isStrictlyIncreasing\n  increasing.foldl (fun acc s => max acc s.length) 0\n\n@[reducible]\ndef longestIncreasingSubseqLength_postcond (xs : List Int) (result: Nat) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Prop :=\n  let allSubseq := (xs.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubseqLength_spec_satisfied (xs: List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) :\n    longestIncreasingSubseqLength_postcond (xs) (longestIncreasingSubseqLength (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_31", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.\n\n-----Input-----\nThe input consists of a single value:\nxs: A list of integers of type `List Int`.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing subsequence found in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubseqLength_spec_satisfied (xs: List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) :\n    longestIncreasingSubseqLength_postcond (xs) (longestIncreasingSubseqLength (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible]\ndef longestIncreasingSubseqLength_precond (xs : List Int) : Prop :=\n  True\n\ndef subsequences {α : Type} : List α → List (List α)\n  | [] => [[]]\n  | x :: xs =>\n    let subs := subsequences xs\n    subs ++ subs.map (fun s => x :: s)\n\ndef isStrictlyIncreasing : List Int → Bool\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => if x < y then isStrictlyIncreasing (y :: rest) else false\n\ndef longestIncreasingSubseqLength (xs : List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Nat :=\n  let subs := subsequences xs\n  let increasing := subs.filter isStrictlyIncreasing\n  increasing.foldl (fun acc s => max acc s.length) 0\n\n@[reducible]\ndef longestIncreasingSubseqLength_postcond (xs : List Int) (result: Nat) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Prop :=\n  let allSubseq := (xs.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubseqLength_spec_satisfied (xs: List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) :\n    longestIncreasingSubseqLength_postcond (xs) (longestIncreasingSubseqLength (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_31"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis test implements a function in Lean 4 that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.\n\n-----Input-----\nnumbers: A list of integers.\n\n-----Output-----\nA natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (numbers: List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) :\n    longestIncreasingSubsequence_postcond (numbers) (longestIncreasingSubsequence (numbers) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_precond (numbers : List Int) : Prop :=\n  True\n\ndef longestIncreasingSubsequence (numbers : List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Nat :=\n  let rec buildTables : List Int → List Int → List Nat → Nat → Nat\n    | [], _, lengths, _ =>\n        let rec findMaxLength : List Nat → Nat\n          | [] => 0\n          | x :: xs =>\n              let maxRest := findMaxLength xs\n              if x > maxRest then x else maxRest\n        findMaxLength lengths\n    | currNum :: restNums, prevNums, lengths, idx =>\n        let rec findLengthEndingAtCurr : List Int → List Nat → Nat → Nat\n          | [], _, best => best\n          | prevVal :: restVals, prevLen :: restLens, best =>\n              if prevVal < currNum then\n                findLengthEndingAtCurr restVals restLens (max best prevLen)\n              else\n                findLengthEndingAtCurr restVals restLens best\n          | _, _, best => best\n\n        let bestPrevLen := findLengthEndingAtCurr prevNums lengths 0\n        let currLength := bestPrevLen + 1\n        buildTables restNums (prevNums ++ [currNum]) (lengths ++ [currLength]) (idx + 1)\n\n  match numbers with\n  | [] => 0\n  | [x] => 1\n  | first :: rest => buildTables rest [first] [1] 1\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_postcond (numbers : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Prop :=\n  let allSubseq := (numbers.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (numbers: List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) :\n    longestIncreasingSubsequence_postcond (numbers) (longestIncreasingSubsequence (numbers) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_32", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis test implements a function in Lean 4 that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.\n\n-----Input-----\nnumbers: A list of integers.\n\n-----Output-----\nA natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (numbers: List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) :\n    longestIncreasingSubsequence_postcond (numbers) (longestIncreasingSubsequence (numbers) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_precond (numbers : List Int) : Prop :=\n  True\n\ndef longestIncreasingSubsequence (numbers : List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Nat :=\n  let rec buildTables : List Int → List Int → List Nat → Nat → Nat\n    | [], _, lengths, _ =>\n        let rec findMaxLength : List Nat → Nat\n          | [] => 0\n          | x :: xs =>\n              let maxRest := findMaxLength xs\n              if x > maxRest then x else maxRest\n        findMaxLength lengths\n    | currNum :: restNums, prevNums, lengths, idx =>\n        let rec findLengthEndingAtCurr : List Int → List Nat → Nat → Nat\n          | [], _, best => best\n          | prevVal :: restVals, prevLen :: restLens, best =>\n              if prevVal < currNum then\n                findLengthEndingAtCurr restVals restLens (max best prevLen)\n              else\n                findLengthEndingAtCurr restVals restLens best\n          | _, _, best => best\n\n        let bestPrevLen := findLengthEndingAtCurr prevNums lengths 0\n        let currLength := bestPrevLen + 1\n        buildTables restNums (prevNums ++ [currNum]) (lengths ++ [currLength]) (idx + 1)\n\n  match numbers with\n  | [] => 0\n  | [x] => 1\n  | first :: rest => buildTables rest [first] [1] 1\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_postcond (numbers : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Prop :=\n  let allSubseq := (numbers.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (numbers: List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) :\n    longestIncreasingSubsequence_postcond (numbers) (longestIncreasingSubsequence (numbers) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_32"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires implementing the \"Longest Increasing Subsequence\" problem in Lean 4.\nGiven a list of integers, the function should compute the length of the longest strictly increasing\nsubsequence. A subsequence is formed by deleting zero or more elements without changing the order.\nIf the list is empty, the function should return 0.\n\n-----Input-----\n- nums: A list of integers.\n\n-----Output-----\n- A natural number representing the length of the longest strictly increasing subsequence.\n- If there is no increasing subsequence, return 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  True\n\ndef longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Nat :=\n  let max2 (a : Nat) (b : Nat) : Nat :=\n    if a > b then a else b\n\n  let rec listLength (l : List Int) : Nat :=\n    match l with\n    | []      => 0\n    | _ :: xs => 1 + listLength xs\n\n  let rec helper (lst : List Int) (prev : Option Int) : Nat :=\n    match lst with\n    | [] => 0\n    | h :: t =>\n        let canTake : Bool :=\n          if prev = none then true\n          else if prev.get! < h then true else false\n        let withTake : Nat :=\n          if canTake then 1 + helper t (some h) else 0\n        let withoutTake : Nat := helper t prev\n        max2 withTake withoutTake\n\n  let result := helper nums none\n  result\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_33", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires implementing the \"Longest Increasing Subsequence\" problem in Lean 4.\nGiven a list of integers, the function should compute the length of the longest strictly increasing\nsubsequence. A subsequence is formed by deleting zero or more elements without changing the order.\nIf the list is empty, the function should return 0.\n\n-----Input-----\n- nums: A list of integers.\n\n-----Output-----\n- A natural number representing the length of the longest strictly increasing subsequence.\n- If there is no increasing subsequence, return 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  True\n\ndef longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Nat :=\n  let max2 (a : Nat) (b : Nat) : Nat :=\n    if a > b then a else b\n\n  let rec listLength (l : List Int) : Nat :=\n    match l with\n    | []      => 0\n    | _ :: xs => 1 + listLength xs\n\n  let rec helper (lst : List Int) (prev : Option Int) : Nat :=\n    match lst with\n    | [] => 0\n    | h :: t =>\n        let canTake : Bool :=\n          if prev = none then true\n          else if prev.get! < h then true else false\n        let withTake : Nat :=\n          if canTake then 1 + helper t (some h) else 0\n        let withoutTake : Nat := helper t prev\n        max2 withTake withoutTake\n\n  let result := helper nums none\n  result\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_33"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the longest strictly increasing subsequence from a given list of integers. \n\n-----Input-----\nThe input consists of a list of integers called nums\n\n-----Output-----\nThe output is an integer:\nReturns a number representing the length of the longest strictly increasing subsequence found in the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  True\n\ndef longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Int :=\n  Id.run do\n    if nums.isEmpty then return 0\n    let mut sub : Array Int := Array.empty\n    sub := sub.push nums.head!\n    for num in nums.tail do\n      if num > sub[sub.size - 1]! then\n        sub := sub.push num\n      else\n        let mut left : Nat := 0\n        let mut right : Nat := sub.size - 1\n        while left < right do\n          let mid := (left + right) / 2\n          if sub[mid]! == num then\n            right := mid\n          else if sub[mid]! < num then\n            left := mid + 1\n          else\n            right := mid\n        sub := sub.set! left num\n    return Int.ofNat sub.size\n\n@[reducible]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_34", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the longest strictly increasing subsequence from a given list of integers. \n\n-----Input-----\nThe input consists of a list of integers called nums\n\n-----Output-----\nThe output is an integer:\nReturns a number representing the length of the longest strictly increasing subsequence found in the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib.Data.List.Basic\n\n@[reducible]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  True\n\ndef longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Int :=\n  Id.run do\n    if nums.isEmpty then return 0\n    let mut sub : Array Int := Array.empty\n    sub := sub.push nums.head!\n    for num in nums.tail do\n      if num > sub[sub.size - 1]! then\n        sub := sub.push num\n      else\n        let mut left : Nat := 0\n        let mut right : Nat := sub.size - 1\n        while left < right do\n          let mid := (left + right) / 2\n          if sub[mid]! == num then\n            right := mid\n          else if sub[mid]! < num then\n            left := mid + 1\n          else\n            right := mid\n        sub := sub.set! left num\n    return Int.ofNat sub.size\n\n@[reducible]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_34"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the majority element in a list of integers. The majority element is the element that appears more than ⌊n/2⌋ times, where n is the list’s length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A list of integers of length ≥ 1, containing a majority element.\n\n-----Output-----\n- An integer: the element that appears more than ⌊n/2⌋ times.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef majorityElement_precond (nums : List Int) : Prop :=\n  nums.length > 0 ∧ nums.any (fun x => nums.count x > nums.length / 2)\n\ndef majorityElement (nums : List Int) (h_precond : majorityElement_precond (nums)) : Int :=\n  Id.run do\n    let mut counts : HashMap Int Nat := {}\n    let n := nums.length\n    for x in nums do\n      let count := counts.getD x 0\n      counts := counts.insert x (count + 1)\n    match counts.toList.find? (fun (_, c) => c > n / 2) with\n    | some (k, _) => k\n    | none      => 0\n\n@[reducible]\ndef majorityElement_postcond (nums : List Int) (result: Int) (h_precond : majorityElement_precond (nums)) : Prop :=\n  let n := nums.length\n  (nums.count result) > n / 2\n  ∧ ∀ x, x ≠ result → nums.count x ≤ n / 2\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_35", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the majority element in a list of integers. The majority element is the element that appears more than ⌊n/2⌋ times, where n is the list’s length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A list of integers of length ≥ 1, containing a majority element.\n\n-----Output-----\n- An integer: the element that appears more than ⌊n/2⌋ times.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef majorityElement_precond (nums : List Int) : Prop :=\n  nums.length > 0 ∧ nums.any (fun x => nums.count x > nums.length / 2)\n\ndef majorityElement (nums : List Int) (h_precond : majorityElement_precond (nums)) : Int :=\n  Id.run do\n    let mut counts : HashMap Int Nat := {}\n    let n := nums.length\n    for x in nums do\n      let count := counts.getD x 0\n      counts := counts.insert x (count + 1)\n    match counts.toList.find? (fun (_, c) => c > n / 2) with\n    | some (k, _) => k\n    | none      => 0\n\n@[reducible]\ndef majorityElement_postcond (nums : List Int) (result: Int) (h_precond : majorityElement_precond (nums)) : Prop :=\n  let n := nums.length\n  (nums.count result) > n / 2\n  ∧ ∀ x, x ≠ result → nums.count x ≤ n / 2\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_35"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than ⌊n / 2⌋ times in the list, where n is the total number of elements.\n\nYou may assume that the input list always contains a majority element.\n\n-----Input-----\nThe input consists of one list:\nxs: A list of natural numbers (List Nat), where a majority element is guaranteed to exist.\n\n-----Output-----\nThe output is a natural number:\nReturns the element that appears more than half the time in the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem majorityElement_spec_satisfied (xs: List Nat) (h_precond : majorityElement_precond (xs)) :\n    majorityElement_postcond (xs) (majorityElement (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef majorityElement_precond (xs : List Nat) : Prop :=\n  xs.length > 0 ∧ xs.any (fun x => xs.count x > xs.length / 2)\n\ndef majorityElement (xs : List Nat) (h_precond : majorityElement_precond (xs)) : Nat :=\n  let rec countOccurrences (target : Nat) (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0\n    | y :: ys =>\n      if y = target then 1 + countOccurrences target ys\n      else countOccurrences target ys\n\n  let rec findCandidate (lst : List Nat) (candidate : Option Nat) (count : Nat) : Nat :=\n    match lst with\n    | [] =>\n      match candidate with\n      | some c => c\n      | none => 0 -- unreachable since we assume majority element exists\n    | x :: xs =>\n      match candidate with\n      | some c =>\n        if x = c then\n          findCandidate xs (some c) (count + 1)\n        else if count = 0 then\n          findCandidate xs (some x) 1\n        else\n          findCandidate xs (some c) (count - 1)\n      | none =>\n        findCandidate xs (some x) 1\n\n  let cand := findCandidate xs none 0\n  cand\n\n@[reducible]\ndef majorityElement_postcond (xs : List Nat) (result: Nat) (h_precond : majorityElement_precond (xs)) : Prop :=\n  let count := xs.count result\n  count > xs.length / 2\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem majorityElement_spec_satisfied (xs: List Nat) (h_precond : majorityElement_precond (xs)) :\n    majorityElement_postcond (xs) (majorityElement (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_36", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than ⌊n / 2⌋ times in the list, where n is the total number of elements.\n\nYou may assume that the input list always contains a majority element.\n\n-----Input-----\nThe input consists of one list:\nxs: A list of natural numbers (List Nat), where a majority element is guaranteed to exist.\n\n-----Output-----\nThe output is a natural number:\nReturns the element that appears more than half the time in the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem majorityElement_spec_satisfied (xs: List Nat) (h_precond : majorityElement_precond (xs)) :\n    majorityElement_postcond (xs) (majorityElement (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef majorityElement_precond (xs : List Nat) : Prop :=\n  xs.length > 0 ∧ xs.any (fun x => xs.count x > xs.length / 2)\n\ndef majorityElement (xs : List Nat) (h_precond : majorityElement_precond (xs)) : Nat :=\n  let rec countOccurrences (target : Nat) (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0\n    | y :: ys =>\n      if y = target then 1 + countOccurrences target ys\n      else countOccurrences target ys\n\n  let rec findCandidate (lst : List Nat) (candidate : Option Nat) (count : Nat) : Nat :=\n    match lst with\n    | [] =>\n      match candidate with\n      | some c => c\n      | none => 0 -- unreachable since we assume majority element exists\n    | x :: xs =>\n      match candidate with\n      | some c =>\n        if x = c then\n          findCandidate xs (some c) (count + 1)\n        else if count = 0 then\n          findCandidate xs (some x) 1\n        else\n          findCandidate xs (some c) (count - 1)\n      | none =>\n        findCandidate xs (some x) 1\n\n  let cand := findCandidate xs none 0\n  cand\n\n@[reducible]\ndef majorityElement_postcond (xs : List Nat) (result: Nat) (h_precond : majorityElement_precond (xs)) : Prop :=\n  let count := xs.count result\n  count > xs.length / 2\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem majorityElement_spec_satisfied (xs: List Nat) (h_precond : majorityElement_precond (xs)) :\n    majorityElement_postcond (xs) (majorityElement (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_36"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that returns the majority element from a list of integers.\n\nThe majority element is the one that appears more than ⌊n / 2⌋ times in the list, where n is the list's length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A list of integers (with at least one majority element).\n\n-----Output-----\nReturns the majority element — the value that appears more than ⌊n / 2⌋ times.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef majorityElement_precond (nums : List Int) : Prop :=\n  True\n\ndef majorityElement (nums : List Int) (h_precond : majorityElement_precond (nums)) : Int :=\n  let rec insert (x : Int) (xs : List Int) : List Int :=\n    match xs with\n    | [] => [x]\n    | h :: t =>\n      if x ≤ h then\n        x :: h :: t\n      else\n        h :: insert x t\n\n  let rec insertionSort (xs : List Int) : List Int :=\n    match xs with\n    | [] => []\n    | h :: t =>\n      let sortedTail := insertionSort t\n      let sorted := insert h sortedTail\n      sorted\n\n  let getAt := fun (xs : List Int) (i : Nat) =>\n    match xs.drop i with\n    | [] => 0\n    | h :: _ => h\n\n  let sorted := insertionSort nums\n\n  let len := sorted.length\n  let mid := len / 2\n  getAt sorted mid\n\n@[reducible, simp]\ndef majorityElement_postcond (nums : List Int) (result: Int) (h_precond : majorityElement_precond (nums)) : Prop :=\n  let n := nums.length\n  (List.count result nums > n / 2) ∧\n  nums.all (fun x => x = result ∨ List.count x nums ≤ n / 2)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_37", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that returns the majority element from a list of integers.\n\nThe majority element is the one that appears more than ⌊n / 2⌋ times in the list, where n is the list's length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A list of integers (with at least one majority element).\n\n-----Output-----\nReturns the majority element — the value that appears more than ⌊n / 2⌋ times.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef majorityElement_precond (nums : List Int) : Prop :=\n  True\n\ndef majorityElement (nums : List Int) (h_precond : majorityElement_precond (nums)) : Int :=\n  let rec insert (x : Int) (xs : List Int) : List Int :=\n    match xs with\n    | [] => [x]\n    | h :: t =>\n      if x ≤ h then\n        x :: h :: t\n      else\n        h :: insert x t\n\n  let rec insertionSort (xs : List Int) : List Int :=\n    match xs with\n    | [] => []\n    | h :: t =>\n      let sortedTail := insertionSort t\n      let sorted := insert h sortedTail\n      sorted\n\n  let getAt := fun (xs : List Int) (i : Nat) =>\n    match xs.drop i with\n    | [] => 0\n    | h :: _ => h\n\n  let sorted := insertionSort nums\n\n  let len := sorted.length\n  let mid := len / 2\n  getAt sorted mid\n\n@[reducible, simp]\ndef majorityElement_postcond (nums : List Int) (result: Int) (h_precond : majorityElement_precond (nums)) : Prop :=\n  let n := nums.length\n  (List.count result nums > n / 2) ∧\n  nums.all (fun x => x = result ∨ List.count x nums ≤ n / 2)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_37"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires implementing a Lean 4 method that, given a list of intervals, returns the maximum amount that can be spanned after we removed one of the intervals\nYou may assume you'll receive at least one interval\n\n-----Input-----\nThe input consists of a list of ordered pairs of intervals.\n-----Output-----\nThe output is an integer:\nReturn the largest span that is possible after removing one of the intervals.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxCoverageAfterRemovingOne_spec_satisfied (intervals: List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) :\n    maxCoverageAfterRemovingOne_postcond (intervals) (maxCoverageAfterRemovingOne (intervals) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxCoverageAfterRemovingOne_precond (intervals : List (Prod Nat Nat)) : Prop :=\n  intervals.length > 0\n\ndef maxCoverageAfterRemovingOne (intervals : List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) : Nat :=\n  let n := intervals.length\n  if n ≤ 1 then 0\n  else\n    (List.range n).foldl (fun acc i =>\n      let remaining := List.eraseIdx intervals i\n      let sorted := List.mergeSort remaining (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n      let merged := sorted.foldl (fun acc curr =>\n        match acc with\n        | [] => [curr]\n        | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n      ) []\n      let coverage := merged.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n      max acc coverage\n    ) 0\n\n@[reducible, simp]\ndef maxCoverageAfterRemovingOne_postcond (intervals : List (Prod Nat Nat)) (result: Nat) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) : Prop :=\n  ∃ i < intervals.length,\n    let remaining := List.eraseIdx intervals i\n    let sorted := List.mergeSort remaining (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n    let merged := sorted.foldl (fun acc curr =>\n      match acc with\n      | [] => [curr]\n      | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n    ) []\n    let cov := merged.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n    result = cov ∧\n    ∀ j < intervals.length,\n      let rem_j := List.eraseIdx intervals j\n      let sort_j := List.mergeSort rem_j (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n      let merged_j := sort_j.foldl (fun acc curr =>\n        match acc with\n        | [] => [curr]\n        | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n      ) []\n      let cov_j := merged_j.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n      cov ≥ cov_j\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxCoverageAfterRemovingOne_spec_satisfied (intervals: List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) :\n    maxCoverageAfterRemovingOne_postcond (intervals) (maxCoverageAfterRemovingOne (intervals) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_38", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires implementing a Lean 4 method that, given a list of intervals, returns the maximum amount that can be spanned after we removed one of the intervals\nYou may assume you'll receive at least one interval\n\n-----Input-----\nThe input consists of a list of ordered pairs of intervals.\n-----Output-----\nThe output is an integer:\nReturn the largest span that is possible after removing one of the intervals.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxCoverageAfterRemovingOne_spec_satisfied (intervals: List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) :\n    maxCoverageAfterRemovingOne_postcond (intervals) (maxCoverageAfterRemovingOne (intervals) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxCoverageAfterRemovingOne_precond (intervals : List (Prod Nat Nat)) : Prop :=\n  intervals.length > 0\n\ndef maxCoverageAfterRemovingOne (intervals : List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) : Nat :=\n  let n := intervals.length\n  if n ≤ 1 then 0\n  else\n    (List.range n).foldl (fun acc i =>\n      let remaining := List.eraseIdx intervals i\n      let sorted := List.mergeSort remaining (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n      let merged := sorted.foldl (fun acc curr =>\n        match acc with\n        | [] => [curr]\n        | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n      ) []\n      let coverage := merged.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n      max acc coverage\n    ) 0\n\n@[reducible, simp]\ndef maxCoverageAfterRemovingOne_postcond (intervals : List (Prod Nat Nat)) (result: Nat) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) : Prop :=\n  ∃ i < intervals.length,\n    let remaining := List.eraseIdx intervals i\n    let sorted := List.mergeSort remaining (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n    let merged := sorted.foldl (fun acc curr =>\n      match acc with\n      | [] => [curr]\n      | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n    ) []\n    let cov := merged.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n    result = cov ∧\n    ∀ j < intervals.length,\n      let rem_j := List.eraseIdx intervals j\n      let sort_j := List.mergeSort rem_j (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n      let merged_j := sort_j.foldl (fun acc curr =>\n        match acc with\n        | [] => [curr]\n        | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n      ) []\n      let cov_j := merged_j.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n      cov ≥ cov_j\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxCoverageAfterRemovingOne_spec_satisfied (intervals: List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) :\n    maxCoverageAfterRemovingOne_postcond (intervals) (maxCoverageAfterRemovingOne (intervals) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_38"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxOfList_precond (lst : List Nat) : Prop :=\n  lst.length > 0\n\ndef maxOfList (lst : List Nat) (h_precond : maxOfList_precond (lst)) : Nat :=\n  let rec helper (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0  -- technically shouldn't happen if input is always non-empty\n    | [x] => x\n    | x :: xs =>\n      let maxTail := helper xs\n      if x > maxTail then x else maxTail\n\n  helper lst\n\n@[reducible, simp]\ndef maxOfList_postcond (lst : List Nat) (result: Nat) (h_precond : maxOfList_precond (lst)) : Prop :=\n  result ∈ lst ∧ ∀ x ∈ lst, x ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_39", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxOfList_precond (lst : List Nat) : Prop :=\n  lst.length > 0\n\ndef maxOfList (lst : List Nat) (h_precond : maxOfList_precond (lst)) : Nat :=\n  let rec helper (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0  -- technically shouldn't happen if input is always non-empty\n    | [x] => x\n    | x :: xs =>\n      let maxTail := helper xs\n      if x > maxTail then x else maxTail\n\n  helper lst\n\n@[reducible, simp]\ndef maxOfList_postcond (lst : List Nat) (result: Nat) (h_precond : maxOfList_precond (lst)) : Prop :=\n  result ∈ lst ∧ ∀ x ∈ lst, x ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_39"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the longest increasing sequence in a given array. The method should return the length of the longest increasing subsequence, in which every element is strictly less than the latter element.\n\n-----Input-----\nThe input consists of an arrat:\na: The input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest increasing subsequence, assuring that it is a subsequence of the input sequence and that every element in it is strictly less than the latter one.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestIncreasingSubsequence_spec_satisfied (a: Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) :\n    LongestIncreasingSubsequence_postcond (a) (LongestIncreasingSubsequence (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef LongestIncreasingSubsequence_precond (a : Array Int) : Prop :=\n  True\n\ndef intMax (x y : Int) : Int :=\n  if x < y then y else x\n\ndef LongestIncreasingSubsequence (a : Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) : Int :=\n  let n := a.size\n  let dp := Id.run do\n    let mut dp := Array.mkArray n 1\n    for i in [1:n] do\n      for j in [0:i] do\n        if a[j]! < a[i]! then\n          let newVal := intMax (dp[i]!) (dp[j]! + 1)\n          dp := dp.set! i newVal\n    return dp\n  match dp with\n  | #[] => 0\n  | _   => dp.foldl intMax 0\n\n@[reducible, simp]\ndef LongestIncreasingSubsequence_postcond (a : Array Int) (result: Int) (h_precond : LongestIncreasingSubsequence_precond (a)) : Prop :=\n  let allSubseq := (a.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestIncreasingSubsequence_spec_satisfied (a: Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) :\n    LongestIncreasingSubsequence_postcond (a) (LongestIncreasingSubsequence (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_4", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the longest increasing sequence in a given array. The method should return the length of the longest increasing subsequence, in which every element is strictly less than the latter element.\n\n-----Input-----\nThe input consists of an arrat:\na: The input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest increasing subsequence, assuring that it is a subsequence of the input sequence and that every element in it is strictly less than the latter one.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestIncreasingSubsequence_spec_satisfied (a: Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) :\n    LongestIncreasingSubsequence_postcond (a) (LongestIncreasingSubsequence (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef LongestIncreasingSubsequence_precond (a : Array Int) : Prop :=\n  True\n\ndef intMax (x y : Int) : Int :=\n  if x < y then y else x\n\ndef LongestIncreasingSubsequence (a : Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) : Int :=\n  let n := a.size\n  let dp := Id.run do\n    let mut dp := Array.mkArray n 1\n    for i in [1:n] do\n      for j in [0:i] do\n        if a[j]! < a[i]! then\n          let newVal := intMax (dp[i]!) (dp[j]! + 1)\n          dp := dp.set! i newVal\n    return dp\n  match dp with\n  | #[] => 0\n  | _   => dp.foldl intMax 0\n\n@[reducible, simp]\ndef LongestIncreasingSubsequence_postcond (a : Array Int) (result: Int) (h_precond : LongestIncreasingSubsequence_precond (a)) : Prop :=\n  let allSubseq := (a.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestIncreasingSubsequence_spec_satisfied (a: Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) :\n    LongestIncreasingSubsequence_postcond (a) (LongestIncreasingSubsequence (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_4"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef maxOfList_precond (lst : List Nat) : Prop :=\n  lst ≠ []  -- Ensure the list is non-empty\n\ndef maxOfList (lst : List Nat) (h_precond : maxOfList_precond (lst)) : Nat :=\n  let rec helper (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0  -- technically shouldn't happen if input is always non-empty\n    | [x] => x\n    | x :: xs =>\n      let maxTail := helper xs\n      if x > maxTail then x else maxTail\n  helper lst\n\n@[reducible]\ndef maxOfList_postcond (lst : List Nat) (result: Nat) (h_precond : maxOfList_precond (lst)) : Prop :=\n  result ∈ lst ∧ ∀ x ∈ lst, x ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_40", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef maxOfList_precond (lst : List Nat) : Prop :=\n  lst ≠ []  -- Ensure the list is non-empty\n\ndef maxOfList (lst : List Nat) (h_precond : maxOfList_precond (lst)) : Nat :=\n  let rec helper (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0  -- technically shouldn't happen if input is always non-empty\n    | [x] => x\n    | x :: xs =>\n      let maxTail := helper xs\n      if x > maxTail then x else maxTail\n  helper lst\n\n@[reducible]\ndef maxOfList_postcond (lst : List Nat) (result: Nat) (h_precond : maxOfList_precond (lst)) : Prop :=\n  result ∈ lst ∧ ∀ x ∈ lst, x ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_40"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that finds the maximum among three given integers. The method should return the largest value, ensuring that the result is greater than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum of the three input numbers, assuring that the returned value is greater than or equal to a, b, and c, and that it matches one of these values.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : maxOfThree_precond (a) (b) (c)) :\n    maxOfThree_postcond (a) (b) (c) (maxOfThree (a) (b) (c) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef maxOfThree_precond (a : Int) (b : Int) (c : Int) : Prop :=\n  True\n\ndef maxOfThree (a : Int) (b : Int) (c : Int) (h_precond : maxOfThree_precond (a) (b) (c)) : Int :=\n  if a >= b && a >= c then a\n  else if b >= a && b >= c then b\n  else c\n\n@[reducible]\ndef maxOfThree_postcond (a : Int) (b : Int) (c : Int) (result: Int) (h_precond : maxOfThree_precond (a) (b) (c)) : Prop :=\n  (result >= a ∧ result >= b ∧ result >= c) ∧ (result = a ∨ result = b ∨ result = c)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : maxOfThree_precond (a) (b) (c)) :\n    maxOfThree_postcond (a) (b) (c) (maxOfThree (a) (b) (c) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_41", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that finds the maximum among three given integers. The method should return the largest value, ensuring that the result is greater than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum of the three input numbers, assuring that the returned value is greater than or equal to a, b, and c, and that it matches one of these values.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : maxOfThree_precond (a) (b) (c)) :\n    maxOfThree_postcond (a) (b) (c) (maxOfThree (a) (b) (c) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef maxOfThree_precond (a : Int) (b : Int) (c : Int) : Prop :=\n  True\n\ndef maxOfThree (a : Int) (b : Int) (c : Int) (h_precond : maxOfThree_precond (a) (b) (c)) : Int :=\n  if a >= b && a >= c then a\n  else if b >= a && b >= c then b\n  else c\n\n@[reducible]\ndef maxOfThree_postcond (a : Int) (b : Int) (c : Int) (result: Int) (h_precond : maxOfThree_precond (a) (b) (c)) : Prop :=\n  (result >= a ∧ result >= b ∧ result >= c) ∧ (result = a ∨ result = b ∨ result = c)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : maxOfThree_precond (a) (b) (c)) :\n    maxOfThree_postcond (a) (b) (c) (maxOfThree (a) (b) (c) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_41"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that takes a list of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.\n\nIf no profit is possible, the function should return 0.\n\n-----Input-----\nThe input consists of:\nprices: A list of natural numbers representing stock prices on each day.\n\n-----Output-----\nThe output is a natural number:\nReturns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxProfit_spec_satisfied (prices: List Nat) (h_precond : maxProfit_precond (prices)) :\n    maxProfit_postcond (prices) (maxProfit (prices) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxProfit_precond (prices : List Nat) : Prop :=\n  True\n\ndef updateMinAndProfit (price : Nat) (minSoFar : Nat) (maxProfit : Nat) : (Nat × Nat) :=\n  let newMin := Nat.min minSoFar price\n  let profit := if price > minSoFar then price - minSoFar else 0\n  let newMaxProfit := Nat.max maxProfit profit\n  (newMin, newMaxProfit)\n\ndef maxProfitAux (prices : List Nat) (minSoFar : Nat) (maxProfit : Nat) : Nat :=\n  match prices with\n  | [] => maxProfit\n  | p :: ps =>\n    let (newMin, newProfit) := updateMinAndProfit p minSoFar maxProfit\n    maxProfitAux ps newMin newProfit\n\ndef maxProfit (prices : List Nat) (h_precond : maxProfit_precond (prices)) : Nat :=\n  match prices with\n  | [] => 0\n  | p :: ps => maxProfitAux ps p 0\n\n@[reducible, simp]\ndef maxProfit_postcond (prices : List Nat) (result: Nat) (h_precond : maxProfit_precond (prices)) : Prop :=\n  (result = 0 ∧ prices = []) ∨\n  (\n    List.Pairwise (fun ⟨pi, i⟩ ⟨pj, j⟩ => i < j → pj - pi ≤ result) prices.zipIdx ∧\n\n    prices.zipIdx.any (fun ⟨pi, i⟩ =>\n      prices.zipIdx.any (fun ⟨pj, j⟩ =>\n        i < j ∧ pj - pi = result))\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxProfit_spec_satisfied (prices: List Nat) (h_precond : maxProfit_precond (prices)) :\n    maxProfit_postcond (prices) (maxProfit (prices) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_42", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that takes a list of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.\n\nIf no profit is possible, the function should return 0.\n\n-----Input-----\nThe input consists of:\nprices: A list of natural numbers representing stock prices on each day.\n\n-----Output-----\nThe output is a natural number:\nReturns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxProfit_spec_satisfied (prices: List Nat) (h_precond : maxProfit_precond (prices)) :\n    maxProfit_postcond (prices) (maxProfit (prices) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxProfit_precond (prices : List Nat) : Prop :=\n  True\n\ndef updateMinAndProfit (price : Nat) (minSoFar : Nat) (maxProfit : Nat) : (Nat × Nat) :=\n  let newMin := Nat.min minSoFar price\n  let profit := if price > minSoFar then price - minSoFar else 0\n  let newMaxProfit := Nat.max maxProfit profit\n  (newMin, newMaxProfit)\n\ndef maxProfitAux (prices : List Nat) (minSoFar : Nat) (maxProfit : Nat) : Nat :=\n  match prices with\n  | [] => maxProfit\n  | p :: ps =>\n    let (newMin, newProfit) := updateMinAndProfit p minSoFar maxProfit\n    maxProfitAux ps newMin newProfit\n\ndef maxProfit (prices : List Nat) (h_precond : maxProfit_precond (prices)) : Nat :=\n  match prices with\n  | [] => 0\n  | p :: ps => maxProfitAux ps p 0\n\n@[reducible, simp]\ndef maxProfit_postcond (prices : List Nat) (result: Nat) (h_precond : maxProfit_precond (prices)) : Prop :=\n  (result = 0 ∧ prices = []) ∨\n  (\n    List.Pairwise (fun ⟨pi, i⟩ ⟨pj, j⟩ => i < j → pj - pi ≤ result) prices.zipIdx ∧\n\n    prices.zipIdx.any (fun ⟨pi, i⟩ =>\n      prices.zipIdx.any (fun ⟨pj, j⟩ =>\n        i < j ∧ pj - pi = result))\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxProfit_spec_satisfied (prices: List Nat) (h_precond : maxProfit_precond (prices)) :\n    maxProfit_postcond (prices) (maxProfit (prices) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_42"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n------Description-----\nThis task requires writing a Lean 4 method that given a 0-indexed integer array `nums` representing the scores of students in an exam. A teacher wants to select a non empty group of students such that the strength of group is maximized. \n\nThe strength of a group is defined as the product of the selected student scores.\n\nYou can choose any non-empty subset of students. The goal is to compute the maximum product of any such subset. \n\n\n----Input---\nnums: An non-empty list of integers.\n\n-----Output-----\n\nAn integer representing the maximum strength.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxStrength_spec_satisfied (nums: List Int) (h_precond : maxStrength_precond (nums)) :\n    maxStrength_postcond (nums) (maxStrength (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible]\ndef maxStrength_precond (nums : List Int) : Prop :=\n  nums ≠ []\n\ndef maxStrength (nums : List Int) (h_precond : maxStrength_precond (nums)) : Int :=\n  let powerSet := fun (l : List Int) =>\n    let n := l.length\n    let masks := List.range (2^n)\n    masks.map fun mask =>\n      (List.range n).foldr (fun i acc =>\n        if (mask.shiftRight i).land 1 == 1 then l[i]! :: acc else acc\n      ) []\n\n  let subsets := powerSet nums\n  let nonEmpty := subsets.filter (· ≠ [])\n  let products := List.map (fun subset =>\n    List.foldl (fun acc x =>\n      acc * x) (1 : Int) subset)\n    nonEmpty\n  (List.max? products).getD (-1000000)\n\n@[reducible]\ndef maxStrength_postcond (nums : List Int) (result: Int) (h_precond : maxStrength_precond (nums)) : Prop :=\n  let sublists := nums.sublists.filter (· ≠ [])\n  let products := sublists.map (List.foldl (· * ·) 1)\n  products.contains result ∧ products.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxStrength_spec_satisfied (nums: List Int) (h_precond : maxStrength_precond (nums)) :\n    maxStrength_postcond (nums) (maxStrength (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_43", "prompt": "I need to solve the following task in Lean 4: \n```\n------Description-----\nThis task requires writing a Lean 4 method that given a 0-indexed integer array `nums` representing the scores of students in an exam. A teacher wants to select a non empty group of students such that the strength of group is maximized. \n\nThe strength of a group is defined as the product of the selected student scores.\n\nYou can choose any non-empty subset of students. The goal is to compute the maximum product of any such subset. \n\n\n----Input---\nnums: An non-empty list of integers.\n\n-----Output-----\n\nAn integer representing the maximum strength.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxStrength_spec_satisfied (nums: List Int) (h_precond : maxStrength_precond (nums)) :\n    maxStrength_postcond (nums) (maxStrength (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible]\ndef maxStrength_precond (nums : List Int) : Prop :=\n  nums ≠ []\n\ndef maxStrength (nums : List Int) (h_precond : maxStrength_precond (nums)) : Int :=\n  let powerSet := fun (l : List Int) =>\n    let n := l.length\n    let masks := List.range (2^n)\n    masks.map fun mask =>\n      (List.range n).foldr (fun i acc =>\n        if (mask.shiftRight i).land 1 == 1 then l[i]! :: acc else acc\n      ) []\n\n  let subsets := powerSet nums\n  let nonEmpty := subsets.filter (· ≠ [])\n  let products := List.map (fun subset =>\n    List.foldl (fun acc x =>\n      acc * x) (1 : Int) subset)\n    nonEmpty\n  (List.max? products).getD (-1000000)\n\n@[reducible]\ndef maxStrength_postcond (nums : List Int) (result: Int) (h_precond : maxStrength_precond (nums)) : Prop :=\n  let sublists := nums.sublists.filter (· ≠ [])\n  let products := sublists.map (List.foldl (· * ·) 1)\n  products.contains result ∧ products.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxStrength_spec_satisfied (nums: List Int) (h_precond : maxStrength_precond (nums)) :\n    maxStrength_postcond (nums) (maxStrength (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_43"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nGiven an integer array arr and a positive integer k, this task requires writing a Lean 4 method that finds the\nmaximum sum of a subarray of arr, such that the length of the subarray is divisible by k.\nIf the array is empty, or generally if there exists no subarray with length divisible by k, \nthe default return value should be 0.\n\n-----Input-----\nThe input consists of:\narr: The array of integers.\nk: An integer larger than 1.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length\nof the subarray is divisible by k.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxSubarraySumDivisibleByK_spec_satisfied (arr: Array Int) (k: Int) :\n    maxSubarraySumDivisibleByK_postcond (arr) (k) (maxSubarraySumDivisibleByK (arr) (k)) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef maxSubarraySumDivisibleByK_precond (arr : Array Int) (k : Int) : Prop :=\n  k > 0\n\ndef maxSubarraySumDivisibleByK (arr : Array Int) (k : Int) : Int :=\n  let n := arr.size\n  if n = 0 || k = 0 then 0\n  else\n    let prefixSums := Id.run do\n      let mut prefixSums := Array.mkArray (n + 1) 0\n      for i in [0:n] do\n        prefixSums := prefixSums.set! (i+1) (prefixSums[i]! + arr[i]!)\n      prefixSums\n\n    let minElem := Id.run do -- find minimum element\n      let mut minElem := arr[0]!\n      for elem in arr do\n        minElem := min minElem elem\n      minElem\n    let maxSum := Id.run do\n      let mut maxSum := minElem - 1\n      for len in List.range (n+1) do\n        if len % k = 0 && len > 0 then\n          for start in [0:(n - len + 1)] do\n            let endIdx := start + len\n            let subarraySum := prefixSums[endIdx]! - prefixSums[start]!\n            maxSum := max maxSum subarraySum\n      maxSum\n\n    let default : Int := minElem - 1\n    if maxSum = default then 0 else maxSum\n\n@[reducible]\ndef maxSubarraySumDivisibleByK_postcond (arr : Array Int) (k : Int) (result: Int) : Prop :=\n  let subarrays := List.range (arr.size) |>.flatMap (fun start =>\n    List.range (arr.size - start + 1) |>.map (fun len => arr.extract start (start + len)))\n  let divisibleSubarrays := subarrays.filter (fun subarray => subarray.size % k = 0 && subarray.size > 0)\n  let subarraySums := divisibleSubarrays.map (fun subarray => subarray.sum)\n  (result = 0 → subarraySums.length = 0) ∧\n  (result ≠ 0 → result ∈ subarraySums ∧ subarraySums.all (fun sum => sum ≤ result))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxSubarraySumDivisibleByK_spec_satisfied (arr: Array Int) (k: Int) :\n    maxSubarraySumDivisibleByK_postcond (arr) (k) (maxSubarraySumDivisibleByK (arr) (k)) := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_44", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nGiven an integer array arr and a positive integer k, this task requires writing a Lean 4 method that finds the\nmaximum sum of a subarray of arr, such that the length of the subarray is divisible by k.\nIf the array is empty, or generally if there exists no subarray with length divisible by k, \nthe default return value should be 0.\n\n-----Input-----\nThe input consists of:\narr: The array of integers.\nk: An integer larger than 1.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length\nof the subarray is divisible by k.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxSubarraySumDivisibleByK_spec_satisfied (arr: Array Int) (k: Int) :\n    maxSubarraySumDivisibleByK_postcond (arr) (k) (maxSubarraySumDivisibleByK (arr) (k)) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef maxSubarraySumDivisibleByK_precond (arr : Array Int) (k : Int) : Prop :=\n  k > 0\n\ndef maxSubarraySumDivisibleByK (arr : Array Int) (k : Int) : Int :=\n  let n := arr.size\n  if n = 0 || k = 0 then 0\n  else\n    let prefixSums := Id.run do\n      let mut prefixSums := Array.mkArray (n + 1) 0\n      for i in [0:n] do\n        prefixSums := prefixSums.set! (i+1) (prefixSums[i]! + arr[i]!)\n      prefixSums\n\n    let minElem := Id.run do -- find minimum element\n      let mut minElem := arr[0]!\n      for elem in arr do\n        minElem := min minElem elem\n      minElem\n    let maxSum := Id.run do\n      let mut maxSum := minElem - 1\n      for len in List.range (n+1) do\n        if len % k = 0 && len > 0 then\n          for start in [0:(n - len + 1)] do\n            let endIdx := start + len\n            let subarraySum := prefixSums[endIdx]! - prefixSums[start]!\n            maxSum := max maxSum subarraySum\n      maxSum\n\n    let default : Int := minElem - 1\n    if maxSum = default then 0 else maxSum\n\n@[reducible]\ndef maxSubarraySumDivisibleByK_postcond (arr : Array Int) (k : Int) (result: Int) : Prop :=\n  let subarrays := List.range (arr.size) |>.flatMap (fun start =>\n    List.range (arr.size - start + 1) |>.map (fun len => arr.extract start (start + len)))\n  let divisibleSubarrays := subarrays.filter (fun subarray => subarray.size % k = 0 && subarray.size > 0)\n  let subarraySums := divisibleSubarrays.map (fun subarray => subarray.sum)\n  (result = 0 → subarraySums.length = 0) ∧\n  (result ≠ 0 → result ∈ subarraySums ∧ subarraySums.all (fun sum => sum ≤ result))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxSubarraySumDivisibleByK_spec_satisfied (arr: Array Int) (k: Int) :\n    maxSubarraySumDivisibleByK_postcond (arr) (k) (maxSubarraySumDivisibleByK (arr) (k)) := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_44"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the maximum subarray sum from a given list of integers. \nA subarray is a contiguous sequence of elements within the list. \nThe function should return the maximum sum that can be obtained from any subarray.\n\n-----Input-----\nThe input is a list of integers:\nxs: A list of integers (can include negative numbers).\n\n-----Output-----\nThe output is an integer:\nReturns the maximum sum among all contiguous subarrays of xs. \nIf the list is empty, the result should be 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxSubarraySum_spec_satisfied (xs: List Int) (h_precond : maxSubarraySum_precond (xs)) :\n    maxSubarraySum_postcond (xs) (maxSubarraySum (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxSubarraySum_precond (xs : List Int) : Prop :=\n  True\n\ndef maxSubarraySum (xs : List Int) (h_precond : maxSubarraySum_precond (xs)) : Int :=\n  let rec helper (lst : List Int) (curMax : Int) (globalMax : Int) : Int :=\n    match lst with\n    | [] => globalMax\n    | x :: rest =>\n      let newCurMax := max x (curMax + x)\n      let newGlobal := max globalMax newCurMax\n      helper rest newCurMax newGlobal\n  match xs with\n  | [] => 0\n  | x :: rest => helper rest x x\n\n@[reducible, simp]\ndef maxSubarraySum_postcond (xs : List Int) (result: Int) (h_precond : maxSubarraySum_precond (xs)) : Prop :=\n  let subarray_sums := List.range (xs.length + 1) |>.flatMap (fun start =>\n    List.range' 1 (xs.length - start) |>.map (fun len =>\n      ((xs.drop start).take len).sum\n    ))\n\n  let has_result_subarray := subarray_sums.any (fun sum => sum == result)\n\n  let is_maximum := subarray_sums.all (· ≤ result)\n\n  match xs with\n  | [] => result == 0\n  | _ => has_result_subarray ∧ is_maximum\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxSubarraySum_spec_satisfied (xs: List Int) (h_precond : maxSubarraySum_precond (xs)) :\n    maxSubarraySum_postcond (xs) (maxSubarraySum (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_45", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the maximum subarray sum from a given list of integers. \nA subarray is a contiguous sequence of elements within the list. \nThe function should return the maximum sum that can be obtained from any subarray.\n\n-----Input-----\nThe input is a list of integers:\nxs: A list of integers (can include negative numbers).\n\n-----Output-----\nThe output is an integer:\nReturns the maximum sum among all contiguous subarrays of xs. \nIf the list is empty, the result should be 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxSubarraySum_spec_satisfied (xs: List Int) (h_precond : maxSubarraySum_precond (xs)) :\n    maxSubarraySum_postcond (xs) (maxSubarraySum (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxSubarraySum_precond (xs : List Int) : Prop :=\n  True\n\ndef maxSubarraySum (xs : List Int) (h_precond : maxSubarraySum_precond (xs)) : Int :=\n  let rec helper (lst : List Int) (curMax : Int) (globalMax : Int) : Int :=\n    match lst with\n    | [] => globalMax\n    | x :: rest =>\n      let newCurMax := max x (curMax + x)\n      let newGlobal := max globalMax newCurMax\n      helper rest newCurMax newGlobal\n  match xs with\n  | [] => 0\n  | x :: rest => helper rest x x\n\n@[reducible, simp]\ndef maxSubarraySum_postcond (xs : List Int) (result: Int) (h_precond : maxSubarraySum_precond (xs)) : Prop :=\n  let subarray_sums := List.range (xs.length + 1) |>.flatMap (fun start =>\n    List.range' 1 (xs.length - start) |>.map (fun len =>\n      ((xs.drop start).take len).sum\n    ))\n\n  let has_result_subarray := subarray_sums.any (fun sum => sum == result)\n\n  let is_maximum := subarray_sums.all (· ≤ result)\n\n  match xs with\n  | [] => result == 0\n  | _ => has_result_subarray ∧ is_maximum\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxSubarraySum_spec_satisfied (xs: List Int) (h_precond : maxSubarraySum_precond (xs)) :\n    maxSubarraySum_postcond (xs) (maxSubarraySum (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_45"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis test implements a function in Lean 4 that finds the maximum sum of any contiguous subarray within a list of integers. A subarray is a continuous section of the original array. If all integers in the list are negative, the function should return 0 (representing the empty subarray).\n\n-----Input-----\nnumbers: A list of integers that may contain positive, negative, or zero values.\n\n-----Output-----\nAn integer representing the maximum sum of any contiguous subarray. If the list is empty or contains only negative numbers, the function returns 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxSubarraySum_spec_satisfied (numbers: List Int) (h_precond : maxSubarraySum_precond (numbers)) :\n    maxSubarraySum_postcond (numbers) (maxSubarraySum (numbers) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxSubarraySum_precond (numbers : List Int) : Prop :=\n  True\n\ndef maxSubarraySum (numbers : List Int) (h_precond : maxSubarraySum_precond (numbers)) : Int :=\n  let rec isAllNegative : List Int → Bool\n    | [] => true\n    | x :: xs => if x >= 0 then false else isAllNegative xs\n\n  let rec findMaxProduct : List Int → Int → Int → Int\n    | [], currMax, _ => currMax\n    | [x], currMax, _ => max currMax x\n    | x :: y :: rest, currMax, currSum =>\n        let newSum := max y (currSum + y)\n        let newMax := max currMax newSum\n        findMaxProduct (y :: rest) newMax newSum\n\n  let handleList : List Int → Nat\n    | [] => 0\n    | xs =>\n        if isAllNegative xs then\n          0\n        else\n          match xs with\n          | [] => 0\n          | x :: rest =>\n              let initialMax := max 0 x\n              let startSum := max 0 x\n              let result := findMaxProduct (x :: rest) initialMax startSum\n              result.toNat\n\n  handleList numbers\n\n@[reducible, simp]\ndef maxSubarraySum_postcond (numbers : List Int) (result: Int) (h_precond : maxSubarraySum_precond (numbers)) : Prop :=\n  let subArraySums :=\n    List.range (numbers.length + 1) |>.flatMap (fun start =>\n      List.range (numbers.length - start + 1) |>.map (fun len =>\n        numbers.drop start |>.take len |>.sum))\n  subArraySums.contains result ∧ subArraySums.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxSubarraySum_spec_satisfied (numbers: List Int) (h_precond : maxSubarraySum_precond (numbers)) :\n    maxSubarraySum_postcond (numbers) (maxSubarraySum (numbers) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_46", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis test implements a function in Lean 4 that finds the maximum sum of any contiguous subarray within a list of integers. A subarray is a continuous section of the original array. If all integers in the list are negative, the function should return 0 (representing the empty subarray).\n\n-----Input-----\nnumbers: A list of integers that may contain positive, negative, or zero values.\n\n-----Output-----\nAn integer representing the maximum sum of any contiguous subarray. If the list is empty or contains only negative numbers, the function returns 0.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxSubarraySum_spec_satisfied (numbers: List Int) (h_precond : maxSubarraySum_precond (numbers)) :\n    maxSubarraySum_postcond (numbers) (maxSubarraySum (numbers) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxSubarraySum_precond (numbers : List Int) : Prop :=\n  True\n\ndef maxSubarraySum (numbers : List Int) (h_precond : maxSubarraySum_precond (numbers)) : Int :=\n  let rec isAllNegative : List Int → Bool\n    | [] => true\n    | x :: xs => if x >= 0 then false else isAllNegative xs\n\n  let rec findMaxProduct : List Int → Int → Int → Int\n    | [], currMax, _ => currMax\n    | [x], currMax, _ => max currMax x\n    | x :: y :: rest, currMax, currSum =>\n        let newSum := max y (currSum + y)\n        let newMax := max currMax newSum\n        findMaxProduct (y :: rest) newMax newSum\n\n  let handleList : List Int → Nat\n    | [] => 0\n    | xs =>\n        if isAllNegative xs then\n          0\n        else\n          match xs with\n          | [] => 0\n          | x :: rest =>\n              let initialMax := max 0 x\n              let startSum := max 0 x\n              let result := findMaxProduct (x :: rest) initialMax startSum\n              result.toNat\n\n  handleList numbers\n\n@[reducible, simp]\ndef maxSubarraySum_postcond (numbers : List Int) (result: Int) (h_precond : maxSubarraySum_precond (numbers)) : Prop :=\n  let subArraySums :=\n    List.range (numbers.length + 1) |>.flatMap (fun start =>\n      List.range (numbers.length - start + 1) |>.map (fun len =>\n        numbers.drop start |>.take len |>.sum))\n  subArraySums.contains result ∧ subArraySums.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxSubarraySum_spec_satisfied (numbers: List Int) (h_precond : maxSubarraySum_precond (numbers)) :\n    maxSubarraySum_postcond (numbers) (maxSubarraySum (numbers) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_46"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that merges all overlapping intervals from a given list of intervals.\n\nEach interval is represented as a pair [start, end], indicating the start and end of the interval. If two intervals overlap, they should be merged into a single interval that spans from the minimum start to the maximum end of the overlapping intervals.\n\nThe goal is to return a list of non-overlapping intervals that cover all the input intervals after merging.\n\n-----Input-----\nThe input consists of one array:\n\nintervals: An array of pairs of integers where intervals[i] = [startᵢ, endᵢ] represents the start and end of the ith interval.\n\n-----Output-----\nThe output is an array of pairs of integers:\nReturns the list of merged, non-overlapping intervals sorted by their start times.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeIntervals_spec_satisfied (intervals: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) :\n    mergeIntervals_postcond (intervals) (mergeIntervals (intervals) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef mergeIntervals_precond (intervals : List (Prod Int Int)) : Prop :=\n  True\n\ndef mergeIntervals (intervals : List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : List (Prod Int Int) :=\n  let rec insert (x : Prod Int Int) (sorted : List (Prod Int Int)) : List (Prod Int Int) :=\n    match sorted with\n    | [] => [x]\n    | y :: ys => if x.fst ≤ y.fst then x :: sorted else y :: insert x ys\n\n  let rec sort (xs : List (Prod Int Int)) : List (Prod Int Int) :=\n    match xs with\n    | [] => []\n    | x :: xs' => insert x (sort xs')\n\n  let sorted := sort intervals\n\n  let rec merge (xs : List (Prod Int Int)) (acc : List (Prod Int Int)) : List (Prod Int Int) :=\n    match xs, acc with\n    | [], _ => acc.reverse\n    | (s, e) :: rest, [] => merge rest [(s, e)]\n    | (s, e) :: rest, (ps, pe) :: accTail =>\n      if s ≤ pe then\n        merge rest ((ps, max pe e) :: accTail)\n      else\n        merge rest ((s, e) :: (ps, pe) :: accTail)\n\n  merge sorted []\n\n@[reducible, simp]\ndef mergeIntervals_postcond (intervals : List (Prod Int Int)) (result: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : Prop :=\n  let covered := intervals.all (fun (s, e) =>\n    result.any (fun (rs, re) => rs ≤ s ∧ e ≤ re))\n\n  let rec noOverlap (l : List (Prod Int Int)) : Bool :=\n    match l with\n    | [] | [_] => true\n    | (_, e1) :: (s2, e2) :: rest => e1 < s2 && noOverlap ((s2, e2) :: rest)\n\n  covered ∧ noOverlap result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeIntervals_spec_satisfied (intervals: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) :\n    mergeIntervals_postcond (intervals) (mergeIntervals (intervals) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_47", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that merges all overlapping intervals from a given list of intervals.\n\nEach interval is represented as a pair [start, end], indicating the start and end of the interval. If two intervals overlap, they should be merged into a single interval that spans from the minimum start to the maximum end of the overlapping intervals.\n\nThe goal is to return a list of non-overlapping intervals that cover all the input intervals after merging.\n\n-----Input-----\nThe input consists of one array:\n\nintervals: An array of pairs of integers where intervals[i] = [startᵢ, endᵢ] represents the start and end of the ith interval.\n\n-----Output-----\nThe output is an array of pairs of integers:\nReturns the list of merged, non-overlapping intervals sorted by their start times.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeIntervals_spec_satisfied (intervals: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) :\n    mergeIntervals_postcond (intervals) (mergeIntervals (intervals) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef mergeIntervals_precond (intervals : List (Prod Int Int)) : Prop :=\n  True\n\ndef mergeIntervals (intervals : List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : List (Prod Int Int) :=\n  let rec insert (x : Prod Int Int) (sorted : List (Prod Int Int)) : List (Prod Int Int) :=\n    match sorted with\n    | [] => [x]\n    | y :: ys => if x.fst ≤ y.fst then x :: sorted else y :: insert x ys\n\n  let rec sort (xs : List (Prod Int Int)) : List (Prod Int Int) :=\n    match xs with\n    | [] => []\n    | x :: xs' => insert x (sort xs')\n\n  let sorted := sort intervals\n\n  let rec merge (xs : List (Prod Int Int)) (acc : List (Prod Int Int)) : List (Prod Int Int) :=\n    match xs, acc with\n    | [], _ => acc.reverse\n    | (s, e) :: rest, [] => merge rest [(s, e)]\n    | (s, e) :: rest, (ps, pe) :: accTail =>\n      if s ≤ pe then\n        merge rest ((ps, max pe e) :: accTail)\n      else\n        merge rest ((s, e) :: (ps, pe) :: accTail)\n\n  merge sorted []\n\n@[reducible, simp]\ndef mergeIntervals_postcond (intervals : List (Prod Int Int)) (result: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : Prop :=\n  let covered := intervals.all (fun (s, e) =>\n    result.any (fun (rs, re) => rs ≤ s ∧ e ≤ re))\n\n  let rec noOverlap (l : List (Prod Int Int)) : Bool :=\n    match l with\n    | [] | [_] => true\n    | (_, e1) :: (s2, e2) :: rest => e1 < s2 && noOverlap ((s2, e2) :: rest)\n\n  covered ∧ noOverlap result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeIntervals_spec_satisfied (intervals: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) :\n    mergeIntervals_postcond (intervals) (mergeIntervals (intervals) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_47"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing the merge sort algorithm in Lean 4 to sort a list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that recursively splits the input list into two halves, sorts them separately, and then merges the sorted halves to produce the final sorted result.\n\nThe merge sort algorithm works as follows:\n1. If the list has one element or is empty, it is already sorted.\n2. Otherwise, divide the list into two roughly equal parts.\n3. Recursively sort both halves.\n4. Merge the two sorted halves to produce a single sorted list.\n\nThe key operation in merge sort is the merging step, which takes two sorted lists and combines them into a single sorted list by repeatedly taking the smaller of the two elements at the front of the lists.\n\n-----Input-----\nThe input consists of one parameter:\nlist: A list of integers that needs to be sorted.\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from the input list, sorted in ascending order. \n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSort_spec_satisfied (list: List Int) (h_precond : mergeSort_precond (list)) :\n    mergeSort_postcond (list) (mergeSort (list) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef mergeSort_precond (list : List Int) : Prop :=\n  True\n\ndef mergeSort (list : List Int) (h_precond : mergeSort_precond (list)) : List Int :=\n\n  let rec insert (x : Int) (sorted : List Int) : List Int :=\n    match sorted with\n    | [] => [x]\n    | y :: ys =>\n        if x ≤ y then\n          x :: sorted\n        else\n          y :: insert x ys\n  termination_by sorted.length\n\n  let rec sort (l : List Int) : List Int :=\n    match l with\n    | [] => []\n    | x :: xs =>\n        let sortedRest := sort xs\n        insert x sortedRest\n  termination_by l.length\n\n  sort list\n\n@[reducible, simp]\ndef mergeSort_postcond (list : List Int) (result: List Int) (h_precond : mergeSort_precond (list)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm list result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSort_spec_satisfied (list: List Int) (h_precond : mergeSort_precond (list)) :\n    mergeSort_postcond (list) (mergeSort (list) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_48", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing the merge sort algorithm in Lean 4 to sort a list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that recursively splits the input list into two halves, sorts them separately, and then merges the sorted halves to produce the final sorted result.\n\nThe merge sort algorithm works as follows:\n1. If the list has one element or is empty, it is already sorted.\n2. Otherwise, divide the list into two roughly equal parts.\n3. Recursively sort both halves.\n4. Merge the two sorted halves to produce a single sorted list.\n\nThe key operation in merge sort is the merging step, which takes two sorted lists and combines them into a single sorted list by repeatedly taking the smaller of the two elements at the front of the lists.\n\n-----Input-----\nThe input consists of one parameter:\nlist: A list of integers that needs to be sorted.\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from the input list, sorted in ascending order. \n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSort_spec_satisfied (list: List Int) (h_precond : mergeSort_precond (list)) :\n    mergeSort_postcond (list) (mergeSort (list) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef mergeSort_precond (list : List Int) : Prop :=\n  True\n\ndef mergeSort (list : List Int) (h_precond : mergeSort_precond (list)) : List Int :=\n\n  let rec insert (x : Int) (sorted : List Int) : List Int :=\n    match sorted with\n    | [] => [x]\n    | y :: ys =>\n        if x ≤ y then\n          x :: sorted\n        else\n          y :: insert x ys\n  termination_by sorted.length\n\n  let rec sort (l : List Int) : List Int :=\n    match l with\n    | [] => []\n    | x :: xs =>\n        let sortedRest := sort xs\n        insert x sortedRest\n  termination_by l.length\n\n  sort list\n\n@[reducible, simp]\ndef mergeSort_postcond (list : List Int) (result: List Int) (h_precond : mergeSort_precond (list)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm list result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSort_spec_satisfied (list: List Int) (h_precond : mergeSort_precond (list)) :\n    mergeSort_postcond (list) (mergeSort (list) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_48"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement a Lean 4 function that merges two ascendingly sorted lists of integers into one single sorted list (ascending). The resulting list must contain all elements from both input lists, preserving their ascending order.\n\n-----Input-----\nThe input consists of two lists of integers:\narr1: A sorted list of integers (ascending)\narr2: Another sorted list of integers (ascending)\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from arr1 and arr2, sorted in ascending order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSortedLists_spec_satisfied (arr1: List Int) (arr2: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) :\n    mergeSortedLists_postcond (arr1) (arr2) (mergeSortedLists (arr1) (arr2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef mergeSortedLists_precond (arr1 : List Int) (arr2 : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr1 ∧ List.Pairwise (· ≤ ·) arr2\n\ndef mergeSortedLists (arr1 : List Int) (arr2 : List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : List Int :=\n  let rec merge (xs : List Int) (ys : List Int) : List Int :=\n    match xs, ys with\n    | [], _ => ys\n    | _, [] => xs\n    | x :: xt, y :: yt =>\n      if x <= y then\n        x :: merge xt (y :: yt)\n      else\n        y :: merge (x :: xt) yt\n\n  merge arr1 arr2\n\n@[reducible]\ndef mergeSortedLists_postcond (arr1 : List Int) (arr2 : List Int) (result: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm (arr1 ++ arr2) result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSortedLists_spec_satisfied (arr1: List Int) (arr2: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) :\n    mergeSortedLists_postcond (arr1) (arr2) (mergeSortedLists (arr1) (arr2) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_49", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement a Lean 4 function that merges two ascendingly sorted lists of integers into one single sorted list (ascending). The resulting list must contain all elements from both input lists, preserving their ascending order.\n\n-----Input-----\nThe input consists of two lists of integers:\narr1: A sorted list of integers (ascending)\narr2: Another sorted list of integers (ascending)\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from arr1 and arr2, sorted in ascending order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSortedLists_spec_satisfied (arr1: List Int) (arr2: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) :\n    mergeSortedLists_postcond (arr1) (arr2) (mergeSortedLists (arr1) (arr2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef mergeSortedLists_precond (arr1 : List Int) (arr2 : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr1 ∧ List.Pairwise (· ≤ ·) arr2\n\ndef mergeSortedLists (arr1 : List Int) (arr2 : List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : List Int :=\n  let rec merge (xs : List Int) (ys : List Int) : List Int :=\n    match xs, ys with\n    | [], _ => ys\n    | _, [] => xs\n    | x :: xt, y :: yt =>\n      if x <= y then\n        x :: merge xt (y :: yt)\n      else\n        y :: merge (x :: xt) yt\n\n  merge arr1 arr2\n\n@[reducible]\ndef mergeSortedLists_postcond (arr1 : List Int) (arr2 : List Int) (result: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm (arr1 ++ arr2) result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSortedLists_spec_satisfied (arr1: List Int) (arr2: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) :\n    mergeSortedLists_postcond (arr1) (arr2) (mergeSortedLists (arr1) (arr2) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_49"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that adds two non-empty linked lists representing non-negative integers.\nThe digits are stored in reverse order (i.e., the first element is the least significant digit).\nEach node (list element) holds a single digit (ranging from 0 to 9). The function should add the two numbers and return the sum \nas a linked list, also in reverse order.\n\n-----Input-----\nThe input consists of:\n- l1: A list of natural numbers representing the digits of the first number in reverse order.\n- l2: A list of natural numbers representing the digits of the second number in reverse order.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a list of digits (in reverse order) representing the sum of the two input numbers.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem addTwoNumbers_spec_satisfied (l1: List Nat) (l2: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) :\n    addTwoNumbers_postcond (l1) (l2) (addTwoNumbers (l1) (l2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef listToNat : List Nat → Nat\n| []       => 0\n| d :: ds  => d + 10 * listToNat ds\n\n@[reducible]\ndef addTwoNumbers_precond (l1 : List Nat) (l2 : List Nat) : Prop :=\n  l1.length > 0 ∧ l2.length > 0 ∧\n  (∀ d ∈ l1, d < 10) ∧ (∀ d ∈ l2, d < 10) ∧\n  (l1.getLast! ≠ 0 ∨ l1 = [0]) ∧\n  (l2.getLast! ≠ 0 ∨ l2 = [0])\n\ndef addTwoNumbers (l1 : List Nat) (l2 : List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) : List Nat :=\n  let rec addAux (l1 l2 : List Nat) (carry : Nat) : List Nat :=\n    match l1, l2 with\n    | [], [] =>\n      if carry = 0 then [] else [carry]\n    | h1::t1, [] =>\n      let sum := h1 + carry\n      (sum % 10) :: addAux t1 [] (sum / 10)\n    | [], h2::t2 =>\n      let sum := h2 + carry\n      (sum % 10) :: addAux [] t2 (sum / 10)\n    | h1::t1, h2::t2 =>\n      let sum := h1 + h2 + carry\n      (sum % 10) :: addAux t1 t2 (sum / 10)\n  addAux l1 l2 0\n\n@[reducible]\ndef addTwoNumbers_postcond (l1 : List Nat) (l2 : List Nat) (result: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) : Prop :=\n  listToNat result = listToNat l1 + listToNat l2 ∧\n  (∀ d ∈ result, d < 10) ∧\n  (result.getLast! ≠ 0 ∨ (l1 = [0] ∧ l2 = [0] ∧ result = [0]))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem addTwoNumbers_spec_satisfied (l1: List Nat) (l2: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) :\n    addTwoNumbers_postcond (l1) (l2) (addTwoNumbers (l1) (l2) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_5", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that adds two non-empty linked lists representing non-negative integers.\nThe digits are stored in reverse order (i.e., the first element is the least significant digit).\nEach node (list element) holds a single digit (ranging from 0 to 9). The function should add the two numbers and return the sum \nas a linked list, also in reverse order.\n\n-----Input-----\nThe input consists of:\n- l1: A list of natural numbers representing the digits of the first number in reverse order.\n- l2: A list of natural numbers representing the digits of the second number in reverse order.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a list of digits (in reverse order) representing the sum of the two input numbers.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem addTwoNumbers_spec_satisfied (l1: List Nat) (l2: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) :\n    addTwoNumbers_postcond (l1) (l2) (addTwoNumbers (l1) (l2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef listToNat : List Nat → Nat\n| []       => 0\n| d :: ds  => d + 10 * listToNat ds\n\n@[reducible]\ndef addTwoNumbers_precond (l1 : List Nat) (l2 : List Nat) : Prop :=\n  l1.length > 0 ∧ l2.length > 0 ∧\n  (∀ d ∈ l1, d < 10) ∧ (∀ d ∈ l2, d < 10) ∧\n  (l1.getLast! ≠ 0 ∨ l1 = [0]) ∧\n  (l2.getLast! ≠ 0 ∨ l2 = [0])\n\ndef addTwoNumbers (l1 : List Nat) (l2 : List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) : List Nat :=\n  let rec addAux (l1 l2 : List Nat) (carry : Nat) : List Nat :=\n    match l1, l2 with\n    | [], [] =>\n      if carry = 0 then [] else [carry]\n    | h1::t1, [] =>\n      let sum := h1 + carry\n      (sum % 10) :: addAux t1 [] (sum / 10)\n    | [], h2::t2 =>\n      let sum := h2 + carry\n      (sum % 10) :: addAux [] t2 (sum / 10)\n    | h1::t1, h2::t2 =>\n      let sum := h1 + h2 + carry\n      (sum % 10) :: addAux t1 t2 (sum / 10)\n  addAux l1 l2 0\n\n@[reducible]\ndef addTwoNumbers_postcond (l1 : List Nat) (l2 : List Nat) (result: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) : Prop :=\n  listToNat result = listToNat l1 + listToNat l2 ∧\n  (∀ d ∈ result, d < 10) ∧\n  (result.getLast! ≠ 0 ∨ (l1 = [0] ∧ l2 = [0] ∧ result = [0]))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem addTwoNumbers_spec_satisfied (l1: List Nat) (l2: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) :\n    addTwoNumbers_postcond (l1) (l2) (addTwoNumbers (l1) (l2) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_5"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves merging two sorted arrays of natural numbers (it is ill defined if inputs aren't sorted.)\n-----Input-----\nThe input consists of two arrays:\na1: A sorted array of natural numbers\na2: A sorted array of natural numbers\n-----Output-----\nThe output is an array:\nReturns a new array with all elements from both input arrays (included once and only once)\nThe resulting array is sorted itself\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSorted_spec_satisfied (a1: Array Nat) (a2: Array Nat) :\n    mergeSorted_postcond (a1) (a2) (mergeSorted (a1) (a2)) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef mergeSorted_precond (a1 : Array Nat) (a2 : Array Nat) : Prop :=\n  List.Pairwise (· ≤ ·) a1.toList ∧ List.Pairwise (· ≤ ·) a2.toList\n\ndef mergeSorted (a1 : Array Nat) (a2 : Array Nat) : Array Nat :=\n  Id.run <| do\n    let mut i := 0\n    let mut j := 0\n    let mut result := #[]\n    while i < a1.size ∧ j < a2.size do\n      if a1[i]! ≤ a2[j]! then\n        result := result.push a1[i]!\n        i := i + 1\n      else\n        result := result.push a2[j]!\n        j := j + 1\n    while i < a1.size do\n      result := result.push a1[i]!\n      i := i + 1\n    while j < a2.size do\n      result := result.push a2[j]!\n      j := j + 1\n    return result\n\n@[reducible]\ndef mergeSorted_postcond (a1 : Array Nat) (a2 : Array Nat) (result: Array Nat) : Prop :=\n  List.Pairwise (· ≤ ·) result.toList ∧\n  result.toList.isPerm (a1.toList ++ a2.toList)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSorted_spec_satisfied (a1: Array Nat) (a2: Array Nat) :\n    mergeSorted_postcond (a1) (a2) (mergeSorted (a1) (a2)) := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_50", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves merging two sorted arrays of natural numbers (it is ill defined if inputs aren't sorted.)\n-----Input-----\nThe input consists of two arrays:\na1: A sorted array of natural numbers\na2: A sorted array of natural numbers\n-----Output-----\nThe output is an array:\nReturns a new array with all elements from both input arrays (included once and only once)\nThe resulting array is sorted itself\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSorted_spec_satisfied (a1: Array Nat) (a2: Array Nat) :\n    mergeSorted_postcond (a1) (a2) (mergeSorted (a1) (a2)) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef mergeSorted_precond (a1 : Array Nat) (a2 : Array Nat) : Prop :=\n  List.Pairwise (· ≤ ·) a1.toList ∧ List.Pairwise (· ≤ ·) a2.toList\n\ndef mergeSorted (a1 : Array Nat) (a2 : Array Nat) : Array Nat :=\n  Id.run <| do\n    let mut i := 0\n    let mut j := 0\n    let mut result := #[]\n    while i < a1.size ∧ j < a2.size do\n      if a1[i]! ≤ a2[j]! then\n        result := result.push a1[i]!\n        i := i + 1\n      else\n        result := result.push a2[j]!\n        j := j + 1\n    while i < a1.size do\n      result := result.push a1[i]!\n      i := i + 1\n    while j < a2.size do\n      result := result.push a2[j]!\n      j := j + 1\n    return result\n\n@[reducible]\ndef mergeSorted_postcond (a1 : Array Nat) (a2 : Array Nat) (result: Array Nat) : Prop :=\n  List.Pairwise (· ≤ ·) result.toList ∧\n  result.toList.isPerm (a1.toList ++ a2.toList)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSorted_spec_satisfied (a1: Array Nat) (a2: Array Nat) :\n    mergeSorted_postcond (a1) (a2) (mergeSorted (a1) (a2)) := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_50"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.\n\n-----Input-----\nThe input consists of:\na: A list of integers sorted in non-decreasing order.\nb: Another list of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a list of integers:\nReturns a merged list that contains all elements from both input lists, sorted in non-decreasing order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSorted_spec_satisfied (a: List Int) (b: List Int) (h_precond : mergeSorted_precond (a) (b)) :\n    mergeSorted_postcond (a) (b) (mergeSorted (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef mergeSorted_precond (a : List Int) (b : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) a ∧ List.Pairwise (· ≤ ·) b\n\ndef mergeSortedAux : List Int → List Int → List Int\n| [], ys => ys\n| xs, [] => xs\n| x :: xs', y :: ys' =>\n  if x ≤ y then\n    let merged := mergeSortedAux xs' (y :: ys')\n    x :: merged\n  else\n    let merged := mergeSortedAux (x :: xs') ys'\n    y :: merged\n\ndef mergeSorted (a : List Int) (b : List Int) (h_precond : mergeSorted_precond (a) (b)) : List Int :=\n  let merged := mergeSortedAux a b\n  merged\n\n@[reducible, simp]\ndef mergeSorted_postcond (a : List Int) (b : List Int) (result: List Int) (h_precond : mergeSorted_precond (a) (b)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧\n  List.isPerm result (a ++ b)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSorted_spec_satisfied (a: List Int) (b: List Int) (h_precond : mergeSorted_precond (a) (b)) :\n    mergeSorted_postcond (a) (b) (mergeSorted (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_51", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.\n\n-----Input-----\nThe input consists of:\na: A list of integers sorted in non-decreasing order.\nb: Another list of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a list of integers:\nReturns a merged list that contains all elements from both input lists, sorted in non-decreasing order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mergeSorted_spec_satisfied (a: List Int) (b: List Int) (h_precond : mergeSorted_precond (a) (b)) :\n    mergeSorted_postcond (a) (b) (mergeSorted (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef mergeSorted_precond (a : List Int) (b : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) a ∧ List.Pairwise (· ≤ ·) b\n\ndef mergeSortedAux : List Int → List Int → List Int\n| [], ys => ys\n| xs, [] => xs\n| x :: xs', y :: ys' =>\n  if x ≤ y then\n    let merged := mergeSortedAux xs' (y :: ys')\n    x :: merged\n  else\n    let merged := mergeSortedAux (x :: xs') ys'\n    y :: merged\n\ndef mergeSorted (a : List Int) (b : List Int) (h_precond : mergeSorted_precond (a) (b)) : List Int :=\n  let merged := mergeSortedAux a b\n  merged\n\n@[reducible, simp]\ndef mergeSorted_postcond (a : List Int) (b : List Int) (result: List Int) (h_precond : mergeSorted_precond (a) (b)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧\n  List.isPerm result (a ++ b)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mergeSorted_spec_satisfied (a: List Int) (b: List Int) (h_precond : mergeSorted_precond (a) (b)) :\n    mergeSorted_postcond (a) (b) (mergeSorted (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_51"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the minimum number of operations to collect the integers from 1 to k by performing the following removal operation on a list of integers.\n\nA removal operation consists of removing the last element from the list nums and adding it to your collection.\n\nThe goal is to determine how many elements must be removed from the end of the list until the set of collected elements (that are less than or equal to k) contains all integers from 1 to k, inclusive.\n\n-----Input-----\nThe input consists of a list and a positive integer:\nnums: A list of positive integers.\nk: A positive integer representing the target upper bound for the collection (i.e., we want to collect 1, 2, ..., k).\n\n-----Output-----\nThe output is an integer:\nReturn the minimum number of operations (elements removed from the end of nums) required to have collected all integers from 1 to k.\n\n-----Note-----\nIt is assumed that the input list contains all integers from 1 to k.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minOperations_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : minOperations_precond (nums) (k)) :\n    minOperations_postcond (nums) (k) (minOperations (nums) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef minOperations_precond (nums : List Nat) (k : Nat) : Prop :=\n  let target_nums := (List.range k).map (· + 1)\n  target_nums.all (fun n => List.elem n nums)\n\ndef minOperations (nums : List Nat) (k : Nat) (h_precond : minOperations_precond (nums) (k)) : Nat :=\n  if k == 0 then 0 else\n  let rec loop (remaining : List Nat) (collected : List Nat) (collected_count : Nat) (ops : Nat) : Nat :=\n    match remaining with\n    | [] => ops -- base case\n    | head :: tail =>\n      let ops' := ops + 1\n      if head > 0 && head <= k && !(List.elem head collected) then\n          let collected' := head :: collected -- add new unique element to our tracking list\n          let collected_count' := collected_count + 1\n          if collected_count' == k then\n            ops' -- found all k distinct required numbers\n          else\n            loop tail collected' collected_count' ops' -- continue searching, count increased\n      else\n        loop tail collected collected_count ops' -- continue searching, count not increased\n  loop nums.reverse [] 0 0\n\n@[reducible, simp]\ndef minOperations_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : minOperations_precond (nums) (k)) : Prop :=\n  let processed := (nums.reverse).take result\n  let target_nums := (List.range k).map (· + 1)\n\n  let collected_all := target_nums.all (fun n => List.elem n processed)\n\n  let is_minimal :=\n    if result > 0 then\n      let processed_minus_one := (nums.reverse).take (result - 1)\n      ¬ (target_nums.all (fun n => List.elem n processed_minus_one))\n    else\n      k == 0\n\n  collected_all ∧ is_minimal\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minOperations_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : minOperations_precond (nums) (k)) :\n    minOperations_postcond (nums) (k) (minOperations (nums) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_52", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the minimum number of operations to collect the integers from 1 to k by performing the following removal operation on a list of integers.\n\nA removal operation consists of removing the last element from the list nums and adding it to your collection.\n\nThe goal is to determine how many elements must be removed from the end of the list until the set of collected elements (that are less than or equal to k) contains all integers from 1 to k, inclusive.\n\n-----Input-----\nThe input consists of a list and a positive integer:\nnums: A list of positive integers.\nk: A positive integer representing the target upper bound for the collection (i.e., we want to collect 1, 2, ..., k).\n\n-----Output-----\nThe output is an integer:\nReturn the minimum number of operations (elements removed from the end of nums) required to have collected all integers from 1 to k.\n\n-----Note-----\nIt is assumed that the input list contains all integers from 1 to k.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minOperations_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : minOperations_precond (nums) (k)) :\n    minOperations_postcond (nums) (k) (minOperations (nums) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef minOperations_precond (nums : List Nat) (k : Nat) : Prop :=\n  let target_nums := (List.range k).map (· + 1)\n  target_nums.all (fun n => List.elem n nums)\n\ndef minOperations (nums : List Nat) (k : Nat) (h_precond : minOperations_precond (nums) (k)) : Nat :=\n  if k == 0 then 0 else\n  let rec loop (remaining : List Nat) (collected : List Nat) (collected_count : Nat) (ops : Nat) : Nat :=\n    match remaining with\n    | [] => ops -- base case\n    | head :: tail =>\n      let ops' := ops + 1\n      if head > 0 && head <= k && !(List.elem head collected) then\n          let collected' := head :: collected -- add new unique element to our tracking list\n          let collected_count' := collected_count + 1\n          if collected_count' == k then\n            ops' -- found all k distinct required numbers\n          else\n            loop tail collected' collected_count' ops' -- continue searching, count increased\n      else\n        loop tail collected collected_count ops' -- continue searching, count not increased\n  loop nums.reverse [] 0 0\n\n@[reducible, simp]\ndef minOperations_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : minOperations_precond (nums) (k)) : Prop :=\n  let processed := (nums.reverse).take result\n  let target_nums := (List.range k).map (· + 1)\n\n  let collected_all := target_nums.all (fun n => List.elem n processed)\n\n  let is_minimal :=\n    if result > 0 then\n      let processed_minus_one := (nums.reverse).take (result - 1)\n      ¬ (target_nums.all (fun n => List.elem n processed_minus_one))\n    else\n      k == 0\n\n  collected_all ∧ is_minimal\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minOperations_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : minOperations_precond (nums) (k)) :\n    minOperations_postcond (nums) (k) (minOperations (nums) (k) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_52"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that calculates the minimum number of right shifts required to sort a given list of distinct positive integers.\n\nA right shift operation on a list nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.\n\nThe function should return the minimum number of right shifts needed to make the list sorted in ascending order. If the list is already sorted, the function should return 0. If it's impossible to sort the list using only right shifts, the function should return -1.\n\n-----Input-----\nThe input consists of a single list of integers:\nnums: A list (List Int) containing distinct positive integers.\n\n-----Output-----\nThe output is a single integer (Int):\n- If the list can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).\n- If the list cannot be sorted using right shifts, return -1.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minimumRightShifts_spec_satisfied (nums: List Int) (h_precond : minimumRightShifts_precond (nums)) :\n    minimumRightShifts_postcond (nums) (minimumRightShifts (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef minimumRightShifts_precond (nums : List Int) : Prop :=\n  List.Nodup nums\n\ndef minimumRightShifts (nums : List Int) (h_precond : minimumRightShifts_precond (nums)) : Int :=\n  let n := nums.length\n  if n <= 1 then 0 else\n\n  let rec isSortedAux (l : List Int) : Bool :=\n    match l with\n    | [] => true       -- empty list is sorted\n    | [_] => true      -- single element list is sorted\n    | x :: y :: xs => if x <= y then isSortedAux (y :: xs) else false -- check pairwise\n\n  if isSortedAux nums then 0 else\n\n  let rightShiftOnce (l : List Int) : List Int :=\n     match l.reverse with\n     | [] => [] -- should not happen for n > 1\n     | last :: revInit => last :: revInit.reverse -- `last` is the original last element\n\n  let rec checkShifts (shifts_count : Nat) (current_list : List Int) : Int :=\n    if shifts_count >= n then -1\n    else\n      if isSortedAux current_list then\n        (shifts_count : Int) -- found it after 'shifts_count' shifts\n      else\n        checkShifts (shifts_count + 1) (rightShiftOnce current_list)\n  termination_by n - shifts_count\n\n  checkShifts 1 (rightShiftOnce nums) -- start checking from the state after 1 shift\n\n@[reducible, simp]\ndef minimumRightShifts_postcond (nums : List Int) (result: Int) (h_precond : minimumRightShifts_precond (nums)) : Prop :=\n  let n := nums.length\n\n  let isSorted (l : List Int) := List.Pairwise (· ≤ ·) l\n  let rightShift (k : Nat) (l : List Int) := l.rotateRight k\n\n  if n <= 1 then result = 0 else -- specification for base cases\n\n  (result ≥ 0 ∧\n   result < n ∧\n   isSorted (rightShift result.toNat nums) ∧\n   (List.range result.toNat |>.all (fun j => ¬ isSorted (rightShift j nums)))\n  ) ∨\n\n  (result = -1 ∧\n   (List.range n |>.all (fun k => ¬ isSorted (rightShift k nums)))\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minimumRightShifts_spec_satisfied (nums: List Int) (h_precond : minimumRightShifts_precond (nums)) :\n    minimumRightShifts_postcond (nums) (minimumRightShifts (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_53", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that calculates the minimum number of right shifts required to sort a given list of distinct positive integers.\n\nA right shift operation on a list nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.\n\nThe function should return the minimum number of right shifts needed to make the list sorted in ascending order. If the list is already sorted, the function should return 0. If it's impossible to sort the list using only right shifts, the function should return -1.\n\n-----Input-----\nThe input consists of a single list of integers:\nnums: A list (List Int) containing distinct positive integers.\n\n-----Output-----\nThe output is a single integer (Int):\n- If the list can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).\n- If the list cannot be sorted using right shifts, return -1.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minimumRightShifts_spec_satisfied (nums: List Int) (h_precond : minimumRightShifts_precond (nums)) :\n    minimumRightShifts_postcond (nums) (minimumRightShifts (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef minimumRightShifts_precond (nums : List Int) : Prop :=\n  List.Nodup nums\n\ndef minimumRightShifts (nums : List Int) (h_precond : minimumRightShifts_precond (nums)) : Int :=\n  let n := nums.length\n  if n <= 1 then 0 else\n\n  let rec isSortedAux (l : List Int) : Bool :=\n    match l with\n    | [] => true       -- empty list is sorted\n    | [_] => true      -- single element list is sorted\n    | x :: y :: xs => if x <= y then isSortedAux (y :: xs) else false -- check pairwise\n\n  if isSortedAux nums then 0 else\n\n  let rightShiftOnce (l : List Int) : List Int :=\n     match l.reverse with\n     | [] => [] -- should not happen for n > 1\n     | last :: revInit => last :: revInit.reverse -- `last` is the original last element\n\n  let rec checkShifts (shifts_count : Nat) (current_list : List Int) : Int :=\n    if shifts_count >= n then -1\n    else\n      if isSortedAux current_list then\n        (shifts_count : Int) -- found it after 'shifts_count' shifts\n      else\n        checkShifts (shifts_count + 1) (rightShiftOnce current_list)\n  termination_by n - shifts_count\n\n  checkShifts 1 (rightShiftOnce nums) -- start checking from the state after 1 shift\n\n@[reducible, simp]\ndef minimumRightShifts_postcond (nums : List Int) (result: Int) (h_precond : minimumRightShifts_precond (nums)) : Prop :=\n  let n := nums.length\n\n  let isSorted (l : List Int) := List.Pairwise (· ≤ ·) l\n  let rightShift (k : Nat) (l : List Int) := l.rotateRight k\n\n  if n <= 1 then result = 0 else -- specification for base cases\n\n  (result ≥ 0 ∧\n   result < n ∧\n   isSorted (rightShift result.toNat nums) ∧\n   (List.range result.toNat |>.all (fun j => ¬ isSorted (rightShift j nums)))\n  ) ∨\n\n  (result = -1 ∧\n   (List.range n |>.all (fun k => ¬ isSorted (rightShift k nums)))\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minimumRightShifts_spec_satisfied (nums: List Int) (h_precond : minimumRightShifts_precond (nums)) :\n    minimumRightShifts_postcond (nums) (minimumRightShifts (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_53"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the one missing number in a list of distinct natural numbers from 0 to n. The list contains exactly n numbers and all numbers are in the range [0, n], but one number in that range is missing.\n\nYour function must return the missing number. You may assume the input list contains no duplicates and only one number is missing.\n\n-----Input-----\n- nums: A list of natural numbers of length n, each in the range [0, n] with exactly one number missing.\n\n-----Output-----\n- A natural number: the missing number in the range [0, n] not present in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem missingNumber_spec_satisfied (nums: List Nat) (h_precond : missingNumber_precond (nums)) :\n    missingNumber_postcond (nums) (missingNumber (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef missingNumber_precond (nums : List Nat) : Prop :=\n  nums.all (fun x => x ≤ nums.length) ∧ List.Nodup nums\n\ndef missingNumber (nums : List Nat) (h_precond : missingNumber_precond (nums)) : Nat :=\n  let n := nums.length\n  let expectedSum := (n * (n + 1)) / 2\n  let actualSum := nums.foldl (· + ·) 0\n  expectedSum - actualSum\n\n@[reducible]\ndef missingNumber_postcond (nums : List Nat) (result: Nat) (h_precond : missingNumber_precond (nums)) : Prop :=\n  let n := nums.length\n  (result ∈ List.range (n + 1)) ∧\n  ¬(result ∈ nums) ∧\n  ∀ x, (x ∈ List.range (n + 1)) → x ≠ result → x ∈ nums\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem missingNumber_spec_satisfied (nums: List Nat) (h_precond : missingNumber_precond (nums)) :\n    missingNumber_postcond (nums) (missingNumber (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_54", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that finds the one missing number in a list of distinct natural numbers from 0 to n. The list contains exactly n numbers and all numbers are in the range [0, n], but one number in that range is missing.\n\nYour function must return the missing number. You may assume the input list contains no duplicates and only one number is missing.\n\n-----Input-----\n- nums: A list of natural numbers of length n, each in the range [0, n] with exactly one number missing.\n\n-----Output-----\n- A natural number: the missing number in the range [0, n] not present in the list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem missingNumber_spec_satisfied (nums: List Nat) (h_precond : missingNumber_precond (nums)) :\n    missingNumber_postcond (nums) (missingNumber (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef missingNumber_precond (nums : List Nat) : Prop :=\n  nums.all (fun x => x ≤ nums.length) ∧ List.Nodup nums\n\ndef missingNumber (nums : List Nat) (h_precond : missingNumber_precond (nums)) : Nat :=\n  let n := nums.length\n  let expectedSum := (n * (n + 1)) / 2\n  let actualSum := nums.foldl (· + ·) 0\n  expectedSum - actualSum\n\n@[reducible]\ndef missingNumber_postcond (nums : List Nat) (result: Nat) (h_precond : missingNumber_precond (nums)) : Prop :=\n  let n := nums.length\n  (result ∈ List.range (n + 1)) ∧\n  ¬(result ∈ nums) ∧\n  ∀ x, (x ∈ List.range (n + 1)) → x ≠ result → x ∈ nums\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem missingNumber_spec_satisfied (nums: List Nat) (h_precond : missingNumber_precond (nums)) :\n    missingNumber_postcond (nums) (missingNumber (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_54"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.\n\n-----Input-----\nThe input consists of:\nxs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.\n\n-----Output-----\nThe output is an integer:\nReturns the number that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mostFrequent_spec_satisfied (xs: List Int) (h_precond : mostFrequent_precond (xs)) :\n    mostFrequent_postcond (xs) (mostFrequent (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef mostFrequent_precond (xs : List Int) : Prop :=\n  xs ≠ []\n\ndef countMap (xs : List Int) : HashMap Int Nat :=\n  let step := fun m x =>\n    let current := m.getD x 0\n    m.insert x (current + 1)\n  let init := (HashMap.empty : HashMap Int Nat)\n  xs.foldl step init\n\ndef getMaxFrequency (m : HashMap Int Nat) : Nat :=\n  let step := fun acc (_k, v) =>\n    if v > acc then v else acc\n  let init := 0\n  m.toList.foldl step init\n\ndef getCandidates (m : HashMap Int Nat) (maxFreq : Nat) : List Int :=\n  let isTarget := fun (_k, v) => v = maxFreq\n  let extract := fun (k, _) => k\n  m.toList.filter isTarget |>.map extract\n\ndef getFirstWithFreq (xs : List Int) (candidates : List Int) : Int :=\n  match xs.find? (fun x => candidates.contains x) with\n  | some x => x\n  | none => 0\n\ndef mostFrequent (xs : List Int) (h_precond : mostFrequent_precond (xs)) : Int :=\n  let freqMap := countMap xs\n  let maxF := getMaxFrequency freqMap\n  let candidates := getCandidates freqMap maxF\n  getFirstWithFreq xs candidates\n\n@[reducible]\ndef mostFrequent_postcond (xs : List Int) (result: Int) (h_precond : mostFrequent_precond (xs)) : Prop :=\n  let count := fun x => xs.countP (fun y => y = x)\n  result ∈ xs ∧\n  xs.all (fun x => count x ≤ count result) ∧\n  ((xs.filter (fun x => count x = count result)).head? = some result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mostFrequent_spec_satisfied (xs: List Int) (h_precond : mostFrequent_precond (xs)) :\n    mostFrequent_postcond (xs) (mostFrequent (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_55", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.\n\n-----Input-----\nThe input consists of:\nxs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.\n\n-----Output-----\nThe output is an integer:\nReturns the number that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem mostFrequent_spec_satisfied (xs: List Int) (h_precond : mostFrequent_precond (xs)) :\n    mostFrequent_postcond (xs) (mostFrequent (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef mostFrequent_precond (xs : List Int) : Prop :=\n  xs ≠ []\n\ndef countMap (xs : List Int) : HashMap Int Nat :=\n  let step := fun m x =>\n    let current := m.getD x 0\n    m.insert x (current + 1)\n  let init := (HashMap.empty : HashMap Int Nat)\n  xs.foldl step init\n\ndef getMaxFrequency (m : HashMap Int Nat) : Nat :=\n  let step := fun acc (_k, v) =>\n    if v > acc then v else acc\n  let init := 0\n  m.toList.foldl step init\n\ndef getCandidates (m : HashMap Int Nat) (maxFreq : Nat) : List Int :=\n  let isTarget := fun (_k, v) => v = maxFreq\n  let extract := fun (k, _) => k\n  m.toList.filter isTarget |>.map extract\n\ndef getFirstWithFreq (xs : List Int) (candidates : List Int) : Int :=\n  match xs.find? (fun x => candidates.contains x) with\n  | some x => x\n  | none => 0\n\ndef mostFrequent (xs : List Int) (h_precond : mostFrequent_precond (xs)) : Int :=\n  let freqMap := countMap xs\n  let maxF := getMaxFrequency freqMap\n  let candidates := getCandidates freqMap maxF\n  getFirstWithFreq xs candidates\n\n@[reducible]\ndef mostFrequent_postcond (xs : List Int) (result: Int) (h_precond : mostFrequent_precond (xs)) : Prop :=\n  let count := fun x => xs.countP (fun y => y = x)\n  result ∈ xs ∧\n  xs.all (fun x => count x ≤ count result) ∧\n  ((xs.filter (fun x => count x = count result)).head? = some result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem mostFrequent_spec_satisfied (xs: List Int) (h_precond : mostFrequent_precond (xs)) :\n    mostFrequent_postcond (xs) (mostFrequent (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_55"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that moves all zeroes in a given integer list to the end, while preserving the relative order of the non-zero elements.\n\nThe method `moveZeroes` processes the input list by separating the non-zero and zero elements. It then returns a new list formed by appending all non-zero elements followed by all the zero elements.\n\n-----Input-----\nThe input is a single list of integers:\nxs: A list of integers (type: List Int), possibly containing zero and non-zero values.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list (type: List Int) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :\n    moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef moveZeroes_precond (xs : List Int) : Prop :=\n  True\n\ndef moveZeroes (xs : List Int) (h_precond : moveZeroes_precond (xs)) : List Int :=\n  let nonzeros := xs.filter (fun x => x ≠ 0)\n  let zeros := xs.filter (fun x => x = 0)\n  nonzeros ++ zeros\n\ndef countVal (val : Int) : List Int → Nat\n  | [] => 0\n  | x :: xs =>\n    let rest := countVal val xs\n    if x = val then rest + 1 else rest\n\ndef isSubsequence (xs ys : List Int) : Bool :=\n  match xs, ys with\n  | [], _ => true\n  | _ :: _, [] => false\n  | x :: xt, y :: yt =>\n    if x = y then isSubsequence xt yt else isSubsequence xs yt\n\n@[reducible]\ndef moveZeroes_postcond (xs : List Int) (result: List Int) (h_precond : moveZeroes_precond (xs)) : Prop :=\n  isSubsequence (xs.filter (fun x => x ≠ 0)) result = true ∧\n\n  (result.dropWhile (fun x => x ≠ 0)).all (fun x => x = 0) ∧\n\n  countVal 0 xs = countVal 0 result ∧\n  xs.length = result.length\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :\n    moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_56", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that moves all zeroes in a given integer list to the end, while preserving the relative order of the non-zero elements.\n\nThe method `moveZeroes` processes the input list by separating the non-zero and zero elements. It then returns a new list formed by appending all non-zero elements followed by all the zero elements.\n\n-----Input-----\nThe input is a single list of integers:\nxs: A list of integers (type: List Int), possibly containing zero and non-zero values.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list (type: List Int) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :\n    moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef moveZeroes_precond (xs : List Int) : Prop :=\n  True\n\ndef moveZeroes (xs : List Int) (h_precond : moveZeroes_precond (xs)) : List Int :=\n  let nonzeros := xs.filter (fun x => x ≠ 0)\n  let zeros := xs.filter (fun x => x = 0)\n  nonzeros ++ zeros\n\ndef countVal (val : Int) : List Int → Nat\n  | [] => 0\n  | x :: xs =>\n    let rest := countVal val xs\n    if x = val then rest + 1 else rest\n\ndef isSubsequence (xs ys : List Int) : Bool :=\n  match xs, ys with\n  | [], _ => true\n  | _ :: _, [] => false\n  | x :: xt, y :: yt =>\n    if x = y then isSubsequence xt yt else isSubsequence xs yt\n\n@[reducible]\ndef moveZeroes_postcond (xs : List Int) (result: List Int) (h_precond : moveZeroes_precond (xs)) : Prop :=\n  isSubsequence (xs.filter (fun x => x ≠ 0)) result = true ∧\n\n  (result.dropWhile (fun x => x ≠ 0)).all (fun x => x = 0) ∧\n\n  countVal 0 xs = countVal 0 result ∧\n  xs.length = result.length\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :\n    moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_56"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 function that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.\n\nGiven two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the function should determine the next greater element for each value in `nums1` as it appears in `nums2`. \nAll integers in both arrays are unique, and the length constraints are.\n\n-----Input-----\nThe input consists of two lists of integers:\nnums1: A list of integers, which is a subset of nums2.\nnums2: A list of integers containing all elements from nums1 and possibly additional elements.\n\n-----Output-----\nThe output is a list of integers:\n- An array of the same length as nums1.\n- For each element nums1[i], the corresponding output element is:\n  - The next greater element of nums1[i] in nums2 if one exists\n  - -1 if there is no next greater element\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem nextGreaterElement_spec_satisfied (nums1: List Int) (nums2: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) :\n    nextGreaterElement_postcond (nums1) (nums2) (nextGreaterElement (nums1) (nums2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef nextGreaterElement_precond (nums1 : List Int) (nums2 : List Int) : Prop :=\n  List.Nodup nums1 ∧\n  List.Nodup nums2 ∧\n  nums1.all (fun x => x ∈ nums2)\n\ndef nextGreaterElement (nums1 : List Int) (nums2 : List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : List Int :=\n  let len1 := nums1.length\n\n  let buildNextGreaterMap : List (Int × Int) :=\n    let rec mapLoop (index : Nat) (stack : List Nat) (map : List (Int × Int)) : List (Int × Int) :=\n      if h : index >= nums2.length then\n        stack.foldl (fun acc pos => (nums2[pos]!, -1) :: acc) map\n      else\n        let currentValue := nums2[index]!\n\n        let rec processStack (s : List Nat) (m : List (Int × Int)) : List Nat × List (Int × Int) :=\n          match s with\n          | [] => ([], m)\n          | topIndex :: rest =>\n              let topValue := nums2[topIndex]!\n              if currentValue > topValue then\n                let newMap := (topValue, currentValue) :: m\n                processStack rest newMap\n              else\n                (s, m)\n\n        let (newStack, newMap) := processStack stack map\n\n        mapLoop (index + 1) (index :: newStack) newMap\n      termination_by nums2.length - index\n\n    mapLoop 0 [] []\n\n  let buildResult : List Int :=\n    let rec resultLoop (i : Nat) (result : List Int) : List Int :=\n      if i >= len1 then\n        result.reverse\n      else\n        let val := nums1[i]!\n        let rec findInMap (m : List (Int × Int)) : Int :=\n          match m with\n          | [] => -1\n          | (num, nextGreater) :: rest =>\n              if num == val then nextGreater\n              else findInMap rest\n\n        let nextGreater := findInMap buildNextGreaterMap\n        resultLoop (i + 1) (nextGreater :: result)\n      termination_by len1 - i\n\n    resultLoop 0 []\n\n  buildResult\n\n@[reducible]\ndef nextGreaterElement_postcond (nums1 : List Int) (nums2 : List Int) (result: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : Prop :=\n  result.length = nums1.length ∧\n\n  (List.range nums1.length |>.all (fun i =>\n    let val := nums1[i]!\n    let resultVal := result[i]!\n\n    let j := nums2.findIdx? (fun x => x == val)\n    match j with\n    | none => false\n    | some idx =>\n      let nextGreater := (List.range (nums2.length - idx - 1)).find? (fun k =>\n        let pos := idx + k + 1\n        nums2[pos]! > val\n      )\n\n      match nextGreater with\n      | none => resultVal = -1\n      | some offset => resultVal = nums2[idx + offset + 1]!\n  )) ∧\n  (result.all (fun val =>\n    val = -1 ∨ val ∈ nums2\n  ))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem nextGreaterElement_spec_satisfied (nums1: List Int) (nums2: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) :\n    nextGreaterElement_postcond (nums1) (nums2) (nextGreaterElement (nums1) (nums2) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_57", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 function that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.\n\nGiven two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the function should determine the next greater element for each value in `nums1` as it appears in `nums2`. \nAll integers in both arrays are unique, and the length constraints are.\n\n-----Input-----\nThe input consists of two lists of integers:\nnums1: A list of integers, which is a subset of nums2.\nnums2: A list of integers containing all elements from nums1 and possibly additional elements.\n\n-----Output-----\nThe output is a list of integers:\n- An array of the same length as nums1.\n- For each element nums1[i], the corresponding output element is:\n  - The next greater element of nums1[i] in nums2 if one exists\n  - -1 if there is no next greater element\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem nextGreaterElement_spec_satisfied (nums1: List Int) (nums2: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) :\n    nextGreaterElement_postcond (nums1) (nums2) (nextGreaterElement (nums1) (nums2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef nextGreaterElement_precond (nums1 : List Int) (nums2 : List Int) : Prop :=\n  List.Nodup nums1 ∧\n  List.Nodup nums2 ∧\n  nums1.all (fun x => x ∈ nums2)\n\ndef nextGreaterElement (nums1 : List Int) (nums2 : List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : List Int :=\n  let len1 := nums1.length\n\n  let buildNextGreaterMap : List (Int × Int) :=\n    let rec mapLoop (index : Nat) (stack : List Nat) (map : List (Int × Int)) : List (Int × Int) :=\n      if h : index >= nums2.length then\n        stack.foldl (fun acc pos => (nums2[pos]!, -1) :: acc) map\n      else\n        let currentValue := nums2[index]!\n\n        let rec processStack (s : List Nat) (m : List (Int × Int)) : List Nat × List (Int × Int) :=\n          match s with\n          | [] => ([], m)\n          | topIndex :: rest =>\n              let topValue := nums2[topIndex]!\n              if currentValue > topValue then\n                let newMap := (topValue, currentValue) :: m\n                processStack rest newMap\n              else\n                (s, m)\n\n        let (newStack, newMap) := processStack stack map\n\n        mapLoop (index + 1) (index :: newStack) newMap\n      termination_by nums2.length - index\n\n    mapLoop 0 [] []\n\n  let buildResult : List Int :=\n    let rec resultLoop (i : Nat) (result : List Int) : List Int :=\n      if i >= len1 then\n        result.reverse\n      else\n        let val := nums1[i]!\n        let rec findInMap (m : List (Int × Int)) : Int :=\n          match m with\n          | [] => -1\n          | (num, nextGreater) :: rest =>\n              if num == val then nextGreater\n              else findInMap rest\n\n        let nextGreater := findInMap buildNextGreaterMap\n        resultLoop (i + 1) (nextGreater :: result)\n      termination_by len1 - i\n\n    resultLoop 0 []\n\n  buildResult\n\n@[reducible]\ndef nextGreaterElement_postcond (nums1 : List Int) (nums2 : List Int) (result: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : Prop :=\n  result.length = nums1.length ∧\n\n  (List.range nums1.length |>.all (fun i =>\n    let val := nums1[i]!\n    let resultVal := result[i]!\n\n    let j := nums2.findIdx? (fun x => x == val)\n    match j with\n    | none => false\n    | some idx =>\n      let nextGreater := (List.range (nums2.length - idx - 1)).find? (fun k =>\n        let pos := idx + k + 1\n        nums2[pos]! > val\n      )\n\n      match nextGreater with\n      | none => resultVal = -1\n      | some offset => resultVal = nums2[idx + offset + 1]!\n  )) ∧\n  (result.all (fun val =>\n    val = -1 ∨ val ∈ nums2\n  ))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem nextGreaterElement_spec_satisfied (nums1: List Int) (nums2: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) :\n    nextGreaterElement_postcond (nums1) (nums2) (nextGreaterElement (nums1) (nums2) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_57"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that returns the nth \"ugly number\". Ugly numbers are positive integers whose only prime factors are 2, 3, or 5.\n\nThe function should generate ugly numbers in ascending order and return the nth one. The first ugly number is 1.\n\n-----Input-----\nThe input is a natural number:\n\nn: The index (1-based) of the ugly number to return.\n\n-----Output-----\nThe output is a natural number:\nThe nth smallest ugly number.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem nthUglyNumber_spec_satisfied (n: Nat) (h_precond : nthUglyNumber_precond (n)) :\n    nthUglyNumber_postcond (n) (nthUglyNumber (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef nthUglyNumber_precond (n : Nat) : Prop :=\n  n > 0\n\ndef nextUgly (seq : List Nat) (c2 c3 c5 : Nat) : (Nat × Nat × Nat × Nat) :=\n  let i2 := seq[c2]! * 2\n  let i3 := seq[c3]! * 3\n  let i5 := seq[c5]! * 5\n  let next := min i2 (min i3 i5)\n  let c2' := if next = i2 then c2 + 1 else c2\n  let c3' := if next = i3 then c3 + 1 else c3\n  let c5' := if next = i5 then c5 + 1 else c5\n  (next, c2', c3', c5')\n\ndef nthUglyNumber (n : Nat) (h_precond : nthUglyNumber_precond (n)) : Nat :=\n  let rec loop (i : Nat) (seq : List Nat) (c2 c3 c5 : Nat) : List Nat :=\n    match i with\n    | 0 => seq\n    | Nat.succ i' =>\n      let (next, c2', c3', c5') := nextUgly seq c2 c3 c5\n      loop i' (seq ++ [next]) c2' c3' c5'\n  (loop (n - 1) [1] 0 0 0)[(n - 1)]!\n\ndef divideOut : Nat → Nat → Nat\n  | n, p =>\n    if h : p > 1 ∧ n > 0 ∧ n % p = 0 then\n      have : n / p < n := by\n        apply Nat.div_lt_self\n        · exact h.2.1  -- n > 0\n        · exact Nat.lt_of_succ_le (Nat.succ_le_of_lt h.1)  -- 1 < p, so 2 ≤ p\n      divideOut (n / p) p\n    else n\ntermination_by n p => n\n\ndef isUgly (x : Nat) : Bool :=\n  if x = 0 then\n    false\n  else\n    let n1 := divideOut x 2\n    let n2 := divideOut n1 3\n    let n3 := divideOut n2 5\n    n3 = 1\n\n@[reducible, simp]\ndef nthUglyNumber_postcond (n : Nat) (result: Nat) (h_precond : nthUglyNumber_precond (n)) : Prop :=\n  isUgly result = true ∧\n  ((List.range (result)).filter (fun i => isUgly i)).length = n - 1\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem nthUglyNumber_spec_satisfied (n: Nat) (h_precond : nthUglyNumber_precond (n)) :\n    nthUglyNumber_postcond (n) (nthUglyNumber (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_58", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that returns the nth \"ugly number\". Ugly numbers are positive integers whose only prime factors are 2, 3, or 5.\n\nThe function should generate ugly numbers in ascending order and return the nth one. The first ugly number is 1.\n\n-----Input-----\nThe input is a natural number:\n\nn: The index (1-based) of the ugly number to return.\n\n-----Output-----\nThe output is a natural number:\nThe nth smallest ugly number.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem nthUglyNumber_spec_satisfied (n: Nat) (h_precond : nthUglyNumber_precond (n)) :\n    nthUglyNumber_postcond (n) (nthUglyNumber (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef nthUglyNumber_precond (n : Nat) : Prop :=\n  n > 0\n\ndef nextUgly (seq : List Nat) (c2 c3 c5 : Nat) : (Nat × Nat × Nat × Nat) :=\n  let i2 := seq[c2]! * 2\n  let i3 := seq[c3]! * 3\n  let i5 := seq[c5]! * 5\n  let next := min i2 (min i3 i5)\n  let c2' := if next = i2 then c2 + 1 else c2\n  let c3' := if next = i3 then c3 + 1 else c3\n  let c5' := if next = i5 then c5 + 1 else c5\n  (next, c2', c3', c5')\n\ndef nthUglyNumber (n : Nat) (h_precond : nthUglyNumber_precond (n)) : Nat :=\n  let rec loop (i : Nat) (seq : List Nat) (c2 c3 c5 : Nat) : List Nat :=\n    match i with\n    | 0 => seq\n    | Nat.succ i' =>\n      let (next, c2', c3', c5') := nextUgly seq c2 c3 c5\n      loop i' (seq ++ [next]) c2' c3' c5'\n  (loop (n - 1) [1] 0 0 0)[(n - 1)]!\n\ndef divideOut : Nat → Nat → Nat\n  | n, p =>\n    if h : p > 1 ∧ n > 0 ∧ n % p = 0 then\n      have : n / p < n := by\n        apply Nat.div_lt_self\n        · exact h.2.1  -- n > 0\n        · exact Nat.lt_of_succ_le (Nat.succ_le_of_lt h.1)  -- 1 < p, so 2 ≤ p\n      divideOut (n / p) p\n    else n\ntermination_by n p => n\n\ndef isUgly (x : Nat) : Bool :=\n  if x = 0 then\n    false\n  else\n    let n1 := divideOut x 2\n    let n2 := divideOut n1 3\n    let n3 := divideOut n2 5\n    n3 = 1\n\n@[reducible, simp]\ndef nthUglyNumber_postcond (n : Nat) (result: Nat) (h_precond : nthUglyNumber_precond (n)) : Prop :=\n  isUgly result = true ∧\n  ((List.range (result)).filter (fun i => isUgly i)).length = n - 1\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem nthUglyNumber_spec_satisfied (n: Nat) (h_precond : nthUglyNumber_precond (n)) :\n    nthUglyNumber_postcond (n) (nthUglyNumber (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_58"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines if a given string is a palindrome, ignoring all\nnon-alphanumeric characters and case differences. For example, the string \"A man, a plan, a canal: Panama\" should return\ntrue.\n\n-----Input-----\nA single string:\ns: The string to check for palindrome property.\n\n-----Output-----\nA boolean (Bool):\ntrue if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem palindromeIgnoreNonAlnum_spec_satisfied (s: String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) :\n    palindromeIgnoreNonAlnum_postcond (s) (palindromeIgnoreNonAlnum (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef palindromeIgnoreNonAlnum_precond (s : String) : Prop :=\n  True\n\ndef palindromeIgnoreNonAlnum (s : String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Bool :=\n  let cleaned : List Char :=\n    s.data.filter (fun c => c.isAlpha || c.isDigit)\n      |>.map Char.toLower\n\n  let n := cleaned.length\n  let startIndex := 0\n  let endIndex := if n = 0 then 0 else n - 1\n\n  let rec check (l r : Nat) : Bool :=\n    if l >= r then\n      true\n    else if cleaned[l]? = cleaned[r]? then\n      check (l + 1) (r - 1)\n    else\n      false\n\n  check startIndex endIndex\n\n@[reducible]\ndef palindromeIgnoreNonAlnum_postcond (s : String) (result: Bool) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Prop :=\n  let cleaned := s.data.filter (fun c => c.isAlpha || c.isDigit) |>.map Char.toLower\nlet forward := cleaned\nlet backward := cleaned.reverse\n\nif result then\n  forward = backward\nelse\n  forward ≠ backward\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem palindromeIgnoreNonAlnum_spec_satisfied (s: String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) :\n    palindromeIgnoreNonAlnum_postcond (s) (palindromeIgnoreNonAlnum (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_59", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines if a given string is a palindrome, ignoring all\nnon-alphanumeric characters and case differences. For example, the string \"A man, a plan, a canal: Panama\" should return\ntrue.\n\n-----Input-----\nA single string:\ns: The string to check for palindrome property.\n\n-----Output-----\nA boolean (Bool):\ntrue if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem palindromeIgnoreNonAlnum_spec_satisfied (s: String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) :\n    palindromeIgnoreNonAlnum_postcond (s) (palindromeIgnoreNonAlnum (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef palindromeIgnoreNonAlnum_precond (s : String) : Prop :=\n  True\n\ndef palindromeIgnoreNonAlnum (s : String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Bool :=\n  let cleaned : List Char :=\n    s.data.filter (fun c => c.isAlpha || c.isDigit)\n      |>.map Char.toLower\n\n  let n := cleaned.length\n  let startIndex := 0\n  let endIndex := if n = 0 then 0 else n - 1\n\n  let rec check (l r : Nat) : Bool :=\n    if l >= r then\n      true\n    else if cleaned[l]? = cleaned[r]? then\n      check (l + 1) (r - 1)\n    else\n      false\n\n  check startIndex endIndex\n\n@[reducible]\ndef palindromeIgnoreNonAlnum_postcond (s : String) (result: Bool) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Prop :=\n  let cleaned := s.data.filter (fun c => c.isAlpha || c.isDigit) |>.map Char.toLower\nlet forward := cleaned\nlet backward := cleaned.reverse\n\nif result then\n  forward = backward\nelse\n  forward ≠ backward\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem palindromeIgnoreNonAlnum_spec_satisfied (s: String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) :\n    palindromeIgnoreNonAlnum_postcond (s) (palindromeIgnoreNonAlnum (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_59"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given string contains all 5 English vowels: a, e, i, o, u.\n\nThe check is case-insensitive, meaning that both uppercase and lowercase vowels count.\n\n-----Input-----\nThe input consists of a string:\ns: A string of alphabetic characters (may include uppercase and lowercase)\n\n-----Output-----\nThe output is true or false:\nReturns true if the input string contains all 5 vowels (a, e, i, o, u), false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem allVowels_spec_satisfied (s: String) (h_precond : allVowels_precond (s)) :\n    allVowels_postcond (s) (allVowels (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef toLower (c : Char) : Char :=\n  if 'A' ≤ c && c ≤ 'Z' then\n    Char.ofNat (Char.toNat c + 32)\n  else\n    c\n\ndef normalize_str (s : String) : List Char :=\n  s.data.map toLower\n\n@[reducible]\ndef allVowels_precond (s : String) : Prop :=\n  True\n\ndef allVowels (s : String) (h_precond : allVowels_precond (s)) : Bool :=\n  let chars := normalize_str s\n  let vowelSet := ['a', 'e', 'i', 'o', 'u']\n  vowelSet.all (fun v => chars.contains v)\n\n@[reducible]\ndef allVowels_postcond (s : String) (result: Bool) (h_precond : allVowels_precond (s)) : Prop :=\n  let chars := normalize_str s\n  (result ↔ List.all ['a', 'e', 'i', 'o', 'u'] (fun v => chars.contains v))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem allVowels_spec_satisfied (s: String) (h_precond : allVowels_precond (s)) :\n    allVowels_postcond (s) (allVowels (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_6", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given string contains all 5 English vowels: a, e, i, o, u.\n\nThe check is case-insensitive, meaning that both uppercase and lowercase vowels count.\n\n-----Input-----\nThe input consists of a string:\ns: A string of alphabetic characters (may include uppercase and lowercase)\n\n-----Output-----\nThe output is true or false:\nReturns true if the input string contains all 5 vowels (a, e, i, o, u), false otherwise.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem allVowels_spec_satisfied (s: String) (h_precond : allVowels_precond (s)) :\n    allVowels_postcond (s) (allVowels (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef toLower (c : Char) : Char :=\n  if 'A' ≤ c && c ≤ 'Z' then\n    Char.ofNat (Char.toNat c + 32)\n  else\n    c\n\ndef normalize_str (s : String) : List Char :=\n  s.data.map toLower\n\n@[reducible]\ndef allVowels_precond (s : String) : Prop :=\n  True\n\ndef allVowels (s : String) (h_precond : allVowels_precond (s)) : Bool :=\n  let chars := normalize_str s\n  let vowelSet := ['a', 'e', 'i', 'o', 'u']\n  vowelSet.all (fun v => chars.contains v)\n\n@[reducible]\ndef allVowels_postcond (s : String) (result: Bool) (h_precond : allVowels_precond (s)) : Prop :=\n  let chars := normalize_str s\n  (result ↔ List.all ['a', 'e', 'i', 'o', 'u'] (fun v => chars.contains v))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem allVowels_spec_satisfied (s: String) (h_precond : allVowels_precond (s)) :\n    allVowels_postcond (s) (allVowels (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_6"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\n\nThis task requires writing a Lean 4 method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.\n\n-----Input-----\n\nThe input consists of a single list with no duplicate natural numbers:\n- nums: A list of natural numbers (Nat)\n\n-----Output-----\n\nThe output is a tuple of two lists:\n- The first list contains all even numbers from the input list, in order.\n- The second list contains all odd numbers from the input list, in order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :\n    partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef partitionEvensOdds_precond (nums : List Nat) : Prop :=\n  True\n\ndef partitionEvensOdds (nums : List Nat) (h_precond : partitionEvensOdds_precond (nums)) : (List Nat × List Nat) :=\n  let rec helper (nums : List Nat) : (List Nat × List Nat) :=\n    match nums with\n    | [] => ([], [])\n    | x :: xs =>\n      let (evens, odds) := helper xs\n      if x % 2 == 0 then (x :: evens, odds)\n      else (evens, x :: odds)\n  helper nums\n\n@[reducible]\ndef partitionEvensOdds_postcond (nums : List Nat) (result: (List Nat × List Nat)) (h_precond : partitionEvensOdds_precond (nums)): Prop :=\n  let evens := result.fst\n  let odds := result.snd\n  evens ++ odds = nums.filter (fun n => n % 2 == 0) ++ nums.filter (fun n => n % 2 == 1) ∧\n  evens.all (fun n => n % 2 == 0) ∧\n  odds.all (fun n => n % 2 == 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :\n    partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_60", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\n\nThis task requires writing a Lean 4 method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.\n\n-----Input-----\n\nThe input consists of a single list with no duplicate natural numbers:\n- nums: A list of natural numbers (Nat)\n\n-----Output-----\n\nThe output is a tuple of two lists:\n- The first list contains all even numbers from the input list, in order.\n- The second list contains all odd numbers from the input list, in order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :\n    partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef partitionEvensOdds_precond (nums : List Nat) : Prop :=\n  True\n\ndef partitionEvensOdds (nums : List Nat) (h_precond : partitionEvensOdds_precond (nums)) : (List Nat × List Nat) :=\n  let rec helper (nums : List Nat) : (List Nat × List Nat) :=\n    match nums with\n    | [] => ([], [])\n    | x :: xs =>\n      let (evens, odds) := helper xs\n      if x % 2 == 0 then (x :: evens, odds)\n      else (evens, x :: odds)\n  helper nums\n\n@[reducible]\ndef partitionEvensOdds_postcond (nums : List Nat) (result: (List Nat × List Nat)) (h_precond : partitionEvensOdds_precond (nums)): Prop :=\n  let evens := result.fst\n  let odds := result.snd\n  evens ++ odds = nums.filter (fun n => n % 2 == 0) ++ nums.filter (fun n => n % 2 == 1) ∧\n  evens.all (fun n => n % 2 == 0) ∧\n  odds.all (fun n => n % 2 == 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :\n    partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_60"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that takes a list of integers and returns a new list. For each index i in the input list, the output at i is equal to the product of all numbers in the list except the number at index i. The solution must run in O(n) time without using the division operation.\n\n-----Input-----\nThe input is a list of integers. For example, [1,2,3,4].\n\n-----Output-----\nThe output is a list of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem productExceptSelf_spec_satisfied (nums: List Int) (h_precond : productExceptSelf_precond (nums)) :\n    productExceptSelf_postcond (nums) (productExceptSelf (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef productExceptSelf_precond (nums : List Int) : Prop :=\n  True\n\ndef computepref (nums : List Int) : List Int :=\n  nums.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]\n\ndef computeSuffix (nums : List Int) : List Int :=\n  let revSuffix := nums.reverse.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]\n  revSuffix.reverse\n\ndef productExceptSelf (nums : List Int) (h_precond : productExceptSelf_precond (nums)) : List Int :=\n  let n := nums.length\n  if n = 0 then []\n  else\n    let pref := computepref nums  -- length = n + 1, where prefix[i] = product of nums[0 ... i-1]\n    let suffix := computeSuffix nums  -- length = n + 1, where suffix[i] = product of nums[i ... n-1]\n    List.range n |>.map (fun i => pref[i]! * suffix[i+1]!)\n\ndef List.myprod : List Int → Int\n  | [] => 1\n  | x :: xs => x * xs.myprod\n\n@[reducible]\ndef productExceptSelf_postcond (nums : List Int) (result: List Int) (h_precond : productExceptSelf_precond (nums)) : Prop :=\n  nums.length = result.length ∧\n  (List.range nums.length |>.all (fun i =>\n    result[i]! = some (((List.take i nums).myprod) * ((List.drop (i+1) nums).myprod))))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem productExceptSelf_spec_satisfied (nums: List Int) (h_precond : productExceptSelf_precond (nums)) :\n    productExceptSelf_postcond (nums) (productExceptSelf (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_61", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that takes a list of integers and returns a new list. For each index i in the input list, the output at i is equal to the product of all numbers in the list except the number at index i. The solution must run in O(n) time without using the division operation.\n\n-----Input-----\nThe input is a list of integers. For example, [1,2,3,4].\n\n-----Output-----\nThe output is a list of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem productExceptSelf_spec_satisfied (nums: List Int) (h_precond : productExceptSelf_precond (nums)) :\n    productExceptSelf_postcond (nums) (productExceptSelf (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef productExceptSelf_precond (nums : List Int) : Prop :=\n  True\n\ndef computepref (nums : List Int) : List Int :=\n  nums.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]\n\ndef computeSuffix (nums : List Int) : List Int :=\n  let revSuffix := nums.reverse.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]\n  revSuffix.reverse\n\ndef productExceptSelf (nums : List Int) (h_precond : productExceptSelf_precond (nums)) : List Int :=\n  let n := nums.length\n  if n = 0 then []\n  else\n    let pref := computepref nums  -- length = n + 1, where prefix[i] = product of nums[0 ... i-1]\n    let suffix := computeSuffix nums  -- length = n + 1, where suffix[i] = product of nums[i ... n-1]\n    List.range n |>.map (fun i => pref[i]! * suffix[i+1]!)\n\ndef List.myprod : List Int → Int\n  | [] => 1\n  | x :: xs => x * xs.myprod\n\n@[reducible]\ndef productExceptSelf_postcond (nums : List Int) (result: List Int) (h_precond : productExceptSelf_precond (nums)) : Prop :=\n  nums.length = result.length ∧\n  (List.range nums.length |>.all (fun i =>\n    result[i]! = some (((List.take i nums).myprod) * ((List.drop (i+1) nums).myprod))))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem productExceptSelf_spec_satisfied (nums: List Int) (h_precond : productExceptSelf_precond (nums)) :\n    productExceptSelf_postcond (nums) (productExceptSelf (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_61"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.\n\nGiven an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.\n\n-----Input-----\nThe input consists of one array:\nheights: An array of non-negative integers representing elevation levels.\n\n-----Output-----\nThe output is an integer:\nReturns the total amount of rainwater that can be trapped.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem rain_spec_satisfied (heights: List (Int)) (h_precond : rain_precond (heights)) :\n    rain_postcond (heights) (rain (heights) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef rain_precond (heights : List (Int)) : Prop :=\n  heights.all (fun h => h >= 0)\n\ndef rain (heights : List (Int)) (h_precond : rain_precond (heights)) : Int :=\n  if heights.length < 3 then 0 else\n    let n := heights.length\n\n    let rec aux (left : Nat) (right : Nat) (leftMax : Int) (rightMax : Int) (water : Int) : Int :=\n      if left >= right then\n        water  -- Base case: all elements processed\n      else if heights[left]! <= heights[right]! then\n        let newLeftMax := max leftMax (heights[left]!)\n        let newWater := water + max 0 (leftMax - heights[left]!)\n        aux (left+1) right newLeftMax rightMax newWater\n      else\n        let newRightMax := max rightMax (heights[right]!)\n        let newWater := water + max 0 (rightMax - heights[right]!)\n        aux left (right-1) leftMax newRightMax newWater\n      termination_by right - left\n    aux 0 (n-1) (heights[0]!) (heights[n-1]!) 0\n\n@[reducible]\ndef rain_postcond (heights : List (Int)) (result: Int) (h_precond : rain_precond (heights)) : Prop :=\n  result >= 0 ∧\n  if heights.length < 3 then result = 0 else\n    result =\n      let max_left_at := λ i =>\n        let rec ml (j : Nat) (max_so_far : Int) : Int :=\n          if j > i then max_so_far\n          else ml (j+1) (max max_so_far (heights[j]!))\n          termination_by i + 1 - j\n        ml 0 0\n\n      let max_right_at := λ i =>\n        let rec mr (j : Nat) (max_so_far : Int) : Int :=\n          if j >= heights.length then max_so_far\n          else mr (j+1) (max max_so_far (heights[j]!))\n          termination_by heights.length - j\n        mr i 0\n\n      let water_at := λ i =>\n        max 0 (min (max_left_at i) (max_right_at i) - heights[i]!)\n\n      let rec sum_water (i : Nat) (acc : Int) : Int :=\n        if i >= heights.length then acc\n        else sum_water (i+1) (acc + water_at i)\n        termination_by heights.length - i\n\n      sum_water 0 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem rain_spec_satisfied (heights: List (Int)) (h_precond : rain_precond (heights)) :\n    rain_postcond (heights) (rain (heights) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_62", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.\n\nGiven an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.\n\n-----Input-----\nThe input consists of one array:\nheights: An array of non-negative integers representing elevation levels.\n\n-----Output-----\nThe output is an integer:\nReturns the total amount of rainwater that can be trapped.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem rain_spec_satisfied (heights: List (Int)) (h_precond : rain_precond (heights)) :\n    rain_postcond (heights) (rain (heights) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef rain_precond (heights : List (Int)) : Prop :=\n  heights.all (fun h => h >= 0)\n\ndef rain (heights : List (Int)) (h_precond : rain_precond (heights)) : Int :=\n  if heights.length < 3 then 0 else\n    let n := heights.length\n\n    let rec aux (left : Nat) (right : Nat) (leftMax : Int) (rightMax : Int) (water : Int) : Int :=\n      if left >= right then\n        water  -- Base case: all elements processed\n      else if heights[left]! <= heights[right]! then\n        let newLeftMax := max leftMax (heights[left]!)\n        let newWater := water + max 0 (leftMax - heights[left]!)\n        aux (left+1) right newLeftMax rightMax newWater\n      else\n        let newRightMax := max rightMax (heights[right]!)\n        let newWater := water + max 0 (rightMax - heights[right]!)\n        aux left (right-1) leftMax newRightMax newWater\n      termination_by right - left\n    aux 0 (n-1) (heights[0]!) (heights[n-1]!) 0\n\n@[reducible]\ndef rain_postcond (heights : List (Int)) (result: Int) (h_precond : rain_precond (heights)) : Prop :=\n  result >= 0 ∧\n  if heights.length < 3 then result = 0 else\n    result =\n      let max_left_at := λ i =>\n        let rec ml (j : Nat) (max_so_far : Int) : Int :=\n          if j > i then max_so_far\n          else ml (j+1) (max max_so_far (heights[j]!))\n          termination_by i + 1 - j\n        ml 0 0\n\n      let max_right_at := λ i =>\n        let rec mr (j : Nat) (max_so_far : Int) : Int :=\n          if j >= heights.length then max_so_far\n          else mr (j+1) (max max_so_far (heights[j]!))\n          termination_by heights.length - j\n        mr i 0\n\n      let water_at := λ i =>\n        max 0 (min (max_left_at i) (max_right_at i) - heights[i]!)\n\n      let rec sum_water (i : Nat) (acc : Int) : Int :=\n        if i >= heights.length then acc\n        else sum_water (i+1) (acc + water_at i)\n        termination_by heights.length - i\n\n      sum_water 0 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem rain_spec_satisfied (heights: List (Int)) (h_precond : rain_precond (heights)) :\n    rain_postcond (heights) (rain (heights) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_62"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that counts the unique elements from a sorted array.\n\n-----Input-----\nThe input is a single list of integers:\nnums: An array of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a single integer:\nReturns the number of unique elements (k).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem removeDuplicates_spec_satisfied (nums: List Int) (h_precond : removeDuplicates_precond (nums)) :\n    removeDuplicates_postcond (nums) (removeDuplicates (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef removeDuplicates_precond (nums : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) nums\n\ndef removeDuplicates (nums : List Int) (h_precond : removeDuplicates_precond (nums)) : Nat :=\n  match nums with\n  | [] =>\n    0\n  | h :: t =>\n    let init := h\n    let initCount := 1\n    let rec countUniques (prev : Int) (xs : List Int) (k : Nat) : Nat :=\n      match xs with\n      | [] =>\n        k\n      | head :: tail =>\n        let isDuplicate := head = prev\n        if isDuplicate then\n          countUniques prev tail k\n        else\n          let newK := k + 1\n          countUniques head tail newK\n    countUniques init t initCount\n\n@[reducible]\ndef removeDuplicates_postcond (nums : List Int) (result: Nat) (h_precond : removeDuplicates_precond (nums)) : Prop :=\n  result - nums.eraseDups.length = 0 ∧\n  nums.eraseDups.length ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem removeDuplicates_spec_satisfied (nums: List Int) (h_precond : removeDuplicates_precond (nums)) :\n    removeDuplicates_postcond (nums) (removeDuplicates (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_63", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that counts the unique elements from a sorted array.\n\n-----Input-----\nThe input is a single list of integers:\nnums: An array of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a single integer:\nReturns the number of unique elements (k).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem removeDuplicates_spec_satisfied (nums: List Int) (h_precond : removeDuplicates_precond (nums)) :\n    removeDuplicates_postcond (nums) (removeDuplicates (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef removeDuplicates_precond (nums : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) nums\n\ndef removeDuplicates (nums : List Int) (h_precond : removeDuplicates_precond (nums)) : Nat :=\n  match nums with\n  | [] =>\n    0\n  | h :: t =>\n    let init := h\n    let initCount := 1\n    let rec countUniques (prev : Int) (xs : List Int) (k : Nat) : Nat :=\n      match xs with\n      | [] =>\n        k\n      | head :: tail =>\n        let isDuplicate := head = prev\n        if isDuplicate then\n          countUniques prev tail k\n        else\n          let newK := k + 1\n          countUniques head tail newK\n    countUniques init t initCount\n\n@[reducible]\ndef removeDuplicates_postcond (nums : List Int) (result: Nat) (h_precond : removeDuplicates_precond (nums)) : Prop :=\n  result - nums.eraseDups.length = 0 ∧\n  nums.eraseDups.length ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem removeDuplicates_spec_satisfied (nums: List Int) (h_precond : removeDuplicates_precond (nums)) :\n    removeDuplicates_postcond (nums) (removeDuplicates (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_63"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.\n\n-----Input-----\nThe input consists of two elements:\nlst: A list of natural numbers (List Nat).\ntarget: A natural number to be removed from the list.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem removeElement_spec_satisfied (lst: List Nat) (target: Nat) (h_precond : removeElement_precond (lst) (target)):\n    removeElement_postcond (lst) (target) (removeElement (lst) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef removeElement_precond (lst : List Nat) (target : Nat) : Prop :=\n  True\n\ndef removeElement (lst : List Nat) (target : Nat) (h_precond : removeElement_precond (lst) (target)) : List Nat :=\n  let rec helper (lst : List Nat) (target : Nat) : List Nat :=\n    match lst with\n    | [] => []\n    | x :: xs =>\n      let rest := helper xs target\n      if x = target then rest else x :: rest\n  helper lst target\n\n@[reducible]\ndef removeElement_postcond (lst : List Nat) (target : Nat) (result: List Nat) (h_precond : removeElement_precond (lst) (target)): Prop :=\n\n  let lst' := lst.filter (fun x => x ≠ target)\n  result.zipIdx.all (fun (x, i) =>\n    match lst'[i]? with\n    | some y => x = y\n    | none => false) ∧ result.length = lst'.length\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem removeElement_spec_satisfied (lst: List Nat) (target: Nat) (h_precond : removeElement_precond (lst) (target)):\n    removeElement_postcond (lst) (target) (removeElement (lst) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_64", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.\n\n-----Input-----\nThe input consists of two elements:\nlst: A list of natural numbers (List Nat).\ntarget: A natural number to be removed from the list.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem removeElement_spec_satisfied (lst: List Nat) (target: Nat) (h_precond : removeElement_precond (lst) (target)):\n    removeElement_postcond (lst) (target) (removeElement (lst) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef removeElement_precond (lst : List Nat) (target : Nat) : Prop :=\n  True\n\ndef removeElement (lst : List Nat) (target : Nat) (h_precond : removeElement_precond (lst) (target)) : List Nat :=\n  let rec helper (lst : List Nat) (target : Nat) : List Nat :=\n    match lst with\n    | [] => []\n    | x :: xs =>\n      let rest := helper xs target\n      if x = target then rest else x :: rest\n  helper lst target\n\n@[reducible]\ndef removeElement_postcond (lst : List Nat) (target : Nat) (result: List Nat) (h_precond : removeElement_precond (lst) (target)): Prop :=\n\n  let lst' := lst.filter (fun x => x ≠ target)\n  result.zipIdx.all (fun (x, i) =>\n    match lst'[i]? with\n    | some y => x = y\n    | none => false) ∧ result.length = lst'.length\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem removeElement_spec_satisfied (lst: List Nat) (target: Nat) (h_precond : removeElement_precond (lst) (target)):\n    removeElement_postcond (lst) (target) (removeElement (lst) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_64"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that reverses a given string. The method should return a new string which consists of the characters of the input string in reverse order.\n\n-----Input-----\nThe input consists of:\ns: A string (which may be empty).\n\n-----Output-----\nThe output is a string:\nReturns a string where the characters are in reverse order from the original input.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem reverseString_spec_satisfied (s: String) (h_precond : reverseString_precond (s)) :\n    reverseString_postcond (s) (reverseString (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef reverseString_precond (s : String) : Prop :=\n  True\n\ndef reverseString (s : String) (h_precond : reverseString_precond (s)) : String :=\n  let rec reverseAux (chars : List Char) (acc : List Char) : List Char :=\n    match chars with\n    | [] => acc\n    | h::t => reverseAux t (h::acc)\n  String.mk (reverseAux (s.toList) [])\n\n@[reducible]\ndef reverseString_postcond (s : String) (result: String) (h_precond : reverseString_precond (s)) : Prop :=\n  result.length = s.length ∧ result.toList = s.toList.reverse\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem reverseString_spec_satisfied (s: String) (h_precond : reverseString_precond (s)) :\n    reverseString_postcond (s) (reverseString (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_65", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that reverses a given string. The method should return a new string which consists of the characters of the input string in reverse order.\n\n-----Input-----\nThe input consists of:\ns: A string (which may be empty).\n\n-----Output-----\nThe output is a string:\nReturns a string where the characters are in reverse order from the original input.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem reverseString_spec_satisfied (s: String) (h_precond : reverseString_precond (s)) :\n    reverseString_postcond (s) (reverseString (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef reverseString_precond (s : String) : Prop :=\n  True\n\ndef reverseString (s : String) (h_precond : reverseString_precond (s)) : String :=\n  let rec reverseAux (chars : List Char) (acc : List Char) : List Char :=\n    match chars with\n    | [] => acc\n    | h::t => reverseAux t (h::acc)\n  String.mk (reverseAux (s.toList) [])\n\n@[reducible]\ndef reverseString_postcond (s : String) (result: String) (h_precond : reverseString_precond (s)) : Prop :=\n  result.length = s.length ∧ result.toList = s.toList.reverse\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem reverseString_spec_satisfied (s: String) (h_precond : reverseString_precond (s)) :\n    reverseString_postcond (s) (reverseString (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_65"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven an input string \"words_str\", this task requires writing a Lean 4 function that reverses the order of its words. A word is defined as a contiguous sequence of non-space characters. The function must remove any extra spaces so that the output string contains words separated by a single space and has no leading or trailing spaces. The characters within each word must stay the same as the original input.\n\n-----Input-----\nwords_str: A string that may contain leading, trailing, or multiple spaces between words.\n\n-----Output-----\nA string with the words from the input reversed, where words are separated by a single space, with no extra spaces at the beginning or end.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem reverseWords_spec_satisfied (words_str: String) (h_precond : reverseWords_precond (words_str)) :\n    reverseWords_postcond (words_str) (reverseWords (words_str) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef reverseWords_precond (words_str : String) : Prop :=\n  True\n\ndef reverseWords (words_str : String) (h_precond : reverseWords_precond (words_str)) : String :=\n  let rawWords : List String := words_str.splitOn \" \"\n  let rec filterNonEmpty (words : List String) : List String :=\n    match words with\n    | [] => []\n    | h :: t =>\n      if h = \"\" then\n        filterNonEmpty t\n      else\n        h :: filterNonEmpty t\n  let filteredWords : List String := filterNonEmpty rawWords\n  let revWords : List String := filteredWords.reverse\n  let rec joinWithSpace (words : List String) : String :=\n    match words with\n    | [] => \"\"\n    | [w] => w\n    | h :: t =>\n      h ++ \" \" ++ joinWithSpace t\n  let result : String := joinWithSpace revWords\n  result\n\n@[reducible]\ndef reverseWords_postcond (words_str : String) (result: String) (h_precond : reverseWords_precond (words_str)) : Prop :=\n  ∃ words : List String,\n    (words = (words_str.splitOn \" \").filter (fun w => w ≠ \"\")) ∧\n    result = String.intercalate \" \" (words.reverse)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem reverseWords_spec_satisfied (words_str: String) (h_precond : reverseWords_precond (words_str)) :\n    reverseWords_postcond (words_str) (reverseWords (words_str) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_66", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven an input string \"words_str\", this task requires writing a Lean 4 function that reverses the order of its words. A word is defined as a contiguous sequence of non-space characters. The function must remove any extra spaces so that the output string contains words separated by a single space and has no leading or trailing spaces. The characters within each word must stay the same as the original input.\n\n-----Input-----\nwords_str: A string that may contain leading, trailing, or multiple spaces between words.\n\n-----Output-----\nA string with the words from the input reversed, where words are separated by a single space, with no extra spaces at the beginning or end.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem reverseWords_spec_satisfied (words_str: String) (h_precond : reverseWords_precond (words_str)) :\n    reverseWords_postcond (words_str) (reverseWords (words_str) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef reverseWords_precond (words_str : String) : Prop :=\n  True\n\ndef reverseWords (words_str : String) (h_precond : reverseWords_precond (words_str)) : String :=\n  let rawWords : List String := words_str.splitOn \" \"\n  let rec filterNonEmpty (words : List String) : List String :=\n    match words with\n    | [] => []\n    | h :: t =>\n      if h = \"\" then\n        filterNonEmpty t\n      else\n        h :: filterNonEmpty t\n  let filteredWords : List String := filterNonEmpty rawWords\n  let revWords : List String := filteredWords.reverse\n  let rec joinWithSpace (words : List String) : String :=\n    match words with\n    | [] => \"\"\n    | [w] => w\n    | h :: t =>\n      h ++ \" \" ++ joinWithSpace t\n  let result : String := joinWithSpace revWords\n  result\n\n@[reducible]\ndef reverseWords_postcond (words_str : String) (result: String) (h_precond : reverseWords_precond (words_str)) : Prop :=\n  ∃ words : List String,\n    (words = (words_str.splitOn \" \").filter (fun w => w ≠ \"\")) ∧\n    result = String.intercalate \" \" (words.reverse)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem reverseWords_spec_satisfied (words_str: String) (h_precond : reverseWords_precond (words_str)) :\n    reverseWords_postcond (words_str) (reverseWords (words_str) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_66"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, \"aaabbc\" becomes [(’a’, 3), (’b’, 2), (’c’, 1)].\n\nThe resulting encoded list must satisfy the following properties:\n1. No pair has a zero or negative run-length.\n2. Consecutive pairs in the encoding list must not have the same character.\n3. Decoding the output should return the original string.\n\n-----Input-----\nThe input is a single string, `s`.\n\n-----Output-----\nThe output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :\n    runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef runLengthEncode_precond (s : String) : Prop :=\n  True\n\ndef runLengthEncode (s : String) (h_precond : runLengthEncode_precond (s)) : List (Char × Nat) :=\n  let chars := s.data\n\n  let rec encodeAux (acc : List (Char × Nat)) (rest : List Char) : List (Char × Nat) :=\n    match rest with\n    | [] => acc.reverse\n    | h :: t =>\n      match acc with\n      | (ch, count) :: accTail =>\n        if ch = h then\n          encodeAux ((ch, count + 1) :: accTail) t\n        else\n          encodeAux ((h, 1) :: (ch, count) :: accTail) t\n      | [] =>\n        encodeAux ([(h, 1)]) t\n\n  let encoded := encodeAux [] chars\n  encoded\n\ndef decodeRLE (lst : List (Char × Nat)) : String :=\n  match lst with\n  | [] => \"\"\n  | (ch, cnt) :: tail =>\n    let repeated := String.mk (List.replicate cnt ch)\n    repeated ++ decodeRLE tail\n\n@[reducible, simp]\ndef runLengthEncode_postcond (s : String) (result: List (Char × Nat)) (h_precond : runLengthEncode_precond (s)) : Prop :=\n  (∀ pair ∈ result, pair.snd > 0) ∧\n  (∀ i : Nat, i < result.length - 1 → (result[i]!).fst ≠ (result[i+1]!).fst) ∧\n  decodeRLE result = s\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :\n    runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_67", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, \"aaabbc\" becomes [(’a’, 3), (’b’, 2), (’c’, 1)].\n\nThe resulting encoded list must satisfy the following properties:\n1. No pair has a zero or negative run-length.\n2. Consecutive pairs in the encoding list must not have the same character.\n3. Decoding the output should return the original string.\n\n-----Input-----\nThe input is a single string, `s`.\n\n-----Output-----\nThe output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :\n    runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef runLengthEncode_precond (s : String) : Prop :=\n  True\n\ndef runLengthEncode (s : String) (h_precond : runLengthEncode_precond (s)) : List (Char × Nat) :=\n  let chars := s.data\n\n  let rec encodeAux (acc : List (Char × Nat)) (rest : List Char) : List (Char × Nat) :=\n    match rest with\n    | [] => acc.reverse\n    | h :: t =>\n      match acc with\n      | (ch, count) :: accTail =>\n        if ch = h then\n          encodeAux ((ch, count + 1) :: accTail) t\n        else\n          encodeAux ((h, 1) :: (ch, count) :: accTail) t\n      | [] =>\n        encodeAux ([(h, 1)]) t\n\n  let encoded := encodeAux [] chars\n  encoded\n\ndef decodeRLE (lst : List (Char × Nat)) : String :=\n  match lst with\n  | [] => \"\"\n  | (ch, cnt) :: tail =>\n    let repeated := String.mk (List.replicate cnt ch)\n    repeated ++ decodeRLE tail\n\n@[reducible, simp]\ndef runLengthEncode_postcond (s : String) (result: List (Char × Nat)) (h_precond : runLengthEncode_precond (s)) : Prop :=\n  (∀ pair ∈ result, pair.snd > 0) ∧\n  (∀ i : Nat, i < result.length - 1 → (result[i]!).fst ≠ (result[i+1]!).fst) ∧\n  decodeRLE result = s\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :\n    runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_67"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing a Run-Length Encoding (RLE) algorithm in Lean 4. The method should take a string as input and return a compressed string where consecutive duplicate characters are replaced by the character followed by its count. The output must strictly alternate between characters and digits, reconstruct to the original input when decoded, and return a non-empty string if and only if the input is non-empty.\n\n-----Input-----\nThe input is a string consisting of any characters (including special characters and digits).\n\n-----Output-----\nThe output is a string where each sequence of identical characters is replaced by the character followed by its count. The output must:\n1. Alternate between characters and digits (e.g., \"a3b2\").\n2. Reconstruct to the original input when decoded.\n3. Be non-empty if and only if the input is non-empty.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem runLengthEncoder_spec_satisfied (input: String) (h_precond : runLengthEncoder_precond (input)) :\n    runLengthEncoder_postcond (input) (runLengthEncoder (input) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef runLengthEncoder_precond (input : String) : Prop :=\n  True\n\ndef runLengthEncoder (input : String) (h_precond : runLengthEncoder_precond (input)) : String :=\n  let chars : String → List Char := fun s => s.data\n\n  let charEq : Char → Char → Bool := fun c1 c2 => c1 == c2\n\n  let numToString : Nat → String := fun n =>\n    let rec digits : Nat → List Char := fun n =>\n      if n < 10 then\n        [Char.ofNat (n + 48)]  -- ASCII '0' is 48\n      else\n        digits (n / 10) ++ [Char.ofNat (n % 10 + 48)]\n    String.mk (digits n)\n\n  let rec encode : List Char → Option Char → Nat → String :=\n    fun input currentChar count =>\n      match input with\n      | [] =>\n        match currentChar with\n        | none => \"\"\n        | some c => String.mk [c] ++ numToString count\n      | c::rest =>\n        match currentChar with\n        | none => encode rest c 1\n        | some c' =>\n          if charEq c c' then\n            encode rest c' (count + 1)\n          else\n            let currentPart := String.mk [c'] ++ numToString count\n            currentPart ++ encode rest c 1\n\n  if input.isEmpty then\n    \"\"\n  else\n    let firstChar := (chars input).head?\n    encode (chars input).tail firstChar 1\n\n@[reducible]\ndef runLengthEncoder_postcond (input : String) (result: String) (h_precond : runLengthEncoder_precond (input)) : Prop :=\n  let chars : String → List Char := fun s => s.data\n\n  let parseEncodedString : String → List (Char × Nat) :=\n    let rec parseState : List Char → Option Char → Option Nat → List (Char × Nat) → List (Char × Nat) :=\n      fun remaining currentChar currentCount acc =>\n        match remaining with\n        | [] =>\n          match currentChar, currentCount with\n          | some c, some n => (c, n) :: acc\n          | _, _ => acc\n        | c :: cs =>\n          if c.isDigit then\n            match currentChar with\n            | none => [] -- Invalid format: digit without preceding character\n            | some ch =>\n              let digit := c.toNat - 48\n              let newCount :=\n                match currentCount with\n                | none => digit\n                | some n => n * 10 + digit\n              parseState cs currentChar (some newCount) acc\n          else\n            let newAcc :=\n              match currentChar, currentCount with\n              | some ch, some n => (ch, n) :: acc\n              | _, _ => acc\n            parseState cs (some c) none newAcc\n\n    fun s =>\n      let result := parseState (chars s) none none []\n      result.reverse\n\n  let formatValid : Bool :=\n    let rec checkPairs (chars : List Char) (nowDigit : Bool) : Bool :=\n      match chars with\n      | [] => true\n      | c :: cs =>\n        if nowDigit && c.isDigit then\n          checkPairs cs true\n        else\n          match cs with\n          | [] => false -- Ending with character, no digits\n          | d :: ds =>\n            if d.isDigit then\n              checkPairs ds true\n            else\n              false -- No digit after character\n\n    checkPairs (chars result) false\n\n  let contentValid : Bool :=\n    let pairs := parseEncodedString result\n    let expanded := pairs.flatMap (fun (c, n) => List.replicate n c)\n    expanded == chars input\n\n  let nonEmptyValid : Bool :=\n    input.isEmpty = result.isEmpty\n\n  formatValid && contentValid && nonEmptyValid\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem runLengthEncoder_spec_satisfied (input: String) (h_precond : runLengthEncoder_precond (input)) :\n    runLengthEncoder_postcond (input) (runLengthEncoder (input) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_68", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires implementing a Run-Length Encoding (RLE) algorithm in Lean 4. The method should take a string as input and return a compressed string where consecutive duplicate characters are replaced by the character followed by its count. The output must strictly alternate between characters and digits, reconstruct to the original input when decoded, and return a non-empty string if and only if the input is non-empty.\n\n-----Input-----\nThe input is a string consisting of any characters (including special characters and digits).\n\n-----Output-----\nThe output is a string where each sequence of identical characters is replaced by the character followed by its count. The output must:\n1. Alternate between characters and digits (e.g., \"a3b2\").\n2. Reconstruct to the original input when decoded.\n3. Be non-empty if and only if the input is non-empty.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem runLengthEncoder_spec_satisfied (input: String) (h_precond : runLengthEncoder_precond (input)) :\n    runLengthEncoder_postcond (input) (runLengthEncoder (input) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef runLengthEncoder_precond (input : String) : Prop :=\n  True\n\ndef runLengthEncoder (input : String) (h_precond : runLengthEncoder_precond (input)) : String :=\n  let chars : String → List Char := fun s => s.data\n\n  let charEq : Char → Char → Bool := fun c1 c2 => c1 == c2\n\n  let numToString : Nat → String := fun n =>\n    let rec digits : Nat → List Char := fun n =>\n      if n < 10 then\n        [Char.ofNat (n + 48)]  -- ASCII '0' is 48\n      else\n        digits (n / 10) ++ [Char.ofNat (n % 10 + 48)]\n    String.mk (digits n)\n\n  let rec encode : List Char → Option Char → Nat → String :=\n    fun input currentChar count =>\n      match input with\n      | [] =>\n        match currentChar with\n        | none => \"\"\n        | some c => String.mk [c] ++ numToString count\n      | c::rest =>\n        match currentChar with\n        | none => encode rest c 1\n        | some c' =>\n          if charEq c c' then\n            encode rest c' (count + 1)\n          else\n            let currentPart := String.mk [c'] ++ numToString count\n            currentPart ++ encode rest c 1\n\n  if input.isEmpty then\n    \"\"\n  else\n    let firstChar := (chars input).head?\n    encode (chars input).tail firstChar 1\n\n@[reducible]\ndef runLengthEncoder_postcond (input : String) (result: String) (h_precond : runLengthEncoder_precond (input)) : Prop :=\n  let chars : String → List Char := fun s => s.data\n\n  let parseEncodedString : String → List (Char × Nat) :=\n    let rec parseState : List Char → Option Char → Option Nat → List (Char × Nat) → List (Char × Nat) :=\n      fun remaining currentChar currentCount acc =>\n        match remaining with\n        | [] =>\n          match currentChar, currentCount with\n          | some c, some n => (c, n) :: acc\n          | _, _ => acc\n        | c :: cs =>\n          if c.isDigit then\n            match currentChar with\n            | none => [] -- Invalid format: digit without preceding character\n            | some ch =>\n              let digit := c.toNat - 48\n              let newCount :=\n                match currentCount with\n                | none => digit\n                | some n => n * 10 + digit\n              parseState cs currentChar (some newCount) acc\n          else\n            let newAcc :=\n              match currentChar, currentCount with\n              | some ch, some n => (ch, n) :: acc\n              | _, _ => acc\n            parseState cs (some c) none newAcc\n\n    fun s =>\n      let result := parseState (chars s) none none []\n      result.reverse\n\n  let formatValid : Bool :=\n    let rec checkPairs (chars : List Char) (nowDigit : Bool) : Bool :=\n      match chars with\n      | [] => true\n      | c :: cs =>\n        if nowDigit && c.isDigit then\n          checkPairs cs true\n        else\n          match cs with\n          | [] => false -- Ending with character, no digits\n          | d :: ds =>\n            if d.isDigit then\n              checkPairs ds true\n            else\n              false -- No digit after character\n\n    checkPairs (chars result) false\n\n  let contentValid : Bool :=\n    let pairs := parseEncodedString result\n    let expanded := pairs.flatMap (fun (c, n) => List.replicate n c)\n    expanded == chars input\n\n  let nonEmptyValid : Bool :=\n    input.isEmpty = result.isEmpty\n\n  formatValid && contentValid && nonEmptyValid\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem runLengthEncoder_spec_satisfied (input: String) (h_precond : runLengthEncoder_precond (input)) :\n    runLengthEncoder_postcond (input) (runLengthEncoder (input) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_68"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.\n\nThis function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.\n\n-----Input-----\nxs : List Int — a sorted list of distinct integers in increasing order\ntarget : Int — the integer to search for\n\n-----Output-----\nA natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem searchInsert_spec_satisfied (xs: List Int) (target: Int) (h_precond : searchInsert_precond (xs) (target)) :\n    searchInsert_postcond (xs) (target) (searchInsert (xs) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef searchInsert_precond (xs : List Int) (target : Int) : Prop :=\n  List.Pairwise (· < ·) xs\n\ndef searchInsert (xs : List Int) (target : Int) (h_precond : searchInsert_precond (xs) (target)) : Nat :=\n  match xs with\n  | [] =>\n      0\n  | _ :: _ =>\n      let rec helper : List Int → Nat → Nat :=\n        fun ys idx =>\n          match ys with\n          | [] =>\n              idx\n          | y :: ys' =>\n              let isCurrent := y\n              let currentIndex := idx\n              let targetValue := target\n              let condition := targetValue ≤ isCurrent\n              if condition then\n                currentIndex\n              else\n                let incrementedIndex := currentIndex + 1\n                let rest := ys'\n                helper rest incrementedIndex\n      let startingIndex := 0\n      let result := helper xs startingIndex\n      result\n\n@[reducible]\ndef searchInsert_postcond (xs : List Int) (target : Int) (result: Nat) (h_precond : searchInsert_precond (xs) (target)) : Prop :=\n  let allBeforeLess := (List.range result).all (fun i => xs[i]! < target)\n  let inBounds := result ≤ xs.length\n  let insertedCorrectly :=\n    result < xs.length → target ≤ xs[result]!\n  inBounds ∧ allBeforeLess ∧ insertedCorrectly\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem searchInsert_spec_satisfied (xs: List Int) (target: Int) (h_precond : searchInsert_precond (xs) (target)) :\n    searchInsert_postcond (xs) (target) (searchInsert (xs) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_69", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.\n\nThis function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.\n\n-----Input-----\nxs : List Int — a sorted list of distinct integers in increasing order\ntarget : Int — the integer to search for\n\n-----Output-----\nA natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem searchInsert_spec_satisfied (xs: List Int) (target: Int) (h_precond : searchInsert_precond (xs) (target)) :\n    searchInsert_postcond (xs) (target) (searchInsert (xs) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef searchInsert_precond (xs : List Int) (target : Int) : Prop :=\n  List.Pairwise (· < ·) xs\n\ndef searchInsert (xs : List Int) (target : Int) (h_precond : searchInsert_precond (xs) (target)) : Nat :=\n  match xs with\n  | [] =>\n      0\n  | _ :: _ =>\n      let rec helper : List Int → Nat → Nat :=\n        fun ys idx =>\n          match ys with\n          | [] =>\n              idx\n          | y :: ys' =>\n              let isCurrent := y\n              let currentIndex := idx\n              let targetValue := target\n              let condition := targetValue ≤ isCurrent\n              if condition then\n                currentIndex\n              else\n                let incrementedIndex := currentIndex + 1\n                let rest := ys'\n                helper rest incrementedIndex\n      let startingIndex := 0\n      let result := helper xs startingIndex\n      result\n\n@[reducible]\ndef searchInsert_postcond (xs : List Int) (target : Int) (result: Nat) (h_precond : searchInsert_precond (xs) (target)) : Prop :=\n  let allBeforeLess := (List.range result).all (fun i => xs[i]! < target)\n  let inBounds := result ≤ xs.length\n  let insertedCorrectly :=\n    result < xs.length → target ≤ xs[result]!\n  inBounds ∧ allBeforeLess ∧ insertedCorrectly\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem searchInsert_spec_satisfied (xs: List Int) (target: Int) (h_precond : searchInsert_precond (xs) (target)) :\n    searchInsert_postcond (xs) (target) (searchInsert (xs) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_69"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that converts a binary number represented as a list of digits (0 or 1) into its corresponding decimal value. The list is ordered in big-endian format, meaning the most significant digit comes first.\nThe function should interpret the list as a binary number and return its decimal representation as a natural number.\n\n-----Input-----\nThe input is a list of natural numbers:\ndigits: A list of digits, each of which is either 0 or 1, representing a binary number in big-endian order.\n\n-----Output-----\nThe output is a natural number:\nReturns the decimal value of the binary number represented by the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem binaryToDecimal_spec_satisfied (digits: List Nat) (h_precond : binaryToDecimal_precond (digits)) :\n    binaryToDecimal_postcond (digits) (binaryToDecimal (digits) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef binaryToDecimal_precond (digits : List Nat) : Prop :=\n  digits.all (fun d => d = 0 ∨ d = 1)\n\ndef binaryToDecimal (digits : List Nat) (h_precond : binaryToDecimal_precond (digits)) : Nat :=\n  let rec helper (digits : List Nat) : Nat :=\n    match digits with\n    | [] => 0\n    | first :: rest => first * Nat.pow 2 rest.length + helper rest\n  helper digits\n\n@[reducible]\ndef binaryToDecimal_postcond (digits : List Nat) (result: Nat) (h_precond : binaryToDecimal_precond (digits)) : Prop :=\n  result - List.foldl (λ acc bit => acc * 2 + bit) 0 digits = 0 ∧\n  List.foldl (λ acc bit => acc * 2 + bit) 0 digits - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem binaryToDecimal_spec_satisfied (digits: List Nat) (h_precond : binaryToDecimal_precond (digits)) :\n    binaryToDecimal_postcond (digits) (binaryToDecimal (digits) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_7", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that converts a binary number represented as a list of digits (0 or 1) into its corresponding decimal value. The list is ordered in big-endian format, meaning the most significant digit comes first.\nThe function should interpret the list as a binary number and return its decimal representation as a natural number.\n\n-----Input-----\nThe input is a list of natural numbers:\ndigits: A list of digits, each of which is either 0 or 1, representing a binary number in big-endian order.\n\n-----Output-----\nThe output is a natural number:\nReturns the decimal value of the binary number represented by the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem binaryToDecimal_spec_satisfied (digits: List Nat) (h_precond : binaryToDecimal_precond (digits)) :\n    binaryToDecimal_postcond (digits) (binaryToDecimal (digits) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef binaryToDecimal_precond (digits : List Nat) : Prop :=\n  digits.all (fun d => d = 0 ∨ d = 1)\n\ndef binaryToDecimal (digits : List Nat) (h_precond : binaryToDecimal_precond (digits)) : Nat :=\n  let rec helper (digits : List Nat) : Nat :=\n    match digits with\n    | [] => 0\n    | first :: rest => first * Nat.pow 2 rest.length + helper rest\n  helper digits\n\n@[reducible]\ndef binaryToDecimal_postcond (digits : List Nat) (result: Nat) (h_precond : binaryToDecimal_precond (digits)) : Prop :=\n  result - List.foldl (λ acc bit => acc * 2 + bit) 0 digits = 0 ∧\n  List.foldl (λ acc bit => acc * 2 + bit) 0 digits - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem binaryToDecimal_spec_satisfied (digits: List Nat) (h_precond : binaryToDecimal_precond (digits)) :\n    binaryToDecimal_postcond (digits) (binaryToDecimal (digits) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_7"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description---\nThis task requires writing a Lean 4 method that's goal is to determine the minimum number of adjacent swaps needed to make the array semi-ordered. You may repeatedly swap 2 adjacent elements in the array. A permutation is called semi-ordered if the first number equals 1 and the last number equals n. \n\n-----Input-----\n\nThe input consists of:\n- nums: A list of integeris.\n\n----Output-----\n\nThe output is an integer.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem semiOrderedPermutation_spec_satisfied (nums: List Int) (h_precond : semiOrderedPermutation_precond (nums)) :\n    semiOrderedPermutation_postcond (nums) (semiOrderedPermutation (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef semiOrderedPermutation_precond (nums : List Int) : Prop :=\n  True\n\ndef semiOrderedPermutation (nums : List Int) (h_precond : semiOrderedPermutation_precond (nums)) : Int :=\n  let lengthList := nums.length\n  let numOne : Int := 1\n  let largestNum : Int := Int.ofNat lengthList\n\n  let firstIndex := nums.idxOf numOne\n  let lastIndex := nums.idxOf largestNum\n\n  let startPosition := 0\n  let endPosition := lengthList - 1\n\n  let shouldMoveOne := firstIndex != startPosition\n  let shouldMoveLast := lastIndex != endPosition\n\n  let distanceOne := if shouldMoveOne then firstIndex else 0\n  let distanceLast := if shouldMoveLast then endPosition - lastIndex else 0\n\n  let totalMoves := distanceOne + distanceLast\n  let needAdjustment := firstIndex > lastIndex\n  let adjustedMoves := if needAdjustment then totalMoves - 1 else totalMoves\n\n  adjustedMoves\n\n@[reducible]\ndef semiOrderedPermutation_postcond (nums : List Int) (result: Int) (h_precond : semiOrderedPermutation_precond (nums)) : Prop :=\n  let n := nums.length\n  let pos1 := nums.idxOf 1\n  let posn := nums.idxOf (Int.ofNat n)\n  if pos1 > posn then\n    pos1 + n = result + 2 + posn\n  else\n    pos1 + n = result + 1 + posn\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem semiOrderedPermutation_spec_satisfied (nums: List Int) (h_precond : semiOrderedPermutation_precond (nums)) :\n    semiOrderedPermutation_postcond (nums) (semiOrderedPermutation (nums) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_70", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description---\nThis task requires writing a Lean 4 method that's goal is to determine the minimum number of adjacent swaps needed to make the array semi-ordered. You may repeatedly swap 2 adjacent elements in the array. A permutation is called semi-ordered if the first number equals 1 and the last number equals n. \n\n-----Input-----\n\nThe input consists of:\n- nums: A list of integeris.\n\n----Output-----\n\nThe output is an integer.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem semiOrderedPermutation_spec_satisfied (nums: List Int) (h_precond : semiOrderedPermutation_precond (nums)) :\n    semiOrderedPermutation_postcond (nums) (semiOrderedPermutation (nums) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef semiOrderedPermutation_precond (nums : List Int) : Prop :=\n  True\n\ndef semiOrderedPermutation (nums : List Int) (h_precond : semiOrderedPermutation_precond (nums)) : Int :=\n  let lengthList := nums.length\n  let numOne : Int := 1\n  let largestNum : Int := Int.ofNat lengthList\n\n  let firstIndex := nums.idxOf numOne\n  let lastIndex := nums.idxOf largestNum\n\n  let startPosition := 0\n  let endPosition := lengthList - 1\n\n  let shouldMoveOne := firstIndex != startPosition\n  let shouldMoveLast := lastIndex != endPosition\n\n  let distanceOne := if shouldMoveOne then firstIndex else 0\n  let distanceLast := if shouldMoveLast then endPosition - lastIndex else 0\n\n  let totalMoves := distanceOne + distanceLast\n  let needAdjustment := firstIndex > lastIndex\n  let adjustedMoves := if needAdjustment then totalMoves - 1 else totalMoves\n\n  adjustedMoves\n\n@[reducible]\ndef semiOrderedPermutation_postcond (nums : List Int) (result: Int) (h_precond : semiOrderedPermutation_precond (nums)) : Prop :=\n  let n := nums.length\n  let pos1 := nums.idxOf 1\n  let posn := nums.idxOf (Int.ofNat n)\n  if pos1 > posn then\n    pos1 + n = result + 2 + posn\n  else\n    pos1 + n = result + 1 + posn\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem semiOrderedPermutation_spec_satisfied (nums: List Int) (h_precond : semiOrderedPermutation_precond (nums)) :\n    semiOrderedPermutation_postcond (nums) (semiOrderedPermutation (nums) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_70"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that, given a binary string `s` and an integer `k`, finds the shortest contiguous substring that contains exactly `k` characters `'1'`.\n\nAmong all substrings of `s` that contain exactly `k` occurrences of `'1'`, return the one that is shortest in length. If there are multiple such substrings with the same length, return the lexicographically smallest one.\n\nIf no such substring exists, return the empty string.\n\n-----Input-----\n- s: A binary string (only consisting of characters `'0'` and `'1'`)\n- k: A natural number (k ≥ 0)\n\n-----Output-----\nA string representing the shortest substring of `s` that contains exactly `k` ones. If no such substring exists, return `\"\"`.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem shortestBeautifulSubstring_spec_satisfied (s: String) (k: Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) :\n    shortestBeautifulSubstring_postcond (s) (k) (shortestBeautifulSubstring (s) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef countOnes (lst : List Char) : Nat :=\n  lst.foldl (fun acc c => if c = '1' then acc + 1 else acc) 0\n\n@[reducible]\ndef shortestBeautifulSubstring_precond (s : String) (k : Nat) : Prop :=\n  s.toList.all (fun c => c = '0' ∨ c = '1')\n\ndef listToString (lst : List Char) : String :=\n  String.mk lst\ndef isLexSmaller (a b : List Char) : Bool :=\n  listToString a < listToString b\ndef allSubstrings (s : List Char) : List (List Char) :=\n  let n := s.length\n  (List.range n).flatMap (fun i =>\n    (List.range (n - i)).map (fun j =>\n      s.drop i |>.take (j + 1)))\n\ndef shortestBeautifulSubstring (s : String) (k : Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : String :=\n  let chars := s.data\n  let candidates := allSubstrings chars |>.filter (fun sub => countOnes sub = k)\n\n  let compare (a b : List Char) : Bool :=\n    a.length < b.length ∨ (a.length = b.length ∧ isLexSmaller a b)\n\n  let best := candidates.foldl (fun acc cur =>\n    match acc with\n    | none => some cur\n    | some best => if compare cur best then some cur else some best) none\n  match best with\n  | some b => listToString b\n  | none => \"\"\n\n@[reducible]\ndef shortestBeautifulSubstring_postcond (s : String) (k : Nat) (result: String) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : Prop :=\n  let chars := s.data\n  let substrings := (List.range chars.length).flatMap (fun i =>\n    (List.range (chars.length - i + 1)).map (fun len =>\n      chars.drop i |>.take len))\n  let isBeautiful := fun sub => countOnes sub = k\n  let beautiful := substrings.filter (fun sub => isBeautiful sub)\n  let targets := beautiful.map (·.asString) |>.filter (fun s => s ≠ \"\")\n  (result = \"\" ∧ targets = []) ∨\n  (result ∈ targets ∧\n   ∀ r ∈ targets, r.length ≥ result.length ∨ (r.length = result.length ∧ result ≤ r))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem shortestBeautifulSubstring_spec_satisfied (s: String) (k: Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) :\n    shortestBeautifulSubstring_postcond (s) (k) (shortestBeautifulSubstring (s) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_71", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that, given a binary string `s` and an integer `k`, finds the shortest contiguous substring that contains exactly `k` characters `'1'`.\n\nAmong all substrings of `s` that contain exactly `k` occurrences of `'1'`, return the one that is shortest in length. If there are multiple such substrings with the same length, return the lexicographically smallest one.\n\nIf no such substring exists, return the empty string.\n\n-----Input-----\n- s: A binary string (only consisting of characters `'0'` and `'1'`)\n- k: A natural number (k ≥ 0)\n\n-----Output-----\nA string representing the shortest substring of `s` that contains exactly `k` ones. If no such substring exists, return `\"\"`.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem shortestBeautifulSubstring_spec_satisfied (s: String) (k: Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) :\n    shortestBeautifulSubstring_postcond (s) (k) (shortestBeautifulSubstring (s) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef countOnes (lst : List Char) : Nat :=\n  lst.foldl (fun acc c => if c = '1' then acc + 1 else acc) 0\n\n@[reducible]\ndef shortestBeautifulSubstring_precond (s : String) (k : Nat) : Prop :=\n  s.toList.all (fun c => c = '0' ∨ c = '1')\n\ndef listToString (lst : List Char) : String :=\n  String.mk lst\ndef isLexSmaller (a b : List Char) : Bool :=\n  listToString a < listToString b\ndef allSubstrings (s : List Char) : List (List Char) :=\n  let n := s.length\n  (List.range n).flatMap (fun i =>\n    (List.range (n - i)).map (fun j =>\n      s.drop i |>.take (j + 1)))\n\ndef shortestBeautifulSubstring (s : String) (k : Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : String :=\n  let chars := s.data\n  let candidates := allSubstrings chars |>.filter (fun sub => countOnes sub = k)\n\n  let compare (a b : List Char) : Bool :=\n    a.length < b.length ∨ (a.length = b.length ∧ isLexSmaller a b)\n\n  let best := candidates.foldl (fun acc cur =>\n    match acc with\n    | none => some cur\n    | some best => if compare cur best then some cur else some best) none\n  match best with\n  | some b => listToString b\n  | none => \"\"\n\n@[reducible]\ndef shortestBeautifulSubstring_postcond (s : String) (k : Nat) (result: String) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : Prop :=\n  let chars := s.data\n  let substrings := (List.range chars.length).flatMap (fun i =>\n    (List.range (chars.length - i + 1)).map (fun len =>\n      chars.drop i |>.take len))\n  let isBeautiful := fun sub => countOnes sub = k\n  let beautiful := substrings.filter (fun sub => isBeautiful sub)\n  let targets := beautiful.map (·.asString) |>.filter (fun s => s ≠ \"\")\n  (result = \"\" ∧ targets = []) ∨\n  (result ∈ targets ∧\n   ∀ r ∈ targets, r.length ≥ result.length ∨ (r.length = result.length ∧ result ≤ r))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem shortestBeautifulSubstring_spec_satisfied (s: String) (k: Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) :\n    shortestBeautifulSubstring_postcond (s) (k) (shortestBeautifulSubstring (s) (k) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_71"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that given an natural number n, returns the smallest prime factor that is less than 10. If none exist, return 0\n\n-----Input-----\nThe input consists of one natural number:\nn: The main natural number.\n\n-----Output-----\nThe output is an natural number:\nReturns the smallest prime factor that is less than 10 or, if none exist, 0\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem singleDigitPrimeFactor_spec_satisfied (n: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) :\n    singleDigitPrimeFactor_postcond (n) (singleDigitPrimeFactor (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef singleDigitPrimeFactor_precond (n : Nat) : Prop :=\n  True\n\ndef singleDigitPrimeFactor (n : Nat) (h_precond : singleDigitPrimeFactor_precond (n)) : Nat :=\n  if n == 0 then 0\n  else if n % 2 == 0 then 2\n  else if n % 3 == 0 then 3\n  else if n % 5 == 0 then 5\n  else if n % 7 == 0 then 7\n  else 0\n\n@[reducible, simp]\ndef singleDigitPrimeFactor_postcond (n : Nat) (result: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) : Prop :=\n  result ∈ [0, 2, 3, 5, 7] ∧\n  (result = 0 → (n = 0 ∨ [2, 3, 5, 7].all (n % · ≠ 0))) ∧\n  (result ≠ 0 → n ≠ 0 ∧ n % result == 0 ∧ (List.range result).all (fun x => x ∈ [2, 3, 5, 7] → n % x ≠ 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem singleDigitPrimeFactor_spec_satisfied (n: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) :\n    singleDigitPrimeFactor_postcond (n) (singleDigitPrimeFactor (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_72", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that given an natural number n, returns the smallest prime factor that is less than 10. If none exist, return 0\n\n-----Input-----\nThe input consists of one natural number:\nn: The main natural number.\n\n-----Output-----\nThe output is an natural number:\nReturns the smallest prime factor that is less than 10 or, if none exist, 0\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem singleDigitPrimeFactor_spec_satisfied (n: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) :\n    singleDigitPrimeFactor_postcond (n) (singleDigitPrimeFactor (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef singleDigitPrimeFactor_precond (n : Nat) : Prop :=\n  True\n\ndef singleDigitPrimeFactor (n : Nat) (h_precond : singleDigitPrimeFactor_precond (n)) : Nat :=\n  if n == 0 then 0\n  else if n % 2 == 0 then 2\n  else if n % 3 == 0 then 3\n  else if n % 5 == 0 then 5\n  else if n % 7 == 0 then 7\n  else 0\n\n@[reducible, simp]\ndef singleDigitPrimeFactor_postcond (n : Nat) (result: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) : Prop :=\n  result ∈ [0, 2, 3, 5, 7] ∧\n  (result = 0 → (n = 0 ∨ [2, 3, 5, 7].all (n % · ≠ 0))) ∧\n  (result ≠ 0 → n ≠ 0 ∧ n % result == 0 ∧ (List.range result).all (fun x => x ∈ [2, 3, 5, 7] → n % x ≠ 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem singleDigitPrimeFactor_spec_satisfied (n: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) :\n    singleDigitPrimeFactor_postcond (n) (singleDigitPrimeFactor (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_72"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the first missing natural number in an increasingly sorted list. The method should return the smallest natural number that is not in the list, ensuring that all natural numbers that are smaller is inside the list.\n\n-----Input-----\nThe input consists of a list of natural numbers sorted in increasing order:\nl: The sorted list\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that is not in the list, which means all natural numbers that are smaller than the returned value should be inside the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem smallestMissing_spec_satisfied (l: List Nat) (h_precond : smallestMissing_precond (l)) :\n    smallestMissing_postcond (l) (smallestMissing (l) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef smallestMissing_precond (l : List Nat) : Prop :=\n  List.Pairwise (· < ·) l\n\ndef smallestMissing (l : List Nat) (h_precond : smallestMissing_precond (l)) : Nat :=\n  let sortedList := l\n  let rec search (lst : List Nat) (n : Nat) : Nat :=\n    match lst with\n    | [] => n\n    | x :: xs =>\n      let isEqual := x = n\n      let isGreater := x > n\n      let nextCand := n + 1\n      if isEqual then\n        search xs nextCand\n      else if isGreater then\n        n\n      else\n        search xs n\n  let result := search sortedList 0\n  result\n\n@[reducible]\ndef smallestMissing_postcond (l : List Nat) (result: Nat) (h_precond : smallestMissing_precond (l)) : Prop :=\n  result ∉ l ∧ ∀ candidate : Nat, candidate < result → candidate ∈ l\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem smallestMissing_spec_satisfied (l: List Nat) (h_precond : smallestMissing_precond (l)) :\n    smallestMissing_postcond (l) (smallestMissing (l) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_73", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the first missing natural number in an increasingly sorted list. The method should return the smallest natural number that is not in the list, ensuring that all natural numbers that are smaller is inside the list.\n\n-----Input-----\nThe input consists of a list of natural numbers sorted in increasing order:\nl: The sorted list\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that is not in the list, which means all natural numbers that are smaller than the returned value should be inside the input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem smallestMissing_spec_satisfied (l: List Nat) (h_precond : smallestMissing_precond (l)) :\n    smallestMissing_postcond (l) (smallestMissing (l) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef smallestMissing_precond (l : List Nat) : Prop :=\n  List.Pairwise (· < ·) l\n\ndef smallestMissing (l : List Nat) (h_precond : smallestMissing_precond (l)) : Nat :=\n  let sortedList := l\n  let rec search (lst : List Nat) (n : Nat) : Nat :=\n    match lst with\n    | [] => n\n    | x :: xs =>\n      let isEqual := x = n\n      let isGreater := x > n\n      let nextCand := n + 1\n      if isEqual then\n        search xs nextCand\n      else if isGreater then\n        n\n      else\n        search xs n\n  let result := search sortedList 0\n  result\n\n@[reducible]\ndef smallestMissing_postcond (l : List Nat) (result: Nat) (h_precond : smallestMissing_precond (l)) : Prop :=\n  result ∉ l ∧ ∀ candidate : Nat, candidate < result → candidate ∈ l\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem smallestMissing_spec_satisfied (l: List Nat) (h_precond : smallestMissing_precond (l)) :\n    smallestMissing_postcond (l) (smallestMissing (l) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_73"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function called `solution` that takes a list of natural numbers `nums`. The function should calculate and return the sum of values obtained for each subarray, where the value for a subarray is the square of the count of distinct elements within that subarray.\n\n-----Input-----\nThe input is a list of natural numbers:\n`nums`: A list where each element is a natural number.\nConstraints:\n- The length of the list `nums` (n) is between 1 and 100 (inclusive).\n- Each element in `nums` is between 1 and 100 (inclusive).\n\n-----Output-----\nThe output is a natural number:\nReturns the total sum of squared distinct counts for all subarrays.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem solution_spec_satisfied (nums: List Nat) :\n    solution_postcond (nums) (solution (nums)) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\nopen Std\n\n@[reducible]\ndef solution_precond (nums : List Nat) : Prop :=\n  1 ≤ nums.length ∧ nums.length ≤ 100 ∧ nums.all (fun x => 1 ≤ x ∧ x ≤ 100)\n\ndef solution (nums : List Nat) : Nat :=\n  let n := nums.length\n  let subarray := fun (i j : Nat) => (nums.drop i).take (j - i + 1)\n  let distinctCount := fun (l : List Nat) =>\n    let hashSet := l.foldl (fun (s : HashSet Nat) a => s.insert a) HashSet.empty\n    hashSet.size\n  List.range n |>.foldl (fun acc i =>\n    acc +\n      (List.range (n - i) |>.foldl (fun acc' d =>\n        let subarr := subarray i (i + d)\n        let cnt := distinctCount subarr\n        acc' + cnt * cnt\n      ) 0)\n  ) 0\n\n@[reducible]\ndef solution_postcond (nums : List Nat) (result: Nat) : Prop :=\n  let n := nums.length;\n\n  let getSubarray_local := fun (i j : Nat) =>\n    (nums.drop i).take (j - i + 1);\n\n  let distinctCount_local := fun (l : List Nat) =>\n    let foldFn := fun (seen : List Nat) (x : Nat) =>\n      if seen.elem x then seen else x :: seen;\n    let distinctElems := l.foldl foldFn [];\n    distinctElems.length;\n\n  let square_local := fun (n : Nat) => n * n;\n\n  (1 <= n ∧ n <= 100 ∧ nums.all (fun x => 1 <= x ∧ x <= 100)) ->\n  (\n    result >= 0\n    ∧\n    let expectedSum : Nat :=\n      List.range n |>.foldl (fun (outerSum : Nat) (i : Nat) =>\n        let innerSum : Nat :=\n          List.range (n - i) |>.foldl (fun (currentInnerSum : Nat) (d : Nat) =>\n            let j := i + d;\n            let subarr := getSubarray_local i j;\n            let count := distinctCount_local subarr;\n            currentInnerSum + square_local count\n          ) 0\n        outerSum + innerSum\n      ) 0;\n\n    result = expectedSum\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem solution_spec_satisfied (nums: List Nat) :\n    solution_postcond (nums) (solution (nums)) := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_74", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function called `solution` that takes a list of natural numbers `nums`. The function should calculate and return the sum of values obtained for each subarray, where the value for a subarray is the square of the count of distinct elements within that subarray.\n\n-----Input-----\nThe input is a list of natural numbers:\n`nums`: A list where each element is a natural number.\nConstraints:\n- The length of the list `nums` (n) is between 1 and 100 (inclusive).\n- Each element in `nums` is between 1 and 100 (inclusive).\n\n-----Output-----\nThe output is a natural number:\nReturns the total sum of squared distinct counts for all subarrays.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem solution_spec_satisfied (nums: List Nat) :\n    solution_postcond (nums) (solution (nums)) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\nopen Std\n\n@[reducible]\ndef solution_precond (nums : List Nat) : Prop :=\n  1 ≤ nums.length ∧ nums.length ≤ 100 ∧ nums.all (fun x => 1 ≤ x ∧ x ≤ 100)\n\ndef solution (nums : List Nat) : Nat :=\n  let n := nums.length\n  let subarray := fun (i j : Nat) => (nums.drop i).take (j - i + 1)\n  let distinctCount := fun (l : List Nat) =>\n    let hashSet := l.foldl (fun (s : HashSet Nat) a => s.insert a) HashSet.empty\n    hashSet.size\n  List.range n |>.foldl (fun acc i =>\n    acc +\n      (List.range (n - i) |>.foldl (fun acc' d =>\n        let subarr := subarray i (i + d)\n        let cnt := distinctCount subarr\n        acc' + cnt * cnt\n      ) 0)\n  ) 0\n\n@[reducible]\ndef solution_postcond (nums : List Nat) (result: Nat) : Prop :=\n  let n := nums.length;\n\n  let getSubarray_local := fun (i j : Nat) =>\n    (nums.drop i).take (j - i + 1);\n\n  let distinctCount_local := fun (l : List Nat) =>\n    let foldFn := fun (seen : List Nat) (x : Nat) =>\n      if seen.elem x then seen else x :: seen;\n    let distinctElems := l.foldl foldFn [];\n    distinctElems.length;\n\n  let square_local := fun (n : Nat) => n * n;\n\n  (1 <= n ∧ n <= 100 ∧ nums.all (fun x => 1 <= x ∧ x <= 100)) ->\n  (\n    result >= 0\n    ∧\n    let expectedSum : Nat :=\n      List.range n |>.foldl (fun (outerSum : Nat) (i : Nat) =>\n        let innerSum : Nat :=\n          List.range (n - i) |>.foldl (fun (currentInnerSum : Nat) (d : Nat) =>\n            let j := i + d;\n            let subarr := getSubarray_local i j;\n            let count := distinctCount_local subarr;\n            currentInnerSum + square_local count\n          ) 0\n        outerSum + innerSum\n      ) 0;\n\n    result = expectedSum\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem solution_spec_satisfied (nums: List Nat) :\n    solution_postcond (nums) (solution (nums)) := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_74"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.\n\nThe algorithm uses dynamic programming (Kadane’s Algorithm) to solve the problem:\n1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.\n2. For each subsequent element, update:\n     cur = max(element, cur + element)\n     maxSoFar = max(maxSoFar, cur)\n3. Return maxSoFar as the answer.\n\n-----Input-----\nThe input is provided as a list of integers:\n  sequence: A list of n integers.\n\n-----Output-----\nThe output is a single integer representing the maximum subarray sum.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :\n    task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef task_code_precond (sequence : List Int) : Prop :=\n  True\n\ndef task_code (sequence : List Int) (h_precond : task_code_precond (sequence)) : Int :=\n  match sequence with\n  | []      => 0  -- If no elements are provided (should not happen according to the problem)\n  | x :: xs =>\n      let (_, maxSoFar) :=\n        xs.foldl (fun (acc : Int × Int) (x : Int) =>\n          let (cur, maxSoFar) := acc\n          let newCur := if cur + x >= x then cur + x else x\n          let newMax := if maxSoFar >= newCur then maxSoFar else newCur\n          (newCur, newMax)\n        ) (x, x)\n      maxSoFar\n\n@[reducible, simp]\ndef task_code_postcond (sequence : List Int) (result: Int) (h_precond : task_code_precond (sequence)) : Prop :=\n  let subArrays :=\n    List.range (sequence.length + 1) |>.flatMap (fun start =>\n      List.range (sequence.length - start + 1) |>.map (fun len =>\n        sequence.drop start |>.take len))\n  let subArraySums := subArrays.filter (· ≠ []) |>.map (·.sum)\n  subArraySums.contains result ∧ subArraySums.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :\n    task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_75", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.\n\nThe algorithm uses dynamic programming (Kadane’s Algorithm) to solve the problem:\n1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.\n2. For each subsequent element, update:\n     cur = max(element, cur + element)\n     maxSoFar = max(maxSoFar, cur)\n3. Return maxSoFar as the answer.\n\n-----Input-----\nThe input is provided as a list of integers:\n  sequence: A list of n integers.\n\n-----Output-----\nThe output is a single integer representing the maximum subarray sum.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :\n    task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef task_code_precond (sequence : List Int) : Prop :=\n  True\n\ndef task_code (sequence : List Int) (h_precond : task_code_precond (sequence)) : Int :=\n  match sequence with\n  | []      => 0  -- If no elements are provided (should not happen according to the problem)\n  | x :: xs =>\n      let (_, maxSoFar) :=\n        xs.foldl (fun (acc : Int × Int) (x : Int) =>\n          let (cur, maxSoFar) := acc\n          let newCur := if cur + x >= x then cur + x else x\n          let newMax := if maxSoFar >= newCur then maxSoFar else newCur\n          (newCur, newMax)\n        ) (x, x)\n      maxSoFar\n\n@[reducible, simp]\ndef task_code_postcond (sequence : List Int) (result: Int) (h_precond : task_code_precond (sequence)) : Prop :=\n  let subArrays :=\n    List.range (sequence.length + 1) |>.flatMap (fun start =>\n      List.range (sequence.length - start + 1) |>.map (fun len =>\n        sequence.drop start |>.take len))\n  let subArraySums := subArrays.filter (· ≠ []) |>.map (·.sum)\n  subArraySums.contains result ∧ subArraySums.all (· ≤ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :\n    task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_75"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that returns the k most frequent elements from a list of integers. The method should count the frequency of each distinct element in the list and return the k elements with the highest frequency.\n\n-----Input-----\nThe input consists of two values:\nnums: A list of integers, possibly with duplicates.\nk: A natural number indicating how many of the most frequent elements to return. Assimng k <= # of distinct elements in nums. \n\n-----Output-----\nThe output is a list of integers:\nReturns exactly k integers representing the elements that appear most frequently in the input list in the order form the higher frequency to lower frequency.\nIf two numbers have the same frequency, use the order of the first occurance in nums.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem topKFrequent_spec_satisfied (nums: List Int) (k: Nat) (h_precond : topKFrequent_precond (nums) (k)) :\n    topKFrequent_postcond (nums) (k) (topKFrequent (nums) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std\nopen Std\n\n@[reducible]\ndef topKFrequent_precond (nums : List Int) (k : Nat) : Prop :=\n  k ≤ nums.eraseDups.length\n\ndef topKFrequent (nums : List Int) (k : Nat) (h_precond : topKFrequent_precond (nums) (k)) : List Int :=\n  let freqMap : HashMap Int Nat :=\n    nums.foldl (init := {}) fun acc n =>\n      let oldVal := match acc.toList.find? (fun (key, _) => key == n) with\n                    | some (_, c) => c\n                    | none        => 0\n      acc.insert n (oldVal + 1)\n  let sorted := freqMap.toList.foldl\n    (fun acc pair =>\n      let (x, cx) := pair\n      let rec insertSorted (xs : List (Int × Nat)) : List (Int × Nat) :=\n        match xs with\n        | [] => [pair]\n        | (y, cy) :: ys =>\n          if cx > cy then\n            pair :: (y, cy) :: ys\n          else\n            (y, cy) :: insertSorted ys\n      insertSorted acc\n    ) []\n\n  sorted.take k |>.map (fun (n, _) => n)\n\n@[reducible]\ndef topKFrequent_postcond (nums : List Int) (k : Nat) (result: List Int) (h_precond : topKFrequent_precond (nums) (k)) : Prop :=\n  result.length = k ∧\n\n  result.all (· ∈ nums) ∧\n\n  List.Pairwise (· ≠ ·) result ∧\n\n  (result.all (fun x =>\n    nums.all (fun y =>\n      y ∉ result →\n        nums.count x > nums.count y ∨\n        (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)\n    ))) ∧\n\n  List.Pairwise (fun (x, i) (y, j) =>\n    i < j → nums.count x > nums.count y ∨\n    (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)\n  ) result.zipIdx\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem topKFrequent_spec_satisfied (nums: List Int) (k: Nat) (h_precond : topKFrequent_precond (nums) (k)) :\n    topKFrequent_postcond (nums) (k) (topKFrequent (nums) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_76", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that returns the k most frequent elements from a list of integers. The method should count the frequency of each distinct element in the list and return the k elements with the highest frequency.\n\n-----Input-----\nThe input consists of two values:\nnums: A list of integers, possibly with duplicates.\nk: A natural number indicating how many of the most frequent elements to return. Assimng k <= # of distinct elements in nums. \n\n-----Output-----\nThe output is a list of integers:\nReturns exactly k integers representing the elements that appear most frequently in the input list in the order form the higher frequency to lower frequency.\nIf two numbers have the same frequency, use the order of the first occurance in nums.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem topKFrequent_spec_satisfied (nums: List Int) (k: Nat) (h_precond : topKFrequent_precond (nums) (k)) :\n    topKFrequent_postcond (nums) (k) (topKFrequent (nums) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std\nopen Std\n\n@[reducible]\ndef topKFrequent_precond (nums : List Int) (k : Nat) : Prop :=\n  k ≤ nums.eraseDups.length\n\ndef topKFrequent (nums : List Int) (k : Nat) (h_precond : topKFrequent_precond (nums) (k)) : List Int :=\n  let freqMap : HashMap Int Nat :=\n    nums.foldl (init := {}) fun acc n =>\n      let oldVal := match acc.toList.find? (fun (key, _) => key == n) with\n                    | some (_, c) => c\n                    | none        => 0\n      acc.insert n (oldVal + 1)\n  let sorted := freqMap.toList.foldl\n    (fun acc pair =>\n      let (x, cx) := pair\n      let rec insertSorted (xs : List (Int × Nat)) : List (Int × Nat) :=\n        match xs with\n        | [] => [pair]\n        | (y, cy) :: ys =>\n          if cx > cy then\n            pair :: (y, cy) :: ys\n          else\n            (y, cy) :: insertSorted ys\n      insertSorted acc\n    ) []\n\n  sorted.take k |>.map (fun (n, _) => n)\n\n@[reducible]\ndef topKFrequent_postcond (nums : List Int) (k : Nat) (result: List Int) (h_precond : topKFrequent_precond (nums) (k)) : Prop :=\n  result.length = k ∧\n\n  result.all (· ∈ nums) ∧\n\n  List.Pairwise (· ≠ ·) result ∧\n\n  (result.all (fun x =>\n    nums.all (fun y =>\n      y ∉ result →\n        nums.count x > nums.count y ∨\n        (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)\n    ))) ∧\n\n  List.Pairwise (fun (x, i) (y, j) =>\n    i < j → nums.count x > nums.count y ∨\n    (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)\n  ) result.zipIdx\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem topKFrequent_spec_satisfied (nums: List Int) (k: Nat) (h_precond : topKFrequent_precond (nums) (k)) :\n    topKFrequent_postcond (nums) (k) (topKFrequent (nums) (k) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_76"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that calculates how much water can be trapped between elevations after it rains. The input is a list of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.\n\n-----Input-----\n- height: A list of natural numbers representing elevations.\n\n-----Output-----\n- A natural number: total units of water that can be trapped.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :\n    trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef trapRainWater_precond (height : List Nat) : Prop :=\n  True\n\ndef trapRainWater (height : List Nat) (h_precond : trapRainWater_precond (height)) : Nat :=\n  Id.run do\n    let mut left := 0\n    let mut right := height.length - 1\n    let mut leftMax := 0\n    let mut rightMax := 0\n    let mut water := 0\n\n    while left < right do\n      let hLeft := height[left]!\n      let hRight := height[right]!\n\n      if hLeft < hRight then\n        if hLeft >= leftMax then\n          leftMax := hLeft\n        else\n          water := water + (leftMax - hLeft)\n        left := left + 1\n      else\n        if hRight >= rightMax then\n          rightMax := hRight\n        else\n          water := water + (rightMax - hRight)\n        right := right - 1\n\n    return water\n\n@[reducible, simp]\ndef trapRainWater_postcond (height : List Nat) (result: Nat) (h_precond : trapRainWater_precond (height)) : Prop :=\n  let waterAt := List.range height.length |>.map (fun i =>\n    let lmax := List.take (i+1) height |>.foldl Nat.max 0\n    let rmax := List.drop i height |>.foldl Nat.max 0\n    Nat.min lmax rmax - height[i]!)\n\n  result - (waterAt.foldl (· + ·) 0) = 0 ∧ (waterAt.foldl (· + ·) 0) ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :\n    trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_77", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 function that calculates how much water can be trapped between elevations after it rains. The input is a list of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.\n\n-----Input-----\n- height: A list of natural numbers representing elevations.\n\n-----Output-----\n- A natural number: total units of water that can be trapped.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :\n    trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef trapRainWater_precond (height : List Nat) : Prop :=\n  True\n\ndef trapRainWater (height : List Nat) (h_precond : trapRainWater_precond (height)) : Nat :=\n  Id.run do\n    let mut left := 0\n    let mut right := height.length - 1\n    let mut leftMax := 0\n    let mut rightMax := 0\n    let mut water := 0\n\n    while left < right do\n      let hLeft := height[left]!\n      let hRight := height[right]!\n\n      if hLeft < hRight then\n        if hLeft >= leftMax then\n          leftMax := hLeft\n        else\n          water := water + (leftMax - hLeft)\n        left := left + 1\n      else\n        if hRight >= rightMax then\n          rightMax := hRight\n        else\n          water := water + (rightMax - hRight)\n        right := right - 1\n\n    return water\n\n@[reducible, simp]\ndef trapRainWater_postcond (height : List Nat) (result: Nat) (h_precond : trapRainWater_precond (height)) : Prop :=\n  let waterAt := List.range height.length |>.map (fun i =>\n    let lmax := List.take (i+1) height |>.foldl Nat.max 0\n    let rmax := List.drop i height |>.foldl Nat.max 0\n    Nat.min lmax rmax - height[i]!)\n\n  result - (waterAt.foldl (· + ·) 0) = 0 ∧ (waterAt.foldl (· + ·) 0) ≤ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :\n    trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_77"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that solves the Two Sum problem. Given a list of integers and a target integer, the method must return a pair of indices such that the sum of the numbers at those indices equals the target. You may assume that each input has exactly one solution and that you may not use the same element twice. The answer should be returned with first index is smaller than the second.\n\n-----Input-----\nThe input consists of:\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\nThe output is a pair (tuple) of integers representing the indices of the two numbers in the input list that add up to the target.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  let pairwiseSum := List.range nums.length |>.flatMap (fun i =>\n    nums.drop (i + 1) |>.map (fun y => nums[i]! + y))\n  nums.length > 1 ∧ pairwiseSum.count target = 1\n\ndef findComplement (nums : List Int) (target : Int) (i : Nat) (x : Int) : Option Nat :=\n  let rec aux (nums : List Int) (j : Nat) : Option Nat :=\n    match nums with\n    | []      => none\n    | y :: ys => if x + y = target then some (i + j + 1) else aux ys (j + 1)\n  aux nums 0\n\ndef twoSumAux (nums : List Int) (target : Int) (i : Nat) : Prod Nat Nat :=\n  match nums with\n  | []      => panic! \"No solution exists\"\n  | x :: xs =>\n    match findComplement xs target i x with\n    | some j => (i, j)\n    | none   => twoSumAux xs target (i + 1)\n\ndef twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Prod Nat Nat :=\n  twoSumAux nums target 0\n\n@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Prod Nat Nat) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  let i := result.fst;\n  let j := result.snd;\n  (i < j) ∧\n  (i < nums.length) ∧ (j < nums.length) ∧\n  (nums[i]!) + (nums[j]!) = target\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_78", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that solves the Two Sum problem. Given a list of integers and a target integer, the method must return a pair of indices such that the sum of the numbers at those indices equals the target. You may assume that each input has exactly one solution and that you may not use the same element twice. The answer should be returned with first index is smaller than the second.\n\n-----Input-----\nThe input consists of:\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\nThe output is a pair (tuple) of integers representing the indices of the two numbers in the input list that add up to the target.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  let pairwiseSum := List.range nums.length |>.flatMap (fun i =>\n    nums.drop (i + 1) |>.map (fun y => nums[i]! + y))\n  nums.length > 1 ∧ pairwiseSum.count target = 1\n\ndef findComplement (nums : List Int) (target : Int) (i : Nat) (x : Int) : Option Nat :=\n  let rec aux (nums : List Int) (j : Nat) : Option Nat :=\n    match nums with\n    | []      => none\n    | y :: ys => if x + y = target then some (i + j + 1) else aux ys (j + 1)\n  aux nums 0\n\ndef twoSumAux (nums : List Int) (target : Int) (i : Nat) : Prod Nat Nat :=\n  match nums with\n  | []      => panic! \"No solution exists\"\n  | x :: xs =>\n    match findComplement xs target i x with\n    | some j => (i, j)\n    | none   => twoSumAux xs target (i + 1)\n\ndef twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Prod Nat Nat :=\n  twoSumAux nums target 0\n\n@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Prod Nat Nat) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  let i := result.fst;\n  let j := result.snd;\n  (i < j) ∧\n  (i < nums.length) ∧ (j < nums.length) ∧\n  (nums[i]!) + (nums[j]!) = target\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_78"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that implementing the \"Two Sum\" problem. Given a list of integers \nand a target integer, the function should return the indices of the two numbers that add up to \nthe target. If no valid pair exists, the function should return none. And the indices returned must \nbe within the bounds of the list. If multiple pair exists, return the first pair.\n\n-----Input-----\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\n- An option type containing a pair of natural numbers (indices) such that \n  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  True\n\ndef twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Option (Nat × Nat) :=\n  let rec outer (lst : List Int) (i : Nat)\n            : Option (Nat × Nat) :=\n        match lst with\n        | [] =>\n            none\n        | x :: xs =>\n            let rec inner (lst' : List Int) (j : Nat)\n                    : Option Nat :=\n                match lst' with\n                | [] =>\n                    none\n                | y :: ys =>\n                    if x + y = target then\n                        some j\n                    else\n                        inner ys (j + 1)\n            match inner xs (i + 1) with\n            | some j =>\n                some (i, j)\n            | none =>\n                outer xs (i + 1)\n        outer nums 0\n\n@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Option (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n    match result with\n    | none => List.Pairwise (· + · ≠ target) nums\n    | some (i, j) =>\n        i < j ∧\n        j < nums.length ∧\n        nums[i]! + nums[j]! = target ∧\n        List.Pairwise (fun a b => a + b ≠ target) (nums.take i) ∧\n        List.all (nums.take i) (fun a => List.all (nums.drop i) (fun b => a + b ≠ target) ) ∧\n        List.all (nums.drop (j + 1)) (fun a => a + nums[j]! ≠ target)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_79", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that implementing the \"Two Sum\" problem. Given a list of integers \nand a target integer, the function should return the indices of the two numbers that add up to \nthe target. If no valid pair exists, the function should return none. And the indices returned must \nbe within the bounds of the list. If multiple pair exists, return the first pair.\n\n-----Input-----\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\n- An option type containing a pair of natural numbers (indices) such that \n  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  True\n\ndef twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Option (Nat × Nat) :=\n  let rec outer (lst : List Int) (i : Nat)\n            : Option (Nat × Nat) :=\n        match lst with\n        | [] =>\n            none\n        | x :: xs =>\n            let rec inner (lst' : List Int) (j : Nat)\n                    : Option Nat :=\n                match lst' with\n                | [] =>\n                    none\n                | y :: ys =>\n                    if x + y = target then\n                        some j\n                    else\n                        inner ys (j + 1)\n            match inner xs (i + 1) with\n            | some j =>\n                some (i, j)\n            | none =>\n                outer xs (i + 1)\n        outer nums 0\n\n@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Option (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n    match result with\n    | none => List.Pairwise (· + · ≠ target) nums\n    | some (i, j) =>\n        i < j ∧\n        j < nums.length ∧\n        nums[i]! + nums[j]! = target ∧\n        List.Pairwise (fun a b => a + b ≠ target) (nums.take i) ∧\n        List.all (nums.take i) (fun a => List.all (nums.drop i) (fun b => a + b ≠ target) ) ∧\n        List.all (nums.drop (j + 1)) (fun a => a + nums[j]! ≠ target)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_79"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.\n\nYou start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.\n\nIf multiple solutions exist, return the one with the smallest starting gas station index.\n\n-----Input-----\nThe input consists of two arrays:\n\ngas: An array of integers where gas[i] represents the amount of gas available at the ith station.\n\ncost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem canCompleteCircuit_spec_satisfied (gas: List Int) (cost: List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) :\n    canCompleteCircuit_postcond (gas) (cost) (canCompleteCircuit (gas) (cost) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef canCompleteCircuit_precond (gas : List Int) (cost : List Int) : Prop :=\n  True\n\ndef canCompleteCircuit (gas : List Int) (cost : List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Int :=\n  let totalGas := gas.foldl (· + ·) 0\n  let totalCost := cost.foldl (· + ·) 0\n\n  if totalGas < totalCost then\n    -1\n  else\n    let rec loop (g c : List Int) (idx : Nat) (tank : Int) (start : Nat) : Int :=\n      match g, c with\n      | [], [] => start\n      | gi :: gs, ci :: cs =>\n        let tank' := tank + gi - ci\n        if tank' < 0 then\n          loop gs cs (idx + 1) 0 (idx + 1)\n        else\n          loop gs cs (idx + 1) tank' start\n      | _, _ => -1  -- lengths don’t match\n\n    let zipped := List.zip gas cost\n    let rec walk (pairs : List (Int × Int)) (i : Nat) (tank : Int) (start : Nat) : Int :=\n      match pairs with\n      | [] => start\n      | (g, c) :: rest =>\n        let newTank := tank + g - c\n        if newTank < 0 then\n          walk rest (i + 1) 0 (i + 1)\n        else\n          walk rest (i + 1) newTank start\n\n    walk zipped 0 0 0\n\n@[reducible]\ndef canCompleteCircuit_postcond (gas : List Int) (cost : List Int) (result: Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Prop :=\n  let valid (start : Nat) := List.range gas.length |>.all (fun i =>\n    let acc := List.range (i + 1) |>.foldl (fun t j =>\n      let jdx := (start + j) % gas.length\n      t + gas[jdx]! - cost[jdx]!) 0\n    acc ≥ 0)\n  (result = -1 → (List.range gas.length).all (fun start => ¬ valid start)) ∧\n  (result ≥ 0 → result < gas.length ∧ valid result.toNat ∧ (List.range result.toNat).all (fun start => ¬ valid start))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem canCompleteCircuit_spec_satisfied (gas: List Int) (cost: List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) :\n    canCompleteCircuit_postcond (gas) (cost) (canCompleteCircuit (gas) (cost) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_8", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.\n\nYou start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.\n\nIf multiple solutions exist, return the one with the smallest starting gas station index.\n\n-----Input-----\nThe input consists of two arrays:\n\ngas: An array of integers where gas[i] represents the amount of gas available at the ith station.\n\ncost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem canCompleteCircuit_spec_satisfied (gas: List Int) (cost: List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) :\n    canCompleteCircuit_postcond (gas) (cost) (canCompleteCircuit (gas) (cost) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef canCompleteCircuit_precond (gas : List Int) (cost : List Int) : Prop :=\n  True\n\ndef canCompleteCircuit (gas : List Int) (cost : List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Int :=\n  let totalGas := gas.foldl (· + ·) 0\n  let totalCost := cost.foldl (· + ·) 0\n\n  if totalGas < totalCost then\n    -1\n  else\n    let rec loop (g c : List Int) (idx : Nat) (tank : Int) (start : Nat) : Int :=\n      match g, c with\n      | [], [] => start\n      | gi :: gs, ci :: cs =>\n        let tank' := tank + gi - ci\n        if tank' < 0 then\n          loop gs cs (idx + 1) 0 (idx + 1)\n        else\n          loop gs cs (idx + 1) tank' start\n      | _, _ => -1  -- lengths don’t match\n\n    let zipped := List.zip gas cost\n    let rec walk (pairs : List (Int × Int)) (i : Nat) (tank : Int) (start : Nat) : Int :=\n      match pairs with\n      | [] => start\n      | (g, c) :: rest =>\n        let newTank := tank + g - c\n        if newTank < 0 then\n          walk rest (i + 1) 0 (i + 1)\n        else\n          walk rest (i + 1) newTank start\n\n    walk zipped 0 0 0\n\n@[reducible]\ndef canCompleteCircuit_postcond (gas : List Int) (cost : List Int) (result: Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Prop :=\n  let valid (start : Nat) := List.range gas.length |>.all (fun i =>\n    let acc := List.range (i + 1) |>.foldl (fun t j =>\n      let jdx := (start + j) % gas.length\n      t + gas[jdx]! - cost[jdx]!) 0\n    acc ≥ 0)\n  (result = -1 → (List.range gas.length).all (fun start => ¬ valid start)) ∧\n  (result ≥ 0 → result < gas.length ∧ valid result.toNat ∧ (List.range result.toNat).all (fun start => ¬ valid start))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem canCompleteCircuit_spec_satisfied (gas: List Int) (cost: List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) :\n    canCompleteCircuit_postcond (gas) (cost) (canCompleteCircuit (gas) (cost) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_8"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that finds the indices of two numbers in an array that add up to a target value. Given an array of integers and a target integer, the function should return the indices of the two numbers such that they add up to the target.\n\nYou may assume that each input has exactly one solution, and you may not use the same element twice.\n\n-----Input-----\nThe input consists of:\nnums: An array of integers.\ntarget: An integer representing the target sum.\n\n-----Output-----\nThe output is an array of two integers:\nReturns the indices of the two numbers in the array that add up to the target. The indices should be sorted.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size ≥ 2 ∧\n\n  (List.range nums.size).any (fun i =>\n    (List.range i).any (fun j => nums[i]! + nums[j]! = target)) ∧\n\n  ((List.range nums.size).flatMap (fun i =>\n    (List.range i).filter (fun j => nums[i]! + nums[j]! = target))).length = 1\n\ndef twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Array Nat :=\n  let rec findIndices (i : Nat) (j : Nat) (fuel : Nat) : Array Nat :=\n    match fuel with\n    | 0 => #[] -- Fuel exhausted, return empty array\n    | fuel+1 =>\n      if i >= nums.size then\n        #[] -- No solution found\n      else if j >= nums.size then\n        findIndices (i + 1) (i + 2) fuel -- Move to next i and reset j\n      else\n        if nums[i]! + nums[j]! == target then\n          #[i, j] -- Found solution\n        else\n          findIndices i (j + 1) fuel -- Try next j\n\n  findIndices 0 1 (nums.size * nums.size)\n\n@[reducible]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result: Array Nat) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  result.size = 2 ∧\n\n  result[0]! < nums.size ∧ result[1]! < nums.size ∧\n\n  result[0]! < result[1]! ∧\n\n  nums[result[0]!]! + nums[result[1]!]! = target\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_80", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires writing a Lean 4 method that finds the indices of two numbers in an array that add up to a target value. Given an array of integers and a target integer, the function should return the indices of the two numbers such that they add up to the target.\n\nYou may assume that each input has exactly one solution, and you may not use the same element twice.\n\n-----Input-----\nThe input consists of:\nnums: An array of integers.\ntarget: An integer representing the target sum.\n\n-----Output-----\nThe output is an array of two integers:\nReturns the indices of the two numbers in the array that add up to the target. The indices should be sorted.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size ≥ 2 ∧\n\n  (List.range nums.size).any (fun i =>\n    (List.range i).any (fun j => nums[i]! + nums[j]! = target)) ∧\n\n  ((List.range nums.size).flatMap (fun i =>\n    (List.range i).filter (fun j => nums[i]! + nums[j]! = target))).length = 1\n\ndef twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Array Nat :=\n  let rec findIndices (i : Nat) (j : Nat) (fuel : Nat) : Array Nat :=\n    match fuel with\n    | 0 => #[] -- Fuel exhausted, return empty array\n    | fuel+1 =>\n      if i >= nums.size then\n        #[] -- No solution found\n      else if j >= nums.size then\n        findIndices (i + 1) (i + 2) fuel -- Move to next i and reset j\n      else\n        if nums[i]! + nums[j]! == target then\n          #[i, j] -- Found solution\n        else\n          findIndices i (j + 1) fuel -- Try next j\n\n  findIndices 0 1 (nums.size * nums.size)\n\n@[reducible]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result: Array Nat) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  result.size = 2 ∧\n\n  result[0]! < nums.size ∧ result[1]! < nums.size ∧\n\n  result[0]! < result[1]! ∧\n\n  nums[result[0]!]! + nums[result[1]!]! = target\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_80"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement a Lean 4 function that, given a list of integers, removes all duplicates and returns the resulting list in ascending order.\n\n-----Input-----\nThe input consists of a single list of integers:\narr: A list of integers.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list containing the unique elements of the input, sorted in ascending order. The returned list must not contain any duplicates, and every element in the output must appear in the original input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :\n    uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef uniqueSorted_precond (arr : List Int) : Prop :=\n  True\n\ndef uniqueSorted (arr : List Int) (h_precond : uniqueSorted_precond (arr)) : List Int :=\n  let rec insert (x : Int) (sorted : List Int) : List Int :=\n  match sorted with\n  | [] =>\n    [x]\n  | head :: tail =>\n    if x <= head then\n      x :: head :: tail\n    else\n      head :: insert x tail\n\nlet rec insertionSort (xs : List Int) : List Int :=\n  match xs with\n  | [] =>\n    []\n  | h :: t =>\n    let sortedTail := insertionSort t\n    insert h sortedTail\n\nlet removeDups : List Int → List Int\n| xs =>\n  let rec aux (remaining : List Int) (seen : List Int) (acc : List Int) : List Int :=\n    match remaining with\n    | [] =>\n      acc.reverse\n    | h :: t =>\n      if h ∈ seen then\n        aux t seen acc\n      else\n        aux t (h :: seen) (h :: acc)\n  aux xs [] []\n\ninsertionSort (removeDups arr)\n\n@[reducible, simp]\ndef uniqueSorted_postcond (arr : List Int) (result: List Int) (h_precond : uniqueSorted_precond (arr)) : Prop :=\n  List.isPerm arr.eraseDups result ∧ List.Pairwise (· ≤ ·) result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :\n    uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_81", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nImplement a Lean 4 function that, given a list of integers, removes all duplicates and returns the resulting list in ascending order.\n\n-----Input-----\nThe input consists of a single list of integers:\narr: A list of integers.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list containing the unique elements of the input, sorted in ascending order. The returned list must not contain any duplicates, and every element in the output must appear in the original input list.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :\n    uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef uniqueSorted_precond (arr : List Int) : Prop :=\n  True\n\ndef uniqueSorted (arr : List Int) (h_precond : uniqueSorted_precond (arr)) : List Int :=\n  let rec insert (x : Int) (sorted : List Int) : List Int :=\n  match sorted with\n  | [] =>\n    [x]\n  | head :: tail =>\n    if x <= head then\n      x :: head :: tail\n    else\n      head :: insert x tail\n\nlet rec insertionSort (xs : List Int) : List Int :=\n  match xs with\n  | [] =>\n    []\n  | h :: t =>\n    let sortedTail := insertionSort t\n    insert h sortedTail\n\nlet removeDups : List Int → List Int\n| xs =>\n  let rec aux (remaining : List Int) (seen : List Int) (acc : List Int) : List Int :=\n    match remaining with\n    | [] =>\n      acc.reverse\n    | h :: t =>\n      if h ∈ seen then\n        aux t seen acc\n      else\n        aux t (h :: seen) (h :: acc)\n  aux xs [] []\n\ninsertionSort (removeDups arr)\n\n@[reducible, simp]\ndef uniqueSorted_postcond (arr : List Int) (result: List Int) (h_precond : uniqueSorted_precond (arr)) : Prop :=\n  List.isPerm arr.eraseDups result ∧ List.Pairwise (· ≤ ·) result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :\n    uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_81"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method of which given a number n and divisor d, it counts all the number that is smaller than\nn whose sum of digits is divisible by d. \n-----Input-----\nThe input consists of three Nat:\nn: Nat\nd:Nat where d > 0\n\n-----Output-----\nThe output is an Natural number:\nEnsure this match the count that satisfy the property.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem countSumDivisibleBy_spec_satisfied (n: Nat) (d: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) :\n    countSumDivisibleBy_postcond (n) (d) (countSumDivisibleBy (n) (d) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef sumOfDigits (x : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else go (n / 10) (acc + (n % 10))\n  go x 0\n\n@[reducible]\ndef countSumDivisibleBy_precond (n : Nat) (d : Nat) : Prop :=\n  d > 0\n\ndef isSumDivisibleBy (x : Nat) (d:Nat) : Bool :=\n  (sumOfDigits x) % d = 0\n\ndef countSumDivisibleBy (n : Nat) (d : Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) : Nat :=\n  let rec go (i acc : Nat) : Nat :=\n    match i with\n    | 0 => acc\n    | i'+1 =>\n      let acc' := if isSumDivisibleBy i' d then acc + 1 else acc\n      go i' acc'\n  go n 0\n\n@[reducible]\ndef countSumDivisibleBy_postcond (n : Nat) (d : Nat) (result: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) : Prop :=\n  (List.length (List.filter (fun x => x < n ∧ (sumOfDigits x) % d = 0) (List.range n))) - result = 0 ∧\n  result ≤ (List.length (List.filter (fun x => x < n ∧ (sumOfDigits x) % d = 0) (List.range n)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem countSumDivisibleBy_spec_satisfied (n: Nat) (d: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) :\n    countSumDivisibleBy_postcond (n) (d) (countSumDivisibleBy (n) (d) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_advanced_9", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method of which given a number n and divisor d, it counts all the number that is smaller than\nn whose sum of digits is divisible by d. \n-----Input-----\nThe input consists of three Nat:\nn: Nat\nd:Nat where d > 0\n\n-----Output-----\nThe output is an Natural number:\nEnsure this match the count that satisfy the property.\n\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem countSumDivisibleBy_spec_satisfied (n: Nat) (d: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) :\n    countSumDivisibleBy_postcond (n) (d) (countSumDivisibleBy (n) (d) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef sumOfDigits (x : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else go (n / 10) (acc + (n % 10))\n  go x 0\n\n@[reducible]\ndef countSumDivisibleBy_precond (n : Nat) (d : Nat) : Prop :=\n  d > 0\n\ndef isSumDivisibleBy (x : Nat) (d:Nat) : Bool :=\n  (sumOfDigits x) % d = 0\n\ndef countSumDivisibleBy (n : Nat) (d : Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) : Nat :=\n  let rec go (i acc : Nat) : Nat :=\n    match i with\n    | 0 => acc\n    | i'+1 =>\n      let acc' := if isSumDivisibleBy i' d then acc + 1 else acc\n      go i' acc'\n  go n 0\n\n@[reducible]\ndef countSumDivisibleBy_postcond (n : Nat) (d : Nat) (result: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) : Prop :=\n  (List.length (List.filter (fun x => x < n ∧ (sumOfDigits x) % d = 0) (List.range n))) - result = 0 ∧\n  result ≤ (List.length (List.filter (fun x => x < n ∧ (sumOfDigits x) % d = 0) (List.range n)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem countSumDivisibleBy_spec_satisfied (n: Nat) (d: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) :\n    countSumDivisibleBy_postcond (n) (d) (countSumDivisibleBy (n) (d) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_advanced_9"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether two given integers have opposite signs. In other words, the method should return true if one integer is positive and the other is negative. Note that zero is considered neither positive nor negative; therefore, if either integer is zero, the method should return false.\n\n-----Input-----\nThe input consists of two integers:\na: An integer.\nb: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if one of the integers is positive and the other is negative (i.e., they have opposite signs).\nReturns false if both integers are either non-negative or non-positive, or if one (or both) is zero.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef hasOppositeSign_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef hasOppositeSign (a : Int) (b : Int) (h_precond : hasOppositeSign_precond (a) (b)) : Bool :=\n  a * b < 0\n\n@[reducible, simp]\ndef hasOppositeSign_postcond (a : Int) (b : Int) (result: Bool) (h_precond : hasOppositeSign_precond (a) (b)) :=\n  (((a < 0 ∧ b > 0) ∨ (a > 0 ∧ b < 0)) → result) ∧\n  (¬((a < 0 ∧ b > 0) ∨ (a > 0 ∧ b < 0)) → ¬result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n  unfold hasOppositeSign hasOppositeSign_postcond\n  constructor\n\n  · intro h\n    cases h with\n    | inl h1 =>\n      simp\n      have ⟨ha, hb⟩ := h1\n      exact Int.mul_neg_of_neg_of_pos ha hb\n    | inr h2 =>\n      simp\n      have ⟨ha, hb⟩ := h2\n      rw [Int.mul_comm]\n      exact Int.mul_neg_of_neg_of_pos hb ha\n\n  · rw [Bool.decide_iff, mul_neg_iff]\n    simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_1", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether two given integers have opposite signs. In other words, the method should return true if one integer is positive and the other is negative. Note that zero is considered neither positive nor negative; therefore, if either integer is zero, the method should return false.\n\n-----Input-----\nThe input consists of two integers:\na: An integer.\nb: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if one of the integers is positive and the other is negative (i.e., they have opposite signs).\nReturns false if both integers are either non-negative or non-positive, or if one (or both) is zero.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef hasOppositeSign_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef hasOppositeSign (a : Int) (b : Int) (h_precond : hasOppositeSign_precond (a) (b)) : Bool :=\n  a * b < 0\n\n@[reducible, simp]\ndef hasOppositeSign_postcond (a : Int) (b : Int) (result: Bool) (h_precond : hasOppositeSign_precond (a) (b)) :=\n  (((a < 0 ∧ b > 0) ∨ (a > 0 ∧ b < 0)) → result) ∧\n  (¬((a < 0 ∧ b > 0) ∨ (a > 0 ∧ b < 0)) → ¬result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n```", "ground_truth": "theorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n  unfold hasOppositeSign hasOppositeSign_postcond\n  constructor\n\n  · intro h\n    cases h with\n    | inl h1 =>\n      simp\n      have ⟨ha, hb⟩ := h1\n      exact Int.mul_neg_of_neg_of_pos ha hb\n    | inr h2 =>\n      simp\n      have ⟨ha, hb⟩ := h2\n      rw [Int.mul_comm]\n      exact Int.mul_neg_of_neg_of_pos hb ha\n\n  · rw [Bool.decide_iff, mul_neg_iff]\n    simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_1"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines if a given integer is strictly greater than every element in a provided array. The method should return true only if the integer is larger than each element in the array; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\nn: An integer.\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the integer is greater than all elements in the array.\nReturns false if there is at least one element in the array that is greater than or equal to the integer.\n\n-----Note-----\nThe array is assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isGreater_precond (n : Int) (a : Array Int) : Prop :=\n  a.size > 0\n\ndef isGreater (n : Int) (a : Array Int) (h_precond : isGreater_precond (n) (a)) : Bool :=\n  a.all fun x => n > x\n\n@[reducible, simp]\ndef isGreater_postcond (n : Int) (a : Array Int) (result: Bool) (h_precond : isGreater_precond (n) (a)) :=\n  (∀ i, (hi : i < a.size) → n > a[i]) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n  unfold isGreater isGreater_postcond\n  simp [Array.all_eq]"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_10", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines if a given integer is strictly greater than every element in a provided array. The method should return true only if the integer is larger than each element in the array; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\nn: An integer.\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the integer is greater than all elements in the array.\nReturns false if there is at least one element in the array that is greater than or equal to the integer.\n\n-----Note-----\nThe array is assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isGreater_precond (n : Int) (a : Array Int) : Prop :=\n  a.size > 0\n\ndef isGreater (n : Int) (a : Array Int) (h_precond : isGreater_precond (n) (a)) : Bool :=\n  a.all fun x => n > x\n\n@[reducible, simp]\ndef isGreater_postcond (n : Int) (a : Array Int) (result: Bool) (h_precond : isGreater_precond (n) (a)) :=\n  (∀ i, (hi : i < a.size) → n > a[i]) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n```", "ground_truth": "theorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n  unfold isGreater isGreater_postcond\n  simp [Array.all_eq]", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_10"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining the triple of a given integer. The goal is to create a function that, for any integer provided as input, returns a value equal to three times that integer, including handling the case when the input is zero.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is an integer that represents three times the input integer.  \n• If x = 0, the output will be 0.  \n• Otherwise, the output will be computed as x + 2 * x, which is equivalent to 3 * x.\n\n-----Note-----  \nThere are no additional preconditions. It is assumed that x is a valid integer.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  if x = 0 then 0 else\n    let y := 2 * x\n    x + y\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  split_ifs with h₁\n  . rw [h₁]\n    simp\n  . simp\n    rw (occs := [1]) [←Int.one_mul x]\n    rw [←Int.add_mul]\n    simp +arith"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_100", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining the triple of a given integer. The goal is to create a function that, for any integer provided as input, returns a value equal to three times that integer, including handling the case when the input is zero.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is an integer that represents three times the input integer.  \n• If x = 0, the output will be 0.  \n• Otherwise, the output will be computed as x + 2 * x, which is equivalent to 3 * x.\n\n-----Note-----  \nThere are no additional preconditions. It is assumed that x is a valid integer.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  if x = 0 then 0 else\n    let y := 2 * x\n    x + y\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  split_ifs with h₁\n  . rw [h₁]\n    simp\n  . simp\n    rw (occs := [1]) [←Int.one_mul x]\n    rw [←Int.add_mul]\n    simp +arith", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_100"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves computing the triple of a given integer. The goal is to produce an output that is exactly three times the input value.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer representing the value to be tripled.\n\n-----Output-----  \nThe output is an integer that is three times the input value (i.e., 3 * x).\n\n-----Note-----  \nThe implementation uses a local variable to first compute double the input and then adds the original input to get the final result. The accompanying theorem asserts that the function satisfies the specification of computing 3 * x.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  let y := x * 2\n  y + x\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  simp\n  rw (occs := [2]) [←Int.mul_one x]\n  rw [←Int.mul_add]\n  simp +arith"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_101", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves computing the triple of a given integer. The goal is to produce an output that is exactly three times the input value.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer representing the value to be tripled.\n\n-----Output-----  \nThe output is an integer that is three times the input value (i.e., 3 * x).\n\n-----Note-----  \nThe implementation uses a local variable to first compute double the input and then adds the original input to get the final result. The accompanying theorem asserts that the function satisfies the specification of computing 3 * x.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  let y := x * 2\n  y + x\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  simp\n  rw (occs := [2]) [←Int.mul_one x]\n  rw [←Int.mul_add]\n  simp +arith", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_101"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves identifying the first occurrence of a pair of indices in an array of integers such that the sum of the corresponding elements equals the given target value. The focus is on determining the earliest valid pair (i, j), with 0 ≤ i < j < nums.size, where the sum of the two numbers equals the target, without considering any language-specific or implementation details.\n\n-----Input-----\nThe input consists of:\n• nums: An array of integers.\n• target: An integer representing the desired sum.\n\n-----Output-----\nThe output is a pair of natural numbers (i, j) that satisfy:\n• 0 ≤ i < j < nums.size.\n• nums[i] + nums[j] = target.\n• Any valid pair with indices preceding (i, j) does not yield the target sum, and no index between i and j forms a valid sum with nums[i].\n\n-----Note-----\nIt is assumed that the array has at least two elements and that there exists at least one valid pair whose sum is equal to the target.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size > 1 ∧ ¬ List.Pairwise (fun a b => a + b ≠ target) nums.toList\n\ndef twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : (Nat × Nat) :=\n  let n := nums.size\n  let rec outer (i : Nat) : Option (Nat × Nat) :=\n    if i < n - 1 then\n      let rec inner (j : Nat) : Option (Nat × Nat) :=\n        if j < n then\n          if nums[i]! + nums[j]! = target then\n            some (i, j)\n          else\n            inner (j + 1)\n        else\n          none\n      match inner (i + 1) with\n      | some pair => some pair\n      | none      => outer (i + 1)\n    else\n      none\n  match outer 0 with\n  | some pair => pair\n  | none      => panic \"twoSum: no solution found\"\n\n@[reducible, simp]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result: (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) :=\n  let (i, j) := result\n  i < j ∧ j < nums.size ∧ nums[i]! + nums[j]! = target ∧\n  List.Pairwise (fun a b => a + b ≠ target) (nums.toList.take i) ∧\n  List.all (nums.toList.take i) (fun a => List.all (nums.toList.drop i) (fun b => a + b ≠ target) ) ∧\n  List.all (nums.toList.drop (j + 1)) (fun a => a + nums[j]! ≠ target)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_102", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves identifying the first occurrence of a pair of indices in an array of integers such that the sum of the corresponding elements equals the given target value. The focus is on determining the earliest valid pair (i, j), with 0 ≤ i < j < nums.size, where the sum of the two numbers equals the target, without considering any language-specific or implementation details.\n\n-----Input-----\nThe input consists of:\n• nums: An array of integers.\n• target: An integer representing the desired sum.\n\n-----Output-----\nThe output is a pair of natural numbers (i, j) that satisfy:\n• 0 ≤ i < j < nums.size.\n• nums[i] + nums[j] = target.\n• Any valid pair with indices preceding (i, j) does not yield the target sum, and no index between i and j forms a valid sum with nums[i].\n\n-----Note-----\nIt is assumed that the array has at least two elements and that there exists at least one valid pair whose sum is equal to the target.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size > 1 ∧ ¬ List.Pairwise (fun a b => a + b ≠ target) nums.toList\n\ndef twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : (Nat × Nat) :=\n  let n := nums.size\n  let rec outer (i : Nat) : Option (Nat × Nat) :=\n    if i < n - 1 then\n      let rec inner (j : Nat) : Option (Nat × Nat) :=\n        if j < n then\n          if nums[i]! + nums[j]! = target then\n            some (i, j)\n          else\n            inner (j + 1)\n        else\n          none\n      match inner (i + 1) with\n      | some pair => some pair\n      | none      => outer (i + 1)\n    else\n      none\n  match outer 0 with\n  | some pair => pair\n  | none      => panic \"twoSum: no solution found\"\n\n@[reducible, simp]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result: (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) :=\n  let (i, j) := result\n  i < j ∧ j < nums.size ∧ nums[i]! + nums[j]! = target ∧\n  List.Pairwise (fun a b => a + b ≠ target) (nums.toList.take i) ∧\n  List.all (nums.toList.take i) (fun a => List.all (nums.toList.drop i) (fun b => a + b ≠ target) ) ∧\n  List.all (nums.toList.drop (j + 1)) (fun a => a + nums[j]! ≠ target)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_102"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves updating an array of integers by modifying two specific positions. Specifically, the element at index 4 should be increased by 3, and the element at index 7 should be changed to 516. The goal is to correctly update these positions while leaving the rest of the array unchanged. The description assumes that the array contains at least 8 elements.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers. The array must contain at least 8 elements.\n\n-----Output-----  \nThe output is an array of integers that meets the following criteria:  \n• The element at index 4 is updated to its original value plus 3.  \n• The element at index 7 is set to 516.  \n• All other elements in the array remain the same as in the input array.\n\n-----Note-----  \nIt is assumed that the input array has a size of at least 8 elements. Indices are 0-indexed.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem UpdateElements_spec_satisfied (a: Array Int) (h_precond : UpdateElements_precond (a)) :\n    UpdateElements_postcond (a) (UpdateElements (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef UpdateElements_precond (a : Array Int) : Prop :=\n  a.size ≥ 8\n\ndef UpdateElements (a : Array Int) (h_precond : UpdateElements_precond (a)) : Array Int :=\n  let a1 := a.set! 4 ((a[4]!) + 3)\n  let a2 := a1.set! 7 516\n  a2\n\n@[reducible, simp]\ndef UpdateElements_postcond (a : Array Int) (result: Array Int) (h_precond : UpdateElements_precond (a)) :=\n  result[4]! = (a[4]!) + 3 ∧\n  result[7]! = 516 ∧\n  (∀ i, i < a.size → i ≠ 4 → i ≠ 7 → result[i]! = a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem UpdateElements_spec_satisfied (a: Array Int) (h_precond : UpdateElements_precond (a)) :\n    UpdateElements_postcond (a) (UpdateElements (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_103", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves updating an array of integers by modifying two specific positions. Specifically, the element at index 4 should be increased by 3, and the element at index 7 should be changed to 516. The goal is to correctly update these positions while leaving the rest of the array unchanged. The description assumes that the array contains at least 8 elements.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers. The array must contain at least 8 elements.\n\n-----Output-----  \nThe output is an array of integers that meets the following criteria:  \n• The element at index 4 is updated to its original value plus 3.  \n• The element at index 7 is set to 516.  \n• All other elements in the array remain the same as in the input array.\n\n-----Note-----  \nIt is assumed that the input array has a size of at least 8 elements. Indices are 0-indexed.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem UpdateElements_spec_satisfied (a: Array Int) (h_precond : UpdateElements_precond (a)) :\n    UpdateElements_postcond (a) (UpdateElements (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef UpdateElements_precond (a : Array Int) : Prop :=\n  a.size ≥ 8\n\ndef UpdateElements (a : Array Int) (h_precond : UpdateElements_precond (a)) : Array Int :=\n  let a1 := a.set! 4 ((a[4]!) + 3)\n  let a2 := a1.set! 7 516\n  a2\n\n@[reducible, simp]\ndef UpdateElements_postcond (a : Array Int) (result: Array Int) (h_precond : UpdateElements_precond (a)) :=\n  result[4]! = (a[4]!) + 3 ∧\n  result[7]! = 516 ∧\n  (∀ i, i < a.size → i ≠ 4 → i ≠ 7 → result[i]! = a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem UpdateElements_spec_satisfied (a: Array Int) (h_precond : UpdateElements_precond (a)) :\n    UpdateElements_postcond (a) (UpdateElements (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_103"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves combining two maps by creating a new map that includes every key from both inputs. When a key is found in both maps, the value from the second map is used in the result.\n\n-----Input-----  \nThe input consists of:  \n• m1: A Map (represented as a list of key-value pairs) where each key is of type Int and each value is of type Int.  \n• m2: A Map (similarly represented) where keys may overlap with m1.\n\n-----Output-----  \nThe output is a Map that meets the following conditions:  \n• Every key present in m2 is present in the result.  \n• Every key present in m1 is also present in the result.  \n• For keys that appear in both maps, the resulting value is the one from m2.  \n• For keys that appear only in m1, the resulting value remains unchanged.  \n• No keys outside those present in m1 or m2 are included in the result.\n• The entries in the map should be sorted\n\n-----Note-----  \nIt is assumed that the Map structure ensures key uniqueness in the final result using BEq for key comparison.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem update_map_spec_satisfied (m1: Map Int Int) (m2: Map Int Int) (h_precond : update_map_precond (m1) (m2)) :\n    update_map_postcond (m1) (m2) (update_map (m1) (m2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\nstructure Map (K V : Type) [BEq K] [BEq V] where\n  entries : List (K × V)\nderiving Inhabited\n\ninstance  (K V : Type) [BEq K] [BEq V] : BEq (Map K V) where\n  beq m1 m2 := List.length m1.entries = List.length m2.entries ∧ List.beq m1.entries m2.entries\n\ndef empty {K V : Type} [BEq K] [BEq V] : Map K V := ⟨[]⟩\n\ndef insert {K V : Type} [BEq K] [BEq V] (m : Map K V) (k : K) (v : V) : Map K V :=\n  let entries := m.entries.filter (fun p => ¬(p.1 == k)) ++ [(k, v)]\n  ⟨entries⟩\n\n@[reducible, simp]\ndef update_map_precond (m1 : Map Int Int) (m2 : Map Int Int) : Prop :=\n  True\n\ndef update_map (m1 : Map Int Int) (m2 : Map Int Int) (h_precond : update_map_precond (m1) (m2)) : Map Int Int :=\n  let foldFn := fun (acc : Map Int Int) (entry : Int × Int) =>\n    insert acc entry.1 entry.2\n  let updated := m2.entries.foldl foldFn m1\n  ⟨updated.entries.mergeSort (fun a b => a.1 ≤ b.1)⟩\n\ndef find? {K V : Type} [BEq K] [BEq V] (m : Map K V) (k : K) : Option V :=\n  m.entries.find? (fun p => p.1 == k) |>.map (·.2)\n\n@[reducible, simp]\ndef update_map_postcond (m1 : Map Int Int) (m2 : Map Int Int) (result: Map Int Int) (h_precond : update_map_precond (m1) (m2)) : Prop :=\n  List.Pairwise (fun a b => a.1 ≤ b.1) result.entries ∧\n  m2.entries.all (fun x => find? result x.1 = some x.2) ∧\n  m1.entries.all (fun x =>\n    match find? m2 x.1 with\n    | some _ => true\n    | none => find? result x.1 = some x.2\n  ) ∧\n  result.entries.all (fun x =>\n    match find? m1 x.1 with\n    | some v => match find? m2 x.1 with\n      | some v' => x.2 = v'\n      | none => x.2 = v\n    | none => find? m2 x.1 = some x.2\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem update_map_spec_satisfied (m1: Map Int Int) (m2: Map Int Int) (h_precond : update_map_precond (m1) (m2)) :\n    update_map_postcond (m1) (m2) (update_map (m1) (m2) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_104", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves combining two maps by creating a new map that includes every key from both inputs. When a key is found in both maps, the value from the second map is used in the result.\n\n-----Input-----  \nThe input consists of:  \n• m1: A Map (represented as a list of key-value pairs) where each key is of type Int and each value is of type Int.  \n• m2: A Map (similarly represented) where keys may overlap with m1.\n\n-----Output-----  \nThe output is a Map that meets the following conditions:  \n• Every key present in m2 is present in the result.  \n• Every key present in m1 is also present in the result.  \n• For keys that appear in both maps, the resulting value is the one from m2.  \n• For keys that appear only in m1, the resulting value remains unchanged.  \n• No keys outside those present in m1 or m2 are included in the result.\n• The entries in the map should be sorted\n\n-----Note-----  \nIt is assumed that the Map structure ensures key uniqueness in the final result using BEq for key comparison.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem update_map_spec_satisfied (m1: Map Int Int) (m2: Map Int Int) (h_precond : update_map_precond (m1) (m2)) :\n    update_map_postcond (m1) (m2) (update_map (m1) (m2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\nstructure Map (K V : Type) [BEq K] [BEq V] where\n  entries : List (K × V)\nderiving Inhabited\n\ninstance  (K V : Type) [BEq K] [BEq V] : BEq (Map K V) where\n  beq m1 m2 := List.length m1.entries = List.length m2.entries ∧ List.beq m1.entries m2.entries\n\ndef empty {K V : Type} [BEq K] [BEq V] : Map K V := ⟨[]⟩\n\ndef insert {K V : Type} [BEq K] [BEq V] (m : Map K V) (k : K) (v : V) : Map K V :=\n  let entries := m.entries.filter (fun p => ¬(p.1 == k)) ++ [(k, v)]\n  ⟨entries⟩\n\n@[reducible, simp]\ndef update_map_precond (m1 : Map Int Int) (m2 : Map Int Int) : Prop :=\n  True\n\ndef update_map (m1 : Map Int Int) (m2 : Map Int Int) (h_precond : update_map_precond (m1) (m2)) : Map Int Int :=\n  let foldFn := fun (acc : Map Int Int) (entry : Int × Int) =>\n    insert acc entry.1 entry.2\n  let updated := m2.entries.foldl foldFn m1\n  ⟨updated.entries.mergeSort (fun a b => a.1 ≤ b.1)⟩\n\ndef find? {K V : Type} [BEq K] [BEq V] (m : Map K V) (k : K) : Option V :=\n  m.entries.find? (fun p => p.1 == k) |>.map (·.2)\n\n@[reducible, simp]\ndef update_map_postcond (m1 : Map Int Int) (m2 : Map Int Int) (result: Map Int Int) (h_precond : update_map_precond (m1) (m2)) : Prop :=\n  List.Pairwise (fun a b => a.1 ≤ b.1) result.entries ∧\n  m2.entries.all (fun x => find? result x.1 = some x.2) ∧\n  m1.entries.all (fun x =>\n    match find? m2 x.1 with\n    | some _ => true\n    | none => find? result x.1 = some x.2\n  ) ∧\n  result.entries.all (fun x =>\n    match find? m1 x.1 with\n    | some v => match find? m2 x.1 with\n      | some v' => x.2 = v'\n      | none => x.2 = v\n    | none => find? m2 x.1 = some x.2\n  )\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem update_map_spec_satisfied (m1: Map Int Int) (m2: Map Int Int) (h_precond : update_map_precond (m1) (m2)) :\n    update_map_postcond (m1) (m2) (update_map (m1) (m2) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_104"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves computing the element-wise product of two integer arrays. For each position in the arrays, the corresponding numbers are multiplied together. If an element is missing in one of the arrays at a given index, the missing value is treated as 0. When both arrays provide values for every index, the resulting array will contain the product of the two numbers at each corresponding index.\n\n-----Input-----\nThe input consists of two arrays:\n• a: An array of integers.\n• b: An array of integers (should be of equal length to a for the specification to hold).\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input arrays.\n• For each index i, the output array contains the product a[i] * b[i].\n• In cases where one of the arrays might be shorter, missing elements default to 0 during multiplication.\n\n-----Note-----\nIt is assumed that the arrays are of equal length for the theorem specification, although the implementation defaults missing indices to 0.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem arrayProduct_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayProduct_precond (a) (b)) :\n    arrayProduct_postcond (a) (b) (arrayProduct (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef arrayProduct_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size\n\ndef loop (a b : Array Int) (len : Nat) : Nat → Array Int → Array Int\n  | i, c =>\n    if i < len then\n      let a_val := if i < a.size then a[i]! else 0\n      let b_val := if i < b.size then b[i]! else 0\n      let new_c := Array.set! c i (a_val * b_val)\n      loop a b len (i+1) new_c\n    else c\n\ndef arrayProduct (a : Array Int) (b : Array Int) (h_precond : arrayProduct_precond (a) (b)) : Array Int :=\n  let len := a.size\n  let c := Array.mkArray len 0\n  loop a b len 0 c\n\n@[reducible, simp]\ndef arrayProduct_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arrayProduct_precond (a) (b)) :=\n  (result.size = a.size) ∧ (∀ i, i < a.size → a[i]! * b[i]! = result[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem arrayProduct_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayProduct_precond (a) (b)) :\n    arrayProduct_postcond (a) (b) (arrayProduct (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_105", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves computing the element-wise product of two integer arrays. For each position in the arrays, the corresponding numbers are multiplied together. If an element is missing in one of the arrays at a given index, the missing value is treated as 0. When both arrays provide values for every index, the resulting array will contain the product of the two numbers at each corresponding index.\n\n-----Input-----\nThe input consists of two arrays:\n• a: An array of integers.\n• b: An array of integers (should be of equal length to a for the specification to hold).\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input arrays.\n• For each index i, the output array contains the product a[i] * b[i].\n• In cases where one of the arrays might be shorter, missing elements default to 0 during multiplication.\n\n-----Note-----\nIt is assumed that the arrays are of equal length for the theorem specification, although the implementation defaults missing indices to 0.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem arrayProduct_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayProduct_precond (a) (b)) :\n    arrayProduct_postcond (a) (b) (arrayProduct (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef arrayProduct_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size\n\ndef loop (a b : Array Int) (len : Nat) : Nat → Array Int → Array Int\n  | i, c =>\n    if i < len then\n      let a_val := if i < a.size then a[i]! else 0\n      let b_val := if i < b.size then b[i]! else 0\n      let new_c := Array.set! c i (a_val * b_val)\n      loop a b len (i+1) new_c\n    else c\n\ndef arrayProduct (a : Array Int) (b : Array Int) (h_precond : arrayProduct_precond (a) (b)) : Array Int :=\n  let len := a.size\n  let c := Array.mkArray len 0\n  loop a b len 0 c\n\n@[reducible, simp]\ndef arrayProduct_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arrayProduct_precond (a) (b)) :=\n  (result.size = a.size) ∧ (∀ i, i < a.size → a[i]! * b[i]! = result[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem arrayProduct_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayProduct_precond (a) (b)) :\n    arrayProduct_postcond (a) (b) (arrayProduct (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_105"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to compute the element-wise sum of two integer arrays. The result should be a new array where each element is the sum of the corresponding elements from the two input arrays. The problem assumes that both arrays have the same length.\n\n-----Input-----  \nThe input consists of two parameters:  \n• a: An array of integers.  \n• b: An array of integers.  \nNote: Both arrays must have the same length.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same size as the input arrays.  \n• Contains elements where each element at index i is computed as a[i]! + b[i]! from the input arrays.\n\n-----Note-----  \nIt is assumed that the two input arrays have equal lengths.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem arraySum_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arraySum_precond (a) (b)) :\n    arraySum_postcond (a) (b) (arraySum (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef arraySum_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size\n\ndef arraySum (a : Array Int) (b : Array Int) (h_precond : arraySum_precond (a) (b)) : Array Int :=\n  if a.size ≠ b.size then\n    panic! \"Array lengths mismatch\"\n  else\n    let n := a.size;\n    let c := Array.mkArray n 0;\n    let rec loop (i : Nat) (c : Array Int) : Array Int :=\n      if i < n then\n        let c' := c.set! i (a[i]! + b[i]!);\n        loop (i + 1) c'\n      else c;\n    loop 0 c\n\n@[reducible, simp]\ndef arraySum_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arraySum_precond (a) (b)) :=\n  (result.size = a.size) ∧ (∀ i : Nat, i < a.size → a[i]! + b[i]! = result[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem arraySum_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arraySum_precond (a) (b)) :\n    arraySum_postcond (a) (b) (arraySum (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_106", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to compute the element-wise sum of two integer arrays. The result should be a new array where each element is the sum of the corresponding elements from the two input arrays. The problem assumes that both arrays have the same length.\n\n-----Input-----  \nThe input consists of two parameters:  \n• a: An array of integers.  \n• b: An array of integers.  \nNote: Both arrays must have the same length.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same size as the input arrays.  \n• Contains elements where each element at index i is computed as a[i]! + b[i]! from the input arrays.\n\n-----Note-----  \nIt is assumed that the two input arrays have equal lengths.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem arraySum_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arraySum_precond (a) (b)) :\n    arraySum_postcond (a) (b) (arraySum (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef arraySum_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size\n\ndef arraySum (a : Array Int) (b : Array Int) (h_precond : arraySum_precond (a) (b)) : Array Int :=\n  if a.size ≠ b.size then\n    panic! \"Array lengths mismatch\"\n  else\n    let n := a.size;\n    let c := Array.mkArray n 0;\n    let rec loop (i : Nat) (c : Array Int) : Array Int :=\n      if i < n then\n        let c' := c.set! i (a[i]! + b[i]!);\n        loop (i + 1) c'\n      else c;\n    loop 0 c\n\n@[reducible, simp]\ndef arraySum_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arraySum_precond (a) (b)) :=\n  (result.size = a.size) ∧ (∀ i : Nat, i < a.size → a[i]! + b[i]! = result[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem arraySum_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arraySum_precond (a) (b)) :\n    arraySum_postcond (a) (b) (arraySum (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_106"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves computing the average of two integers. The objective is to determine a value that closely approximates the true arithmetic mean when using integer division, ensuring that the result reflects the necessary rounding behavior.\n\n-----Input-----  \nThe input consists of:  \n• a: An integer.  \n• b: An integer.\n\n-----Output-----  \nThe output is an integer representing the computed average of a and b using integer division.\n\n-----Note-----  \nThe specification requires that the computed average satisfies the condition that 2 * avg is between (a + b - 1) and (a + b + 1), ensuring that the result meets the expected rounding boundaries.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ComputeAvg_spec_satisfied (a: Int) (b: Int) (h_precond : ComputeAvg_precond (a) (b)) :\n    ComputeAvg_postcond (a) (b) (ComputeAvg (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef ComputeAvg_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef ComputeAvg (a : Int) (b : Int) (h_precond : ComputeAvg_precond (a) (b)) : Int :=\n  (a + b) / 2\n\n@[reducible, simp]\ndef ComputeAvg_postcond (a : Int) (b : Int) (result: Int) (h_precond : ComputeAvg_precond (a) (b)) :=\n  2 * result = a + b - ((a + b) % 2)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ComputeAvg_spec_satisfied (a: Int) (b: Int) (h_precond : ComputeAvg_precond (a) (b)) :\n    ComputeAvg_postcond (a) (b) (ComputeAvg (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_107", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves computing the average of two integers. The objective is to determine a value that closely approximates the true arithmetic mean when using integer division, ensuring that the result reflects the necessary rounding behavior.\n\n-----Input-----  \nThe input consists of:  \n• a: An integer.  \n• b: An integer.\n\n-----Output-----  \nThe output is an integer representing the computed average of a and b using integer division.\n\n-----Note-----  \nThe specification requires that the computed average satisfies the condition that 2 * avg is between (a + b - 1) and (a + b + 1), ensuring that the result meets the expected rounding boundaries.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ComputeAvg_spec_satisfied (a: Int) (b: Int) (h_precond : ComputeAvg_precond (a) (b)) :\n    ComputeAvg_postcond (a) (b) (ComputeAvg (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef ComputeAvg_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef ComputeAvg (a : Int) (b : Int) (h_precond : ComputeAvg_precond (a) (b)) : Int :=\n  (a + b) / 2\n\n@[reducible, simp]\ndef ComputeAvg_postcond (a : Int) (b : Int) (result: Int) (h_precond : ComputeAvg_precond (a) (b)) :=\n  2 * result = a + b - ((a + b) % 2)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ComputeAvg_spec_satisfied (a: Int) (b: Int) (h_precond : ComputeAvg_precond (a) (b)) :\n    ComputeAvg_postcond (a) (b) (ComputeAvg (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_107"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThe problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.\n\n-----Input-----\nThe input consists of:\n• operations: A list of integers representing sequential operations.\n\n-----Output-----\nThe output is a tuple consisting of:\n• An array of integers representing the partial sums. The array’s size is one more than the number of operations, starting with 0 and where for each index i such that 0 ≤ i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].\n• A boolean value that is true if there exists an index i (with 1 ≤ i ≤ operations.length) such that the i-th partial sum is negative, and false otherwise.\n\n-----Note-----\nThe function should also correctly handle an empty list of operations.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem below_zero_spec_satisfied (operations: List Int) (h_precond : below_zero_precond (operations)) :\n    below_zero_postcond (operations) (below_zero (operations) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef below_zero_precond (operations : List Int) : Prop :=\n  True\n\ndef buildS (operations : List Int) : Array Int :=\n  let sList := operations.foldl\n    (fun (acc : List Int) (op : Int) =>\n      let last := acc.getLast? |>.getD 0\n      acc.append [last + op])\n    [0]\n  Array.mk sList\n\ndef below_zero (operations : List Int) (h_precond : below_zero_precond (operations)) : (Array Int × Bool) :=\n  let s := buildS operations\n  let rec check_negative (lst : List Int) : Bool :=\n    match lst with\n    | []      => false\n    | x :: xs => if x < 0 then true else check_negative xs\n  let result := check_negative (s.toList)\n  (s, result)\n\n@[reducible, simp]\ndef below_zero_postcond (operations : List Int) (result: (Array Int × Bool)) (h_precond : below_zero_precond (operations)) :=\n  let s := result.1\n  let result := result.2\n  s.size = operations.length + 1 ∧\n  s[0]? = some 0 ∧\n  (List.range (s.size - 1)).all (fun i => s[i + 1]? = some (s[i]! + operations[i]!)) ∧\n  ((result = true) → ((List.range (operations.length)).any (fun i => s[i + 1]! < 0))) ∧\n  ((result = false) → s.all (· ≥ 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem below_zero_spec_satisfied (operations: List Int) (h_precond : below_zero_precond (operations)) :\n    below_zero_postcond (operations) (below_zero (operations) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_108", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThe problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.\n\n-----Input-----\nThe input consists of:\n• operations: A list of integers representing sequential operations.\n\n-----Output-----\nThe output is a tuple consisting of:\n• An array of integers representing the partial sums. The array’s size is one more than the number of operations, starting with 0 and where for each index i such that 0 ≤ i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].\n• A boolean value that is true if there exists an index i (with 1 ≤ i ≤ operations.length) such that the i-th partial sum is negative, and false otherwise.\n\n-----Note-----\nThe function should also correctly handle an empty list of operations.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem below_zero_spec_satisfied (operations: List Int) (h_precond : below_zero_precond (operations)) :\n    below_zero_postcond (operations) (below_zero (operations) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef below_zero_precond (operations : List Int) : Prop :=\n  True\n\ndef buildS (operations : List Int) : Array Int :=\n  let sList := operations.foldl\n    (fun (acc : List Int) (op : Int) =>\n      let last := acc.getLast? |>.getD 0\n      acc.append [last + op])\n    [0]\n  Array.mk sList\n\ndef below_zero (operations : List Int) (h_precond : below_zero_precond (operations)) : (Array Int × Bool) :=\n  let s := buildS operations\n  let rec check_negative (lst : List Int) : Bool :=\n    match lst with\n    | []      => false\n    | x :: xs => if x < 0 then true else check_negative xs\n  let result := check_negative (s.toList)\n  (s, result)\n\n@[reducible, simp]\ndef below_zero_postcond (operations : List Int) (result: (Array Int × Bool)) (h_precond : below_zero_precond (operations)) :=\n  let s := result.1\n  let result := result.2\n  s.size = operations.length + 1 ∧\n  s[0]? = some 0 ∧\n  (List.range (s.size - 1)).all (fun i => s[i + 1]? = some (s[i]! + operations[i]!)) ∧\n  ((result = true) → ((List.range (operations.length)).any (fun i => s[i + 1]! < 0))) ∧\n  ((result = false) → s.all (· ≥ 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem below_zero_spec_satisfied (operations: List Int) (h_precond : below_zero_precond (operations)) :\n    below_zero_postcond (operations) (below_zero (operations) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_108"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that extracts the last digit of a given non-negative integer. The method should return the last digit, which is obtained by computing the remainder when the number is divided by 10. The result must always be between 0 and 9.\n\n-----Input-----  \nThe input consists of a single value:  \nn: A non-negative integer.\n\n-----Output-----  \nThe output is an integer:  \nReturns the last digit of the input number, ensuring that the digit lies within the range 0 to 9.\n\n-----Note-----  \nIt is assumed that the input number n is non-negative.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef lastDigit_precond (n : Nat) : Prop :=\n  True\n\ndef lastDigit (n : Nat) (h_precond : lastDigit_precond (n)) : Nat :=\n  n % 10\n\n@[reducible, simp]\ndef lastDigit_postcond (n : Nat) (result: Nat) (h_precond : lastDigit_precond (n)) :=\n  (0 ≤ result ∧ result < 10) ∧\n  (n % 10 - result = 0 ∧ result - n % 10 = 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n  unfold lastDigit lastDigit_postcond\n  constructor\n  · constructor\n    · simp\n    · exact Nat.mod_lt n (by decide)\n  · simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_11", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that extracts the last digit of a given non-negative integer. The method should return the last digit, which is obtained by computing the remainder when the number is divided by 10. The result must always be between 0 and 9.\n\n-----Input-----  \nThe input consists of a single value:  \nn: A non-negative integer.\n\n-----Output-----  \nThe output is an integer:  \nReturns the last digit of the input number, ensuring that the digit lies within the range 0 to 9.\n\n-----Note-----  \nIt is assumed that the input number n is non-negative.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef lastDigit_precond (n : Nat) : Prop :=\n  True\n\ndef lastDigit (n : Nat) (h_precond : lastDigit_precond (n)) : Nat :=\n  n % 10\n\n@[reducible, simp]\ndef lastDigit_postcond (n : Nat) (result: Nat) (h_precond : lastDigit_precond (n)) :=\n  (0 ≤ result ∧ result < 10) ∧\n  (n % 10 - result = 0 ∧ result - n % 10 = 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n```", "ground_truth": "theorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n  unfold lastDigit lastDigit_postcond\n  constructor\n  · constructor\n    · simp\n    · exact Nat.mod_lt n (by decide)\n  · simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_11"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the surface area of a cube based on the length of one of its edges. The method should compute the surface area using the standard formula for a cube.\n\n-----Input-----\nThe input consists of:\nsize: An natural number representing the length of an edge of the cube.\n\n-----Output-----\nThe output is an natural number:\nReturns the surface area of the cube.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef cubeSurfaceArea_precond (size : Nat) : Prop :=\n  True\n\ndef cubeSurfaceArea (size : Nat) (h_precond : cubeSurfaceArea_precond (size)) : Nat :=\n  6 * size * size\n\n@[reducible, simp]\ndef cubeSurfaceArea_postcond (size : Nat) (result: Nat) (h_precond : cubeSurfaceArea_precond (size)) :=\n  result - 6 * size * size = 0 ∧ 6 * size * size - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n  unfold cubeSurfaceArea cubeSurfaceArea_postcond\n  simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_12", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the surface area of a cube based on the length of one of its edges. The method should compute the surface area using the standard formula for a cube.\n\n-----Input-----\nThe input consists of:\nsize: An natural number representing the length of an edge of the cube.\n\n-----Output-----\nThe output is an natural number:\nReturns the surface area of the cube.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef cubeSurfaceArea_precond (size : Nat) : Prop :=\n  True\n\ndef cubeSurfaceArea (size : Nat) (h_precond : cubeSurfaceArea_precond (size)) : Nat :=\n  6 * size * size\n\n@[reducible, simp]\ndef cubeSurfaceArea_postcond (size : Nat) (result: Nat) (h_precond : cubeSurfaceArea_precond (size)) :=\n  result - 6 * size * size = 0 ∧ 6 * size * size - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n```", "ground_truth": "theorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n  unfold cubeSurfaceArea cubeSurfaceArea_postcond\n  simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_12"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that transforms an array of integers by replacing every element with its cube. In other words, for each element in the input array, the output array should contain the result of multiplying that element by itself three times.\n\n-----Input-----\nThe input consists of:\na: An array of integers (which may be empty or non-empty).\n\n-----Output-----\nThe output is an array of integers:\nReturns an array with the same length as the input, where each element is the cube of the corresponding element in the input array.\n\n-----Note-----\nThere are no additional preconditions; the method should work correctly for any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef cubeElements_precond (a : Array Int) : Prop :=\n  True\n\ndef cubeElements (a : Array Int) (h_precond : cubeElements_precond (a)) : Array Int :=\n  a.map (fun x => x * x * x)\n\n@[reducible, simp]\ndef cubeElements_postcond (a : Array Int) (result: Array Int) (h_precond : cubeElements_precond (a)) :=\n  (result.size = a.size) ∧\n  (∀ i, i < a.size → result[i]! = a[i]! * a[i]! * a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n  unfold cubeElements cubeElements_postcond\n  simp_all\n  intro i hi\n  have h_maplen : (Array.map (fun x => x * x * x) a).size = a.size := by\n    apply Array.size_map\n  have h1 : (Array.map (fun x => x * x * x) a)[i] = (fun x => x * x * x) a[i] := by\n    apply Array.getElem_map\n  have h_eq : (Array.map (fun x => x * x * x) a)[i] = (Array.map (fun x => x * x * x) a)[i]! := by\n    have hi' : i < (Array.map (fun x => x * x * x) a).size := by\n      simp only [hi, h_maplen]\n    rw [Array.getElem!_eq_getD]\n    simp [hi', hi]\n  rw [← h_eq]\n  simp only [h1]\n  have h_eq' : a[i] = a[i]! := by\n    have hi_a : i < a.size := by\n      simp only [hi]\n    rw [Array.getElem!_eq_getD]\n    simp [hi_a]\n  simp only [h_eq']"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_13", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that transforms an array of integers by replacing every element with its cube. In other words, for each element in the input array, the output array should contain the result of multiplying that element by itself three times.\n\n-----Input-----\nThe input consists of:\na: An array of integers (which may be empty or non-empty).\n\n-----Output-----\nThe output is an array of integers:\nReturns an array with the same length as the input, where each element is the cube of the corresponding element in the input array.\n\n-----Note-----\nThere are no additional preconditions; the method should work correctly for any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef cubeElements_precond (a : Array Int) : Prop :=\n  True\n\ndef cubeElements (a : Array Int) (h_precond : cubeElements_precond (a)) : Array Int :=\n  a.map (fun x => x * x * x)\n\n@[reducible, simp]\ndef cubeElements_postcond (a : Array Int) (result: Array Int) (h_precond : cubeElements_precond (a)) :=\n  (result.size = a.size) ∧\n  (∀ i, i < a.size → result[i]! = a[i]! * a[i]! * a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n```", "ground_truth": "theorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n  unfold cubeElements cubeElements_postcond\n  simp_all\n  intro i hi\n  have h_maplen : (Array.map (fun x => x * x * x) a).size = a.size := by\n    apply Array.size_map\n  have h1 : (Array.map (fun x => x * x * x) a)[i] = (fun x => x * x * x) a[i] := by\n    apply Array.getElem_map\n  have h_eq : (Array.map (fun x => x * x * x) a)[i] = (Array.map (fun x => x * x * x) a)[i]! := by\n    have hi' : i < (Array.map (fun x => x * x * x) a).size := by\n      simp only [hi, h_maplen]\n    rw [Array.getElem!_eq_getD]\n    simp [hi', hi]\n  rw [← h_eq]\n  simp only [h1]\n  have h_eq' : a[i] = a[i]! := by\n    have hi_a : i < a.size := by\n      simp only [hi]\n    rw [Array.getElem!_eq_getD]\n    simp [hi_a]\n  simp only [h_eq']", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_13"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given string contains the character 'z' or 'Z'. The method should return true if the string includes either the lowercase or uppercase letter 'z', and false otherwise.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input string contains the character 'z' or 'Z'.\nReturns false if the input string does not contain the character 'z' or 'Z'.\n\n-----Note-----\nThere are no preconditions; the method will always work as strings and sequences are considered non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef containsZ_precond (s : String) : Prop :=\n  True\n\ndef containsZ (s : String) (h_precond : containsZ_precond (s)) : Bool :=\n  s.toList.any fun c => c = 'z' || c = 'Z'\n\n@[reducible, simp]\ndef containsZ_postcond (s : String) (result: Bool) (h_precond : containsZ_precond (s)) :=\n  let cs := s.toList\n  (∃ x, x ∈ cs ∧ (x = 'z' ∨ x = 'Z')) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n  unfold containsZ containsZ_postcond\n  simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_14", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given string contains the character 'z' or 'Z'. The method should return true if the string includes either the lowercase or uppercase letter 'z', and false otherwise.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input string contains the character 'z' or 'Z'.\nReturns false if the input string does not contain the character 'z' or 'Z'.\n\n-----Note-----\nThere are no preconditions; the method will always work as strings and sequences are considered non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef containsZ_precond (s : String) : Prop :=\n  True\n\ndef containsZ (s : String) (h_precond : containsZ_precond (s)) : Bool :=\n  s.toList.any fun c => c = 'z' || c = 'Z'\n\n@[reducible, simp]\ndef containsZ_postcond (s : String) (result: Bool) (h_precond : containsZ_precond (s)) :=\n  let cs := s.toList\n  (∃ x, x ∈ cs ∧ (x = 'z' ∨ x = 'Z')) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n```", "ground_truth": "theorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n  unfold containsZ containsZ_postcond\n  simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_14"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers (the array may be empty or non-empty).\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one index where an element plus one equals the following element.\nReturns false if the array does not contain any consecutive numbers.\n\n-----Note-----\nThere are no additional preconditions; the method will function correctly regardless of the array's size.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef containsConsecutiveNumbers_precond (a : Array Int) : Prop :=\n  True\n\ndef containsConsecutiveNumbers (a : Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) : Bool :=\n  if a.size ≤ 1 then\n    false\n  else\n    let withIndices := a.mapIdx (fun i x => (i, x))\n    withIndices.any (fun (i, x) =>\n      i < a.size - 1 && x + 1 == a[i+1]!)\n\n@[reducible, simp]\ndef containsConsecutiveNumbers_postcond (a : Array Int) (result: Bool) (h_precond : containsConsecutiveNumbers_precond (a)) :=\n  (∃ i, i < a.size - 1 ∧ a[i]! + 1 = a[i + 1]!) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n  unfold containsConsecutiveNumbers containsConsecutiveNumbers_postcond\n  constructor\n  · simp_all\n    intro i hi hconsec\n    have hi' : 1 + i < a.size := by\n        rw [Nat.add_comm]\n        exact Nat.add_lt_of_lt_sub hi\n    have hi'' : i < a.size := by\n      have : i < 1 + i := by\n        simp [Nat.lt_add_of_pos_left]\n      exact Nat.lt_trans this hi'\n    constructor\n    · exact Nat.lt_of_add_right_lt hi'\n    · apply Array.any_iff_exists.mpr\n      simp\n      exists i\n      simp [hi, hi'']\n      have : a[i]! = a[i] := by\n        exact getElem!_pos a i hi''\n      rw [←this]\n      exact hconsec\n  · simp\n    intro ha h\n    have h' := Array.any_iff_exists.mp h\n    simp at h'\n    rcases h' with ⟨i, hi, ⟨hi', hconsec⟩⟩\n    have : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    exists i\n    rw [this]\n    simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_15", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers (the array may be empty or non-empty).\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one index where an element plus one equals the following element.\nReturns false if the array does not contain any consecutive numbers.\n\n-----Note-----\nThere are no additional preconditions; the method will function correctly regardless of the array's size.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef containsConsecutiveNumbers_precond (a : Array Int) : Prop :=\n  True\n\ndef containsConsecutiveNumbers (a : Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) : Bool :=\n  if a.size ≤ 1 then\n    false\n  else\n    let withIndices := a.mapIdx (fun i x => (i, x))\n    withIndices.any (fun (i, x) =>\n      i < a.size - 1 && x + 1 == a[i+1]!)\n\n@[reducible, simp]\ndef containsConsecutiveNumbers_postcond (a : Array Int) (result: Bool) (h_precond : containsConsecutiveNumbers_precond (a)) :=\n  (∃ i, i < a.size - 1 ∧ a[i]! + 1 = a[i + 1]!) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n```", "ground_truth": "theorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n  unfold containsConsecutiveNumbers containsConsecutiveNumbers_postcond\n  constructor\n  · simp_all\n    intro i hi hconsec\n    have hi' : 1 + i < a.size := by\n        rw [Nat.add_comm]\n        exact Nat.add_lt_of_lt_sub hi\n    have hi'' : i < a.size := by\n      have : i < 1 + i := by\n        simp [Nat.lt_add_of_pos_left]\n      exact Nat.lt_trans this hi'\n    constructor\n    · exact Nat.lt_of_add_right_lt hi'\n    · apply Array.any_iff_exists.mpr\n      simp\n      exists i\n      simp [hi, hi'']\n      have : a[i]! = a[i] := by\n        exact getElem!_pos a i hi''\n      rw [←this]\n      exact hconsec\n  · simp\n    intro ha h\n    have h' := Array.any_iff_exists.mp h\n    simp at h'\n    rcases h' with ⟨i, hi, ⟨hi', hconsec⟩⟩\n    have : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    exists i\n    rw [this]\n    simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_15"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that replaces every occurrence of a specified character within a string with a new character. The output should be a new string that maintains the same length as the input string, with all instances of the designated character replaced by the given substitute, and all other characters preserved unchanged.\n\n-----Input-----\nThe input consists of:\ns: A string in which the replacement will occur.\noldChar: The character within the string that needs to be replaced.\nnewChar: The character that will substitute for every occurrence of oldChar.\n\n-----Output-----\nThe output is a string that meets the following:\n- It has the same length as the input string.\n- All occurrences of oldChar in the input string are replaced with newChar.\n- All characters other than oldChar remain unchanged.\n\n-----Note-----\nThere are no preconditions; the method will always work. It is assumed that the input string is valid and non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef replaceChars_precond (s : String) (oldChar : Char) (newChar : Char) : Prop :=\n  True\n\ndef replaceChars (s : String) (oldChar : Char) (newChar : Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if c = oldChar then newChar else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef replaceChars_postcond (s : String) (oldChar : Char) (newChar : Char) (result: String) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length ∧\n  (∀ i, i < cs.length →\n    (cs[i]! = oldChar → cs'[i]! = newChar) ∧\n    (cs[i]! ≠ oldChar → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n  unfold replaceChars replaceChars_postcond\n  constructor\n  · -- First part: length is preserved\n    simp [String.length]\n  · -- Second part: character replacement specification\n    simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_16", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that replaces every occurrence of a specified character within a string with a new character. The output should be a new string that maintains the same length as the input string, with all instances of the designated character replaced by the given substitute, and all other characters preserved unchanged.\n\n-----Input-----\nThe input consists of:\ns: A string in which the replacement will occur.\noldChar: The character within the string that needs to be replaced.\nnewChar: The character that will substitute for every occurrence of oldChar.\n\n-----Output-----\nThe output is a string that meets the following:\n- It has the same length as the input string.\n- All occurrences of oldChar in the input string are replaced with newChar.\n- All characters other than oldChar remain unchanged.\n\n-----Note-----\nThere are no preconditions; the method will always work. It is assumed that the input string is valid and non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef replaceChars_precond (s : String) (oldChar : Char) (newChar : Char) : Prop :=\n  True\n\ndef replaceChars (s : String) (oldChar : Char) (newChar : Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if c = oldChar then newChar else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef replaceChars_postcond (s : String) (oldChar : Char) (newChar : Char) (result: String) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length ∧\n  (∀ i, i < cs.length →\n    (cs[i]! = oldChar → cs'[i]! = newChar) ∧\n    (cs[i]! ≠ oldChar → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n```", "ground_truth": "theorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n  unfold replaceChars replaceChars_postcond\n  constructor\n  · -- First part: length is preserved\n    simp [String.length]\n  · -- Second part: character replacement specification\n    simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_16"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string that may contain both uppercase and lowercase characters.\n\n-----Output-----\nThe output is a string:\nReturns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isUpperCase (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\ndef shift32 (c : Char) : Char :=\n  Char.ofNat (c.toNat + 32)\n\n@[reducible, simp]\ndef toLowercase_precond (s : String) : Prop :=\n  True\n\ndef toLowercase (s : String) (h_precond : toLowercase_precond (s)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isUpperCase c then shift32 c else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef toLowercase_postcond (s : String) (result: String) (h_precond : toLowercase_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) ∧\n  (∀ i : Nat, i < s.length →\n    (isUpperCase cs[i]! → cs'[i]! = shift32 cs[i]!) ∧\n    (¬isUpperCase cs[i]! → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n  unfold toLowercase toLowercase_postcond\n  simp_all\n  constructor\n  · unfold String.length\n    simp\n  · intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_17", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string that may contain both uppercase and lowercase characters.\n\n-----Output-----\nThe output is a string:\nReturns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isUpperCase (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\ndef shift32 (c : Char) : Char :=\n  Char.ofNat (c.toNat + 32)\n\n@[reducible, simp]\ndef toLowercase_precond (s : String) : Prop :=\n  True\n\ndef toLowercase (s : String) (h_precond : toLowercase_precond (s)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isUpperCase c then shift32 c else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef toLowercase_postcond (s : String) (result: String) (h_precond : toLowercase_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) ∧\n  (∀ i : Nat, i < s.length →\n    (isUpperCase cs[i]! → cs'[i]! = shift32 cs[i]!) ∧\n    (¬isUpperCase cs[i]! → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n```", "ground_truth": "theorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n  unfold toLowercase toLowercase_postcond\n  simp_all\n  constructor\n  · unfold String.length\n    simp\n  · intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_17"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the sum of the digits of a non-negative integer. The method should process each digit of the input number and return the total sum. The output is guaranteed to be a non-negative natural number.\n\n-----Input-----\nThe input consists of:\nn: A non-negative integer.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the digits of the input integer.\n\n-----Note-----\nThe input is assumed to be a valid non-negative integer.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumOfDigits_spec_satisfied (n: Nat) (h_precond : sumOfDigits_precond (n)) :\n    sumOfDigits_postcond (n) (sumOfDigits (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumOfDigits_precond (n : Nat) : Prop :=\n  True\n\ndef sumOfDigits (n : Nat) (h_precond : sumOfDigits_precond (n)) : Nat :=\n  let rec loop (n : Nat) (acc : Nat) : Nat :=\n    if n = 0 then acc\n    else loop (n / 10) (acc + n % 10)\n  loop n 0\n\n@[reducible, simp]\ndef sumOfDigits_postcond (n : Nat) (result: Nat) (h_precond : sumOfDigits_precond (n)) :=\n  result - List.sum (List.map (fun c => Char.toNat c - Char.toNat '0') (String.toList (Nat.repr n))) = 0 ∧\n  List.sum (List.map (fun c => Char.toNat c - Char.toNat '0') (String.toList (Nat.repr n))) - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumOfDigits_spec_satisfied (n: Nat) (h_precond : sumOfDigits_precond (n)) :\n    sumOfDigits_postcond (n) (sumOfDigits (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_18", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the sum of the digits of a non-negative integer. The method should process each digit of the input number and return the total sum. The output is guaranteed to be a non-negative natural number.\n\n-----Input-----\nThe input consists of:\nn: A non-negative integer.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the digits of the input integer.\n\n-----Note-----\nThe input is assumed to be a valid non-negative integer.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumOfDigits_spec_satisfied (n: Nat) (h_precond : sumOfDigits_precond (n)) :\n    sumOfDigits_postcond (n) (sumOfDigits (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumOfDigits_precond (n : Nat) : Prop :=\n  True\n\ndef sumOfDigits (n : Nat) (h_precond : sumOfDigits_precond (n)) : Nat :=\n  let rec loop (n : Nat) (acc : Nat) : Nat :=\n    if n = 0 then acc\n    else loop (n / 10) (acc + n % 10)\n  loop n 0\n\n@[reducible, simp]\ndef sumOfDigits_postcond (n : Nat) (result: Nat) (h_precond : sumOfDigits_precond (n)) :=\n  result - List.sum (List.map (fun c => Char.toNat c - Char.toNat '0') (String.toList (Nat.repr n))) = 0 ∧\n  List.sum (List.map (fun c => Char.toNat c - Char.toNat '0') (String.toList (Nat.repr n))) - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumOfDigits_spec_satisfied (n: Nat) (h_precond : sumOfDigits_precond (n)) :\n    sumOfDigits_postcond (n) (sumOfDigits (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_18"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that checks whether an array of integers is sorted in non-decreasing order. The method should return true if every element is less than or equal to the element that follows it, and false otherwise.\n\n-----Input-----\nThe input consists of:\na: An array of integers. The array can be empty or have any length.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is sorted in non-decreasing order.\nReturns false if the array is not sorted in non-decreasing order.\n\n-----Note-----\nA true result guarantees that for every valid pair of indices i and j (with i < j), the element at position i is less than or equal to the element at position j. A false result indicates that there exists at least one adjacent pair of elements where the first element is greater than the second.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isSorted_precond (a : Array Int) : Prop :=\n  True\n\ndef isSorted (a : Array Int) (h_precond : isSorted_precond (a)) : Bool :=\n  if a.size ≤ 1 then\n    true\n  else\n    a.mapIdx (fun i x =>\n      if h : i + 1 < a.size then\n        decide (x ≤ a[i + 1])\n      else\n        true) |>.all id\n\n@[reducible, simp]\ndef isSorted_postcond (a : Array Int) (result: Bool) (h_precond : isSorted_precond (a)) :=\n  (∀ i, (hi : i < a.size - 1) → a[i] ≤ a[i + 1]) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n  unfold isSorted isSorted_postcond\n  simp_all\n  cases a with | mk a =>\n    simp\n    cases a with\n    | nil => simp\n    | cons x xs =>\n      simp\n      cases xs with\n      | nil => simp\n      | cons x' xs =>\n        simp\n        constructor <;> simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_19", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that checks whether an array of integers is sorted in non-decreasing order. The method should return true if every element is less than or equal to the element that follows it, and false otherwise.\n\n-----Input-----\nThe input consists of:\na: An array of integers. The array can be empty or have any length.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is sorted in non-decreasing order.\nReturns false if the array is not sorted in non-decreasing order.\n\n-----Note-----\nA true result guarantees that for every valid pair of indices i and j (with i < j), the element at position i is less than or equal to the element at position j. A false result indicates that there exists at least one adjacent pair of elements where the first element is greater than the second.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isSorted_precond (a : Array Int) : Prop :=\n  True\n\ndef isSorted (a : Array Int) (h_precond : isSorted_precond (a)) : Bool :=\n  if a.size ≤ 1 then\n    true\n  else\n    a.mapIdx (fun i x =>\n      if h : i + 1 < a.size then\n        decide (x ≤ a[i + 1])\n      else\n        true) |>.all id\n\n@[reducible, simp]\ndef isSorted_postcond (a : Array Int) (result: Bool) (h_precond : isSorted_precond (a)) :=\n  (∀ i, (hi : i < a.size - 1) → a[i] ≤ a[i + 1]) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n```", "ground_truth": "theorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n  unfold isSorted isSorted_postcond\n  simp_all\n  cases a with | mk a =>\n    simp\n    cases a with\n    | nil => simp\n    | cons x xs =>\n      simp\n      cases xs with\n      | nil => simp\n      | cons x' xs =>\n        simp\n        constructor <;> simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_19"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the smallest number in an array of integers.\n\n-----Input-----\nThe input consists of:\ns: An array of integers.\n\n-----Output-----\nThe output is an option integer:\nReturns the smallest number found in the input array or none if the array is empty.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef findSmallest_precond (s : Array Nat) : Prop :=\n  True\n\ndef findSmallest (s : Array Nat) (h_precond : findSmallest_precond (s)) : Option Nat :=\n  s.toList.min?\n\n@[reducible, simp]\ndef findSmallest_postcond (s : Array Nat) (result: Option Nat) (h_precond : findSmallest_precond (s)) :=\n  let xs := s.toList\n  match result with\n  | none => xs = []\n  | some r => r ∈ xs ∧ (∀ x, x ∈ xs → r ≤ x)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n  unfold findSmallest_postcond findSmallest\n  cases res : s.toList.min? with\n  | none =>\n    simp only [res]\n    rw [List.min?_eq_none_iff] at res\n    exact res\n  | some r =>\n    simp only [res]\n    rw [List.min?_eq_some_iff'] at res\n    exact res"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_2", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the smallest number in an array of integers.\n\n-----Input-----\nThe input consists of:\ns: An array of integers.\n\n-----Output-----\nThe output is an option integer:\nReturns the smallest number found in the input array or none if the array is empty.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef findSmallest_precond (s : Array Nat) : Prop :=\n  True\n\ndef findSmallest (s : Array Nat) (h_precond : findSmallest_precond (s)) : Option Nat :=\n  s.toList.min?\n\n@[reducible, simp]\ndef findSmallest_postcond (s : Array Nat) (result: Option Nat) (h_precond : findSmallest_precond (s)) :=\n  let xs := s.toList\n  match result with\n  | none => xs = []\n  | some r => r ∈ xs ∧ (∀ x, x ∈ xs → r ≤ x)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n```", "ground_truth": "theorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n  unfold findSmallest_postcond findSmallest\n  cases res : s.toList.min? with\n  | none =>\n    simp only [res]\n    rw [List.min?_eq_none_iff] at res\n    exact res\n  | some r =>\n    simp only [res]\n    rw [List.min?_eq_some_iff'] at res\n    exact res", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_2"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product of all unique integers from the input array.\n\n-----Note-----\nThe order in which the unique integers are multiplied does not affect the final product.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :\n    uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\n\n@[reducible, simp]\ndef uniqueProduct_precond (arr : Array Int) : Prop :=\n  True\n\ndef uniqueProduct (arr : Array Int) (h_precond : uniqueProduct_precond (arr)) : Int :=\n  let rec loop (i : Nat) (seen : Std.HashSet Int) (product : Int) : Int :=\n    if i < arr.size then\n      let x := arr[i]!\n      if seen.contains x then\n        loop (i + 1) seen product\n      else\n        loop (i + 1) (seen.insert x) (product * x)\n    else\n      product\n  loop 0 Std.HashSet.empty 1\n\n@[reducible, simp]\ndef uniqueProduct_postcond (arr : Array Int) (result: Int) (h_precond : uniqueProduct_precond (arr)) :=\n  result - (arr.toList.eraseDups.foldl (· * ·) 1) = 0 ∧\n  (arr.toList.eraseDups.foldl (· * ·) 1) - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :\n    uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_20", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product of all unique integers from the input array.\n\n-----Note-----\nThe order in which the unique integers are multiplied does not affect the final product.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :\n    uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\n\n@[reducible, simp]\ndef uniqueProduct_precond (arr : Array Int) : Prop :=\n  True\n\ndef uniqueProduct (arr : Array Int) (h_precond : uniqueProduct_precond (arr)) : Int :=\n  let rec loop (i : Nat) (seen : Std.HashSet Int) (product : Int) : Int :=\n    if i < arr.size then\n      let x := arr[i]!\n      if seen.contains x then\n        loop (i + 1) seen product\n      else\n        loop (i + 1) (seen.insert x) (product * x)\n    else\n      product\n  loop 0 Std.HashSet.empty 1\n\n@[reducible, simp]\ndef uniqueProduct_postcond (arr : Array Int) (result: Int) (h_precond : uniqueProduct_precond (arr)) :=\n  result - (arr.toList.eraseDups.foldl (· * ·) 1) = 0 ∧\n  (arr.toList.eraseDups.foldl (· * ·) 1) - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :\n    uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_20"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that determines whether one list is a sublist of another. In other words, the method should check if the first list appears as a contiguous sequence within the second list and return true if it does, and false otherwise.\n\n-----Input-----  \nThe input consists of two lists of integers:  \nsub: A list of integers representing the potential sublist.  \nmain: A list of integers in which to search for the sublist.\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if the first list appears as a contiguous sequence within the second list.  \nReturns false if the first list does not appear as a contiguous sequence in the second list.\n\n-----Note-----  \nThere are no preconditions for this method; the sequences are always non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isSublist_spec_satisfied (sub: List Int) (main: List Int) (h_precond : isSublist_precond (sub) (main)) :\n    isSublist_postcond (sub) (main) (isSublist (sub) (main) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isSublist_precond (sub : List Int) (main : List Int) : Prop :=\n  True\n\ndef isSublist (sub : List Int) (main : List Int) (h_precond : isSublist_precond (sub) (main)) : Bool :=\n  let subLen := sub.length\n  let mainLen := main.length\n  if subLen > mainLen then\n    false\n  else\n    let rec check (i : Nat) : Bool :=\n      if i + subLen > mainLen then\n        false\n      else if sub = (main.drop i).take subLen then\n        true\n      else if i + 1 ≤ mainLen then\n        check (i + 1)\n      else\n        false\n    termination_by mainLen - i\n    check 0\n\n@[reducible, simp]\ndef isSublist_postcond (sub : List Int) (main : List Int) (result: Bool) (h_precond : isSublist_precond (sub) (main)) :=\n  (∃ i, i + sub.length ≤ main.length ∧ sub = (main.drop i).take sub.length) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isSublist_spec_satisfied (sub: List Int) (main: List Int) (h_precond : isSublist_precond (sub) (main)) :\n    isSublist_postcond (sub) (main) (isSublist (sub) (main) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_21", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that determines whether one list is a sublist of another. In other words, the method should check if the first list appears as a contiguous sequence within the second list and return true if it does, and false otherwise.\n\n-----Input-----  \nThe input consists of two lists of integers:  \nsub: A list of integers representing the potential sublist.  \nmain: A list of integers in which to search for the sublist.\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if the first list appears as a contiguous sequence within the second list.  \nReturns false if the first list does not appear as a contiguous sequence in the second list.\n\n-----Note-----  \nThere are no preconditions for this method; the sequences are always non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isSublist_spec_satisfied (sub: List Int) (main: List Int) (h_precond : isSublist_precond (sub) (main)) :\n    isSublist_postcond (sub) (main) (isSublist (sub) (main) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isSublist_precond (sub : List Int) (main : List Int) : Prop :=\n  True\n\ndef isSublist (sub : List Int) (main : List Int) (h_precond : isSublist_precond (sub) (main)) : Bool :=\n  let subLen := sub.length\n  let mainLen := main.length\n  if subLen > mainLen then\n    false\n  else\n    let rec check (i : Nat) : Bool :=\n      if i + subLen > mainLen then\n        false\n      else if sub = (main.drop i).take subLen then\n        true\n      else if i + 1 ≤ mainLen then\n        check (i + 1)\n      else\n        false\n    termination_by mainLen - i\n    check 0\n\n@[reducible, simp]\ndef isSublist_postcond (sub : List Int) (main : List Int) (result: Bool) (h_precond : isSublist_precond (sub) (main)) :=\n  (∃ i, i + sub.length ≤ main.length ∧ sub = (main.drop i).take sub.length) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isSublist_spec_satisfied (sub: List Int) (main: List Int) (h_precond : isSublist_precond (sub) (main)) :\n    isSublist_postcond (sub) (main) (isSublist (sub) (main) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_21"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that identifies the dissimilar elements between two arrays of integers. In other words, the method should return an array containing all elements that appear in one input array but not in the other. The output array must contain no duplicate elements and the order of elements does not matter.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all distinct elements from both input arrays that are not present in the other array and should be sorted\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem dissimilarElements_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :\n    dissimilarElements_postcond (a) (b) (dissimilarElements (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\n\ndef inArray (a : Array Int) (x : Int) : Bool :=\n  a.any (fun y => y = x)\n\n@[reducible, simp]\ndef dissimilarElements_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef dissimilarElements (a : Array Int) (b : Array Int) (h_precond : dissimilarElements_precond (a) (b)) : Array Int :=\n  let res := a.foldl (fun acc x => if !inArray b x then acc.insert x else acc) Std.HashSet.empty\n  let res := b.foldl (fun acc x => if !inArray a x then acc.insert x else acc) res\n  res.toArray.insertionSort\n\n@[reducible, simp]\ndef dissimilarElements_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :=\n  result.all (fun x => inArray a x ≠ inArray b x)∧\n  result.toList.Pairwise (· ≤ ·) ∧\n  a.all (fun x => if x ∈ b then x ∉ result else x ∈ result) ∧\n  b.all (fun x => if x ∈ a then x ∉ result else x ∈ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem dissimilarElements_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :\n    dissimilarElements_postcond (a) (b) (dissimilarElements (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_22", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that identifies the dissimilar elements between two arrays of integers. In other words, the method should return an array containing all elements that appear in one input array but not in the other. The output array must contain no duplicate elements and the order of elements does not matter.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all distinct elements from both input arrays that are not present in the other array and should be sorted\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem dissimilarElements_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :\n    dissimilarElements_postcond (a) (b) (dissimilarElements (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\n\ndef inArray (a : Array Int) (x : Int) : Bool :=\n  a.any (fun y => y = x)\n\n@[reducible, simp]\ndef dissimilarElements_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef dissimilarElements (a : Array Int) (b : Array Int) (h_precond : dissimilarElements_precond (a) (b)) : Array Int :=\n  let res := a.foldl (fun acc x => if !inArray b x then acc.insert x else acc) Std.HashSet.empty\n  let res := b.foldl (fun acc x => if !inArray a x then acc.insert x else acc) res\n  res.toArray.insertionSort\n\n@[reducible, simp]\ndef dissimilarElements_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :=\n  result.all (fun x => inArray a x ≠ inArray b x)∧\n  result.toList.Pairwise (· ≤ ·) ∧\n  a.all (fun x => if x ∈ b then x ∉ result else x ∈ result) ∧\n  b.all (fun x => if x ∈ a then x ∉ result else x ∈ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem dissimilarElements_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :\n    dissimilarElements_postcond (a) (b) (dissimilarElements (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_22"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the difference between the maximum and minimum values in an array of integers. In other words, the method should determine the highest and lowest numbers in the array and return the result of subtracting the minimum from the maximum.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference between the largest and the smallest values in the input array.\n\n-----Note-----\nThe input array is assumed to be non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem differenceMinMax_spec_satisfied (a: Array Int) (h_precond : differenceMinMax_precond (a)) :\n    differenceMinMax_postcond (a) (differenceMinMax (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef differenceMinMax_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef differenceMinMax (a : Array Int) (h_precond : differenceMinMax_precond (a)) : Int :=\n  let rec loop (i : Nat) (minVal maxVal : Int) : Int :=\n    if i < a.size then\n      let x := a[i]!\n      let newMin := if x < minVal then x else minVal\n      let newMax := if x > maxVal then x else maxVal\n      loop (i + 1) newMin newMax\n    else\n      maxVal - minVal\n  loop 1 (a[0]!) (a[0]!)\n\n@[reducible, simp]\ndef differenceMinMax_postcond (a : Array Int) (result: Int) (h_precond : differenceMinMax_precond (a)) :=\n  result + (a.foldl (fun acc x => if x < acc then x else acc) (a[0]!)) = (a.foldl (fun acc x => if x > acc then x else acc) (a[0]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem differenceMinMax_spec_satisfied (a: Array Int) (h_precond : differenceMinMax_precond (a)) :\n    differenceMinMax_postcond (a) (differenceMinMax (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_23", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the difference between the maximum and minimum values in an array of integers. In other words, the method should determine the highest and lowest numbers in the array and return the result of subtracting the minimum from the maximum.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference between the largest and the smallest values in the input array.\n\n-----Note-----\nThe input array is assumed to be non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem differenceMinMax_spec_satisfied (a: Array Int) (h_precond : differenceMinMax_precond (a)) :\n    differenceMinMax_postcond (a) (differenceMinMax (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef differenceMinMax_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef differenceMinMax (a : Array Int) (h_precond : differenceMinMax_precond (a)) : Int :=\n  let rec loop (i : Nat) (minVal maxVal : Int) : Int :=\n    if i < a.size then\n      let x := a[i]!\n      let newMin := if x < minVal then x else minVal\n      let newMax := if x > maxVal then x else maxVal\n      loop (i + 1) newMin newMax\n    else\n      maxVal - minVal\n  loop 1 (a[0]!) (a[0]!)\n\n@[reducible, simp]\ndef differenceMinMax_postcond (a : Array Int) (result: Int) (h_precond : differenceMinMax_precond (a)) :=\n  result + (a.foldl (fun acc x => if x < acc then x else acc) (a[0]!)) = (a.foldl (fun acc x => if x > acc then x else acc) (a[0]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem differenceMinMax_spec_satisfied (a: Array Int) (h_precond : differenceMinMax_precond (a)) :\n    differenceMinMax_postcond (a) (differenceMinMax (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_23"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the difference between the first even number and the first odd number in an array of integers. The method should process the array sequentially until it identifies the first even number and the first odd number, and then return the difference calculated as (first even number) minus (first odd number).\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference computed as the first even number minus the first odd number found in the array.\n\n-----Note-----\nThe input array is assumed to be non-empty and to contain at least one even number and one odd number.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem firstEvenOddDifference_spec_satisfied (a: Array Int) (h_precond : firstEvenOddDifference_precond (a)) :\n    firstEvenOddDifference_postcond (a) (firstEvenOddDifference (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 == 0\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 != 0\n\n@[reducible, simp]\ndef firstEvenOddDifference_precond (a : Array Int) : Prop :=\n  a.size > 1 ∧\n  (∃ x ∈ a, isEven x) ∧\n  (∃ x ∈ a, isOdd x)\n\ndef firstEvenOddDifference (a : Array Int) (h_precond : firstEvenOddDifference_precond (a)) : Int :=\n  let rec findFirstEvenOdd (i : Nat) (firstEven firstOdd : Option Nat) : Int :=\n    if i < a.size then\n      let x := a[i]!\n      let firstEven := if firstEven.isNone && isEven x then some i else firstEven\n      let firstOdd := if firstOdd.isNone && isOdd x then some i else firstOdd\n      match firstEven, firstOdd with\n      | some e, some o => a[e]! - a[o]!\n      | _, _ => findFirstEvenOdd (i + 1) firstEven firstOdd\n    else\n      0\n  findFirstEvenOdd 0 none none\n\n@[reducible, simp]\ndef firstEvenOddDifference_postcond (a : Array Int) (result: Int) (h_precond : firstEvenOddDifference_precond (a)) :=\n  ∃ i j, i < a.size ∧ j < a.size ∧ isEven (a[i]!) ∧ isOdd (a[j]!) ∧\n    result = a[i]! - a[j]! ∧\n    (∀ k, k < i → isOdd (a[k]!)) ∧ (∀ k, k < j → isEven (a[k]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem firstEvenOddDifference_spec_satisfied (a: Array Int) (h_precond : firstEvenOddDifference_precond (a)) :\n    firstEvenOddDifference_postcond (a) (firstEvenOddDifference (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_24", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the difference between the first even number and the first odd number in an array of integers. The method should process the array sequentially until it identifies the first even number and the first odd number, and then return the difference calculated as (first even number) minus (first odd number).\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference computed as the first even number minus the first odd number found in the array.\n\n-----Note-----\nThe input array is assumed to be non-empty and to contain at least one even number and one odd number.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem firstEvenOddDifference_spec_satisfied (a: Array Int) (h_precond : firstEvenOddDifference_precond (a)) :\n    firstEvenOddDifference_postcond (a) (firstEvenOddDifference (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 == 0\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 != 0\n\n@[reducible, simp]\ndef firstEvenOddDifference_precond (a : Array Int) : Prop :=\n  a.size > 1 ∧\n  (∃ x ∈ a, isEven x) ∧\n  (∃ x ∈ a, isOdd x)\n\ndef firstEvenOddDifference (a : Array Int) (h_precond : firstEvenOddDifference_precond (a)) : Int :=\n  let rec findFirstEvenOdd (i : Nat) (firstEven firstOdd : Option Nat) : Int :=\n    if i < a.size then\n      let x := a[i]!\n      let firstEven := if firstEven.isNone && isEven x then some i else firstEven\n      let firstOdd := if firstOdd.isNone && isOdd x then some i else firstOdd\n      match firstEven, firstOdd with\n      | some e, some o => a[e]! - a[o]!\n      | _, _ => findFirstEvenOdd (i + 1) firstEven firstOdd\n    else\n      0\n  findFirstEvenOdd 0 none none\n\n@[reducible, simp]\ndef firstEvenOddDifference_postcond (a : Array Int) (result: Int) (h_precond : firstEvenOddDifference_precond (a)) :=\n  ∃ i j, i < a.size ∧ j < a.size ∧ isEven (a[i]!) ∧ isOdd (a[j]!) ∧\n    result = a[i]! - a[j]! ∧\n    (∀ k, k < i → isOdd (a[k]!)) ∧ (∀ k, k < j → isEven (a[k]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem firstEvenOddDifference_spec_satisfied (a: Array Int) (h_precond : firstEvenOddDifference_precond (a)) :\n    firstEvenOddDifference_postcond (a) (firstEvenOddDifference (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_24"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates both the sum and the average of the first n natural numbers. The method should compute the sum of numbers from 0 to n (which equals n * (n + 1) / 2) and then determine the average by dividing this sum by n. The specification assumes that the input n is a positive integer.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of the first natural numbers. The value of n is assumed to be positive.\n\n-----Output-----\nThe output is a pair consisting of:\n- An integer representing the sum of the first n natural numbers.\n- A floating-point number representing the average of the first n natural numbers.\n\n-----Note-----\nThe input n must be a positive integer.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumAndAverage_spec_satisfied (n: Nat) (h_precond : sumAndAverage_precond (n)) :\n    sumAndAverage_postcond (n) (sumAndAverage (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumAndAverage_precond (n : Nat) : Prop :=\n  True\n\ndef sumAndAverage (n : Nat) (h_precond : sumAndAverage_precond (n)) : Int × Float :=\n  if n ≤ 0 then (0, 0.0)\n  else\n    let sum := (List.range (n + 1)).sum\n    let average : Float := sum.toFloat / (n.toFloat)\n    (sum, average)\n\n@[reducible, simp]\ndef sumAndAverage_postcond (n : Nat) (result: Int × Float) (h_precond : sumAndAverage_precond (n)) :=\n  (n = 0 → result == (0, 0.0)) ∧\n  (n > 0 →\n    result.1 == n * (n + 1) / 2 ∧\n    result.2 == ((n * (n + 1) / 2).toFloat) / (n.toFloat))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumAndAverage_spec_satisfied (n: Nat) (h_precond : sumAndAverage_precond (n)) :\n    sumAndAverage_postcond (n) (sumAndAverage (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_25", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates both the sum and the average of the first n natural numbers. The method should compute the sum of numbers from 0 to n (which equals n * (n + 1) / 2) and then determine the average by dividing this sum by n. The specification assumes that the input n is a positive integer.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of the first natural numbers. The value of n is assumed to be positive.\n\n-----Output-----\nThe output is a pair consisting of:\n- An integer representing the sum of the first n natural numbers.\n- A floating-point number representing the average of the first n natural numbers.\n\n-----Note-----\nThe input n must be a positive integer.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumAndAverage_spec_satisfied (n: Nat) (h_precond : sumAndAverage_precond (n)) :\n    sumAndAverage_postcond (n) (sumAndAverage (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumAndAverage_precond (n : Nat) : Prop :=\n  True\n\ndef sumAndAverage (n : Nat) (h_precond : sumAndAverage_precond (n)) : Int × Float :=\n  if n ≤ 0 then (0, 0.0)\n  else\n    let sum := (List.range (n + 1)).sum\n    let average : Float := sum.toFloat / (n.toFloat)\n    (sum, average)\n\n@[reducible, simp]\ndef sumAndAverage_postcond (n : Nat) (result: Int × Float) (h_precond : sumAndAverage_precond (n)) :=\n  (n = 0 → result == (0, 0.0)) ∧\n  (n > 0 →\n    result.1 == n * (n + 1) / 2 ∧\n    result.2 == ((n * (n + 1) / 2).toFloat) / (n.toFloat))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumAndAverage_spec_satisfied (n: Nat) (h_precond : sumAndAverage_precond (n)) :\n    sumAndAverage_postcond (n) (sumAndAverage (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_25"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given integer is even. In other words, the method should return true if the number is even and false if the number is odd.\n\n-----Input-----\nThe input consists of:\nn: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is even.\nReturns false if the input number is odd.\n\n-----Note-----\nThere are no preconditions; the method will always work for any integer input.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isEven_precond (n : Int) : Prop :=\n  True\n\ndef isEven (n : Int) (h_precond : isEven_precond (n)) : Bool :=\n  n % 2 == 0\n\n@[reducible, simp]\ndef isEven_postcond (n : Int) (result: Bool) (h_precond : isEven_precond (n)) :=\n  (result → n % 2 = 0) ∧ (¬ result → n % 2 ≠ 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n  unfold isEven isEven_postcond\n  simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_26", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given integer is even. In other words, the method should return true if the number is even and false if the number is odd.\n\n-----Input-----\nThe input consists of:\nn: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is even.\nReturns false if the input number is odd.\n\n-----Note-----\nThere are no preconditions; the method will always work for any integer input.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isEven_precond (n : Int) : Prop :=\n  True\n\ndef isEven (n : Int) (h_precond : isEven_precond (n)) : Bool :=\n  n % 2 == 0\n\n@[reducible, simp]\ndef isEven_postcond (n : Int) (result: Bool) (h_precond : isEven_precond (n)) :=\n  (result → n % 2 = 0) ∧ (¬ result → n % 2 ≠ 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n```", "ground_truth": "theorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n  unfold isEven isEven_postcond\n  simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_26"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that identifies the first repeated character in a given string. The method should return a tuple containing a Boolean value and a character. The Boolean value indicates whether any character in the string is repeated. If it is true, the accompanying character is the first character that appears more than once. If it is false, it indicates that there are no repeated characters in the string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a tuple (Bool × Char):\n- Returns true and the first repeated character in the string if any repeated character is found.\n- Returns false and an arbitrary character if no repeated characters are present.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :\n    findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\n\n@[reducible, simp]\ndef findFirstRepeatedChar_precond (s : String) : Prop :=\n  True\n\ndef findFirstRepeatedChar (s : String) (h_precond : findFirstRepeatedChar_precond (s)) : Option Char :=\n  let cs := s.toList\n  let rec loop (i : Nat) (seen : Std.HashSet Char) : Option Char :=\n    if i < cs.length then\n      let c := cs[i]!\n      if seen.contains c then\n        some c\n      else\n        loop (i + 1) (seen.insert c)\n    else\n      none\n  loop 0 Std.HashSet.empty\n\n@[reducible, simp]\ndef findFirstRepeatedChar_postcond (s : String) (result: Option Char) (h_precond : findFirstRepeatedChar_precond (s)) :=\n  let cs := s.toList\n  match result with\n  | some c =>\n    let secondIdx := cs.zipIdx.findIdx (fun (x, i) => x = c && i ≠ cs.idxOf c)\n    cs.count c ≥ 2 ∧\n    List.Pairwise (· ≠ ·) (cs.take secondIdx)\n  | none =>\n    List.Pairwise (· ≠ ·) cs\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :\n    findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_27", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that identifies the first repeated character in a given string. The method should return a tuple containing a Boolean value and a character. The Boolean value indicates whether any character in the string is repeated. If it is true, the accompanying character is the first character that appears more than once. If it is false, it indicates that there are no repeated characters in the string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a tuple (Bool × Char):\n- Returns true and the first repeated character in the string if any repeated character is found.\n- Returns false and an arbitrary character if no repeated characters are present.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :\n    findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Std.Data.HashSet\n\n@[reducible, simp]\ndef findFirstRepeatedChar_precond (s : String) : Prop :=\n  True\n\ndef findFirstRepeatedChar (s : String) (h_precond : findFirstRepeatedChar_precond (s)) : Option Char :=\n  let cs := s.toList\n  let rec loop (i : Nat) (seen : Std.HashSet Char) : Option Char :=\n    if i < cs.length then\n      let c := cs[i]!\n      if seen.contains c then\n        some c\n      else\n        loop (i + 1) (seen.insert c)\n    else\n      none\n  loop 0 Std.HashSet.empty\n\n@[reducible, simp]\ndef findFirstRepeatedChar_postcond (s : String) (result: Option Char) (h_precond : findFirstRepeatedChar_precond (s)) :=\n  let cs := s.toList\n  match result with\n  | some c =>\n    let secondIdx := cs.zipIdx.findIdx (fun (x, i) => x = c && i ≠ cs.idxOf c)\n    cs.count c ≥ 2 ∧\n    List.Pairwise (· ≠ ·) (cs.take secondIdx)\n  | none =>\n    List.Pairwise (· ≠ ·) cs\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :\n    findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_27"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given natural number is prime. A number (with n ≥ 2) is considered prime if it is divisible only by 1 and itself. The method should return true when the input number is prime and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: A natural number (Nat) such that n ≥ 2.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is prime (i.e., there is no integer k with 1 < k < n that divides n).\nReturns false if the input number is not prime (i.e., there exists an integer k with 1 < k < n that divides n).\n\n-----Note-----\nThe input is expected to satisfy the condition n ≥ 2.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPrime_spec_satisfied (n: Nat) (h_precond : isPrime_precond (n)) :\n    isPrime_postcond (n) (isPrime (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isPrime_precond (n : Nat) : Prop :=\n  n ≥ 2\n\ndef isPrime (n : Nat) (h_precond : isPrime_precond (n)) : Bool :=\n  let bound := n\n  let rec check (i : Nat) (fuel : Nat) : Bool :=\n    if fuel = 0 then true\n    else if i * i > n then true\n    else if n % i = 0 then false\n    else check (i + 1) (fuel - 1)\n  check 2 bound\n\n@[reducible, simp]\ndef isPrime_postcond (n : Nat) (result: Bool) (h_precond : isPrime_precond (n)) :=\n  (result → (List.range' 2 (n - 2)).all (fun k => n % k ≠ 0)) ∧\n  (¬ result → (List.range' 2 (n - 2)).any (fun k => n % k = 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPrime_spec_satisfied (n: Nat) (h_precond : isPrime_precond (n)) :\n    isPrime_postcond (n) (isPrime (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_28", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given natural number is prime. A number (with n ≥ 2) is considered prime if it is divisible only by 1 and itself. The method should return true when the input number is prime and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: A natural number (Nat) such that n ≥ 2.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is prime (i.e., there is no integer k with 1 < k < n that divides n).\nReturns false if the input number is not prime (i.e., there exists an integer k with 1 < k < n that divides n).\n\n-----Note-----\nThe input is expected to satisfy the condition n ≥ 2.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isPrime_spec_satisfied (n: Nat) (h_precond : isPrime_precond (n)) :\n    isPrime_postcond (n) (isPrime (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef isPrime_precond (n : Nat) : Prop :=\n  n ≥ 2\n\ndef isPrime (n : Nat) (h_precond : isPrime_precond (n)) : Bool :=\n  let bound := n\n  let rec check (i : Nat) (fuel : Nat) : Bool :=\n    if fuel = 0 then true\n    else if i * i > n then true\n    else if n % i = 0 then false\n    else check (i + 1) (fuel - 1)\n  check 2 bound\n\n@[reducible, simp]\ndef isPrime_postcond (n : Nat) (result: Bool) (h_precond : isPrime_precond (n)) :=\n  (result → (List.range' 2 (n - 2)).all (fun k => n % k ≠ 0)) ∧\n  (¬ result → (List.range' 2 (n - 2)).any (fun k => n % k = 0))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isPrime_spec_satisfied (n: Nat) (h_precond : isPrime_precond (n)) :\n    isPrime_postcond (n) (isPrime (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_28"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that removes an element from a given array of integers at a specified index. The resulting array should contain all the original elements except for the one at the given index. Elements before the removed element remain unchanged, and elements after it are shifted one position to the left.\n\n-----Input-----  \nThe input consists of:  \n• s: An array of integers.  \n• k: A natural number representing the index of the element to remove (0-indexed).\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has a length one less than the input array.  \n• Contains the same elements as the input array, except that the element at index k is omitted.  \n• Preserves the original order with elements after the removed element shifted left by one position.\n\n-----Note-----  \nIt is assumed that k is a valid index (0 ≤ k < the length of the array).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef removeElement_precond (s : Array Int) (k : Nat) : Prop :=\n  k < s.size\n\ndef removeElement (s : Array Int) (k : Nat) (h_precond : removeElement_precond (s) (k)) : Array Int :=\n  s.eraseIdx! k\n\n@[reducible, simp]\ndef removeElement_postcond (s : Array Int) (k : Nat) (result: Array Int) (h_precond : removeElement_precond (s) (k)) :=\n  result.size = s.size - 1 ∧\n  (∀ i, i < k → result[i]! = s[i]!) ∧\n  (∀ i, i < result.size → i ≥ k → result[i]! = s[i + 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n  unfold removeElement removeElement_postcond\n  unfold removeElement_precond at h_precond\n  simp_all\n  unfold Array.eraseIdx!\n  simp [h_precond]\n  constructor\n  · intro i hi\n    have hi' : i < s.size - 1 := by\n      have hk := Nat.le_sub_one_of_lt h_precond\n      exact Nat.lt_of_lt_of_le hi hk\n    rw [Array.getElem!_eq_getD, Array.getElem!_eq_getD]\n    unfold Array.getD\n    simp [hi', Nat.lt_trans hi h_precond, Array.getElem_eraseIdx, hi]\n  · intro i hi hi'\n    rw [Array.getElem!_eq_getD, Array.getElem!_eq_getD]\n    unfold Array.getD\n    have hi'' : i + 1 < s.size := by exact Nat.add_lt_of_lt_sub hi\n    simp [hi, hi'']\n    have : ¬ i < k := by simp [hi']\n    simp [Array.getElem_eraseIdx, this]"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_29", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that removes an element from a given array of integers at a specified index. The resulting array should contain all the original elements except for the one at the given index. Elements before the removed element remain unchanged, and elements after it are shifted one position to the left.\n\n-----Input-----  \nThe input consists of:  \n• s: An array of integers.  \n• k: A natural number representing the index of the element to remove (0-indexed).\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has a length one less than the input array.  \n• Contains the same elements as the input array, except that the element at index k is omitted.  \n• Preserves the original order with elements after the removed element shifted left by one position.\n\n-----Note-----  \nIt is assumed that k is a valid index (0 ≤ k < the length of the array).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef removeElement_precond (s : Array Int) (k : Nat) : Prop :=\n  k < s.size\n\ndef removeElement (s : Array Int) (k : Nat) (h_precond : removeElement_precond (s) (k)) : Array Int :=\n  s.eraseIdx! k\n\n@[reducible, simp]\ndef removeElement_postcond (s : Array Int) (k : Nat) (result: Array Int) (h_precond : removeElement_precond (s) (k)) :=\n  result.size = s.size - 1 ∧\n  (∀ i, i < k → result[i]! = s[i]!) ∧\n  (∀ i, i < result.size → i ≥ k → result[i]! = s[i + 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n```", "ground_truth": "theorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n  unfold removeElement removeElement_postcond\n  unfold removeElement_precond at h_precond\n  simp_all\n  unfold Array.eraseIdx!\n  simp [h_precond]\n  constructor\n  · intro i hi\n    have hi' : i < s.size - 1 := by\n      have hk := Nat.le_sub_one_of_lt h_precond\n      exact Nat.lt_of_lt_of_le hi hk\n    rw [Array.getElem!_eq_getD, Array.getElem!_eq_getD]\n    unfold Array.getD\n    simp [hi', Nat.lt_trans hi h_precond, Array.getElem_eraseIdx, hi]\n  · intro i hi hi'\n    rw [Array.getElem!_eq_getD, Array.getElem!_eq_getD]\n    unfold Array.getD\n    have hi'' : i + 1 < s.size := by exact Nat.add_lt_of_lt_sub hi\n    simp [hi, hi'']\n    have : ¬ i < k := by simp [hi']\n    simp [Array.getElem_eraseIdx, this]", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_29"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given integer is divisible by 11. The method should return true if the number is divisible by 11 and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: An integer to check for divisibility by 11.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is divisible by 11.\nReturns false if the input number is not divisible by 11.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef isDivisibleBy11_precond (n : Int) : Prop :=\n  True\n\ndef isDivisibleBy11 (n : Int) (h_precond : isDivisibleBy11_precond (n)) : Bool :=\n  n % 11 == 0\n\n@[reducible, simp]\ndef isDivisibleBy11_postcond (n : Int) (result: Bool) (h_precond : isDivisibleBy11_precond (n)) :=\n  (result → (∃ k : Int, n = 11 * k)) ∧ (¬ result → (∀ k : Int, ¬ n = 11 * k))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n  unfold isDivisibleBy11 isDivisibleBy11_postcond\n  constructor\n  · simp_all\n    exact fun a => a\n  · apply Not.imp_symm\n    rw [not_forall_not]\n    intro h\n    rw [beq_iff_eq]\n    exact Int.emod_eq_zero_of_dvd h"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_3", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines whether a given integer is divisible by 11. The method should return true if the number is divisible by 11 and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: An integer to check for divisibility by 11.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is divisible by 11.\nReturns false if the input number is not divisible by 11.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef isDivisibleBy11_precond (n : Int) : Prop :=\n  True\n\ndef isDivisibleBy11 (n : Int) (h_precond : isDivisibleBy11_precond (n)) : Bool :=\n  n % 11 == 0\n\n@[reducible, simp]\ndef isDivisibleBy11_postcond (n : Int) (result: Bool) (h_precond : isDivisibleBy11_precond (n)) :=\n  (result → (∃ k : Int, n = 11 * k)) ∧ (¬ result → (∀ k : Int, ¬ n = 11 * k))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n```", "ground_truth": "theorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n  unfold isDivisibleBy11 isDivisibleBy11_postcond\n  constructor\n  · simp_all\n    exact fun a => a\n  · apply Not.imp_symm\n    rw [not_forall_not]\n    intro h\n    rw [beq_iff_eq]\n    exact Int.emod_eq_zero_of_dvd h", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_3"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.\n\n-----Input----- \nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output----- \nThe output is an array of integers:\nReturns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.\n\n-----Note----- \nPreconditions:\n- Both arrays must be non-null.\n- Both arrays must have the same length.\n- All elements in the second array should be non-zero.\n\nPostconditions:\n- The length of the resulting array is the same as the length of the input arrays.\n- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef elementWiseModulo_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size ∧ a.size > 0 ∧\n  (∀ i, i < b.size → b[i]! ≠ 0)\n\ndef elementWiseModulo (a : Array Int) (b : Array Int) (h_precond : elementWiseModulo_precond (a) (b)) : Array Int :=\n  a.mapIdx (fun i x => x % b[i]!)\n\n@[reducible, simp]\ndef elementWiseModulo_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :=\n  result.size = a.size ∧\n  (∀ i, i < result.size → result[i]! = a[i]! % b[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n  unfold elementWiseModulo elementWiseModulo_postcond\n  unfold elementWiseModulo_precond at h_precond\n  simp_all\n  intro i hi\n  have h_maplen : (Array.mapIdx (fun i x => x % b[i]!) a).size = a.size := by\n    apply Array.size_mapIdx\n  have h1 : (Array.mapIdx (fun i x => x % b[i]!) a)[i] = (fun i x => x % b[i]!) i a[i] := by\n    apply Array.getElem_mapIdx\n  have h_eq : (Array.mapIdx (fun i x => x % b[i]!) a)[i] = (Array.mapIdx (fun i x => x % b[i]!) a)[i]! := by\n    have hi' : i < (Array.mapIdx (fun i x => x % b[i]!) a).size := by\n      simp only [h_precond, hi, h_maplen]\n    rw [Array.getElem!_eq_getD]\n    unfold Array.getD\n    simp [hi', hi, h_precond]\n  rw [← h_eq]\n  simp only [h1]\n  have h_eq' : a[i] = a[i]! := by\n    have hi_a : i < a.size := by\n      simp only [h_precond, hi]\n    simp_all [Array.getElem!_eq_getD]\n  simp only [h_eq']"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_30", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.\n\n-----Input----- \nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output----- \nThe output is an array of integers:\nReturns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.\n\n-----Note----- \nPreconditions:\n- Both arrays must be non-null.\n- Both arrays must have the same length.\n- All elements in the second array should be non-zero.\n\nPostconditions:\n- The length of the resulting array is the same as the length of the input arrays.\n- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef elementWiseModulo_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size ∧ a.size > 0 ∧\n  (∀ i, i < b.size → b[i]! ≠ 0)\n\ndef elementWiseModulo (a : Array Int) (b : Array Int) (h_precond : elementWiseModulo_precond (a) (b)) : Array Int :=\n  a.mapIdx (fun i x => x % b[i]!)\n\n@[reducible, simp]\ndef elementWiseModulo_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :=\n  result.size = a.size ∧\n  (∀ i, i < result.size → result[i]! = a[i]! % b[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n```", "ground_truth": "theorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n  unfold elementWiseModulo elementWiseModulo_postcond\n  unfold elementWiseModulo_precond at h_precond\n  simp_all\n  intro i hi\n  have h_maplen : (Array.mapIdx (fun i x => x % b[i]!) a).size = a.size := by\n    apply Array.size_mapIdx\n  have h1 : (Array.mapIdx (fun i x => x % b[i]!) a)[i] = (fun i x => x % b[i]!) i a[i] := by\n    apply Array.getElem_mapIdx\n  have h_eq : (Array.mapIdx (fun i x => x % b[i]!) a)[i] = (Array.mapIdx (fun i x => x % b[i]!) a)[i]! := by\n    have hi' : i < (Array.mapIdx (fun i x => x % b[i]!) a).size := by\n      simp only [h_precond, hi, h_maplen]\n    rw [Array.getElem!_eq_getD]\n    unfold Array.getD\n    simp [hi', hi, h_precond]\n  rw [← h_eq]\n  simp only [h1]\n  have h_eq' : a[i] = a[i]! := by\n    have hi_a : i < a.size := by\n      simp only [h_precond, hi]\n    simp_all [Array.getElem!_eq_getD]\n  simp only [h_eq']", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_30"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that converts a given string to uppercase. The method should replace every lowercase letter in the input string with its corresponding uppercase character while leaving all other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a string:\nReturns a new string in which every lowercase letter from the input string is converted to uppercase, and all other characters are exactly the same as in the input string, ensuring the output string has the same length as the input.\n\n-----Note-----\nThere are no preconditions since the method assumes that the input string is always valid (i.e., non-null).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isLowerCase (c : Char) : Bool :=\n  'a' ≤ c ∧ c ≤ 'z'\n\ndef shiftMinus32 (c : Char) : Char :=\n  Char.ofNat ((c.toNat - 32) % 128)\n\n@[reducible, simp]\ndef toUppercase_precond (s : String) : Prop :=\n  True\n\ndef toUppercase (s : String) (h_precond : toUppercase_precond (s)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isLowerCase c then shiftMinus32 c else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef toUppercase_postcond (s : String) (result: String) (h_precond : toUppercase_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) ∧\n  (∀ i, i < s.length →\n    (isLowerCase cs[i]! → cs'[i]! = shiftMinus32 cs[i]!) ∧\n    (¬isLowerCase cs[i]! → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n  unfold toUppercase toUppercase_postcond\n  simp_all\n  constructor\n  · unfold String.length\n    simp\n  · intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_31", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that converts a given string to uppercase. The method should replace every lowercase letter in the input string with its corresponding uppercase character while leaving all other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a string:\nReturns a new string in which every lowercase letter from the input string is converted to uppercase, and all other characters are exactly the same as in the input string, ensuring the output string has the same length as the input.\n\n-----Note-----\nThere are no preconditions since the method assumes that the input string is always valid (i.e., non-null).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isLowerCase (c : Char) : Bool :=\n  'a' ≤ c ∧ c ≤ 'z'\n\ndef shiftMinus32 (c : Char) : Char :=\n  Char.ofNat ((c.toNat - 32) % 128)\n\n@[reducible, simp]\ndef toUppercase_precond (s : String) : Prop :=\n  True\n\ndef toUppercase (s : String) (h_precond : toUppercase_precond (s)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isLowerCase c then shiftMinus32 c else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef toUppercase_postcond (s : String) (result: String) (h_precond : toUppercase_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) ∧\n  (∀ i, i < s.length →\n    (isLowerCase cs[i]! → cs'[i]! = shiftMinus32 cs[i]!) ∧\n    (¬isLowerCase cs[i]! → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n```", "ground_truth": "theorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n  unfold toUppercase toUppercase_postcond\n  simp_all\n  constructor\n  · unfold String.length\n    simp\n  · intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_31"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that swaps the first and last elements of an array of integers. The method should produce a new array where the first element of the output is the last element of the input, the last element of the output is the first element of the input, and all other elements remain in their original positions.\n\n-----Input-----  \nThe input consists of:  \na: An array of integers (assumed to be non-empty).\n\n-----Output-----  \nThe output is an array of integers:  \nReturns a new array where:  \n- The former last element becomes the first element.  \n- The former first element becomes the last element.  \n- All other elements remain unchanged.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\ndef swapFirstAndLast_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef swapFirstAndLast (a : Array Int) (h_precond: swapFirstAndLast_precond a) : Array Int :=\n  let first := a[0]!\n  let last := a[a.size - 1]!\n  a.set! 0 last |>.set! (a.size - 1) first\n\n@[reducible, simp]\ndef swapFirstAndLast_postcond (a : Array Int) (result : Array Int) (h_precond: swapFirstAndLast_precond a) : Prop :=\n  result.size = a.size ∧\n  result[0]! = a[a.size - 1]! ∧\n  result[result.size - 1]! = a[0]! ∧\n  (List.range (result.size - 2)).all (fun i => result[i + 1]! = a[i + 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n  unfold swapFirstAndLast swapFirstAndLast_postcond\n  unfold swapFirstAndLast_precond at h_precond\n  simp_all\n  constructor\n  · simp [Array.getElem!_eq_getD]\n    rw [← Array.getElem?_toList, ← Array.getElem?_toList]\n    simp\n    rw [List.getElem?_set]\n    cases ha' : a.size with\n    | zero => simp_all\n    | succ n =>\n      cases hn : n with\n      | zero =>\n        simp [h_precond]\n      | succ n' => simp_all\n  · constructor\n    · simp_all [Array.getElem!_eq_getD]\n    · intro i hi\n      simp [Array.getElem!_eq_getD]\n      rw [← Array.getElem?_toList, ← Array.getElem?_toList]\n      simp\n      rw [List.getElem?_set, List.length_set]\n      simp_all\n      have : i + 2 < a.size := by\n        exact Nat.add_lt_of_lt_sub hi\n      have : a.size ≠ i + 2 := by\n        exact Ne.symm (Nat.ne_of_lt this)\n      simp [this]"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_32", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that swaps the first and last elements of an array of integers. The method should produce a new array where the first element of the output is the last element of the input, the last element of the output is the first element of the input, and all other elements remain in their original positions.\n\n-----Input-----  \nThe input consists of:  \na: An array of integers (assumed to be non-empty).\n\n-----Output-----  \nThe output is an array of integers:  \nReturns a new array where:  \n- The former last element becomes the first element.  \n- The former first element becomes the last element.  \n- All other elements remain unchanged.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\ndef swapFirstAndLast_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef swapFirstAndLast (a : Array Int) (h_precond: swapFirstAndLast_precond a) : Array Int :=\n  let first := a[0]!\n  let last := a[a.size - 1]!\n  a.set! 0 last |>.set! (a.size - 1) first\n\n@[reducible, simp]\ndef swapFirstAndLast_postcond (a : Array Int) (result : Array Int) (h_precond: swapFirstAndLast_precond a) : Prop :=\n  result.size = a.size ∧\n  result[0]! = a[a.size - 1]! ∧\n  result[result.size - 1]! = a[0]! ∧\n  (List.range (result.size - 2)).all (fun i => result[i + 1]! = a[i + 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n```", "ground_truth": "theorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n  unfold swapFirstAndLast swapFirstAndLast_postcond\n  unfold swapFirstAndLast_precond at h_precond\n  simp_all\n  constructor\n  · simp [Array.getElem!_eq_getD]\n    rw [← Array.getElem?_toList, ← Array.getElem?_toList]\n    simp\n    rw [List.getElem?_set]\n    cases ha' : a.size with\n    | zero => simp_all\n    | succ n =>\n      cases hn : n with\n      | zero =>\n        simp [h_precond]\n      | succ n' => simp_all\n  · constructor\n    · simp_all [Array.getElem!_eq_getD]\n    · intro i hi\n      simp [Array.getElem!_eq_getD]\n      rw [← Array.getElem?_toList, ← Array.getElem?_toList]\n      simp\n      rw [List.getElem?_set, List.length_set]\n      simp_all\n      have : i + 2 < a.size := by\n        exact Nat.add_lt_of_lt_sub hi\n      have : a.size ≠ i + 2 := by\n        exact Ne.symm (Nat.ne_of_lt this)\n      simp [this]", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_32"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that returns the smallest natural number missing from a given sorted list of natural numbers. In other words, starting from 0, the method should identify the first natural number that does not appear in the list. The input list is assumed to be sorted in non-decreasing order and contains only natural numbers (including 0).\n\n-----Input-----\nThe input consists of:\ns: A list of natural numbers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that does not appear in the input list.\n\n-----Note-----\nIt is assumed that the input list is sorted and contains only natural numbers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem smallestMissingNumber_spec_satisfied (s: List Nat) (h_precond : smallestMissingNumber_precond (s)) :\n    smallestMissingNumber_postcond (s) (smallestMissingNumber (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef smallestMissingNumber_precond (s : List Nat) : Prop :=\n  List.Pairwise (· ≤ ·) s\n\ndef smallestMissingNumber (s : List Nat) (h_precond : smallestMissingNumber_precond (s)) : Nat :=\n  let rec findMissing (v : Nat) (l : List Nat) : Nat :=\n    match l with\n    | [] => v\n    | x :: xs =>\n      if x > v then v\n      else if x = v then findMissing (v + 1) xs\n      else findMissing v xs\n  findMissing 0 s\n\n@[reducible, simp]\ndef smallestMissingNumber_postcond (s : List Nat) (result: Nat) (h_precond : smallestMissingNumber_precond (s)) :=\n  ¬ List.elem result s ∧ (∀ k : Nat, k < result → List.elem k s)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem smallestMissingNumber_spec_satisfied (s: List Nat) (h_precond : smallestMissingNumber_precond (s)) :\n    smallestMissingNumber_postcond (s) (smallestMissingNumber (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_33", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that returns the smallest natural number missing from a given sorted list of natural numbers. In other words, starting from 0, the method should identify the first natural number that does not appear in the list. The input list is assumed to be sorted in non-decreasing order and contains only natural numbers (including 0).\n\n-----Input-----\nThe input consists of:\ns: A list of natural numbers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that does not appear in the input list.\n\n-----Note-----\nIt is assumed that the input list is sorted and contains only natural numbers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem smallestMissingNumber_spec_satisfied (s: List Nat) (h_precond : smallestMissingNumber_precond (s)) :\n    smallestMissingNumber_postcond (s) (smallestMissingNumber (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef smallestMissingNumber_precond (s : List Nat) : Prop :=\n  List.Pairwise (· ≤ ·) s\n\ndef smallestMissingNumber (s : List Nat) (h_precond : smallestMissingNumber_precond (s)) : Nat :=\n  let rec findMissing (v : Nat) (l : List Nat) : Nat :=\n    match l with\n    | [] => v\n    | x :: xs =>\n      if x > v then v\n      else if x = v then findMissing (v + 1) xs\n      else findMissing v xs\n  findMissing 0 s\n\n@[reducible, simp]\ndef smallestMissingNumber_postcond (s : List Nat) (result: Nat) (h_precond : smallestMissingNumber_precond (s)) :=\n  ¬ List.elem result s ∧ (∀ k : Nat, k < result → List.elem k s)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem smallestMissingNumber_spec_satisfied (s: List Nat) (h_precond : smallestMissingNumber_precond (s)) :\n    smallestMissingNumber_postcond (s) (smallestMissingNumber (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_33"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that extracts even numbers from an array of integers. The method should return a new array containing only the even numbers found in the input array, while preserving the order in which they appear.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all the even numbers from the input array. Specifically:\n- Every element in the output array is an even integer.\n- All even integers present in the input array are included in the output array.\n- The relative order of the even integers is preserved as in the input array.\n\n-----Note-----\nThere are no preconditions for this task; the method will work with any array, including empty arrays (which are not null).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : findEvenNumbers_precond (arr)) :\n    findEvenNumbers_postcond (arr) (findEvenNumbers (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0\n\n@[reducible, simp]\ndef findEvenNumbers_precond (arr : Array Int) : Prop :=\n  True\n\ndef findEvenNumbers (arr : Array Int) (h_precond : findEvenNumbers_precond (arr)) : Array Int :=\n  arr.foldl (fun acc x => if isEven x then acc.push x else acc) #[]\n\n@[reducible, simp]\ndef findEvenNumbers_postcond (arr : Array Int) (result: Array Int) (h_precond : findEvenNumbers_precond (arr)) :=\n  (∀ x, x ∈ result → isEven x ∧ x ∈ arr.toList) ∧\n  (∀ x, x ∈ arr.toList → isEven x → x ∈ result) ∧\n  (∀ x y, x ∈ arr.toList → y ∈ arr.toList →\n    isEven x → isEven y →\n    arr.toList.idxOf x ≤ arr.toList.idxOf y →\n    result.toList.idxOf x ≤ result.toList.idxOf y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : findEvenNumbers_precond (arr)) :\n    findEvenNumbers_postcond (arr) (findEvenNumbers (arr) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_34", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that extracts even numbers from an array of integers. The method should return a new array containing only the even numbers found in the input array, while preserving the order in which they appear.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all the even numbers from the input array. Specifically:\n- Every element in the output array is an even integer.\n- All even integers present in the input array are included in the output array.\n- The relative order of the even integers is preserved as in the input array.\n\n-----Note-----\nThere are no preconditions for this task; the method will work with any array, including empty arrays (which are not null).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : findEvenNumbers_precond (arr)) :\n    findEvenNumbers_postcond (arr) (findEvenNumbers (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0\n\n@[reducible, simp]\ndef findEvenNumbers_precond (arr : Array Int) : Prop :=\n  True\n\ndef findEvenNumbers (arr : Array Int) (h_precond : findEvenNumbers_precond (arr)) : Array Int :=\n  arr.foldl (fun acc x => if isEven x then acc.push x else acc) #[]\n\n@[reducible, simp]\ndef findEvenNumbers_postcond (arr : Array Int) (result: Array Int) (h_precond : findEvenNumbers_precond (arr)) :=\n  (∀ x, x ∈ result → isEven x ∧ x ∈ arr.toList) ∧\n  (∀ x, x ∈ arr.toList → isEven x → x ∈ result) ∧\n  (∀ x y, x ∈ arr.toList → y ∈ arr.toList →\n    isEven x → isEven y →\n    arr.toList.idxOf x ≤ arr.toList.idxOf y →\n    result.toList.idxOf x ≤ result.toList.idxOf y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : findEvenNumbers_precond (arr)) :\n    findEvenNumbers_postcond (arr) (findEvenNumbers (arr) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_34"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that rearranges an array of integers by moving all zero values to the end of the array. The method should ensure that the relative order of the non-zero elements remains the same, the overall size of the array is unchanged, and the number of zeroes in the array stays constant.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array where:\n- The length is the same as that of the input array.\n- All zero values are positioned at the end.\n- The relative order of non-zero elements is preserved.\n- The count of zero values remains the same as in the input array.\n\n-----Note-----\nThere are no preconditions; the method will always work for any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem MoveZeroesToEnd_spec_satisfied (arr: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :\n    MoveZeroesToEnd_postcond (arr) (MoveZeroesToEnd (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef MoveZeroesToEnd_precond (arr : Array Int) : Prop :=\n  True\n\ndef MoveZeroesToEnd (arr : Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) : Array Int :=\n  let nonZeros := arr.toList.filter (· ≠ 0)\n  let zeros := arr.toList.filter (· = 0)\n  Array.mk (nonZeros ++ zeros)\n\n@[reducible, simp]\ndef MoveZeroesToEnd_postcond (arr : Array Int) (result: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :=\n  let firstResZeroIdx := result.toList.idxOf 0\n  List.isPerm result.toList arr.toList ∧\n  result.toList.take firstResZeroIdx = arr.toList.filter (· ≠ 0) ∧\n  result.toList.drop firstResZeroIdx = arr.toList.filter (· = 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem MoveZeroesToEnd_spec_satisfied (arr: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :\n    MoveZeroesToEnd_postcond (arr) (MoveZeroesToEnd (arr) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_35", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that rearranges an array of integers by moving all zero values to the end of the array. The method should ensure that the relative order of the non-zero elements remains the same, the overall size of the array is unchanged, and the number of zeroes in the array stays constant.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array where:\n- The length is the same as that of the input array.\n- All zero values are positioned at the end.\n- The relative order of non-zero elements is preserved.\n- The count of zero values remains the same as in the input array.\n\n-----Note-----\nThere are no preconditions; the method will always work for any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem MoveZeroesToEnd_spec_satisfied (arr: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :\n    MoveZeroesToEnd_postcond (arr) (MoveZeroesToEnd (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef MoveZeroesToEnd_precond (arr : Array Int) : Prop :=\n  True\n\ndef MoveZeroesToEnd (arr : Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) : Array Int :=\n  let nonZeros := arr.toList.filter (· ≠ 0)\n  let zeros := arr.toList.filter (· = 0)\n  Array.mk (nonZeros ++ zeros)\n\n@[reducible, simp]\ndef MoveZeroesToEnd_postcond (arr : Array Int) (result: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :=\n  let firstResZeroIdx := result.toList.idxOf 0\n  List.isPerm result.toList arr.toList ∧\n  result.toList.take firstResZeroIdx = arr.toList.filter (· ≠ 0) ∧\n  result.toList.drop firstResZeroIdx = arr.toList.filter (· = 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem MoveZeroesToEnd_spec_satisfied (arr: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :\n    MoveZeroesToEnd_postcond (arr) (MoveZeroesToEnd (arr) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_35"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that takes a given string and returns a new string where every occurrence of a space, comma, or dot is replaced with a colon. The transformation must preserve the original string’s length and leave all other characters unmodified.\n\n-----Input-----  \nThe input consists of:  \ns: A string.\n\n-----Output-----  \nThe output is a string:  \n- The returned string must have the same length as the input string.  \n- Every space, comma, or dot in the input string is replaced with a colon.  \n- All other characters remain unchanged.\n\n-----Note-----  \nThere are no preconditions; the input string is assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isSpaceCommaDot (c : Char) : Bool :=\n  if c = ' ' then true\n  else if c = ',' then true\n  else if c = '.' then true\n  else false\n\n@[reducible, simp]\ndef replaceWithColon_precond (s : String) : Prop :=\n  True\n\ndef replaceWithColon (s : String) (h_precond : replaceWithColon_precond (s)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isSpaceCommaDot c then ':' else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef replaceWithColon_postcond (s : String) (result: String) (h_precond : replaceWithColon_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length ∧\n  (∀ i, i < s.length →\n    (isSpaceCommaDot cs[i]! → cs'[i]! = ':') ∧\n    (¬isSpaceCommaDot cs[i]! → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n  unfold replaceWithColon replaceWithColon_postcond\n  simp\n  constructor\n  · unfold String.length\n    simp\n  · intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_36", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that takes a given string and returns a new string where every occurrence of a space, comma, or dot is replaced with a colon. The transformation must preserve the original string’s length and leave all other characters unmodified.\n\n-----Input-----  \nThe input consists of:  \ns: A string.\n\n-----Output-----  \nThe output is a string:  \n- The returned string must have the same length as the input string.  \n- Every space, comma, or dot in the input string is replaced with a colon.  \n- All other characters remain unchanged.\n\n-----Note-----  \nThere are no preconditions; the input string is assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isSpaceCommaDot (c : Char) : Bool :=\n  if c = ' ' then true\n  else if c = ',' then true\n  else if c = '.' then true\n  else false\n\n@[reducible, simp]\ndef replaceWithColon_precond (s : String) : Prop :=\n  True\n\ndef replaceWithColon (s : String) (h_precond : replaceWithColon_precond (s)) : String :=\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isSpaceCommaDot c then ':' else c)\n  String.mk cs'\n\n@[reducible, simp]\ndef replaceWithColon_postcond (s : String) (result: String) (h_precond : replaceWithColon_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length ∧\n  (∀ i, i < s.length →\n    (isSpaceCommaDot cs[i]! → cs'[i]! = ':') ∧\n    (¬isSpaceCommaDot cs[i]! → cs'[i]! = cs[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n```", "ground_truth": "theorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n  unfold replaceWithColon replaceWithColon_postcond\n  simp\n  constructor\n  · unfold String.length\n    simp\n  · intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_36"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that locates the first occurrence of a specified integer within a sorted array of integers. The method returns the index corresponding to the first time the target value appears in the array; if the target is absent, it returns -1. It is also essential that the original array remains unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of integers sorted in non-decreasing order.  \n• target: An integer representing the value to search for.\n\n-----Output-----  \nThe output is an integer:  \n• If the target is found, the method returns the index of its first occurrence.  \n• If the target is not found, the method returns -1.\n\n-----Note-----  \n• The input array must be sorted in non-decreasing order.  \n• The array is guaranteed to remain unmodified after the method executes.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findFirstOccurrence_spec_satisfied (arr: Array Int) (target: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :\n    findFirstOccurrence_postcond (arr) (target) (findFirstOccurrence (arr) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef findFirstOccurrence_precond (arr : Array Int) (target : Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr.toList\n\ndef findFirstOccurrence (arr : Array Int) (target : Int) (h_precond : findFirstOccurrence_precond (arr) (target)) : Int :=\n  let rec loop (i : Nat) : Int :=\n    if i < arr.size then\n      let a := arr[i]!\n      if a = target then i\n      else if a > target then -1\n      else loop (i + 1)\n    else -1\n  loop 0\n\n@[reducible, simp]\ndef findFirstOccurrence_postcond (arr : Array Int) (target : Int) (result: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :=\n  (result ≥ 0 →\n    arr[result.toNat]! = target ∧\n    (∀ i : Nat, i < result.toNat → arr[i]! ≠ target)) ∧\n  (result = -1 →\n    (∀ i : Nat, i < arr.size → arr[i]! ≠ target))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findFirstOccurrence_spec_satisfied (arr: Array Int) (target: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :\n    findFirstOccurrence_postcond (arr) (target) (findFirstOccurrence (arr) (target) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_37", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that locates the first occurrence of a specified integer within a sorted array of integers. The method returns the index corresponding to the first time the target value appears in the array; if the target is absent, it returns -1. It is also essential that the original array remains unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of integers sorted in non-decreasing order.  \n• target: An integer representing the value to search for.\n\n-----Output-----  \nThe output is an integer:  \n• If the target is found, the method returns the index of its first occurrence.  \n• If the target is not found, the method returns -1.\n\n-----Note-----  \n• The input array must be sorted in non-decreasing order.  \n• The array is guaranteed to remain unmodified after the method executes.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findFirstOccurrence_spec_satisfied (arr: Array Int) (target: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :\n    findFirstOccurrence_postcond (arr) (target) (findFirstOccurrence (arr) (target) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef findFirstOccurrence_precond (arr : Array Int) (target : Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr.toList\n\ndef findFirstOccurrence (arr : Array Int) (target : Int) (h_precond : findFirstOccurrence_precond (arr) (target)) : Int :=\n  let rec loop (i : Nat) : Int :=\n    if i < arr.size then\n      let a := arr[i]!\n      if a = target then i\n      else if a > target then -1\n      else loop (i + 1)\n    else -1\n  loop 0\n\n@[reducible, simp]\ndef findFirstOccurrence_postcond (arr : Array Int) (target : Int) (result: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :=\n  (result ≥ 0 →\n    arr[result.toNat]! = target ∧\n    (∀ i : Nat, i < result.toNat → arr[i]! ≠ target)) ∧\n  (result = -1 →\n    (∀ i : Nat, i < arr.size → arr[i]! ≠ target))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findFirstOccurrence_spec_satisfied (arr: Array Int) (target: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :\n    findFirstOccurrence_postcond (arr) (target) (findFirstOccurrence (arr) (target) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_37"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that checks whether all characters in an input string are identical. The method should return true if every character in the string is the same, and false if at least one character differs. An empty string or a single-character string is considered to have all characters identical.\n\n-----Input-----  \nThe input consists of:  \ns: A string.\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if every character in the string is identical.  \nReturns false if there is at least one differing character.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem allCharactersSame_spec_satisfied (s: String) (h_precond : allCharactersSame_precond (s)) :\n    allCharactersSame_postcond (s) (allCharactersSame (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef allCharactersSame_precond (s : String) : Prop :=\n  True\n\ndef allCharactersSame (s : String) (h_precond : allCharactersSame_precond (s)) : Bool :=\n  match s.toList with\n  | []      => true\n  | c :: cs => cs.all (fun x => x = c)\n\n@[reducible, simp]\ndef allCharactersSame_postcond (s : String) (result: Bool) (h_precond : allCharactersSame_precond (s)) :=\n  let cs := s.toList\n  (result → List.Pairwise (· = ·) cs) ∧\n  (¬ result → (cs ≠ [] ∧ cs.any (fun x => x ≠ cs[0]!)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem allCharactersSame_spec_satisfied (s: String) (h_precond : allCharactersSame_precond (s)) :\n    allCharactersSame_postcond (s) (allCharactersSame (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_38", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that checks whether all characters in an input string are identical. The method should return true if every character in the string is the same, and false if at least one character differs. An empty string or a single-character string is considered to have all characters identical.\n\n-----Input-----  \nThe input consists of:  \ns: A string.\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if every character in the string is identical.  \nReturns false if there is at least one differing character.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem allCharactersSame_spec_satisfied (s: String) (h_precond : allCharactersSame_precond (s)) :\n    allCharactersSame_postcond (s) (allCharactersSame (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef allCharactersSame_precond (s : String) : Prop :=\n  True\n\ndef allCharactersSame (s : String) (h_precond : allCharactersSame_precond (s)) : Bool :=\n  match s.toList with\n  | []      => true\n  | c :: cs => cs.all (fun x => x = c)\n\n@[reducible, simp]\ndef allCharactersSame_postcond (s : String) (result: Bool) (h_precond : allCharactersSame_precond (s)) :=\n  let cs := s.toList\n  (result → List.Pairwise (· = ·) cs) ∧\n  (¬ result → (cs ≠ [] ∧ cs.any (fun x => x ≠ cs[0]!)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem allCharactersSame_spec_satisfied (s: String) (h_precond : allCharactersSame_precond (s)) :\n    allCharactersSame_postcond (s) (allCharactersSame (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_38"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.\n\n-----Input-----  \nThe input consists of:  \n• l: A list of integers.  \n• n: A non-negative natural number that indicates the number of positions by which to rotate the list.\n\n-----Output-----  \nThe output is a list of integers:  \n• Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.\n\n-----Note-----  \n• The precondition requires that n is non-negative.  \n• If the input list is empty, it should be returned unchanged.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :\n    rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef rotateRight_precond (l : List Int) (n : Nat) : Prop :=\n  True\n\ndef rotateRight (l : List Int) (n : Nat) (h_precond : rotateRight_precond (l) (n)) : List Int :=\n  let len := l.length\n  if len = 0 then l\n  else\n    (List.range len).map (fun i : Nat =>\n      let idx_int : Int := ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n      let idx_nat : Nat := Int.toNat idx_int\n      l.getD idx_nat (l.headD 0)\n    )\n\n@[reducible, simp]\ndef rotateRight_postcond (l : List Int) (n : Nat) (result: List Int) (h_precond : rotateRight_precond (l) (n)) :=\n  result.length = l.length ∧\n  (∀ i : Nat, i < l.length →\n    let len := l.length\n    let rotated_index := Int.toNat ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n    result[i]? = l[rotated_index]?)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :\n    rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_39", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.\n\n-----Input-----  \nThe input consists of:  \n• l: A list of integers.  \n• n: A non-negative natural number that indicates the number of positions by which to rotate the list.\n\n-----Output-----  \nThe output is a list of integers:  \n• Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.\n\n-----Note-----  \n• The precondition requires that n is non-negative.  \n• If the input list is empty, it should be returned unchanged.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :\n    rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef rotateRight_precond (l : List Int) (n : Nat) : Prop :=\n  True\n\ndef rotateRight (l : List Int) (n : Nat) (h_precond : rotateRight_precond (l) (n)) : List Int :=\n  let len := l.length\n  if len = 0 then l\n  else\n    (List.range len).map (fun i : Nat =>\n      let idx_int : Int := ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n      let idx_nat : Nat := Int.toNat idx_int\n      l.getD idx_nat (l.headD 0)\n    )\n\n@[reducible, simp]\ndef rotateRight_postcond (l : List Int) (n : Nat) (result: List Int) (h_precond : rotateRight_precond (l) (n)) :=\n  result.length = l.length ∧\n  (∀ i : Nat, i < l.length →\n    let len := l.length\n    let rotated_index := Int.toNat ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n    result[i]? = l[rotated_index]?)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :\n    rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_39"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the kth element in a given array using 1-based indexing. The method should return the element at the specified position, where the first element is at position 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\nk: An integer representing the position (1-based index) of the element to find.\n\n-----Output-----\nThe output is an integer:\nReturns the element at the kth position in the array.\n\n-----Note-----\nThe input k is assumed to be valid (between 1 and array length inclusive).\nThe array is assumed to be non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef kthElement_precond (arr : Array Int) (k : Nat) : Prop :=\n  k ≥ 1 ∧ k ≤ arr.size\n\ndef kthElement (arr : Array Int) (k : Nat) (h_precond : kthElement_precond (arr) (k)) : Int :=\n  arr[k - 1]!\n\n@[reducible, simp]\ndef kthElement_postcond (arr : Array Int) (k : Nat) (result: Int) (h_precond : kthElement_precond (arr) (k)) :=\n  arr.any (fun x => x = result ∧ x = arr[k - 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n  unfold kthElement kthElement_postcond\n  unfold kthElement_precond at h_precond\n  have ⟨hp1, hp2⟩ := h_precond\n  simp_all\n  have h': k - 1 < arr.size := by\n    exact Nat.sub_one_lt_of_le hp1 hp2\n  exists k - 1\n  exists h'\n  exact Eq.symm (getElem!_pos arr (k - 1) ((Iff.of_eq (Eq.refl (k - 1 < arr.size))).mpr h'))"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_4", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the kth element in a given array using 1-based indexing. The method should return the element at the specified position, where the first element is at position 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\nk: An integer representing the position (1-based index) of the element to find.\n\n-----Output-----\nThe output is an integer:\nReturns the element at the kth position in the array.\n\n-----Note-----\nThe input k is assumed to be valid (between 1 and array length inclusive).\nThe array is assumed to be non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef kthElement_precond (arr : Array Int) (k : Nat) : Prop :=\n  k ≥ 1 ∧ k ≤ arr.size\n\ndef kthElement (arr : Array Int) (k : Nat) (h_precond : kthElement_precond (arr) (k)) : Int :=\n  arr[k - 1]!\n\n@[reducible, simp]\ndef kthElement_postcond (arr : Array Int) (k : Nat) (result: Int) (h_precond : kthElement_precond (arr) (k)) :=\n  arr.any (fun x => x = result ∧ x = arr[k - 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n```", "ground_truth": "theorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n  unfold kthElement kthElement_postcond\n  unfold kthElement_precond at h_precond\n  have ⟨hp1, hp2⟩ := h_precond\n  simp_all\n  have h': k - 1 < arr.size := by\n    exact Nat.sub_one_lt_of_le hp1 hp2\n  exists k - 1\n  exists h'\n  exact Eq.symm (getElem!_pos arr (k - 1) ((Iff.of_eq (Eq.refl (k - 1 < arr.size))).mpr h'))", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_4"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the second-smallest number in an array of integers. The method should determine and return the number that is larger than the smallest element in the array. It is crucial that the input array remains unchanged after the computation.\n\n-----Input-----\nThe input consists of:\ns: An array of integers containing at least two elements.\n\n-----Output-----\nThe output is an integer:\nReturns the second-smallest number in the input array.\n\n-----Note-----\n- The input array is guaranteed to contain at least two elements and is non-null.\n- It is assumed that there exist at least two distinct values in the array to ensure a unique second-smallest element.\n- The original array must remain unmodified.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem secondSmallest_spec_satisfied (s: Array Int) (h_precond : secondSmallest_precond (s)) :\n    secondSmallest_postcond (s) (secondSmallest (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef secondSmallest_precond (s : Array Int) : Prop :=\n  s.size > 1\n\ndef minListHelper : List Int → Int\n| [] => panic! \"minListHelper: empty list\"\n| [_] => panic! \"minListHelper: singleton list\"\n| a :: b :: [] => if a ≤ b then a else b\n| a :: b :: c :: xs =>\n    let m := minListHelper (b :: c :: xs)\n    if a ≤ m then a else m\n\ndef minList (l : List Int) : Int :=\n  minListHelper l\n\ndef secondSmallestAux (s : Array Int) (i minIdx secondIdx : Nat) : Int :=\n  if i ≥ s.size then\n    s[secondIdx]!\n  else\n    let x    := s[i]!\n    let m    := s[minIdx]!\n    let smin := s[secondIdx]!\n    if x < m then\n      secondSmallestAux s (i + 1) i minIdx\n    else if x < smin then\n      secondSmallestAux s (i + 1) minIdx i\n    else\n      secondSmallestAux s (i + 1) minIdx secondIdx\ntermination_by s.size - i\n\ndef secondSmallest (s : Array Int) (h_precond : secondSmallest_precond (s)) : Int :=\n  let (minIdx, secondIdx) :=\n    if s[1]! < s[0]! then (1, 0) else (0, 1)\n  secondSmallestAux s 2 minIdx secondIdx\n\n@[reducible, simp]\ndef secondSmallest_postcond (s : Array Int) (result: Int) (h_precond : secondSmallest_precond (s)) :=\n  (∃ i, i < s.size ∧ s[i]! = result) ∧\n  (∃ j, j < s.size ∧ s[j]! < result ∧\n    ∀ k, k < s.size → s[k]! ≠ s[j]! → s[k]! ≥ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem secondSmallest_spec_satisfied (s: Array Int) (h_precond : secondSmallest_precond (s)) :\n    secondSmallest_postcond (s) (secondSmallest (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_40", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the second-smallest number in an array of integers. The method should determine and return the number that is larger than the smallest element in the array. It is crucial that the input array remains unchanged after the computation.\n\n-----Input-----\nThe input consists of:\ns: An array of integers containing at least two elements.\n\n-----Output-----\nThe output is an integer:\nReturns the second-smallest number in the input array.\n\n-----Note-----\n- The input array is guaranteed to contain at least two elements and is non-null.\n- It is assumed that there exist at least two distinct values in the array to ensure a unique second-smallest element.\n- The original array must remain unmodified.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem secondSmallest_spec_satisfied (s: Array Int) (h_precond : secondSmallest_precond (s)) :\n    secondSmallest_postcond (s) (secondSmallest (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef secondSmallest_precond (s : Array Int) : Prop :=\n  s.size > 1\n\ndef minListHelper : List Int → Int\n| [] => panic! \"minListHelper: empty list\"\n| [_] => panic! \"minListHelper: singleton list\"\n| a :: b :: [] => if a ≤ b then a else b\n| a :: b :: c :: xs =>\n    let m := minListHelper (b :: c :: xs)\n    if a ≤ m then a else m\n\ndef minList (l : List Int) : Int :=\n  minListHelper l\n\ndef secondSmallestAux (s : Array Int) (i minIdx secondIdx : Nat) : Int :=\n  if i ≥ s.size then\n    s[secondIdx]!\n  else\n    let x    := s[i]!\n    let m    := s[minIdx]!\n    let smin := s[secondIdx]!\n    if x < m then\n      secondSmallestAux s (i + 1) i minIdx\n    else if x < smin then\n      secondSmallestAux s (i + 1) minIdx i\n    else\n      secondSmallestAux s (i + 1) minIdx secondIdx\ntermination_by s.size - i\n\ndef secondSmallest (s : Array Int) (h_precond : secondSmallest_precond (s)) : Int :=\n  let (minIdx, secondIdx) :=\n    if s[1]! < s[0]! then (1, 0) else (0, 1)\n  secondSmallestAux s 2 minIdx secondIdx\n\n@[reducible, simp]\ndef secondSmallest_postcond (s : Array Int) (result: Int) (h_precond : secondSmallest_precond (s)) :=\n  (∃ i, i < s.size ∧ s[i]! = result) ∧\n  (∃ j, j < s.size ∧ s[j]! < result ∧\n    ∀ k, k < s.size → s[k]! ≠ s[j]! → s[k]! ≥ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem secondSmallest_spec_satisfied (s: Array Int) (h_precond : secondSmallest_precond (s)) :\n    secondSmallest_postcond (s) (secondSmallest (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_40"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that determines whether an array of integers contains only one distinct element. The method should return true if the array is empty or if every element in the array is the same, and false if there are at least two different elements.\n\n-----Input-----  \nThe input consists of:  \na: An array of integers.\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if the array is empty or if all elements in the array are identical.  \nReturns false if the array contains at least two distinct elements.\n\n-----Note-----  \nThe input array is assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasOnlyOneDistinctElement_spec_satisfied (a: Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) :\n    hasOnlyOneDistinctElement_postcond (a) (hasOnlyOneDistinctElement (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef hasOnlyOneDistinctElement_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef hasOnlyOneDistinctElement (a : Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) : Bool :=\n  if a.size = 0 then\n    true\n  else\n    let firstElement := a[0]!\n    let rec loop (i : Nat) : Bool :=\n      if h : i < a.size then\n        if a[i]! = firstElement then loop (i + 1) else false\n      else\n        true\n    loop 1\n\n@[reducible, simp]\ndef hasOnlyOneDistinctElement_postcond (a : Array Int) (result: Bool) (h_precond : hasOnlyOneDistinctElement_precond (a)) :=\n  let l := a.toList\n  (result → List.Pairwise (· = ·) l) ∧\n  (¬ result → (l.any (fun x => x ≠ l[0]!)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasOnlyOneDistinctElement_spec_satisfied (a: Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) :\n    hasOnlyOneDistinctElement_postcond (a) (hasOnlyOneDistinctElement (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_41", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that determines whether an array of integers contains only one distinct element. The method should return true if the array is empty or if every element in the array is the same, and false if there are at least two different elements.\n\n-----Input-----  \nThe input consists of:  \na: An array of integers.\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if the array is empty or if all elements in the array are identical.  \nReturns false if the array contains at least two distinct elements.\n\n-----Note-----  \nThe input array is assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasOnlyOneDistinctElement_spec_satisfied (a: Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) :\n    hasOnlyOneDistinctElement_postcond (a) (hasOnlyOneDistinctElement (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef hasOnlyOneDistinctElement_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef hasOnlyOneDistinctElement (a : Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) : Bool :=\n  if a.size = 0 then\n    true\n  else\n    let firstElement := a[0]!\n    let rec loop (i : Nat) : Bool :=\n      if h : i < a.size then\n        if a[i]! = firstElement then loop (i + 1) else false\n      else\n        true\n    loop 1\n\n@[reducible, simp]\ndef hasOnlyOneDistinctElement_postcond (a : Array Int) (result: Bool) (h_precond : hasOnlyOneDistinctElement_precond (a)) :=\n  let l := a.toList\n  (result → List.Pairwise (· = ·) l) ∧\n  (¬ result → (l.any (fun x => x ≠ l[0]!)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasOnlyOneDistinctElement_spec_satisfied (a: Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) :\n    hasOnlyOneDistinctElement_postcond (a) (hasOnlyOneDistinctElement (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_41"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that counts the number of digit characters within a given string. A digit is any character between '0' and '9'. The method should determine how many such digit characters appear in the input.\n\n-----Input-----  \nThe input consists of:  \ns: A string.\n\n-----Output-----  \nThe output is a natural number (Nat):  \nReturns a non-negative count representing the number of digit characters found in the input string.\n\n-----Note-----  \nThere are no additional preconditions; the method works for any provided string.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isDigit (c : Char) : Bool :=\n  '0' ≤ c ∧ c ≤ '9'\n\n@[reducible, simp]\ndef countDigits_precond (s : String) : Prop :=\n  True\n\ndef countDigits (s : String) (h_precond : countDigits_precond (s)) : Nat :=\n  List.length (List.filter isDigit s.toList)\n\n@[reducible, simp]\ndef countDigits_postcond (s : String) (result: Nat) (h_precond : countDigits_precond (s)) :=\n  result - List.length (List.filter isDigit s.toList) = 0 ∧\n  List.length (List.filter isDigit s.toList) - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n  unfold countDigits countDigits_postcond\n  simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_42", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that counts the number of digit characters within a given string. A digit is any character between '0' and '9'. The method should determine how many such digit characters appear in the input.\n\n-----Input-----  \nThe input consists of:  \ns: A string.\n\n-----Output-----  \nThe output is a natural number (Nat):  \nReturns a non-negative count representing the number of digit characters found in the input string.\n\n-----Note-----  \nThere are no additional preconditions; the method works for any provided string.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isDigit (c : Char) : Bool :=\n  '0' ≤ c ∧ c ≤ '9'\n\n@[reducible, simp]\ndef countDigits_precond (s : String) : Prop :=\n  True\n\ndef countDigits (s : String) (h_precond : countDigits_precond (s)) : Nat :=\n  List.length (List.filter isDigit s.toList)\n\n@[reducible, simp]\ndef countDigits_postcond (s : String) (result: Nat) (h_precond : countDigits_precond (s)) :=\n  result - List.length (List.filter isDigit s.toList) = 0 ∧\n  List.length (List.filter isDigit s.toList) - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n```", "ground_truth": "theorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n  unfold countDigits countDigits_postcond\n  simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_42"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the sum of the fourth power of the first n odd natural numbers. In other words, given a non-negative integer n, the method should calculate the sum: 1⁴ + 3⁴ + 5⁴ + ... for the first n odd numbers.\n\n-----Input-----\nThe input consists of:\nn: A non-negative natural number representing the number of odd natural numbers to consider.\n\n-----Output----- \nThe output is a natural number:\nReturns the sum of the fourth power of the first n odd natural numbers.\n\n-----Note----- \nThe input n is assumed to be a non-negative integer.\nThe correctness of the result is established by a theorem that relates the computed sum to a specific formula.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumOfFourthPowerOfOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :\n    sumOfFourthPowerOfOddNumbers_postcond (n) (sumOfFourthPowerOfOddNumbers (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumOfFourthPowerOfOddNumbers_precond (n : Nat) : Prop :=\n  True\n\ndef sumOfFourthPowerOfOddNumbers (n : Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) : Nat :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let prev := sumOfFourthPowerOfOddNumbers n h_precond\n    let nextOdd := 2 * n + 1\n    prev + nextOdd^4\n\n@[reducible, simp]\ndef sumOfFourthPowerOfOddNumbers_postcond (n : Nat) (result: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :=\n  15 * result = n * (2 * n + 1) * (7 + 24 * n^3 - 12 * n^2 - 14 * n)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumOfFourthPowerOfOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :\n    sumOfFourthPowerOfOddNumbers_postcond (n) (sumOfFourthPowerOfOddNumbers (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_43", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the sum of the fourth power of the first n odd natural numbers. In other words, given a non-negative integer n, the method should calculate the sum: 1⁴ + 3⁴ + 5⁴ + ... for the first n odd numbers.\n\n-----Input-----\nThe input consists of:\nn: A non-negative natural number representing the number of odd natural numbers to consider.\n\n-----Output----- \nThe output is a natural number:\nReturns the sum of the fourth power of the first n odd natural numbers.\n\n-----Note----- \nThe input n is assumed to be a non-negative integer.\nThe correctness of the result is established by a theorem that relates the computed sum to a specific formula.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumOfFourthPowerOfOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :\n    sumOfFourthPowerOfOddNumbers_postcond (n) (sumOfFourthPowerOfOddNumbers (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumOfFourthPowerOfOddNumbers_precond (n : Nat) : Prop :=\n  True\n\ndef sumOfFourthPowerOfOddNumbers (n : Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) : Nat :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let prev := sumOfFourthPowerOfOddNumbers n h_precond\n    let nextOdd := 2 * n + 1\n    prev + nextOdd^4\n\n@[reducible, simp]\ndef sumOfFourthPowerOfOddNumbers_postcond (n : Nat) (result: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :=\n  15 * result = n * (2 * n + 1) * (7 + 24 * n^3 - 12 * n^2 - 14 * n)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumOfFourthPowerOfOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :\n    sumOfFourthPowerOfOddNumbers_postcond (n) (sumOfFourthPowerOfOddNumbers (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_43"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if, for every odd index in the array, the corresponding element is odd.\nReturns false if there is at least one odd index where the corresponding element is not odd.\n\n-----Note-----\nThere are no preconditions; the method will work for any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 == 1\n\n@[reducible, simp]\ndef isOddAtIndexOdd_precond (a : Array Int) : Prop :=\n  True\n\ndef isOddAtIndexOdd (a : Array Int) (h_precond : isOddAtIndexOdd_precond (a)) : Bool :=\n  let indexedArray := a.mapIdx fun i x => (i, x)\n\n  indexedArray.all fun (i, x) => !(isOdd i) || isOdd x\n\n@[reducible, simp]\ndef isOddAtIndexOdd_postcond (a : Array Int) (result: Bool) (h_precond : isOddAtIndexOdd_precond (a)) :=\n  result ↔ (∀ i, (hi : i < a.size) → isOdd i → isOdd (a[i]))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n  unfold isOddAtIndexOdd isOddAtIndexOdd_postcond\n  simp_all\n  constructor\n  · intro h\n    intro i hi h_odd\n    have h_all_odd : (a.mapIdx (fun j x => (j, x))).all (fun (i, x) => !(isOdd i) || isOdd x) = true := by\n      simp_all\n    rw [Array.all_iff_forall] at h_all_odd\n    simp_all\n    have h_sat_i : !(isOdd i) || isOdd a[i] := by\n      simp\n      apply h_all_odd i hi\n    simp [h_odd] at h_sat_i\n    exact h_sat_i\n  · intro h\n    apply Array.all_iff_forall.mpr\n    intro i hi\n    simp\n    intro hi'\n    have h_sat : isOdd i → isOdd a[i] := by\n      apply h i hi'\n    rw [Decidable.imp_iff_not_or] at h_sat\n    simp at h_sat\n    exact h_sat"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_44", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if, for every odd index in the array, the corresponding element is odd.\nReturns false if there is at least one odd index where the corresponding element is not odd.\n\n-----Note-----\nThere are no preconditions; the method will work for any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 == 1\n\n@[reducible, simp]\ndef isOddAtIndexOdd_precond (a : Array Int) : Prop :=\n  True\n\ndef isOddAtIndexOdd (a : Array Int) (h_precond : isOddAtIndexOdd_precond (a)) : Bool :=\n  let indexedArray := a.mapIdx fun i x => (i, x)\n\n  indexedArray.all fun (i, x) => !(isOdd i) || isOdd x\n\n@[reducible, simp]\ndef isOddAtIndexOdd_postcond (a : Array Int) (result: Bool) (h_precond : isOddAtIndexOdd_precond (a)) :=\n  result ↔ (∀ i, (hi : i < a.size) → isOdd i → isOdd (a[i]))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n```", "ground_truth": "theorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n  unfold isOddAtIndexOdd isOddAtIndexOdd_postcond\n  simp_all\n  constructor\n  · intro h\n    intro i hi h_odd\n    have h_all_odd : (a.mapIdx (fun j x => (j, x))).all (fun (i, x) => !(isOdd i) || isOdd x) = true := by\n      simp_all\n    rw [Array.all_iff_forall] at h_all_odd\n    simp_all\n    have h_sat_i : !(isOdd i) || isOdd a[i] := by\n      simp\n      apply h_all_odd i hi\n    simp [h_odd] at h_sat_i\n    exact h_sat_i\n  · intro h\n    apply Array.all_iff_forall.mpr\n    intro i hi\n    simp\n    intro hi'\n    have h_sat : isOdd i → isOdd a[i] := by\n      apply h i hi'\n    rw [Decidable.imp_iff_not_or] at h_sat\n    simp at h_sat\n    exact h_sat", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_44"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.\n\n-----Input-----  \nThe input consists of:  \nlst: A list of integers.\n\n-----Output-----  \nThe output is an integer:  \nReturns the product resulting from multiplying the first even number and the first odd number found in the list.\n\n-----Note-----  \nThe input list is assumed to contain at least one even number and one odd number.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 ≠ 0\n\ndef firstEvenOddIndices (lst : List Int) : Option (Nat × Nat) :=\n  let evenIndex := lst.findIdx? isEven\n  let oddIndex := lst.findIdx? isOdd\n  match evenIndex, oddIndex with\n  | some ei, some oi => some (ei, oi)\n  | _, _ => none\n\n@[reducible, simp]\ndef findProduct_precond (lst : List Int) : Prop :=\n  lst.length > 1 ∧\n  (∃ x ∈ lst, isEven x) ∧\n  (∃ x ∈ lst, isOdd x)\n\ndef findProduct (lst : List Int) (h_precond : findProduct_precond (lst)) : Int :=\n  match firstEvenOddIndices lst with\n  | some (ei, oi) => lst[ei]! * lst[oi]!\n  | none => 0\n\n@[reducible, simp]\ndef findProduct_postcond (lst : List Int) (result: Int) (h_precond : findProduct_precond (lst)) :=\n  match firstEvenOddIndices lst with\n  | some (ei, oi) => result = lst[ei]! * lst[oi]!\n  | none => True\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n  unfold findProduct findProduct_postcond\n  split\n  case h_1 _ ei oi _ =>\n    split\n    case h_1 _ ei' oi' heq =>\n      have : ei = ei' ∧ oi = oi' := by\n        rw [Option.some_inj] at heq\n        cases heq with\n        | refl => exact ⟨rfl, rfl⟩\n      simp [this]\n    case h_2 _ heq => contradiction\n  case h_2 => simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_45", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.\n\n-----Input-----  \nThe input consists of:  \nlst: A list of integers.\n\n-----Output-----  \nThe output is an integer:  \nReturns the product resulting from multiplying the first even number and the first odd number found in the list.\n\n-----Note-----  \nThe input list is assumed to contain at least one even number and one odd number.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 ≠ 0\n\ndef firstEvenOddIndices (lst : List Int) : Option (Nat × Nat) :=\n  let evenIndex := lst.findIdx? isEven\n  let oddIndex := lst.findIdx? isOdd\n  match evenIndex, oddIndex with\n  | some ei, some oi => some (ei, oi)\n  | _, _ => none\n\n@[reducible, simp]\ndef findProduct_precond (lst : List Int) : Prop :=\n  lst.length > 1 ∧\n  (∃ x ∈ lst, isEven x) ∧\n  (∃ x ∈ lst, isOdd x)\n\ndef findProduct (lst : List Int) (h_precond : findProduct_precond (lst)) : Int :=\n  match firstEvenOddIndices lst with\n  | some (ei, oi) => lst[ei]! * lst[oi]!\n  | none => 0\n\n@[reducible, simp]\ndef findProduct_postcond (lst : List Int) (result: Int) (h_precond : findProduct_precond (lst)) :=\n  match firstEvenOddIndices lst with\n  | some (ei, oi) => result = lst[ei]! * lst[oi]!\n  | none => True\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n```", "ground_truth": "theorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n  unfold findProduct findProduct_postcond\n  split\n  case h_1 _ ei oi _ =>\n    split\n    case h_1 _ ei' oi' heq =>\n      have : ei = ei' ∧ oi = oi' := by\n        rw [Option.some_inj] at heq\n        cases heq with\n        | refl => exact ⟨rfl, rfl⟩\n      simp [this]\n    case h_2 _ heq => contradiction\n  case h_2 => simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_45"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the last occurrence of a specified element in a sorted array of integers. The method should return the index corresponding to the last occurrence of the element if it is present; if the element is absent, it should return -1. Additionally, the array must remain unchanged after the method is executed.\n\n-----Input-----\nThe input consists of:\narr: A sorted array of integers in non-decreasing order.\nelem: An integer whose last occurrence position is to be determined.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the last occurrence of the specified integer in the array if it exists.\nReturns -1 if the integer is not found in the array.\n\n-----Note-----\nThe input array is assumed to be sorted in non-decreasing order and remains unchanged by the method.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lastPosition_spec_satisfied (arr: Array Int) (elem: Int) (h_precond : lastPosition_precond (arr) (elem)) :\n    lastPosition_postcond (arr) (elem) (lastPosition (arr) (elem) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef lastPosition_precond (arr : Array Int) (elem : Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr.toList\n\ndef lastPosition (arr : Array Int) (elem : Int) (h_precond : lastPosition_precond (arr) (elem)) : Int :=\n  let rec loop (i : Nat) (pos : Int) : Int :=\n    if i < arr.size then\n      let a := arr[i]!\n      if a = elem then loop (i + 1) i\n      else loop (i + 1) pos\n    else pos\n  loop 0 (-1)\n\n@[reducible, simp]\ndef lastPosition_postcond (arr : Array Int) (elem : Int) (result: Int) (h_precond : lastPosition_precond (arr) (elem)) :=\n  (result ≥ 0 →\n    arr[result.toNat]! = elem ∧ (arr.toList.drop (result.toNat + 1)).all (· ≠ elem)) ∧\n  (result = -1 → arr.toList.all (· ≠ elem))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lastPosition_spec_satisfied (arr: Array Int) (elem: Int) (h_precond : lastPosition_precond (arr) (elem)) :\n    lastPosition_postcond (arr) (elem) (lastPosition (arr) (elem) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_46", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the last occurrence of a specified element in a sorted array of integers. The method should return the index corresponding to the last occurrence of the element if it is present; if the element is absent, it should return -1. Additionally, the array must remain unchanged after the method is executed.\n\n-----Input-----\nThe input consists of:\narr: A sorted array of integers in non-decreasing order.\nelem: An integer whose last occurrence position is to be determined.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the last occurrence of the specified integer in the array if it exists.\nReturns -1 if the integer is not found in the array.\n\n-----Note-----\nThe input array is assumed to be sorted in non-decreasing order and remains unchanged by the method.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem lastPosition_spec_satisfied (arr: Array Int) (elem: Int) (h_precond : lastPosition_precond (arr) (elem)) :\n    lastPosition_postcond (arr) (elem) (lastPosition (arr) (elem) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef lastPosition_precond (arr : Array Int) (elem : Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr.toList\n\ndef lastPosition (arr : Array Int) (elem : Int) (h_precond : lastPosition_precond (arr) (elem)) : Int :=\n  let rec loop (i : Nat) (pos : Int) : Int :=\n    if i < arr.size then\n      let a := arr[i]!\n      if a = elem then loop (i + 1) i\n      else loop (i + 1) pos\n    else pos\n  loop 0 (-1)\n\n@[reducible, simp]\ndef lastPosition_postcond (arr : Array Int) (elem : Int) (result: Int) (h_precond : lastPosition_precond (arr) (elem)) :=\n  (result ≥ 0 →\n    arr[result.toNat]! = elem ∧ (arr.toList.drop (result.toNat + 1)).all (· ≠ elem)) ∧\n  (result = -1 → arr.toList.all (· ≠ elem))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem lastPosition_spec_satisfied (arr: Array Int) (elem: Int) (h_precond : lastPosition_precond (arr) (elem)) :\n    lastPosition_postcond (arr) (elem) (lastPosition (arr) (elem) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_46"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the sum of all the elements in an array of integers. The method should process the entire array and return the total sum of its elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the sum of all elements in the input array.\n\n-----Note-----\n- The input array is assumed not to be null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef arraySum_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef arraySum (a : Array Int) (h_precond : arraySum_precond (a)) : Int :=\n  a.toList.sum\n\ndef sumTo (a : Array Int) (n : Nat) : Int :=\n  if n = 0 then 0\n  else sumTo a (n - 1) + a[n - 1]!\n\n@[reducible, simp]\ndef arraySum_postcond (a : Array Int) (result: Int) (h_precond : arraySum_precond (a)) :=\n  result - sumTo a a.size = 0 ∧\n  result ≥ sumTo a a.size\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n  unfold arraySum arraySum_postcond\n  apply eq_of_sub_zero_and_ge a.toList.sum (sumTo a a.size)\n  cases a with | mk d =>\n    induction d with\n    | nil => simp [sumTo]\n    | cons x xs ih =>\n      simp [ih]\n\n      have h1 : sumTo ⟨x::xs⟩ (xs.length + 1) = sumTo ⟨x::xs⟩ xs.length + (x::xs)[xs.length] := by\n        rw [sumTo]\n        simp\n\n      rw [h1]\n\n      have h2 : xs = List.nil → (x::xs)[xs.length] = x := by\n        intro h_nil\n        simp [h_nil]\n\n      have h3 (x' : Int) (xs' : List Int): xs'.length ≠ 0 → sumTo ⟨x'::xs'⟩ xs'.length = x' + sumTo ⟨xs'⟩ (xs'.length - 1) := by\n        induction xs'.length with\n        | zero => simp\n        | succ n ih_len =>\n          simp\n          cases n with\n          | zero => simp [sumTo]\n          | succ n' =>\n            simp at ih_len\n            unfold sumTo\n            simp_all\n            rw [Int.add_assoc]\n\n      cases xs with\n      | nil => simp [h2, sumTo]\n      | cons y ys =>\n        simp_all\n        have h4 : sumTo ⟨x::y::ys⟩ (ys.length + 1) = x + sumTo ⟨y::ys⟩ ys.length := by\n          apply h3 x (y::ys)\n          simp\n        rw [h4, sumTo]\n        simp\n        rw [Int.add_assoc]"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_47", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that calculates the sum of all the elements in an array of integers. The method should process the entire array and return the total sum of its elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the sum of all elements in the input array.\n\n-----Note-----\n- The input array is assumed not to be null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef arraySum_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef arraySum (a : Array Int) (h_precond : arraySum_precond (a)) : Int :=\n  a.toList.sum\n\ndef sumTo (a : Array Int) (n : Nat) : Int :=\n  if n = 0 then 0\n  else sumTo a (n - 1) + a[n - 1]!\n\n@[reducible, simp]\ndef arraySum_postcond (a : Array Int) (result: Int) (h_precond : arraySum_precond (a)) :=\n  result - sumTo a a.size = 0 ∧\n  result ≥ sumTo a a.size\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n```", "ground_truth": "theorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n  unfold arraySum arraySum_postcond\n  apply eq_of_sub_zero_and_ge a.toList.sum (sumTo a a.size)\n  cases a with | mk d =>\n    induction d with\n    | nil => simp [sumTo]\n    | cons x xs ih =>\n      simp [ih]\n\n      have h1 : sumTo ⟨x::xs⟩ (xs.length + 1) = sumTo ⟨x::xs⟩ xs.length + (x::xs)[xs.length] := by\n        rw [sumTo]\n        simp\n\n      rw [h1]\n\n      have h2 : xs = List.nil → (x::xs)[xs.length] = x := by\n        intro h_nil\n        simp [h_nil]\n\n      have h3 (x' : Int) (xs' : List Int): xs'.length ≠ 0 → sumTo ⟨x'::xs'⟩ xs'.length = x' + sumTo ⟨xs'⟩ (xs'.length - 1) := by\n        induction xs'.length with\n        | zero => simp\n        | succ n ih_len =>\n          simp\n          cases n with\n          | zero => simp [sumTo]\n          | succ n' =>\n            simp at ih_len\n            unfold sumTo\n            simp_all\n            rw [Int.add_assoc]\n\n      cases xs with\n      | nil => simp [h2, sumTo]\n      | cons y ys =>\n        simp_all\n        have h4 : sumTo ⟨x::y::ys⟩ (ys.length + 1) = x + sumTo ⟨y::ys⟩ ys.length := by\n          apply h3 x (y::ys)\n          simp\n        rw [h4, sumTo]\n        simp\n        rw [Int.add_assoc]", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_47"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that determines whether a given non-negative natural number is a perfect square. In other words, the method should return true if there exists a natural number whose square is equal to the input number, and false if no such number exists.\n\n-----Input-----  \nThe input consists of a single natural number:  \nn: A non-negative natural number (Nat).\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if there exists an integer such that its square equals the input n.  \nReturns false if no integer squared equals the input n.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem check_correct (n : Nat) (x fuel : Nat) :\n   isPerfectSquare.check n x fuel = true → ∃ i, x ≤ i ∧ i * i = n := by\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp_all\n\n    if hgt : x * x > n then\n      simp_all\n    else if heq : x * x = n then\n      simp_all\n      exists x\n    else\n      simp_all\n      have h_rec := ih (x + 1)\n      intro h\n      have ⟨i, hi, heqi⟩ := h_rec h\n      exists i\n      constructor\n      · -- Show x ≤ i by transitivity: x ≤ x+1 ≤ i\n        exact Nat.le_trans (Nat.le_succ x) hi\n      · -- Pass through the equality i * i = n\n        exact heqi\n\ntheorem check_complete (n : Nat) (x fuel : Nat) (i : Nat)\n    (hx : x ≤ i) (hi : i * i = n) (hfuel : i < x + fuel) :\n  isPerfectSquare.check n x fuel = true := by\n\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp_all\n    exact absurd hfuel (Nat.not_lt_of_le hx)\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp\n\n    if hgt : x * x > n then\n      have x_le_i_squared : x * x ≤ i * i := Nat.mul_le_mul hx hx\n      rw [hi] at x_le_i_squared\n      exact absurd hgt (Nat.not_lt_of_ge x_le_i_squared)\n    else if heq : x * x = n then\n      simp_all\n    else\n\n      if hxi : x = i then\n        rw [hxi] at heq\n        exact absurd hi heq\n      else\n        simp_all\n        have x_lt_i : x < i := Nat.lt_of_le_of_ne hx hxi\n        have x_succ_le_i : x + 1 ≤ i := Nat.succ_le_of_lt x_lt_i\n\n        have i_lt_next_fuel : i < (x + 1) + fuel := by\n          rw [Nat.add_assoc, Nat.add_comm _ fuel]\n          exact hfuel\n\n        exact ih (x + 1) x_succ_le_i i_lt_next_fuel\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef isPerfectSquare_precond (n : Nat) : Prop :=\n  True\n\ndef isPerfectSquare (n : Nat) : Bool :=\n  if n = 0 then true\n  else\n    let rec check (x : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false\n      | fuel + 1 =>\n        if x * x > n then false\n        else if x * x = n then true\n        else check (x + 1) fuel\n    check 1 n\n\n@[reducible, simp]\ndef isPerfectSquare_postcond (n : Nat) (result : Bool) : Prop :=\n  result ↔ ∃ i : Nat, i * i = n\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem check_correct (n : Nat) (x fuel : Nat) :\n   isPerfectSquare.check n x fuel = true → ∃ i, x ≤ i ∧ i * i = n := by\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp_all\n\n    if hgt : x * x > n then\n      simp_all\n    else if heq : x * x = n then\n      simp_all\n      exists x\n    else\n      simp_all\n      have h_rec := ih (x + 1)\n      intro h\n      have ⟨i, hi, heqi⟩ := h_rec h\n      exists i\n      constructor\n      · -- Show x ≤ i by transitivity: x ≤ x+1 ≤ i\n        exact Nat.le_trans (Nat.le_succ x) hi\n      · -- Pass through the equality i * i = n\n        exact heqi\n\ntheorem check_complete (n : Nat) (x fuel : Nat) (i : Nat)\n    (hx : x ≤ i) (hi : i * i = n) (hfuel : i < x + fuel) :\n  isPerfectSquare.check n x fuel = true := by\n\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp_all\n    exact absurd hfuel (Nat.not_lt_of_le hx)\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp\n\n    if hgt : x * x > n then\n      have x_le_i_squared : x * x ≤ i * i := Nat.mul_le_mul hx hx\n      rw [hi] at x_le_i_squared\n      exact absurd hgt (Nat.not_lt_of_ge x_le_i_squared)\n    else if heq : x * x = n then\n      simp_all\n    else\n\n      if hxi : x = i then\n        rw [hxi] at heq\n        exact absurd hi heq\n      else\n        simp_all\n        have x_lt_i : x < i := Nat.lt_of_le_of_ne hx hxi\n        have x_succ_le_i : x + 1 ≤ i := Nat.succ_le_of_lt x_lt_i\n\n        have i_lt_next_fuel : i < (x + 1) + fuel := by\n          rw [Nat.add_assoc, Nat.add_comm _ fuel]\n          exact hfuel\n\n        exact ih (x + 1) x_succ_le_i i_lt_next_fuel\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem check_correct (n : Nat) (x fuel : Nat) :\n   isPerfectSquare.check n x fuel = true → ∃ i, x ≤ i ∧ i * i = n := by\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp_all\n\n    if hgt : x * x > n then\n      simp_all\n    else if heq : x * x = n then\n      simp_all\n      exists x\n    else\n      simp_all\n      have h_rec := ih (x + 1)\n      intro h\n      have ⟨i, hi, heqi⟩ := h_rec h\n      exists i\n      constructor\n      · -- Show x ≤ i by transitivity: x ≤ x+1 ≤ i\n        exact Nat.le_trans (Nat.le_succ x) hi\n      · -- Pass through the equality i * i = n\n        exact heqi\n\ntheorem check_complete (n : Nat) (x fuel : Nat) (i : Nat)\n    (hx : x ≤ i) (hi : i * i = n) (hfuel : i < x + fuel) :\n  isPerfectSquare.check n x fuel = true := by\n\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp_all\n    exact absurd hfuel (Nat.not_lt_of_le hx)\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp\n\n    if hgt : x * x > n then\n      have x_le_i_squared : x * x ≤ i * i := Nat.mul_le_mul hx hx\n      rw [hi] at x_le_i_squared\n      exact absurd hgt (Nat.not_lt_of_ge x_le_i_squared)\n    else if heq : x * x = n then\n      simp_all\n    else\n\n      if hxi : x = i then\n        rw [hxi] at heq\n        exact absurd hi heq\n      else\n        simp_all\n        have x_lt_i : x < i := Nat.lt_of_le_of_ne hx hxi\n        have x_succ_le_i : x + 1 ≤ i := Nat.succ_le_of_lt x_lt_i\n\n        have i_lt_next_fuel : i < (x + 1) + fuel := by\n          rw [Nat.add_assoc, Nat.add_comm _ fuel]\n          exact hfuel\n\n        exact ih (x + 1) x_succ_le_i i_lt_next_fuel\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n  unfold isPerfectSquare_postcond isPerfectSquare\n  simp\n  cases n with\n  | zero => simp\n  | succ n' =>\n    apply Iff.intro\n\n    · intro h\n      simp at h\n      have ⟨i, ⟨hi_le, hi_eq⟩⟩ := check_correct (n' + 1) 1 (n' + 1) h\n      exists i\n\n    · intro h\n      simp\n      have ⟨i, hi⟩ := h\n      have i_pos : i > 0 := by\n        apply Nat.pos_of_ne_zero\n        intro h_zero\n        rw [h_zero, zero_mul] at hi\n        exact Nat.succ_ne_zero n' hi.symm\n\n      have i_ge_1 : i ≥ 1 := Nat.succ_le_of_lt i_pos\n\n      have i_lt_bound : i < 1 + (n' + 1) := by\n        have i_le_n_plus_1 : i ≤ n' + 1 := by\n          apply Nat.le_of_mul_le_mul_left\n          · rw [hi]\n            simp\n            exact i_ge_1\n          · exact i_pos\n\n        apply Nat.lt_succ_of_le at i_le_n_plus_1\n        simp_all +arith\n\n      exact check_complete (n' + 1) 1 (n' + 1) i i_ge_1 hi i_lt_bound"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_48", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that determines whether a given non-negative natural number is a perfect square. In other words, the method should return true if there exists a natural number whose square is equal to the input number, and false if no such number exists.\n\n-----Input-----  \nThe input consists of a single natural number:  \nn: A non-negative natural number (Nat).\n\n-----Output-----  \nThe output is a Boolean value:  \nReturns true if there exists an integer such that its square equals the input n.  \nReturns false if no integer squared equals the input n.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem check_correct (n : Nat) (x fuel : Nat) :\n   isPerfectSquare.check n x fuel = true → ∃ i, x ≤ i ∧ i * i = n := by\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp_all\n\n    if hgt : x * x > n then\n      simp_all\n    else if heq : x * x = n then\n      simp_all\n      exists x\n    else\n      simp_all\n      have h_rec := ih (x + 1)\n      intro h\n      have ⟨i, hi, heqi⟩ := h_rec h\n      exists i\n      constructor\n      · -- Show x ≤ i by transitivity: x ≤ x+1 ≤ i\n        exact Nat.le_trans (Nat.le_succ x) hi\n      · -- Pass through the equality i * i = n\n        exact heqi\n\ntheorem check_complete (n : Nat) (x fuel : Nat) (i : Nat)\n    (hx : x ≤ i) (hi : i * i = n) (hfuel : i < x + fuel) :\n  isPerfectSquare.check n x fuel = true := by\n\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp_all\n    exact absurd hfuel (Nat.not_lt_of_le hx)\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp\n\n    if hgt : x * x > n then\n      have x_le_i_squared : x * x ≤ i * i := Nat.mul_le_mul hx hx\n      rw [hi] at x_le_i_squared\n      exact absurd hgt (Nat.not_lt_of_ge x_le_i_squared)\n    else if heq : x * x = n then\n      simp_all\n    else\n\n      if hxi : x = i then\n        rw [hxi] at heq\n        exact absurd hi heq\n      else\n        simp_all\n        have x_lt_i : x < i := Nat.lt_of_le_of_ne hx hxi\n        have x_succ_le_i : x + 1 ≤ i := Nat.succ_le_of_lt x_lt_i\n\n        have i_lt_next_fuel : i < (x + 1) + fuel := by\n          rw [Nat.add_assoc, Nat.add_comm _ fuel]\n          exact hfuel\n\n        exact ih (x + 1) x_succ_le_i i_lt_next_fuel\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef isPerfectSquare_precond (n : Nat) : Prop :=\n  True\n\ndef isPerfectSquare (n : Nat) : Bool :=\n  if n = 0 then true\n  else\n    let rec check (x : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false\n      | fuel + 1 =>\n        if x * x > n then false\n        else if x * x = n then true\n        else check (x + 1) fuel\n    check 1 n\n\n@[reducible, simp]\ndef isPerfectSquare_postcond (n : Nat) (result : Bool) : Prop :=\n  result ↔ ∃ i : Nat, i * i = n\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem check_correct (n : Nat) (x fuel : Nat) :\n   isPerfectSquare.check n x fuel = true → ∃ i, x ≤ i ∧ i * i = n := by\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp_all\n\n    if hgt : x * x > n then\n      simp_all\n    else if heq : x * x = n then\n      simp_all\n      exists x\n    else\n      simp_all\n      have h_rec := ih (x + 1)\n      intro h\n      have ⟨i, hi, heqi⟩ := h_rec h\n      exists i\n      constructor\n      · -- Show x ≤ i by transitivity: x ≤ x+1 ≤ i\n        exact Nat.le_trans (Nat.le_succ x) hi\n      · -- Pass through the equality i * i = n\n        exact heqi\n\ntheorem check_complete (n : Nat) (x fuel : Nat) (i : Nat)\n    (hx : x ≤ i) (hi : i * i = n) (hfuel : i < x + fuel) :\n  isPerfectSquare.check n x fuel = true := by\n\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp_all\n    exact absurd hfuel (Nat.not_lt_of_le hx)\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp\n\n    if hgt : x * x > n then\n      have x_le_i_squared : x * x ≤ i * i := Nat.mul_le_mul hx hx\n      rw [hi] at x_le_i_squared\n      exact absurd hgt (Nat.not_lt_of_ge x_le_i_squared)\n    else if heq : x * x = n then\n      simp_all\n    else\n\n      if hxi : x = i then\n        rw [hxi] at heq\n        exact absurd hi heq\n      else\n        simp_all\n        have x_lt_i : x < i := Nat.lt_of_le_of_ne hx hxi\n        have x_succ_le_i : x + 1 ≤ i := Nat.succ_le_of_lt x_lt_i\n\n        have i_lt_next_fuel : i < (x + 1) + fuel := by\n          rw [Nat.add_assoc, Nat.add_comm _ fuel]\n          exact hfuel\n\n        exact ih (x + 1) x_succ_le_i i_lt_next_fuel\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n```", "ground_truth": "theorem check_correct (n : Nat) (x fuel : Nat) :\n   isPerfectSquare.check n x fuel = true → ∃ i, x ≤ i ∧ i * i = n := by\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp_all\n\n    if hgt : x * x > n then\n      simp_all\n    else if heq : x * x = n then\n      simp_all\n      exists x\n    else\n      simp_all\n      have h_rec := ih (x + 1)\n      intro h\n      have ⟨i, hi, heqi⟩ := h_rec h\n      exists i\n      constructor\n      · -- Show x ≤ i by transitivity: x ≤ x+1 ≤ i\n        exact Nat.le_trans (Nat.le_succ x) hi\n      · -- Pass through the equality i * i = n\n        exact heqi\n\ntheorem check_complete (n : Nat) (x fuel : Nat) (i : Nat)\n    (hx : x ≤ i) (hi : i * i = n) (hfuel : i < x + fuel) :\n  isPerfectSquare.check n x fuel = true := by\n\n  induction fuel generalizing x with\n  | zero =>\n    unfold isPerfectSquare.check\n    simp_all\n    exact absurd hfuel (Nat.not_lt_of_le hx)\n\n  | succ fuel ih =>\n    unfold isPerfectSquare.check\n    simp\n\n    if hgt : x * x > n then\n      have x_le_i_squared : x * x ≤ i * i := Nat.mul_le_mul hx hx\n      rw [hi] at x_le_i_squared\n      exact absurd hgt (Nat.not_lt_of_ge x_le_i_squared)\n    else if heq : x * x = n then\n      simp_all\n    else\n\n      if hxi : x = i then\n        rw [hxi] at heq\n        exact absurd hi heq\n      else\n        simp_all\n        have x_lt_i : x < i := Nat.lt_of_le_of_ne hx hxi\n        have x_succ_le_i : x + 1 ≤ i := Nat.succ_le_of_lt x_lt_i\n\n        have i_lt_next_fuel : i < (x + 1) + fuel := by\n          rw [Nat.add_assoc, Nat.add_comm _ fuel]\n          exact hfuel\n\n        exact ih (x + 1) x_succ_le_i i_lt_next_fuel\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n  unfold isPerfectSquare_postcond isPerfectSquare\n  simp\n  cases n with\n  | zero => simp\n  | succ n' =>\n    apply Iff.intro\n\n    · intro h\n      simp at h\n      have ⟨i, ⟨hi_le, hi_eq⟩⟩ := check_correct (n' + 1) 1 (n' + 1) h\n      exists i\n\n    · intro h\n      simp\n      have ⟨i, hi⟩ := h\n      have i_pos : i > 0 := by\n        apply Nat.pos_of_ne_zero\n        intro h_zero\n        rw [h_zero, zero_mul] at hi\n        exact Nat.succ_ne_zero n' hi.symm\n\n      have i_ge_1 : i ≥ 1 := Nat.succ_le_of_lt i_pos\n\n      have i_lt_bound : i < 1 + (n' + 1) := by\n        have i_le_n_plus_1 : i ≤ n' + 1 := by\n          apply Nat.le_of_mul_le_mul_left\n          · rw [hi]\n            simp\n            exact i_ge_1\n          · exact i_pos\n\n        apply Nat.lt_succ_of_le at i_le_n_plus_1\n        simp_all +arith\n\n      exact check_complete (n' + 1) 1 (n' + 1) i i_ge_1 hi i_lt_bound", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_48"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that searches an array of integers to locate the first odd number. The method should return a pair where the first element is a Boolean indicating whether an odd number was found, and the second element is the index of that odd number if found, or -1 if no odd number exists. When an odd number is found, the method should return the smallest index at which an odd number occurs.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a pair (Bool, Int):\n- If the Boolean is true, then the integer represents the smallest index of an odd number in the array.\n- If the Boolean is false, then there are no odd numbers in the array, and the accompanying integer is -1.\n\n-----Note-----\n- The input array is assumed to be non-null.\n- If multiple odd numbers are present, the index returned should correspond to the first occurrence.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isOdd (x : Int) : Bool :=\n  x % 2 ≠ 0\n\n@[reducible, simp]\ndef findFirstOdd_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef findFirstOdd (a : Array Int) (h_precond : findFirstOdd_precond (a)) : Option Nat :=\n  let indexed := a.toList.zipIdx\n\n  let found := List.find? (fun (x, _) => isOdd x) indexed\n\n  Option.map (fun (_, i) => i) found\n\n@[reducible, simp]\ndef findFirstOdd_postcond (a : Array Int) (result: Option Nat) (h_precond : findFirstOdd_precond (a)) :=\n  match result with\n  | some idx => idx < a.size ∧ isOdd (a[idx]!) ∧\n    (∀ j, j < idx → ¬ isOdd (a[j]!))\n  | none => ∀ i, i < a.size → ¬ isOdd (a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n  unfold findFirstOdd findFirstOdd_postcond\n  let la := a.toList\n  have h_la : la = a.toList := by rfl\n  let indexed := la.zipIdx\n  have h_indexed : indexed = la.zipIdx := by rfl\n  let found := List.find? (fun (x, _) => isOdd x) indexed\n  have h_found : found = List.find? (fun (x, _) => isOdd x) indexed := by rfl\n  let res := Option.map (fun (_, i) => i) found\n  have h_res : res = Option.map (fun (_, i) => i) found := by rfl\n  simp_all\n  cases h_rescase : res with\n  | none =>\n    rw [← h_res, h_rescase]\n    simp\n    rw [h_rescase] at h_res\n    have h_notfound : found = none := by\n      rw [h_found]\n      exact Option.map_eq_none.mp h_rescase\n    rw [List.find?_eq_none] at h_notfound\n    simp at h_notfound\n    intro i hi\n    have hi' : i < la.length := by exact hi\n    have h_mem : (la[i], i) ∈ indexed := by\n      have : la[i]? = some la[i] := by\n        exact (List.getElem?_eq_some_getElem_iff la i hi').mpr trivial\n      apply List.mem_zipIdx_iff_getElem?.mpr\n      simp\n    have hai : a[i]! = a[i] := by\n      exact getElem!_pos a i hi'\n    rw [hai]\n    exact h_notfound a[i] i h_mem\n  | some i =>\n    rw [← h_res, h_rescase]\n    rw [h_res] at h_rescase\n    simp\n    rw [Option.map_eq_some'] at h_rescase\n    rcases h_rescase with ⟨p, ⟨h_found', hp⟩⟩\n    have h_mem : p ∈ indexed := by\n      exact List.mem_of_find?_eq_some h_found'\n    have ⟨_, hi, hx⟩ := List.mem_zipIdx h_mem\n    have ⟨h_odd, ⟨i', hi', hii', h_prefix⟩⟩ := List.find?_eq_some_iff_getElem.mp h_found'\n    simp_all\n    have hai : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    rw [hai]\n    constructor\n    · exact h_odd\n    · intro j hj\n      have hii' : i = i' := by\n        rw [← hii'] at hp\n        simp_all\n      have hj' : j < a.size := by\n        exact Nat.lt_trans hj hi\n      have haj : a[j]! = a[j] := by\n        exact getElem!_pos a j hj'\n      rw [haj]\n      rw [hii'] at hj\n      exact h_prefix j hj"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_49", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that searches an array of integers to locate the first odd number. The method should return a pair where the first element is a Boolean indicating whether an odd number was found, and the second element is the index of that odd number if found, or -1 if no odd number exists. When an odd number is found, the method should return the smallest index at which an odd number occurs.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a pair (Bool, Int):\n- If the Boolean is true, then the integer represents the smallest index of an odd number in the array.\n- If the Boolean is false, then there are no odd numbers in the array, and the accompanying integer is -1.\n\n-----Note-----\n- The input array is assumed to be non-null.\n- If multiple odd numbers are present, the index returned should correspond to the first occurrence.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isOdd (x : Int) : Bool :=\n  x % 2 ≠ 0\n\n@[reducible, simp]\ndef findFirstOdd_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef findFirstOdd (a : Array Int) (h_precond : findFirstOdd_precond (a)) : Option Nat :=\n  let indexed := a.toList.zipIdx\n\n  let found := List.find? (fun (x, _) => isOdd x) indexed\n\n  Option.map (fun (_, i) => i) found\n\n@[reducible, simp]\ndef findFirstOdd_postcond (a : Array Int) (result: Option Nat) (h_precond : findFirstOdd_precond (a)) :=\n  match result with\n  | some idx => idx < a.size ∧ isOdd (a[idx]!) ∧\n    (∀ j, j < idx → ¬ isOdd (a[j]!))\n  | none => ∀ i, i < a.size → ¬ isOdd (a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n```", "ground_truth": "theorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n  unfold findFirstOdd findFirstOdd_postcond\n  let la := a.toList\n  have h_la : la = a.toList := by rfl\n  let indexed := la.zipIdx\n  have h_indexed : indexed = la.zipIdx := by rfl\n  let found := List.find? (fun (x, _) => isOdd x) indexed\n  have h_found : found = List.find? (fun (x, _) => isOdd x) indexed := by rfl\n  let res := Option.map (fun (_, i) => i) found\n  have h_res : res = Option.map (fun (_, i) => i) found := by rfl\n  simp_all\n  cases h_rescase : res with\n  | none =>\n    rw [← h_res, h_rescase]\n    simp\n    rw [h_rescase] at h_res\n    have h_notfound : found = none := by\n      rw [h_found]\n      exact Option.map_eq_none.mp h_rescase\n    rw [List.find?_eq_none] at h_notfound\n    simp at h_notfound\n    intro i hi\n    have hi' : i < la.length := by exact hi\n    have h_mem : (la[i], i) ∈ indexed := by\n      have : la[i]? = some la[i] := by\n        exact (List.getElem?_eq_some_getElem_iff la i hi').mpr trivial\n      apply List.mem_zipIdx_iff_getElem?.mpr\n      simp\n    have hai : a[i]! = a[i] := by\n      exact getElem!_pos a i hi'\n    rw [hai]\n    exact h_notfound a[i] i h_mem\n  | some i =>\n    rw [← h_res, h_rescase]\n    rw [h_res] at h_rescase\n    simp\n    rw [Option.map_eq_some'] at h_rescase\n    rcases h_rescase with ⟨p, ⟨h_found', hp⟩⟩\n    have h_mem : p ∈ indexed := by\n      exact List.mem_of_find?_eq_some h_found'\n    have ⟨_, hi, hx⟩ := List.mem_zipIdx h_mem\n    have ⟨h_odd, ⟨i', hi', hii', h_prefix⟩⟩ := List.find?_eq_some_iff_getElem.mp h_found'\n    simp_all\n    have hai : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    rw [hai]\n    constructor\n    · exact h_odd\n    · intro j hj\n      have hii' : i = i' := by\n        rw [← hii'] at hp\n        simp_all\n      have hj' : j < a.size := by\n        exact Nat.lt_trans hj hi\n      have haj : a[j]! = a[j] := by\n        exact getElem!_pos a j hj'\n      rw [haj]\n      rw [hii'] at hj\n      exact h_prefix j hj", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_49"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that multiplies two integers. The method should return the product of the two input numbers.\n\n-----Input-----\nThe input consists of:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the two input integers (a * b).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef multiply_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef multiply (a : Int) (b : Int) (h_precond : multiply_precond (a) (b)) : Int :=\n  a * b\n\n@[reducible, simp]\ndef multiply_postcond (a : Int) (b : Int) (result: Int) (h_precond : multiply_precond (a) (b)) :=\n  result - a * b = 0 ∧ a * b - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n  unfold multiply multiply_postcond\n  simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_5", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that multiplies two integers. The method should return the product of the two input numbers.\n\n-----Input-----\nThe input consists of:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the two input integers (a * b).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef multiply_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef multiply (a : Int) (b : Int) (h_precond : multiply_precond (a) (b)) : Int :=\n  a * b\n\n@[reducible, simp]\ndef multiply_postcond (a : Int) (b : Int) (result: Int) (h_precond : multiply_precond (a) (b)) :=\n  result - a * b = 0 ∧ a * b - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n```", "ground_truth": "theorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n  unfold multiply multiply_postcond\n  simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_5"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task is about calculating the absolute value of an integer. The goal is to determine the non-negative value of a given integer: if the integer is non-negative, it remains unchanged; if it is negative, its positive counterpart is returned.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is an integer that represents the absolute value of the input. Specifically:  \n• If x is non-negative, the output is x.  \n• If x is negative, the output is the negation of x (that is, a value y such that x + y = 0).\n\n-----Note-----  \nThis function should correctly handle zero, positive, and negative integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef Abs_precond (x : Int) : Prop :=\n  True\n\ndef Abs (x : Int) (h_precond : Abs_precond (x)) : Int :=\n  if x < 0 then -x else x\n\n@[reducible, simp]\ndef Abs_postcond (x : Int) (result: Int) (h_precond : Abs_precond (x)) :=\n  (x ≥ 0 → x = result) ∧ (x < 0 → x + result = 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n    simp [Abs_postcond, Abs]\n    apply And.intro\n    . intro h\n      split\n      case isTrue ht =>\n        have h': ¬0 ≤ x := not_le.mpr ht\n        contradiction\n      case isFalse =>\n        rfl\n    . intro h\n      split\n      case isTrue =>\n        simp\n      case isFalse =>\n        contradiction"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_50", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task is about calculating the absolute value of an integer. The goal is to determine the non-negative value of a given integer: if the integer is non-negative, it remains unchanged; if it is negative, its positive counterpart is returned.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is an integer that represents the absolute value of the input. Specifically:  \n• If x is non-negative, the output is x.  \n• If x is negative, the output is the negation of x (that is, a value y such that x + y = 0).\n\n-----Note-----  \nThis function should correctly handle zero, positive, and negative integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef Abs_precond (x : Int) : Prop :=\n  True\n\ndef Abs (x : Int) (h_precond : Abs_precond (x)) : Int :=\n  if x < 0 then -x else x\n\n@[reducible, simp]\ndef Abs_postcond (x : Int) (result: Int) (h_precond : Abs_precond (x)) :=\n  (x ≥ 0 → x = result) ∧ (x < 0 → x + result = 0)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n```", "ground_truth": "theorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n    simp [Abs_postcond, Abs]\n    apply And.intro\n    . intro h\n      split\n      case isTrue ht =>\n        have h': ¬0 ≤ x := not_le.mpr ht\n        contradiction\n      case isFalse =>\n        rfl\n    . intro h\n      split\n      case isTrue =>\n        simp\n      case isFalse =>\n        contradiction", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_50"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires creating a function that determines the correct insertion index for a given integer in a sorted array. The goal is to identify an index where every number before it is less than the specified value, and every number from that index onward is greater than or equal to the value. If the given integer is larger than all elements in the array, the function should return the array’s size.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers that is assumed to be sorted in non-decreasing order.\n• key: An integer to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) representing the index determined by the binary search. The index satisfies the following postconditions:\n• It is between 0 and the size of the array.\n• Every element before the returned index is less than the key.\n• If the returned index equals the size of the array, then all elements are less than the key.\n• Every element from the index onwards is greater than or equal to the key.\n\n-----Note-----\nIt is assumed that the input array is sorted in non-decreasing order. The function returns the first index where the key could be inserted while maintaining the sorted order.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem BinarySearch_spec_satisfied (a: Array Int) (key: Int) (h_precond : BinarySearch_precond (a) (key)) :\n    BinarySearch_postcond (a) (key) (BinarySearch (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef BinarySearch_precond (a : Array Int) (key : Int) : Prop :=\n  List.Pairwise (· ≤ ·) a.toList\n\ndef binarySearchLoop (a : Array Int) (key : Int) (lo hi : Nat) : Nat :=\n  if lo < hi then\n    let mid := (lo + hi) / 2\n    if (a[mid]! < key) then binarySearchLoop a key (mid + 1) hi\n    else binarySearchLoop a key lo mid\n  else\n    lo\n\ndef BinarySearch (a : Array Int) (key : Int) (h_precond : BinarySearch_precond (a) (key)) : Nat :=\n  binarySearchLoop a key 0 a.size\n\n@[reducible, simp]\ndef BinarySearch_postcond (a : Array Int) (key : Int) (result: Nat) (h_precond : BinarySearch_precond (a) (key)) :=\n  result ≤ a.size ∧\n  ((a.take result).all (fun x => x < key)) ∧\n  ((a.drop result).all (fun x => x ≥ key))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem BinarySearch_spec_satisfied (a: Array Int) (key: Int) (h_precond : BinarySearch_precond (a) (key)) :\n    BinarySearch_postcond (a) (key) (BinarySearch (a) (key) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_51", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task requires creating a function that determines the correct insertion index for a given integer in a sorted array. The goal is to identify an index where every number before it is less than the specified value, and every number from that index onward is greater than or equal to the value. If the given integer is larger than all elements in the array, the function should return the array’s size.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers that is assumed to be sorted in non-decreasing order.\n• key: An integer to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) representing the index determined by the binary search. The index satisfies the following postconditions:\n• It is between 0 and the size of the array.\n• Every element before the returned index is less than the key.\n• If the returned index equals the size of the array, then all elements are less than the key.\n• Every element from the index onwards is greater than or equal to the key.\n\n-----Note-----\nIt is assumed that the input array is sorted in non-decreasing order. The function returns the first index where the key could be inserted while maintaining the sorted order.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem BinarySearch_spec_satisfied (a: Array Int) (key: Int) (h_precond : BinarySearch_precond (a) (key)) :\n    BinarySearch_postcond (a) (key) (BinarySearch (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef BinarySearch_precond (a : Array Int) (key : Int) : Prop :=\n  List.Pairwise (· ≤ ·) a.toList\n\ndef binarySearchLoop (a : Array Int) (key : Int) (lo hi : Nat) : Nat :=\n  if lo < hi then\n    let mid := (lo + hi) / 2\n    if (a[mid]! < key) then binarySearchLoop a key (mid + 1) hi\n    else binarySearchLoop a key lo mid\n  else\n    lo\n\ndef BinarySearch (a : Array Int) (key : Int) (h_precond : BinarySearch_precond (a) (key)) : Nat :=\n  binarySearchLoop a key 0 a.size\n\n@[reducible, simp]\ndef BinarySearch_postcond (a : Array Int) (key : Int) (result: Nat) (h_precond : BinarySearch_precond (a) (key)) :=\n  result ≤ a.size ∧\n  ((a.take result).all (fun x => x < key)) ∧\n  ((a.drop result).all (fun x => x ≥ key))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem BinarySearch_spec_satisfied (a: Array Int) (key: Int) (h_precond : BinarySearch_precond (a) (key)) :\n    BinarySearch_postcond (a) (key) (BinarySearch (a) (key) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_51"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers. This array can be empty or non-empty.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! ≤ a[j]!).  \n• Has the same size as the input array.  \n• Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.\n\n-----Note-----  \nThe implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem BubbleSort_spec_satisfied (a: Array Int) (h_precond : BubbleSort_precond (a)) :\n    BubbleSort_postcond (a) (BubbleSort (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef BubbleSort_precond (a : Array Int) : Prop :=\n  True\n\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  let temp := a[i]!\n  let a₁ := a.set! i (a[j]!)\n  a₁.set! j temp\n\ndef bubbleInner (j i : Nat) (a : Array Int) : Array Int :=\n  if j < i then\n    let a' := if a[j]! > a[j+1]! then swap a j (j+1) else a\n    bubbleInner (j+1) i a'\n  else\n    a\n\ndef bubbleOuter (i : Nat) (a : Array Int) : Array Int :=\n  if i > 0 then\n    let a' := bubbleInner 0 i a\n    bubbleOuter (i - 1) a'\n  else\n    a\n\ndef BubbleSort (a : Array Int) (h_precond : BubbleSort_precond (a)) : Array Int :=\n  if a.size = 0 then a else bubbleOuter (a.size - 1) a\n\n@[reducible, simp]\ndef BubbleSort_postcond (a : Array Int) (result: Array Int) (h_precond : BubbleSort_precond (a)) :=\n  List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm result.toList a.toList\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem BubbleSort_spec_satisfied (a: Array Int) (h_precond : BubbleSort_precond (a)) :\n    BubbleSort_postcond (a) (BubbleSort (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_52", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers. This array can be empty or non-empty.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! ≤ a[j]!).  \n• Has the same size as the input array.  \n• Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.\n\n-----Note-----  \nThe implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem BubbleSort_spec_satisfied (a: Array Int) (h_precond : BubbleSort_precond (a)) :\n    BubbleSort_postcond (a) (BubbleSort (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef BubbleSort_precond (a : Array Int) : Prop :=\n  True\n\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  let temp := a[i]!\n  let a₁ := a.set! i (a[j]!)\n  a₁.set! j temp\n\ndef bubbleInner (j i : Nat) (a : Array Int) : Array Int :=\n  if j < i then\n    let a' := if a[j]! > a[j+1]! then swap a j (j+1) else a\n    bubbleInner (j+1) i a'\n  else\n    a\n\ndef bubbleOuter (i : Nat) (a : Array Int) : Array Int :=\n  if i > 0 then\n    let a' := bubbleInner 0 i a\n    bubbleOuter (i - 1) a'\n  else\n    a\n\ndef BubbleSort (a : Array Int) (h_precond : BubbleSort_precond (a)) : Array Int :=\n  if a.size = 0 then a else bubbleOuter (a.size - 1) a\n\n@[reducible, simp]\ndef BubbleSort_postcond (a : Array Int) (result: Array Int) (h_precond : BubbleSort_precond (a)) :=\n  List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm result.toList a.toList\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem BubbleSort_spec_satisfied (a: Array Int) (h_precond : BubbleSort_precond (a)) :\n    BubbleSort_postcond (a) (BubbleSort (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_52"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis problem asks for a method to determine the sum of the first N natural numbers. The task focuses on computing the total when given an input N, ensuring that the value is 0 when N is 0 and correctly calculated for positive values of N.\n\n-----Input-----\nThe input consists of:\n• N: A natural number (Nat) representing the count of the first natural numbers to sum.\n\n-----Output-----\nThe output is a natural number (Nat), which is the sum of the first N natural numbers computed as: N * (N + 1) / 2.\n\n-----Note-----\nThe computation leverages a recursive implementation. There are no additional preconditions beyond providing a valid natural number.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef CalSum_precond (N : Nat) : Prop :=\n  True\n\ndef CalSum (N : Nat) (h_precond : CalSum_precond (N)) : Nat :=\n  let rec loop (n : Nat) : Nat :=\n    if n = 0 then 0\n    else n + loop (n - 1)\n  loop N\n\n@[reducible, simp]\ndef CalSum_postcond (N : Nat) (result: Nat) (h_precond : CalSum_precond (N)) :=\n  2 * result = N * (N + 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n  unfold CalSum_postcond CalSum\n  induction N with\n  | zero =>\n    unfold CalSum.loop\n    simp\n  | succ n ih =>\n    unfold CalSum_precond at ih\n    simp at ih\n    unfold CalSum.loop\n    simp\n    rw [Nat.mul_add]\n    rw [ih]\n    rw [← Nat.add_mul]\n    rw [Nat.add_comm, Nat.mul_comm]"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_53", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis problem asks for a method to determine the sum of the first N natural numbers. The task focuses on computing the total when given an input N, ensuring that the value is 0 when N is 0 and correctly calculated for positive values of N.\n\n-----Input-----\nThe input consists of:\n• N: A natural number (Nat) representing the count of the first natural numbers to sum.\n\n-----Output-----\nThe output is a natural number (Nat), which is the sum of the first N natural numbers computed as: N * (N + 1) / 2.\n\n-----Note-----\nThe computation leverages a recursive implementation. There are no additional preconditions beyond providing a valid natural number.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef CalSum_precond (N : Nat) : Prop :=\n  True\n\ndef CalSum (N : Nat) (h_precond : CalSum_precond (N)) : Nat :=\n  let rec loop (n : Nat) : Nat :=\n    if n = 0 then 0\n    else n + loop (n - 1)\n  loop N\n\n@[reducible, simp]\ndef CalSum_postcond (N : Nat) (result: Nat) (h_precond : CalSum_precond (N)) :=\n  2 * result = N * (N + 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n```", "ground_truth": "theorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n  unfold CalSum_postcond CalSum\n  induction N with\n  | zero =>\n    unfold CalSum.loop\n    simp\n  | succ n ih =>\n    unfold CalSum_precond at ih\n    simp at ih\n    unfold CalSum.loop\n    simp\n    rw [Nat.mul_add]\n    rw [ih]\n    rw [← Nat.add_mul]\n    rw [Nat.add_comm, Nat.mul_comm]", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_53"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task is about determining the minimum absolute difference between any pair of integers, where one integer is taken from the first sorted array and the other integer is taken from the second sorted array. The focus is on accurately finding the smallest absolute difference between any two elements from the arrays, independent of the specific techniques or programming language used.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers, sorted in non-decreasing order and guaranteed to be non-empty.  \n• b: An array of integers, also sorted in non-decreasing order and non-empty.\n\n-----Output-----  \nThe output is a natural number (Nat) representing the minimum absolute difference between any element a[i] from the first array and b[j] from the second array.\n\n-----Note-----  \n• It is assumed that both arrays are non-empty.  \n• The arrays are assumed to be sorted in non-decreasing order.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem CanyonSearch_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : CanyonSearch_precond (a) (b)) :\n    CanyonSearch_postcond (a) (b) (CanyonSearch (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef CanyonSearch_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size > 0 ∧ b.size > 0 ∧ List.Pairwise (· ≤ ·) a.toList ∧ List.Pairwise (· ≤ ·) b.toList\n\ndef canyonSearchAux (a : Array Int) (b : Array Int) (m n d : Nat) : Nat :=\n  if m < a.size ∧ n < b.size then\n    let diff : Nat := ((a[m]! - b[n]!).natAbs)\n    let new_d := if diff < d then diff else d\n    if a[m]! <= b[n]! then\n      canyonSearchAux a b (m + 1) n new_d\n    else\n      canyonSearchAux a b m (n + 1) new_d\n  else\n    d\ntermination_by a.size + b.size - m - n\n\ndef CanyonSearch (a : Array Int) (b : Array Int) (h_precond : CanyonSearch_precond (a) (b)) : Nat :=\n  let init : Nat :=\n    if a[0]! < b[0]! then (b[0]! - a[0]!).natAbs\n    else (a[0]! - b[0]!).natAbs\n  canyonSearchAux a b 0 0 init\n\n@[reducible, simp]\ndef CanyonSearch_postcond (a : Array Int) (b : Array Int) (result: Nat) (h_precond : CanyonSearch_precond (a) (b)) :=\n  (a.any (fun ai => b.any (fun bi => result = (ai - bi).natAbs))) ∧\n  (a.all (fun ai => b.all (fun bi => result ≤ (ai - bi).natAbs)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem CanyonSearch_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : CanyonSearch_precond (a) (b)) :\n    CanyonSearch_postcond (a) (b) (CanyonSearch (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_54", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task is about determining the minimum absolute difference between any pair of integers, where one integer is taken from the first sorted array and the other integer is taken from the second sorted array. The focus is on accurately finding the smallest absolute difference between any two elements from the arrays, independent of the specific techniques or programming language used.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers, sorted in non-decreasing order and guaranteed to be non-empty.  \n• b: An array of integers, also sorted in non-decreasing order and non-empty.\n\n-----Output-----  \nThe output is a natural number (Nat) representing the minimum absolute difference between any element a[i] from the first array and b[j] from the second array.\n\n-----Note-----  \n• It is assumed that both arrays are non-empty.  \n• The arrays are assumed to be sorted in non-decreasing order.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem CanyonSearch_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : CanyonSearch_precond (a) (b)) :\n    CanyonSearch_postcond (a) (b) (CanyonSearch (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef CanyonSearch_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size > 0 ∧ b.size > 0 ∧ List.Pairwise (· ≤ ·) a.toList ∧ List.Pairwise (· ≤ ·) b.toList\n\ndef canyonSearchAux (a : Array Int) (b : Array Int) (m n d : Nat) : Nat :=\n  if m < a.size ∧ n < b.size then\n    let diff : Nat := ((a[m]! - b[n]!).natAbs)\n    let new_d := if diff < d then diff else d\n    if a[m]! <= b[n]! then\n      canyonSearchAux a b (m + 1) n new_d\n    else\n      canyonSearchAux a b m (n + 1) new_d\n  else\n    d\ntermination_by a.size + b.size - m - n\n\ndef CanyonSearch (a : Array Int) (b : Array Int) (h_precond : CanyonSearch_precond (a) (b)) : Nat :=\n  let init : Nat :=\n    if a[0]! < b[0]! then (b[0]! - a[0]!).natAbs\n    else (a[0]! - b[0]!).natAbs\n  canyonSearchAux a b 0 0 init\n\n@[reducible, simp]\ndef CanyonSearch_postcond (a : Array Int) (b : Array Int) (result: Nat) (h_precond : CanyonSearch_precond (a) (b)) :=\n  (a.any (fun ai => b.any (fun bi => result = (ai - bi).natAbs))) ∧\n  (a.all (fun ai => b.all (fun bi => result ≤ (ai - bi).natAbs)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem CanyonSearch_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : CanyonSearch_precond (a) (b)) :\n    CanyonSearch_postcond (a) (b) (CanyonSearch (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_54"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves determining whether two integer values are equal. The goal is simply to compare the two provided numbers and indicate with a Boolean result whether they are the same.\n\n-----Input-----\nThe input consists of two elements:\n• a: An element of type Int.\n• b: An element of type Int.\n\n-----Output-----\nThe output is a Boolean:\n• Returns true if a equals b.\n• Returns false if a does not equal b.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Compare_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef Compare (a : Int) (b : Int) (h_precond : Compare_precond (a) (b)) : Bool :=\n  if a = b then true else false\n\n@[reducible, simp]\ndef Compare_postcond (a : Int) (b : Int) (result: Bool) (h_precond : Compare_precond (a) (b)) :=\n  (a = b → result = true) ∧ (a ≠ b → result = false)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n  unfold Compare_postcond Compare\n  simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_55", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves determining whether two integer values are equal. The goal is simply to compare the two provided numbers and indicate with a Boolean result whether they are the same.\n\n-----Input-----\nThe input consists of two elements:\n• a: An element of type Int.\n• b: An element of type Int.\n\n-----Output-----\nThe output is a Boolean:\n• Returns true if a equals b.\n• Returns false if a does not equal b.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Compare_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef Compare (a : Int) (b : Int) (h_precond : Compare_precond (a) (b)) : Bool :=\n  if a = b then true else false\n\n@[reducible, simp]\ndef Compare_postcond (a : Int) (b : Int) (result: Bool) (h_precond : Compare_precond (a) (b)) :=\n  (a = b → result = true) ∧ (a ≠ b → result = false)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n```", "ground_truth": "theorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n  unfold Compare_postcond Compare\n  simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_55"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n• src: An array of integers representing the source array.  \n• sStart: A natural number indicating the starting index in src from where to begin copying.  \n• dest: An array of integers representing the destination array.  \n• dStart: A natural number indicating the starting index in dest where the segment will be replaced.  \n• len: A natural number specifying the number of elements to copy.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same size as the destination array (dest).  \n• Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.  \n• Under the preconditions that src.size ≥ sStart + len and dest.size ≥ dStart + len, guarantees that:  \n  - All elements with indices less than dStart remain as in dest.  \n  - All elements with indices greater than or equal to dStart + len remain as in dest.  \n  - For each index i with 0 ≤ i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.\n\n-----Note-----  \nIt is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem copy_spec_satisfied (src: Array Int) (sStart: Nat) (dest: Array Int) (dStart: Nat) (len: Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :\n    copy_postcond (src) (sStart) (dest) (dStart) (len) (copy (src) (sStart) (dest) (dStart) (len) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef copy_precond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) : Prop :=\n  src.size ≥ sStart + len ∧\n  dest.size ≥ dStart + len\n\ndef updateSegment : Array Int → Array Int → Nat → Nat → Nat → Array Int\n  | r, src, sStart, dStart, 0 => r\n  | r, src, sStart, dStart, n+1 =>\n      let rNew := r.set! (dStart + n) (src[sStart + n]!)\n      updateSegment rNew src sStart dStart n\n\ndef copy (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) : Array Int :=\n  if len = 0 then dest\n  else\n    let r := dest\n    updateSegment r src sStart dStart len\n\n@[reducible, simp]\ndef copy_postcond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (result: Array Int) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :=\n  result.size = dest.size ∧\n  (∀ i, i < dStart → result[i]! = dest[i]!) ∧\n  (∀ i, dStart + len ≤ i → i < result.size → result[i]! = dest[i]!) ∧\n  (∀ i, i < len → result[dStart + i]! = src[sStart + i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem copy_spec_satisfied (src: Array Int) (sStart: Nat) (dest: Array Int) (dStart: Nat) (len: Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :\n    copy_postcond (src) (sStart) (dest) (dStart) (len) (copy (src) (sStart) (dest) (dStart) (len) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_56", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n• src: An array of integers representing the source array.  \n• sStart: A natural number indicating the starting index in src from where to begin copying.  \n• dest: An array of integers representing the destination array.  \n• dStart: A natural number indicating the starting index in dest where the segment will be replaced.  \n• len: A natural number specifying the number of elements to copy.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same size as the destination array (dest).  \n• Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.  \n• Under the preconditions that src.size ≥ sStart + len and dest.size ≥ dStart + len, guarantees that:  \n  - All elements with indices less than dStart remain as in dest.  \n  - All elements with indices greater than or equal to dStart + len remain as in dest.  \n  - For each index i with 0 ≤ i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.\n\n-----Note-----  \nIt is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem copy_spec_satisfied (src: Array Int) (sStart: Nat) (dest: Array Int) (dStart: Nat) (len: Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :\n    copy_postcond (src) (sStart) (dest) (dStart) (len) (copy (src) (sStart) (dest) (dStart) (len) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef copy_precond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) : Prop :=\n  src.size ≥ sStart + len ∧\n  dest.size ≥ dStart + len\n\ndef updateSegment : Array Int → Array Int → Nat → Nat → Nat → Array Int\n  | r, src, sStart, dStart, 0 => r\n  | r, src, sStart, dStart, n+1 =>\n      let rNew := r.set! (dStart + n) (src[sStart + n]!)\n      updateSegment rNew src sStart dStart n\n\ndef copy (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) : Array Int :=\n  if len = 0 then dest\n  else\n    let r := dest\n    updateSegment r src sStart dStart len\n\n@[reducible, simp]\ndef copy_postcond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (result: Array Int) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :=\n  result.size = dest.size ∧\n  (∀ i, i < dStart → result[i]! = dest[i]!) ∧\n  (∀ i, dStart + len ≤ i → i < result.size → result[i]! = dest[i]!) ∧\n  (∀ i, i < len → result[dStart + i]! = src[sStart + i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem copy_spec_satisfied (src: Array Int) (sStart: Nat) (dest: Array Int) (dStart: Nat) (len: Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :\n    copy_postcond (src) (sStart) (dest) (dStart) (len) (copy (src) (sStart) (dest) (dStart) (len) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_56"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves determining how many numbers within an array are less than a specified threshold. The problem is focused on identifying and counting such numbers based purely on their value in relation to the threshold.\n\n-----Input-----\nThe input consists of:\n• numbers: An array of integers (which may be empty or non-empty).\n• threshold: An integer that serves as the comparison threshold.\n\n-----Output-----\nThe output is a natural number (Nat) representing the count of elements in the array that are less than the given threshold.\n\n-----Note-----\nThere are no additional preconditions; the function should work correctly for any array of integers and any integer threshold.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem CountLessThan_spec_satisfied (numbers: Array Int) (threshold: Int) (h_precond : CountLessThan_precond (numbers) (threshold)) :\n    CountLessThan_postcond (numbers) (threshold) (CountLessThan (numbers) (threshold) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef CountLessThan_precond (numbers : Array Int) (threshold : Int) : Prop :=\n  True\n\ndef countLessThan (numbers : Array Int) (threshold : Int) : Nat :=\n  let rec count (i : Nat) (acc : Nat) : Nat :=\n    if i < numbers.size then\n      let new_acc := if numbers[i]! < threshold then acc + 1 else acc\n      count (i + 1) new_acc\n    else\n      acc\n  count 0 0\n\ndef CountLessThan (numbers : Array Int) (threshold : Int) (h_precond : CountLessThan_precond (numbers) (threshold)) : Nat :=\n  countLessThan numbers threshold\n\n@[reducible, simp]\ndef CountLessThan_postcond (numbers : Array Int) (threshold : Int) (result: Nat) (h_precond : CountLessThan_precond (numbers) (threshold)) :=\n  result - numbers.foldl (fun count n => if n < threshold then count + 1 else count) 0 = 0 ∧\n  numbers.foldl (fun count n => if n < threshold then count + 1 else count) 0 - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem CountLessThan_spec_satisfied (numbers: Array Int) (threshold: Int) (h_precond : CountLessThan_precond (numbers) (threshold)) :\n    CountLessThan_postcond (numbers) (threshold) (CountLessThan (numbers) (threshold) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_57", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves determining how many numbers within an array are less than a specified threshold. The problem is focused on identifying and counting such numbers based purely on their value in relation to the threshold.\n\n-----Input-----\nThe input consists of:\n• numbers: An array of integers (which may be empty or non-empty).\n• threshold: An integer that serves as the comparison threshold.\n\n-----Output-----\nThe output is a natural number (Nat) representing the count of elements in the array that are less than the given threshold.\n\n-----Note-----\nThere are no additional preconditions; the function should work correctly for any array of integers and any integer threshold.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem CountLessThan_spec_satisfied (numbers: Array Int) (threshold: Int) (h_precond : CountLessThan_precond (numbers) (threshold)) :\n    CountLessThan_postcond (numbers) (threshold) (CountLessThan (numbers) (threshold) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef CountLessThan_precond (numbers : Array Int) (threshold : Int) : Prop :=\n  True\n\ndef countLessThan (numbers : Array Int) (threshold : Int) : Nat :=\n  let rec count (i : Nat) (acc : Nat) : Nat :=\n    if i < numbers.size then\n      let new_acc := if numbers[i]! < threshold then acc + 1 else acc\n      count (i + 1) new_acc\n    else\n      acc\n  count 0 0\n\ndef CountLessThan (numbers : Array Int) (threshold : Int) (h_precond : CountLessThan_precond (numbers) (threshold)) : Nat :=\n  countLessThan numbers threshold\n\n@[reducible, simp]\ndef CountLessThan_postcond (numbers : Array Int) (threshold : Int) (result: Nat) (h_precond : CountLessThan_precond (numbers) (threshold)) :=\n  result - numbers.foldl (fun count n => if n < threshold then count + 1 else count) 0 = 0 ∧\n  numbers.foldl (fun count n => if n < threshold then count + 1 else count) 0 - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem CountLessThan_spec_satisfied (numbers: Array Int) (threshold: Int) (h_precond : CountLessThan_precond (numbers) (threshold)) :\n    CountLessThan_postcond (numbers) (threshold) (CountLessThan (numbers) (threshold) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_57"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves transforming an array of integers by doubling each element.\n\n-----Input-----  \nThe input consists of:  \n• s: An array of integers.\n\n-----Output-----  \nThe output is an array of integers where for each valid index i, the element at position i is equal to twice the corresponding element in the input array.\n\n-----Note-----  \nThe implementation makes use of a recursive helper function to update the array in place. It is assumed that the input array is valid and that the doubling operation does not lead to any overflow issues.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem double_array_elements_spec_satisfied (s: Array Int) (h_precond : double_array_elements_precond (s)) :\n    double_array_elements_postcond (s) (double_array_elements (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef double_array_elements_precond (s : Array Int) : Prop :=\n  True\n\ndef double_array_elements_aux (s_old s : Array Int) (i : Nat) : Array Int :=\n  if i < s.size then\n    let new_s := s.set! i (2 * (s_old[i]!))\n    double_array_elements_aux s_old new_s (i + 1)\n  else\n    s\n\ndef double_array_elements (s : Array Int) (h_precond : double_array_elements_precond (s)) : Array Int :=\n  double_array_elements_aux s s 0\n\n@[reducible, simp]\ndef double_array_elements_postcond (s : Array Int) (result: Array Int) (h_precond : double_array_elements_precond (s)) :=\n  result.size = s.size ∧ ∀ i, i < s.size → result[i]! = 2 * s[i]!\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem double_array_elements_spec_satisfied (s: Array Int) (h_precond : double_array_elements_precond (s)) :\n    double_array_elements_postcond (s) (double_array_elements (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_58", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves transforming an array of integers by doubling each element.\n\n-----Input-----  \nThe input consists of:  \n• s: An array of integers.\n\n-----Output-----  \nThe output is an array of integers where for each valid index i, the element at position i is equal to twice the corresponding element in the input array.\n\n-----Note-----  \nThe implementation makes use of a recursive helper function to update the array in place. It is assumed that the input array is valid and that the doubling operation does not lead to any overflow issues.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem double_array_elements_spec_satisfied (s: Array Int) (h_precond : double_array_elements_precond (s)) :\n    double_array_elements_postcond (s) (double_array_elements (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef double_array_elements_precond (s : Array Int) : Prop :=\n  True\n\ndef double_array_elements_aux (s_old s : Array Int) (i : Nat) : Array Int :=\n  if i < s.size then\n    let new_s := s.set! i (2 * (s_old[i]!))\n    double_array_elements_aux s_old new_s (i + 1)\n  else\n    s\n\ndef double_array_elements (s : Array Int) (h_precond : double_array_elements_precond (s)) : Array Int :=\n  double_array_elements_aux s s 0\n\n@[reducible, simp]\ndef double_array_elements_postcond (s : Array Int) (result: Array Int) (h_precond : double_array_elements_precond (s)) :=\n  result.size = s.size ∧ ∀ i, i < s.size → result[i]! = 2 * s[i]!\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem double_array_elements_spec_satisfied (s: Array Int) (h_precond : double_array_elements_precond (s)) :\n    double_array_elements_postcond (s) (double_array_elements (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_58"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nGiven an integer x, determine a pair (a, b) where the first element is twice the value of x and the second element is four times the value of x.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is a tuple (a, b) where:  \n• a = 2 * x  \n• b = 4 * x\n\n-----Note-----  \nThere are no additional preconditions; the method is defined for all integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem DoubleQuadruple_spec_satisfied (x: Int) (h_precond : DoubleQuadruple_precond (x)) :\n    DoubleQuadruple_postcond (x) (DoubleQuadruple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef DoubleQuadruple_precond (x : Int) : Prop :=\n  True\n\ndef DoubleQuadruple (x : Int) (h_precond : DoubleQuadruple_precond (x)) : (Int × Int) :=\n  let a := 2 * x\n  let b := 2 * a\n  (a, b)\n\n@[reducible, simp]\ndef DoubleQuadruple_postcond (x : Int) (result: (Int × Int)) (h_precond : DoubleQuadruple_precond (x)) :=\n  result.fst = 2 * x ∧ result.snd = 2 * result.fst\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem DoubleQuadruple_spec_satisfied (x: Int) (h_precond : DoubleQuadruple_precond (x)) :\n    DoubleQuadruple_postcond (x) (DoubleQuadruple (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_59", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nGiven an integer x, determine a pair (a, b) where the first element is twice the value of x and the second element is four times the value of x.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is a tuple (a, b) where:  \n• a = 2 * x  \n• b = 4 * x\n\n-----Note-----  \nThere are no additional preconditions; the method is defined for all integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem DoubleQuadruple_spec_satisfied (x: Int) (h_precond : DoubleQuadruple_precond (x)) :\n    DoubleQuadruple_postcond (x) (DoubleQuadruple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef DoubleQuadruple_precond (x : Int) : Prop :=\n  True\n\ndef DoubleQuadruple (x : Int) (h_precond : DoubleQuadruple_precond (x)) : (Int × Int) :=\n  let a := 2 * x\n  let b := 2 * a\n  (a, b)\n\n@[reducible, simp]\ndef DoubleQuadruple_postcond (x : Int) (result: (Int × Int)) (h_precond : DoubleQuadruple_precond (x)) :=\n  result.fst = 2 * x ∧ result.snd = 2 * result.fst\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem DoubleQuadruple_spec_satisfied (x: Int) (h_precond : DoubleQuadruple_precond (x)) :\n    DoubleQuadruple_postcond (x) (DoubleQuadruple (x) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_59"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the minimum among three given integers. The method should return the smallest value, ensuring that the result is less than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the minimum of the three input numbers, assuring that the returned value is less than or equal to a, b, and c, and that it matches one of these values.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef minOfThree_precond (a : Int) (b : Int) (c : Int) : Prop :=\n  True\n\ndef minOfThree (a : Int) (b : Int) (c : Int) (h_precond : minOfThree_precond (a) (b) (c)) : Int :=\n  if a <= b && a <= c then a\n  else if b <= a && b <= c then b\n  else c\n\n@[reducible, simp]\ndef minOfThree_postcond (a : Int) (b : Int) (c : Int) (result: Int) (h_precond : minOfThree_precond (a) (b) (c)) :=\n  (result <= a ∧ result <= b ∧ result <= c) ∧\n  (result = a ∨ result = b ∨ result = c)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n  unfold minOfThree minOfThree_postcond\n\n  split\n\n  · by_cases h1: a <= b && a <= c\n    · constructor\n      · simp_all\n      · simp\n    · contradiction\n\n  split\n\n  · by_cases h2: b <= a && b <= c\n    · constructor\n      · simp_all\n      · simp\n    · contradiction\n\n  · by_cases h3: c < a && c < b\n    · constructor\n      · simp_all\n        constructor\n        · exact le_of_lt h3.1\n        · exact le_of_lt h3.2\n      · simp\n    · constructor\n      · simp_all\n        by_cases h': a <= b\n        · simp_all\n          have h'': a <= c := by\n            exact le_trans h' h3\n          rw [← not_lt] at h''\n          contradiction\n        · simp_all\n          have _: b <= a := by exact le_of_lt h'\n          simp_all\n          have h'': c < b := by assumption\n          have h''': c < a := by exact lt_trans h'' h'\n          apply h3 at h'''\n          rw [← not_lt] at h'''\n          contradiction\n      · simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_6", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that finds the minimum among three given integers. The method should return the smallest value, ensuring that the result is less than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the minimum of the three input numbers, assuring that the returned value is less than or equal to a, b, and c, and that it matches one of these values.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef minOfThree_precond (a : Int) (b : Int) (c : Int) : Prop :=\n  True\n\ndef minOfThree (a : Int) (b : Int) (c : Int) (h_precond : minOfThree_precond (a) (b) (c)) : Int :=\n  if a <= b && a <= c then a\n  else if b <= a && b <= c then b\n  else c\n\n@[reducible, simp]\ndef minOfThree_postcond (a : Int) (b : Int) (c : Int) (result: Int) (h_precond : minOfThree_precond (a) (b) (c)) :=\n  (result <= a ∧ result <= b ∧ result <= c) ∧\n  (result = a ∨ result = b ∨ result = c)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n```", "ground_truth": "theorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n  unfold minOfThree minOfThree_postcond\n\n  split\n\n  · by_cases h1: a <= b && a <= c\n    · constructor\n      · simp_all\n      · simp\n    · contradiction\n\n  split\n\n  · by_cases h2: b <= a && b <= c\n    · constructor\n      · simp_all\n      · simp\n    · contradiction\n\n  · by_cases h3: c < a && c < b\n    · constructor\n      · simp_all\n        constructor\n        · exact le_of_lt h3.1\n        · exact le_of_lt h3.2\n      · simp\n    · constructor\n      · simp_all\n        by_cases h': a <= b\n        · simp_all\n          have h'': a <= c := by\n            exact le_trans h' h3\n          rw [← not_lt] at h''\n          contradiction\n        · simp_all\n          have _: b <= a := by exact le_of_lt h'\n          simp_all\n          have h'': c < b := by assumption\n          have h''': c < a := by exact lt_trans h'' h'\n          apply h3 at h'''\n          rw [← not_lt] at h'''\n          contradiction\n      · simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_6"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a function that processes an array of integers and produces a new array containing only the even numbers from the input. The order of these even numbers should remain the same as in the original array, ensuring that every even number from the input appears in the output and that every element in the output is even.\n\n-----Input-----  \nThe input consists of one parameter:  \n• arr: An array of integers.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Contains exactly all even numbers from the input array, preserving their original order.  \n• Meets the specified conditions that ensure no extraneous (odd or non-existing) elements are returned.\n\n-----Note-----  \nThere are no additional preconditions. The function must adhere to the provided specification which enforces evenness and order preservation for the elements in the output array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem FindEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :\n    FindEvenNumbers_postcond (arr) (FindEvenNumbers (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0\n\n@[reducible, simp]\ndef FindEvenNumbers_precond (arr : Array Int) : Prop :=\n  True\n\ndef FindEvenNumbers (arr : Array Int) (h_precond : FindEvenNumbers_precond (arr)) : Array Int :=\n  let rec loop (i : Nat) (acc : Array Int) : Array Int :=\n    if i < arr.size then\n      if isEven (arr.getD i 0) then\n        loop (i + 1) (acc.push (arr.getD i 0))\n      else\n        loop (i + 1) acc\n    else\n      acc\n  loop 0 (Array.mkEmpty 0)\n\n@[reducible, simp]\ndef FindEvenNumbers_postcond (arr : Array Int) (result: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :=\n  result.all (fun x => isEven x && x ∈ arr) ∧\n  List.Pairwise (fun (x, i) (y, j) => if i < j then arr.idxOf x ≤ arr.idxOf y else true) (result.toList.zipIdx)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem FindEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :\n    FindEvenNumbers_postcond (arr) (FindEvenNumbers (arr) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_60", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a function that processes an array of integers and produces a new array containing only the even numbers from the input. The order of these even numbers should remain the same as in the original array, ensuring that every even number from the input appears in the output and that every element in the output is even.\n\n-----Input-----  \nThe input consists of one parameter:  \n• arr: An array of integers.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Contains exactly all even numbers from the input array, preserving their original order.  \n• Meets the specified conditions that ensure no extraneous (odd or non-existing) elements are returned.\n\n-----Note-----  \nThere are no additional preconditions. The function must adhere to the provided specification which enforces evenness and order preservation for the elements in the output array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem FindEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :\n    FindEvenNumbers_postcond (arr) (FindEvenNumbers (arr) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0\n\n@[reducible, simp]\ndef FindEvenNumbers_precond (arr : Array Int) : Prop :=\n  True\n\ndef FindEvenNumbers (arr : Array Int) (h_precond : FindEvenNumbers_precond (arr)) : Array Int :=\n  let rec loop (i : Nat) (acc : Array Int) : Array Int :=\n    if i < arr.size then\n      if isEven (arr.getD i 0) then\n        loop (i + 1) (acc.push (arr.getD i 0))\n      else\n        loop (i + 1) acc\n    else\n      acc\n  loop 0 (Array.mkEmpty 0)\n\n@[reducible, simp]\ndef FindEvenNumbers_postcond (arr : Array Int) (result: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :=\n  result.all (fun x => isEven x && x ∈ arr) ∧\n  List.Pairwise (fun (x, i) (y, j) => if i < j then arr.idxOf x ≤ arr.idxOf y else true) (result.toList.zipIdx)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem FindEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :\n    FindEvenNumbers_postcond (arr) (FindEvenNumbers (arr) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_60"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining whether every character in a provided string is a digit. The objective is to check if all characters fall within the standard digit range, returning true if they do and false otherwise.\n\n-----Input-----  \nThe input consists of:  \n• s: A string whose characters will be analyzed to determine if they are all digits.\n\n-----Output-----  \nThe output is a boolean value:  \n• true if every character in the string is a digit;  \n• false if at least one character is not a digit (note that the empty string returns true).\n\n-----Note-----  \nIt is assumed that the input is a well-formed string. The function uses an iterator to examine every character.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem allDigits_spec_satisfied (s: String) (h_precond : allDigits_precond (s)) :\n    allDigits_postcond (s) (allDigits (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isDigit (c : Char) : Bool :=\n  (c ≥ '0') && (c ≤ '9')\n\n@[reducible, simp]\ndef allDigits_precond (s : String) : Prop :=\n  True\n\ndef allDigits (s : String) (h_precond : allDigits_precond (s)) : Bool :=\n  let rec loop (it : String.Iterator) : Bool :=\n    if it.atEnd then\n      true\n    else\n      if !isDigit it.curr then\n        false\n      else\n        loop it.next\n  loop s.iter\n\n@[reducible, simp]\ndef allDigits_postcond (s : String) (result: Bool) (h_precond : allDigits_precond (s)) :=\n  (result = true ↔ ∀ c ∈ s.toList, isDigit c)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem allDigits_spec_satisfied (s: String) (h_precond : allDigits_precond (s)) :\n    allDigits_postcond (s) (allDigits (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_61", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining whether every character in a provided string is a digit. The objective is to check if all characters fall within the standard digit range, returning true if they do and false otherwise.\n\n-----Input-----  \nThe input consists of:  \n• s: A string whose characters will be analyzed to determine if they are all digits.\n\n-----Output-----  \nThe output is a boolean value:  \n• true if every character in the string is a digit;  \n• false if at least one character is not a digit (note that the empty string returns true).\n\n-----Note-----  \nIt is assumed that the input is a well-formed string. The function uses an iterator to examine every character.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem allDigits_spec_satisfied (s: String) (h_precond : allDigits_precond (s)) :\n    allDigits_postcond (s) (allDigits (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef isDigit (c : Char) : Bool :=\n  (c ≥ '0') && (c ≤ '9')\n\n@[reducible, simp]\ndef allDigits_precond (s : String) : Prop :=\n  True\n\ndef allDigits (s : String) (h_precond : allDigits_precond (s)) : Bool :=\n  let rec loop (it : String.Iterator) : Bool :=\n    if it.atEnd then\n      true\n    else\n      if !isDigit it.curr then\n        false\n      else\n        loop it.next\n  loop s.iter\n\n@[reducible, simp]\ndef allDigits_postcond (s : String) (result: Bool) (h_precond : allDigits_precond (s)) :=\n  (result = true ↔ ∀ c ∈ s.toList, isDigit c)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem allDigits_spec_satisfied (s: String) (h_precond : allDigits_precond (s)) :\n    allDigits_postcond (s) (allDigits (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_61"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• key: An integer representing the value to search for in the array.\n\n-----Output-----  \nThe output is an integer which represents:  \n• The index in the array where the key is found, provided that the index is in the range [0, a.size).  \n• -1 if the key is not present in the array.  \nIn addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.\n\n-----Note-----  \nThe function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Find_spec_satisfied (a: Array Int) (key: Int) (h_precond : Find_precond (a) (key)) :\n    Find_postcond (a) (key) (Find (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Find_precond (a : Array Int) (key : Int) : Prop :=\n  True\n\ndef Find (a : Array Int) (key : Int) (h_precond : Find_precond (a) (key)) : Int :=\n  let rec search (index : Nat) : Int :=\n    if index < a.size then\n      if a[index]! = key then Int.ofNat index\n      else search (index + 1)\n    else -1\n  search 0\n\n@[reducible, simp]\ndef Find_postcond (a : Array Int) (key : Int) (result: Int) (h_precond : Find_precond (a) (key)) :=\n  (result = -1 ∨ (result ≥ 0 ∧ result < Int.ofNat a.size))\n  ∧ ((result ≠ -1) → (a[(Int.toNat result)]! = key ∧ ∀ (i : Nat), i < Int.toNat result → a[i]! ≠ key))\n  ∧ ((result = -1) → ∀ (i : Nat), i < a.size → a[i]! ≠ key)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Find_spec_satisfied (a: Array Int) (key: Int) (h_precond : Find_precond (a) (key)) :\n    Find_postcond (a) (key) (Find (a) (key) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_62", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• key: An integer representing the value to search for in the array.\n\n-----Output-----  \nThe output is an integer which represents:  \n• The index in the array where the key is found, provided that the index is in the range [0, a.size).  \n• -1 if the key is not present in the array.  \nIn addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.\n\n-----Note-----  \nThe function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Find_spec_satisfied (a: Array Int) (key: Int) (h_precond : Find_precond (a) (key)) :\n    Find_postcond (a) (key) (Find (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Find_precond (a : Array Int) (key : Int) : Prop :=\n  True\n\ndef Find (a : Array Int) (key : Int) (h_precond : Find_precond (a) (key)) : Int :=\n  let rec search (index : Nat) : Int :=\n    if index < a.size then\n      if a[index]! = key then Int.ofNat index\n      else search (index + 1)\n    else -1\n  search 0\n\n@[reducible, simp]\ndef Find_postcond (a : Array Int) (key : Int) (result: Int) (h_precond : Find_precond (a) (key)) :=\n  (result = -1 ∨ (result ≥ 0 ∧ result < Int.ofNat a.size))\n  ∧ ((result ≠ -1) → (a[(Int.toNat result)]! = key ∧ ∀ (i : Nat), i < Int.toNat result → a[i]! ≠ key))\n  ∧ ((result = -1) → ∀ (i : Nat), i < a.size → a[i]! ≠ key)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Find_spec_satisfied (a: Array Int) (key: Int) (h_precond : Find_precond (a) (key)) :\n    Find_postcond (a) (key) (Find (a) (key) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_62"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to determine whether there exists at least one pair of different floating-point numbers in a list such that the absolute difference between them is less than a given threshold. The focus is solely on deciding if such a pair is present in the list.\n\n-----Input-----  \nThe input consists of:  \n• numbers: A list of floating-point numbers.  \n• threshold: A floating-point number representing the maximum allowed difference between two numbers for them to be considered \"close.\"  \n\n-----Output-----  \nThe output is a boolean value:  \n• true – if there exists at least one pair of distinct elements in the list such that the absolute difference between them is less than the threshold.  \n• false – if for every possible pair of elements, the absolute difference is greater than or equal to the threshold.\n\n-----Note-----  \nIt is assumed that the list of numbers is provided and that the threshold is non-negative.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem has_close_elements_spec_satisfied (numbers: List Float) (threshold: Float) (h_precond : has_close_elements_precond (numbers) (threshold)) :\n    has_close_elements_postcond (numbers) (threshold) (has_close_elements (numbers) (threshold) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef absDiff (a b : Float) : Float :=\n  if a - b < 0.0 then b - a else a - b\n\n@[reducible, simp]\ndef has_close_elements_precond (numbers : List Float) (threshold : Float) : Prop :=\n  threshold ≥ 0.0\n\ndef has_close_elements (numbers : List Float) (threshold : Float) (h_precond : has_close_elements_precond (numbers) (threshold)) : Bool :=\n  let len := numbers.length\n  let rec outer (idx : Nat) : Bool :=\n    if idx < len then\n      let rec inner (idx2 : Nat) : Bool :=\n        if idx2 < idx then\n          let a := numbers.getD idx2 0.0\n          let b := numbers.getD idx 0.0\n          let d := absDiff a b\n          if d < threshold then true else inner (idx2 + 1)\n        else\n          false\n      if inner 0 then true else outer (idx + 1)\n    else\n      false\n  outer 0\n\n@[reducible, simp]\ndef has_close_elements_postcond (numbers : List Float) (threshold : Float) (result: Bool) (h_precond : has_close_elements_precond (numbers) (threshold)) :=\n  ¬ result ↔ (List.Pairwise (fun a b => absDiff a b ≥ threshold) numbers)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem has_close_elements_spec_satisfied (numbers: List Float) (threshold: Float) (h_precond : has_close_elements_precond (numbers) (threshold)) :\n    has_close_elements_postcond (numbers) (threshold) (has_close_elements (numbers) (threshold) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_63", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to determine whether there exists at least one pair of different floating-point numbers in a list such that the absolute difference between them is less than a given threshold. The focus is solely on deciding if such a pair is present in the list.\n\n-----Input-----  \nThe input consists of:  \n• numbers: A list of floating-point numbers.  \n• threshold: A floating-point number representing the maximum allowed difference between two numbers for them to be considered \"close.\"  \n\n-----Output-----  \nThe output is a boolean value:  \n• true – if there exists at least one pair of distinct elements in the list such that the absolute difference between them is less than the threshold.  \n• false – if for every possible pair of elements, the absolute difference is greater than or equal to the threshold.\n\n-----Note-----  \nIt is assumed that the list of numbers is provided and that the threshold is non-negative.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem has_close_elements_spec_satisfied (numbers: List Float) (threshold: Float) (h_precond : has_close_elements_precond (numbers) (threshold)) :\n    has_close_elements_postcond (numbers) (threshold) (has_close_elements (numbers) (threshold) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\ndef absDiff (a b : Float) : Float :=\n  if a - b < 0.0 then b - a else a - b\n\n@[reducible, simp]\ndef has_close_elements_precond (numbers : List Float) (threshold : Float) : Prop :=\n  threshold ≥ 0.0\n\ndef has_close_elements (numbers : List Float) (threshold : Float) (h_precond : has_close_elements_precond (numbers) (threshold)) : Bool :=\n  let len := numbers.length\n  let rec outer (idx : Nat) : Bool :=\n    if idx < len then\n      let rec inner (idx2 : Nat) : Bool :=\n        if idx2 < idx then\n          let a := numbers.getD idx2 0.0\n          let b := numbers.getD idx 0.0\n          let d := absDiff a b\n          if d < threshold then true else inner (idx2 + 1)\n        else\n          false\n      if inner 0 then true else outer (idx + 1)\n    else\n      false\n  outer 0\n\n@[reducible, simp]\ndef has_close_elements_postcond (numbers : List Float) (threshold : Float) (result: Bool) (h_precond : has_close_elements_precond (numbers) (threshold)) :=\n  ¬ result ↔ (List.Pairwise (fun a b => absDiff a b ≥ threshold) numbers)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem has_close_elements_spec_satisfied (numbers: List Float) (threshold: Float) (h_precond : has_close_elements_precond (numbers) (threshold)) :\n    has_close_elements_postcond (numbers) (threshold) (has_close_elements (numbers) (threshold) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_63"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:\n• All characters before the insertion position (atPos) remain unchanged.  \n• The new characters from nl are inserted starting at index atPos.  \n• The remaining characters from the original array (starting at atPos) are shifted right by p positions.\n\n-----Input-----  \nThe input consists of:  \n• oline: An array of characters representing the original sequence.  \n• l: A natural number indicating how many characters from oline to consider.  \n• nl: An array of characters to be inserted into oline.  \n• p: A natural number indicating how many characters from nl to consider for insertion.  \n• atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).\n\n-----Output-----  \nThe output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:  \n• Contain the original characters from index 0 up to (but not including) atPos.  \n• Have the next p characters equal to the characters from nl.  \n• Contain the remaining characters from oline (starting from atPos) shifted right by p positions.\n\n-----Note-----  \nIt is assumed that:  \n• atPos is within the range [0, l].  \n• l does not exceed the size of oline.  \n• p does not exceed the size of nl.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem insert_spec_satisfied (oline: Array Char) (l: Nat) (nl: Array Char) (p: Nat) (atPos: Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :\n    insert_postcond (oline) (l) (nl) (p) (atPos) (insert (oline) (l) (nl) (p) (atPos) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef insert_precond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) : Prop :=\n  l ≤ oline.size ∧\n  p ≤ nl.size ∧\n  atPos ≤ l\n\ndef insert (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) : Array Char :=\n  let result := Array.mkArray (l + p) ' '\n\n  let result := Array.foldl\n    (fun acc i =>\n      if i < atPos then acc.set! i (oline[i]!) else acc)\n    result\n    (Array.range l)\n\n  let result := Array.foldl\n    (fun acc i =>\n      acc.set! (atPos + i) (nl[i]!))\n    result\n    (Array.range p)\n\n  let result := Array.foldl\n    (fun acc i =>\n      if i >= atPos then acc.set! (i + p) (oline[i]!) else acc)\n    result\n    (Array.range l)\n\n  result\n\n@[reducible, simp]\ndef insert_postcond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (result: Array Char) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :=\n  result.size = l + p ∧\n  (List.range p).all (fun i => result[atPos + i]! = nl[i]!) ∧\n  (List.range atPos).all (fun i => result[i]! = oline[i]!) ∧\n  (List.range (l - atPos)).all (fun i => result[atPos + p + i]! = oline[atPos + i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem insert_spec_satisfied (oline: Array Char) (l: Nat) (nl: Array Char) (p: Nat) (atPos: Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :\n    insert_postcond (oline) (l) (nl) (p) (atPos) (insert (oline) (l) (nl) (p) (atPos) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_64", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:\n• All characters before the insertion position (atPos) remain unchanged.  \n• The new characters from nl are inserted starting at index atPos.  \n• The remaining characters from the original array (starting at atPos) are shifted right by p positions.\n\n-----Input-----  \nThe input consists of:  \n• oline: An array of characters representing the original sequence.  \n• l: A natural number indicating how many characters from oline to consider.  \n• nl: An array of characters to be inserted into oline.  \n• p: A natural number indicating how many characters from nl to consider for insertion.  \n• atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).\n\n-----Output-----  \nThe output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:  \n• Contain the original characters from index 0 up to (but not including) atPos.  \n• Have the next p characters equal to the characters from nl.  \n• Contain the remaining characters from oline (starting from atPos) shifted right by p positions.\n\n-----Note-----  \nIt is assumed that:  \n• atPos is within the range [0, l].  \n• l does not exceed the size of oline.  \n• p does not exceed the size of nl.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem insert_spec_satisfied (oline: Array Char) (l: Nat) (nl: Array Char) (p: Nat) (atPos: Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :\n    insert_postcond (oline) (l) (nl) (p) (atPos) (insert (oline) (l) (nl) (p) (atPos) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef insert_precond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) : Prop :=\n  l ≤ oline.size ∧\n  p ≤ nl.size ∧\n  atPos ≤ l\n\ndef insert (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) : Array Char :=\n  let result := Array.mkArray (l + p) ' '\n\n  let result := Array.foldl\n    (fun acc i =>\n      if i < atPos then acc.set! i (oline[i]!) else acc)\n    result\n    (Array.range l)\n\n  let result := Array.foldl\n    (fun acc i =>\n      acc.set! (atPos + i) (nl[i]!))\n    result\n    (Array.range p)\n\n  let result := Array.foldl\n    (fun acc i =>\n      if i >= atPos then acc.set! (i + p) (oline[i]!) else acc)\n    result\n    (Array.range l)\n\n  result\n\n@[reducible, simp]\ndef insert_postcond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (result: Array Char) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :=\n  result.size = l + p ∧\n  (List.range p).all (fun i => result[atPos + i]! = nl[i]!) ∧\n  (List.range atPos).all (fun i => result[i]! = oline[i]!) ∧\n  (List.range (l - atPos)).all (fun i => result[atPos + p + i]! = oline[atPos + i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem insert_spec_satisfied (oline: Array Char) (l: Nat) (nl: Array Char) (p: Nat) (atPos: Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :\n    insert_postcond (oline) (l) (nl) (p) (atPos) (insert (oline) (l) (nl) (p) (atPos) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_64"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves computing the integer square root of a given natural number. The goal is to determine the largest natural number r that satisfies r * r ≤ N and N < (r + 1) * (r + 1).\n\n-----Input-----  \nThe input consists of:  \n• N: A natural number.\n\n-----Output-----  \nThe output is a natural number r that meets the following conditions:  \n• r * r ≤ N  \n• N < (r + 1) * (r + 1)\n\n-----Note-----  \nThe implementation relies on a recursive strategy to iteratively increment r until (r + 1)*(r + 1) exceeds N. Edge cases, such as N = 0, should be handled correctly.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SquareRoot_spec_satisfied (N: Nat) (h_precond : SquareRoot_precond (N)) :\n    SquareRoot_postcond (N) (SquareRoot (N) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SquareRoot_precond (N : Nat) : Prop :=\n  True\n\ndef SquareRoot (N : Nat) (h_precond : SquareRoot_precond (N)) : Nat :=\n  let rec boundedLoop : Nat → Nat → Nat\n    | 0, r => r\n    | bound+1, r =>\n        if (r + 1) * (r + 1) ≤ N then\n          boundedLoop bound (r + 1)\n        else\n          r\n  boundedLoop (N+1) 0\n\n@[reducible, simp]\ndef SquareRoot_postcond (N : Nat) (result: Nat) (h_precond : SquareRoot_precond (N)) :=\n  result * result ≤ N ∧ N < (result + 1) * (result + 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SquareRoot_spec_satisfied (N: Nat) (h_precond : SquareRoot_precond (N)) :\n    SquareRoot_postcond (N) (SquareRoot (N) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_65", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves computing the integer square root of a given natural number. The goal is to determine the largest natural number r that satisfies r * r ≤ N and N < (r + 1) * (r + 1).\n\n-----Input-----  \nThe input consists of:  \n• N: A natural number.\n\n-----Output-----  \nThe output is a natural number r that meets the following conditions:  \n• r * r ≤ N  \n• N < (r + 1) * (r + 1)\n\n-----Note-----  \nThe implementation relies on a recursive strategy to iteratively increment r until (r + 1)*(r + 1) exceeds N. Edge cases, such as N = 0, should be handled correctly.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SquareRoot_spec_satisfied (N: Nat) (h_precond : SquareRoot_precond (N)) :\n    SquareRoot_postcond (N) (SquareRoot (N) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SquareRoot_precond (N : Nat) : Prop :=\n  True\n\ndef SquareRoot (N : Nat) (h_precond : SquareRoot_precond (N)) : Nat :=\n  let rec boundedLoop : Nat → Nat → Nat\n    | 0, r => r\n    | bound+1, r =>\n        if (r + 1) * (r + 1) ≤ N then\n          boundedLoop bound (r + 1)\n        else\n          r\n  boundedLoop (N+1) 0\n\n@[reducible, simp]\ndef SquareRoot_postcond (N : Nat) (result: Nat) (h_precond : SquareRoot_precond (N)) :=\n  result * result ≤ N ∧ N < (result + 1) * (result + 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SquareRoot_spec_satisfied (N: Nat) (h_precond : SquareRoot_precond (N)) :\n    SquareRoot_postcond (N) (SquareRoot (N) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_65"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task focuses on determining if a given integer is even. The problem requires checking whether the integer can be represented as twice another integer, meaning it is divisible by 2 without any remainder.\n\n-----Input-----  \nThe input consists of a single integer:  \n• x: An integer to be evaluated.\n\n-----Output-----  \nThe output is a boolean value:  \n• true if x is even (x mod 2 equals 0).  \n• false if x is odd.\n\n-----Note-----  \nNo additional preconditions are required. The method should work correctly for any integer value.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef ComputeIsEven_precond (x : Int) : Prop :=\n  True\n\ndef ComputeIsEven (x : Int) (h_precond : ComputeIsEven_precond (x)) : Bool :=\n  if x % 2 = 0 then true else false\n\n@[reducible, simp]\ndef ComputeIsEven_postcond (x : Int) (result: Bool) (h_precond : ComputeIsEven_precond (x)) :=\n  result = true ↔ ∃ k : Int, x = 2 * k\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n  unfold ComputeIsEven ComputeIsEven_postcond\n  simp\n  rfl"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_66", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task focuses on determining if a given integer is even. The problem requires checking whether the integer can be represented as twice another integer, meaning it is divisible by 2 without any remainder.\n\n-----Input-----  \nThe input consists of a single integer:  \n• x: An integer to be evaluated.\n\n-----Output-----  \nThe output is a boolean value:  \n• true if x is even (x mod 2 equals 0).  \n• false if x is odd.\n\n-----Note-----  \nNo additional preconditions are required. The method should work correctly for any integer value.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef ComputeIsEven_precond (x : Int) : Prop :=\n  True\n\ndef ComputeIsEven (x : Int) (h_precond : ComputeIsEven_precond (x)) : Bool :=\n  if x % 2 = 0 then true else false\n\n@[reducible, simp]\ndef ComputeIsEven_postcond (x : Int) (result: Bool) (h_precond : ComputeIsEven_precond (x)) :=\n  result = true ↔ ∃ k : Int, x = 2 * k\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n```", "ground_truth": "theorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n  unfold ComputeIsEven ComputeIsEven_postcond\n  simp\n  rfl", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_66"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires determining whether a given list of characters is a palindrome; that is, whether the sequence reads the same forward and backward.\n\n-----Input-----  \nThe input consists of:  \n• x: A list of characters (List Char). The list can be empty or non-empty.\n\n-----Output-----  \nThe output is a Boolean value (Bool):  \n• Returns true if the input list is a palindrome.  \n• Returns false otherwise.\n\n-----Note-----  \nAn empty list is considered a palindrome. The function does not impose any additional preconditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem IsPalindrome_spec_satisfied (x: List Char) (h_precond : IsPalindrome_precond (x)) :\n    IsPalindrome_postcond (x) (IsPalindrome (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef IsPalindrome_precond (x : List Char) : Prop :=\n  True\n\ndef isPalindromeHelper (x : List Char) (i j : Nat) : Bool :=\n  if i < j then\n    match x[i]?, x[j]? with\n    | some ci, some cj =>\n      if ci ≠ cj then false else isPalindromeHelper x (i + 1) (j - 1)\n    | _, _ => false  -- This case should not occur due to valid indices\n  else true\n\ndef IsPalindrome (x : List Char) (h_precond : IsPalindrome_precond (x)) : Bool :=\n  if x.length = 0 then true else isPalindromeHelper x 0 (x.length - 1)\n\n@[reducible, simp]\ndef IsPalindrome_postcond (x : List Char) (result: Bool) (h_precond : IsPalindrome_precond (x)) :=\n  result ↔ ∀ i : Nat, i < x.length → (x[i]! = x[x.length - i - 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem IsPalindrome_spec_satisfied (x: List Char) (h_precond : IsPalindrome_precond (x)) :\n    IsPalindrome_postcond (x) (IsPalindrome (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_67", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires determining whether a given list of characters is a palindrome; that is, whether the sequence reads the same forward and backward.\n\n-----Input-----  \nThe input consists of:  \n• x: A list of characters (List Char). The list can be empty or non-empty.\n\n-----Output-----  \nThe output is a Boolean value (Bool):  \n• Returns true if the input list is a palindrome.  \n• Returns false otherwise.\n\n-----Note-----  \nAn empty list is considered a palindrome. The function does not impose any additional preconditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem IsPalindrome_spec_satisfied (x: List Char) (h_precond : IsPalindrome_precond (x)) :\n    IsPalindrome_postcond (x) (IsPalindrome (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef IsPalindrome_precond (x : List Char) : Prop :=\n  True\n\ndef isPalindromeHelper (x : List Char) (i j : Nat) : Bool :=\n  if i < j then\n    match x[i]?, x[j]? with\n    | some ci, some cj =>\n      if ci ≠ cj then false else isPalindromeHelper x (i + 1) (j - 1)\n    | _, _ => false  -- This case should not occur due to valid indices\n  else true\n\ndef IsPalindrome (x : List Char) (h_precond : IsPalindrome_precond (x)) : Bool :=\n  if x.length = 0 then true else isPalindromeHelper x 0 (x.length - 1)\n\n@[reducible, simp]\ndef IsPalindrome_postcond (x : List Char) (result: Bool) (h_precond : IsPalindrome_precond (x)) :=\n  result ↔ ∀ i : Nat, i < x.length → (x[i]! = x[x.length - i - 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem IsPalindrome_spec_satisfied (x: List Char) (h_precond : IsPalindrome_precond (x)) :\n    IsPalindrome_postcond (x) (IsPalindrome (x) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_67"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• e: An integer representing the target to search for in the array.\n\n-----Output-----  \nThe output is a natural number (Nat) which is:  \n• The index of the first occurrence of the target integer if found.  \n• The size of the array if the target integer is not present.  \n\n-----Note-----  \nThere are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array’s size if the element is absent.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef LinearSearch_precond (a : Array Int) (e : Int) : Prop :=\n  True\n\ndef LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=\n  let rec loop (n : Nat) : Nat :=\n    if n < a.size then\n      if a[n]! = e then n\n      else loop (n + 1)\n    else n\n  loop 0\n\n@[reducible, simp]\ndef LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=\n  result ≤ a.size ∧ (result = a.size ∨ a[result]! = e) ∧ (∀ i, i < result → a[i]! ≠ e)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n  unfold LinearSearch_postcond LinearSearch\n  apply And.intro\n  . let aux (x : Nat) : (0 ≤ x) → (x ≤ a.size) → LinearSearch.loop a e x ≤ a.size := by\n      intro hx₀ hx₁\n      let nx := a.size - x\n      have hn₁ : nx = a.size - x := by rfl\n      have hn₂ : x = a.size - nx := by\n        rw [hn₁, Nat.sub_sub_self]\n        apply hx₁\n      rw [hn₂]\n      induction nx with\n      | zero =>\n        unfold LinearSearch.loop\n        simp\n      | succ n₁ ih =>\n        by_cases hp : (a.size ≤ n₁)\n        . rw [Nat.sub_eq_zero_of_le hp] at ih\n          have h_tmp : a.size ≤ n₁ + 1 := Nat.le_add_right_of_le hp\n          rw [Nat.sub_eq_zero_of_le h_tmp]\n          exact ih\n        . have hq : n₁ < a.size := Nat.not_le.mp hp\n          unfold LinearSearch.loop\n          simp\n          split_ifs\n          . simp\n          . rw [Nat.sub_add_eq, Nat.sub_add_cancel]\n            exact ih\n            apply Nat.zero_lt_sub_of_lt\n            exact hq\n          simp\n    have h₀ : 0 ≤ a.size := by simp\n    have h_triv : 0 ≤ 0 := by simp\n    exact aux 0 h_triv h₀\n  . apply And.intro\n    . let aux (x : Nat) : (x ≥ 0) → (x ≤ a.size) → LinearSearch.loop a e x = a.size ∨ a[LinearSearch.loop a e x]! = e := by\n        intro hx₀ hx₁\n        let nx := a.size - x\n        have hn₁ : nx = a.size - x := by rfl\n        have hn₂ : x = a.size - nx := by\n          rw [hn₁, Nat.sub_sub_self]\n          apply hx₁\n        rw [hn₂]\n        induction nx with\n        | zero =>\n          unfold LinearSearch.loop\n          simp\n        | succ n₁ ih =>\n          by_cases hp : (a.size ≤ n₁)\n          . rw [Nat.sub_eq_zero_of_le hp] at ih\n            have h_tmp : a.size ≤ n₁ + 1 := Nat.le_add_right_of_le hp\n            rw [Nat.sub_eq_zero_of_le h_tmp]\n            exact ih\n          . have hq : n₁ < a.size := Nat.not_le.mp hp\n            apply Or.elim ih -- Didn't find elem, so we're gonna also return a.size...\n            . intro ih₁\n              unfold LinearSearch.loop\n              split_ifs\n              . rename_i h₁ h₂\n                rw [h₂]\n                simp\n              . rename_i ha₁ ha₂\n                rw [Nat.sub_add_eq, Nat.sub_add_cancel]\n                rw [ih₁]\n                simp\n                apply Nat.zero_lt_sub_of_lt\n                exact hq\n              . rename_i h₁\n                have ha₁ := Nat.not_lt.mp h₁\n                have ha₂ := Nat.sub_le a.size (n₁ + 1)\n                have ha := Nat.eq_iff_le_and_ge.mpr ⟨ha₁, ha₂⟩\n                rw [←ha]\n                simp\n            . intro ih₂\n              unfold LinearSearch.loop\n              split_ifs\n              . rename_i h₁ h₂\n                rw [h₂]\n                simp\n              . rename_i ha₁ ha₂\n                rw [Nat.sub_add_eq, Nat.sub_add_cancel]\n                rw [ih₂]\n                simp\n                apply Nat.zero_lt_sub_of_lt\n                exact hq\n              . rename_i h₁\n                have ha₁ := Nat.not_lt.mp h₁\n                have ha₂ := Nat.sub_le a.size (n₁ + 1)\n                have ha := Nat.eq_iff_le_and_ge.mpr ⟨ha₁, ha₂⟩\n                rw [←ha]\n                simp\n      have h₀ : 0 ≤ 0 := by simp\n      have h₁ : 0 ≤ a.size := by simp\n      exact aux 0 h₀ h₁\n    . let aux (x : Nat) : (0 ≤ x) → (x ≤ a.size) → (∀ i, x ≤ i → i < LinearSearch.loop a e x → a[i]! ≠ e) := by\n        intro hx₀ hx₁ i\n        let nx := a.size - x\n        have hn₁ : nx = a.size - x := by rfl\n        have hn₂ : x = a.size - nx := by\n          rw [hn₁, Nat.sub_sub_self]\n          apply hx₁\n        rw [hn₂]\n        induction nx with\n        | zero =>\n          unfold LinearSearch.loop\n          simp\n          intro hxi hi\n          have h_contr := Nat.lt_of_le_of_lt hxi hi\n          have h : a.size ≤ a.size := by simp\n          have h : a.size - a.size < a.size - a.size := Nat.sub_lt_sub_right h h_contr\n          simp at h\n        | succ n ih =>\n          intro hxi\n          unfold LinearSearch.loop\n          simp\n          split_ifs\n          . rename_i h₁ h₂\n            intro h_contr\n            have h := Nat.lt_of_le_of_lt hxi h_contr\n            simp at h\n          . rename_i h₁ h₂\n            by_cases hp : (a.size ≤ n)\n            . rw [Nat.sub_eq_zero_iff_le.mpr hp] at ih\n              intro hi\n              have hp₁ : a.size ≤ n + 1 := by\n                have h₁' : n ≤ n + 1 := by simp\n                exact Nat.le_trans hp h₁'\n              rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at hxi\n              rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at hi\n              rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at h₂\n              have ih₁ := ih hxi\n              simp at hi\n              unfold LinearSearch.loop at ih₁\n              split_ifs at ih₁\n              . rename_i h₁'\n                simp at ih₁\n                exact ih₁ hi\n              . rename_i h₁'\n                contradiction\n            . have hq : n < a.size := Nat.not_le.mp hp\n              have hq' : 1 ≤ a.size - n := by\n                have h : 0 < a.size - n := by\n                  exact Nat.sub_pos_of_lt hq\n                exact Nat.one_le_iff_ne_zero.mpr (Nat.ne_zero_of_lt h)\n              rw [Nat.sub_add_eq, Nat.sub_add_cancel hq']\n              intro hi\n              by_cases h_bounds : (a.size - n ≤ i)\n              . exact ih h_bounds hi\n              . have h_bounds' : ( i + 1 < a.size - n + 1) := (@Nat.add_lt_add_iff_right 1 i (a.size - n)).mpr (Nat.not_le.mp h_bounds)\n                have h := Nat.le_of_lt_add_one h_bounds'\n                apply Nat.le_sub_of_add_le at h\n                rw [← Nat.sub_add_eq] at h\n                have hi_fixed := Nat.eq_iff_le_and_ge.mpr ⟨hxi, h⟩\n                rw [hi_fixed] at h₂\n                exact h₂\n          . intro h_contr\n            have h := Nat.lt_of_le_of_lt hxi h_contr\n            simp at h\n      have h₀ : 0 ≤ a.size := by simp\n      have h_triv : 0 ≤ 0 := by simp\n      intro i\n      have h_tmp : 0 ≤ i := Nat.zero_le i\n      exact aux 0 h_triv h₀ i h_tmp\n"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_68", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• e: An integer representing the target to search for in the array.\n\n-----Output-----  \nThe output is a natural number (Nat) which is:  \n• The index of the first occurrence of the target integer if found.  \n• The size of the array if the target integer is not present.  \n\n-----Note-----  \nThere are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array’s size if the element is absent.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef LinearSearch_precond (a : Array Int) (e : Int) : Prop :=\n  True\n\ndef LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=\n  let rec loop (n : Nat) : Nat :=\n    if n < a.size then\n      if a[n]! = e then n\n      else loop (n + 1)\n    else n\n  loop 0\n\n@[reducible, simp]\ndef LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=\n  result ≤ a.size ∧ (result = a.size ∨ a[result]! = e) ∧ (∀ i, i < result → a[i]! ≠ e)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```", "ground_truth": "theorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n  unfold LinearSearch_postcond LinearSearch\n  apply And.intro\n  . let aux (x : Nat) : (0 ≤ x) → (x ≤ a.size) → LinearSearch.loop a e x ≤ a.size := by\n      intro hx₀ hx₁\n      let nx := a.size - x\n      have hn₁ : nx = a.size - x := by rfl\n      have hn₂ : x = a.size - nx := by\n        rw [hn₁, Nat.sub_sub_self]\n        apply hx₁\n      rw [hn₂]\n      induction nx with\n      | zero =>\n        unfold LinearSearch.loop\n        simp\n      | succ n₁ ih =>\n        by_cases hp : (a.size ≤ n₁)\n        . rw [Nat.sub_eq_zero_of_le hp] at ih\n          have h_tmp : a.size ≤ n₁ + 1 := Nat.le_add_right_of_le hp\n          rw [Nat.sub_eq_zero_of_le h_tmp]\n          exact ih\n        . have hq : n₁ < a.size := Nat.not_le.mp hp\n          unfold LinearSearch.loop\n          simp\n          split_ifs\n          . simp\n          . rw [Nat.sub_add_eq, Nat.sub_add_cancel]\n            exact ih\n            apply Nat.zero_lt_sub_of_lt\n            exact hq\n          simp\n    have h₀ : 0 ≤ a.size := by simp\n    have h_triv : 0 ≤ 0 := by simp\n    exact aux 0 h_triv h₀\n  . apply And.intro\n    . let aux (x : Nat) : (x ≥ 0) → (x ≤ a.size) → LinearSearch.loop a e x = a.size ∨ a[LinearSearch.loop a e x]! = e := by\n        intro hx₀ hx₁\n        let nx := a.size - x\n        have hn₁ : nx = a.size - x := by rfl\n        have hn₂ : x = a.size - nx := by\n          rw [hn₁, Nat.sub_sub_self]\n          apply hx₁\n        rw [hn₂]\n        induction nx with\n        | zero =>\n          unfold LinearSearch.loop\n          simp\n        | succ n₁ ih =>\n          by_cases hp : (a.size ≤ n₁)\n          . rw [Nat.sub_eq_zero_of_le hp] at ih\n            have h_tmp : a.size ≤ n₁ + 1 := Nat.le_add_right_of_le hp\n            rw [Nat.sub_eq_zero_of_le h_tmp]\n            exact ih\n          . have hq : n₁ < a.size := Nat.not_le.mp hp\n            apply Or.elim ih -- Didn't find elem, so we're gonna also return a.size...\n            . intro ih₁\n              unfold LinearSearch.loop\n              split_ifs\n              . rename_i h₁ h₂\n                rw [h₂]\n                simp\n              . rename_i ha₁ ha₂\n                rw [Nat.sub_add_eq, Nat.sub_add_cancel]\n                rw [ih₁]\n                simp\n                apply Nat.zero_lt_sub_of_lt\n                exact hq\n              . rename_i h₁\n                have ha₁ := Nat.not_lt.mp h₁\n                have ha₂ := Nat.sub_le a.size (n₁ + 1)\n                have ha := Nat.eq_iff_le_and_ge.mpr ⟨ha₁, ha₂⟩\n                rw [←ha]\n                simp\n            . intro ih₂\n              unfold LinearSearch.loop\n              split_ifs\n              . rename_i h₁ h₂\n                rw [h₂]\n                simp\n              . rename_i ha₁ ha₂\n                rw [Nat.sub_add_eq, Nat.sub_add_cancel]\n                rw [ih₂]\n                simp\n                apply Nat.zero_lt_sub_of_lt\n                exact hq\n              . rename_i h₁\n                have ha₁ := Nat.not_lt.mp h₁\n                have ha₂ := Nat.sub_le a.size (n₁ + 1)\n                have ha := Nat.eq_iff_le_and_ge.mpr ⟨ha₁, ha₂⟩\n                rw [←ha]\n                simp\n      have h₀ : 0 ≤ 0 := by simp\n      have h₁ : 0 ≤ a.size := by simp\n      exact aux 0 h₀ h₁\n    . let aux (x : Nat) : (0 ≤ x) → (x ≤ a.size) → (∀ i, x ≤ i → i < LinearSearch.loop a e x → a[i]! ≠ e) := by\n        intro hx₀ hx₁ i\n        let nx := a.size - x\n        have hn₁ : nx = a.size - x := by rfl\n        have hn₂ : x = a.size - nx := by\n          rw [hn₁, Nat.sub_sub_self]\n          apply hx₁\n        rw [hn₂]\n        induction nx with\n        | zero =>\n          unfold LinearSearch.loop\n          simp\n          intro hxi hi\n          have h_contr := Nat.lt_of_le_of_lt hxi hi\n          have h : a.size ≤ a.size := by simp\n          have h : a.size - a.size < a.size - a.size := Nat.sub_lt_sub_right h h_contr\n          simp at h\n        | succ n ih =>\n          intro hxi\n          unfold LinearSearch.loop\n          simp\n          split_ifs\n          . rename_i h₁ h₂\n            intro h_contr\n            have h := Nat.lt_of_le_of_lt hxi h_contr\n            simp at h\n          . rename_i h₁ h₂\n            by_cases hp : (a.size ≤ n)\n            . rw [Nat.sub_eq_zero_iff_le.mpr hp] at ih\n              intro hi\n              have hp₁ : a.size ≤ n + 1 := by\n                have h₁' : n ≤ n + 1 := by simp\n                exact Nat.le_trans hp h₁'\n              rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at hxi\n              rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at hi\n              rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at h₂\n              have ih₁ := ih hxi\n              simp at hi\n              unfold LinearSearch.loop at ih₁\n              split_ifs at ih₁\n              . rename_i h₁'\n                simp at ih₁\n                exact ih₁ hi\n              . rename_i h₁'\n                contradiction\n            . have hq : n < a.size := Nat.not_le.mp hp\n              have hq' : 1 ≤ a.size - n := by\n                have h : 0 < a.size - n := by\n                  exact Nat.sub_pos_of_lt hq\n                exact Nat.one_le_iff_ne_zero.mpr (Nat.ne_zero_of_lt h)\n              rw [Nat.sub_add_eq, Nat.sub_add_cancel hq']\n              intro hi\n              by_cases h_bounds : (a.size - n ≤ i)\n              . exact ih h_bounds hi\n              . have h_bounds' : ( i + 1 < a.size - n + 1) := (@Nat.add_lt_add_iff_right 1 i (a.size - n)).mpr (Nat.not_le.mp h_bounds)\n                have h := Nat.le_of_lt_add_one h_bounds'\n                apply Nat.le_sub_of_add_le at h\n                rw [← Nat.sub_add_eq] at h\n                have hi_fixed := Nat.eq_iff_le_and_ge.mpr ⟨hxi, h⟩\n                rw [hi_fixed] at h₂\n                exact h₂\n          . intro h_contr\n            have h := Nat.lt_of_le_of_lt hxi h_contr\n            simp at h\n      have h₀ : 0 ≤ a.size := by simp\n      have h_triv : 0 ≤ 0 := by simp\n      intro i\n      have h_tmp : 0 ≤ i := Nat.zero_le i\n      exact aux 0 h_triv h₀ i h_tmp\n", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_68"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves determining the index of the first occurrence of a specified element within an array of integers. The objective is to identify the correct position where the target element appears for the first time, ensuring that all elements prior to that index are different from the target.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• e: An integer representing the element to search for.\n\n-----Output-----  \nThe output is a natural number (Nat) representing the index of the first occurrence of e in the array.  \n• If the element e exists in the array, the index n will satisfy the conditions specified above.\n\n-----Note-----  \nIt is assumed that the input satisfies the precondition where at least one index i in a exists such that a[i]! = e.  \nThe implementation uses a helper function to iterate through the array recursively.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LinearSearch_precond (a : Array Int) (e : Int) : Prop :=\n  ∃ i, i < a.size ∧ a[i]! = e\n\ndef linearSearchAux (a : Array Int) (e : Int) (n : Nat) : Nat :=\n  if n < a.size then\n    if a[n]! = e then n else linearSearchAux a e (n + 1)\n  else\n    0\n\ndef LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=\n  linearSearchAux a e 0\n\n@[reducible, simp]\ndef LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=\n  (result < a.size) ∧ (a[result]! = e) ∧ (∀ k : Nat, k < result → a[k]! ≠ e)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_69", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves determining the index of the first occurrence of a specified element within an array of integers. The objective is to identify the correct position where the target element appears for the first time, ensuring that all elements prior to that index are different from the target.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• e: An integer representing the element to search for.\n\n-----Output-----  \nThe output is a natural number (Nat) representing the index of the first occurrence of e in the array.  \n• If the element e exists in the array, the index n will satisfy the conditions specified above.\n\n-----Note-----  \nIt is assumed that the input satisfies the precondition where at least one index i in a exists such that a[i]! = e.  \nThe implementation uses a helper function to iterate through the array recursively.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LinearSearch_precond (a : Array Int) (e : Int) : Prop :=\n  ∃ i, i < a.size ∧ a[i]! = e\n\ndef linearSearchAux (a : Array Int) (e : Int) (n : Nat) : Nat :=\n  if n < a.size then\n    if a[n]! = e then n else linearSearchAux a e (n + 1)\n  else\n    0\n\ndef LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=\n  linearSearchAux a e 0\n\n@[reducible, simp]\ndef LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=\n  (result < a.size) ∧ (a[result]! = e) ∧ (∀ k : Nat, k < result → a[k]! ≠ e)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_69"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the sum of the squares of the first n odd natural numbers. The result should match the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of odd natural numbers to consider (n should be non-negative).\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the squares of the first n odd natural numbers, as defined by the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumOfSquaresOfFirstNOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :\n    sumOfSquaresOfFirstNOddNumbers_postcond (n) (sumOfSquaresOfFirstNOddNumbers (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumOfSquaresOfFirstNOddNumbers_precond (n : Nat) : Prop :=\n  True\n\ndef sumOfSquaresOfFirstNOddNumbers (n : Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) : Nat :=\n  let rec loop (k : Nat) (sum : Nat) : Nat :=\n    if k = 0 then\n      sum\n    else\n      loop (k - 1) (sum + (2 * k - 1) * (2 * k - 1))\n  loop n 0\n\n@[reducible, simp]\ndef sumOfSquaresOfFirstNOddNumbers_postcond (n : Nat) (result: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :=\n  result - (n * (2 * n - 1) * (2 * n + 1)) / 3 = 0 ∧\n  (n * (2 * n - 1) * (2 * n + 1)) / 3 - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumOfSquaresOfFirstNOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :\n    sumOfSquaresOfFirstNOddNumbers_postcond (n) (sumOfSquaresOfFirstNOddNumbers (n) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_7", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that computes the sum of the squares of the first n odd natural numbers. The result should match the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of odd natural numbers to consider (n should be non-negative).\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the squares of the first n odd natural numbers, as defined by the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem sumOfSquaresOfFirstNOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :\n    sumOfSquaresOfFirstNOddNumbers_postcond (n) (sumOfSquaresOfFirstNOddNumbers (n) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef sumOfSquaresOfFirstNOddNumbers_precond (n : Nat) : Prop :=\n  True\n\ndef sumOfSquaresOfFirstNOddNumbers (n : Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) : Nat :=\n  let rec loop (k : Nat) (sum : Nat) : Nat :=\n    if k = 0 then\n      sum\n    else\n      loop (k - 1) (sum + (2 * k - 1) * (2 * k - 1))\n  loop n 0\n\n@[reducible, simp]\ndef sumOfSquaresOfFirstNOddNumbers_postcond (n : Nat) (result: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :=\n  result - (n * (2 * n - 1) * (2 * n + 1)) / 3 = 0 ∧\n  (n * (2 * n - 1) * (2 * n + 1)) / 3 - result = 0\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem sumOfSquaresOfFirstNOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :\n    sumOfSquaresOfFirstNOddNumbers_postcond (n) (sumOfSquaresOfFirstNOddNumbers (n) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_7"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining the first index in an array where a given condition holds true. The goal is to identify the position of the first element that meets a specified criterion, ensuring that no preceding element does.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of elements (for testing purposes, you can assume it is an array of integers).  \n• P: A predicate function on the elements (represented as a string for test cases, e.g., \"fun x => x > 5\"). It is assumed that at least one element in the array satisfies P.\n\n-----Output-----  \nThe output is a natural number (Nat) which represents the index of the first element in the array that satisfies the predicate P.  \n• The index returned is less than the size of the array.  \n• The element at the returned index satisfies P.  \n• All elements before the returned index do not satisfy P.\n\n-----Note-----  \nIt is assumed that the array contains at least one element that satisfies P. In cases where this precondition does not hold, the behavior of the function is not guaranteed by the specification.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LinearSearch3_spec_satisfied (a: Array Int) (P: Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) :\n    LinearSearch3_postcond (a) (P) (LinearSearch3 (a) (P) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LinearSearch3_precond (a : Array Int) (P : Int -> Bool) : Prop :=\n  ∃ i, i < a.size ∧ P (a[i]!)\n\ndef LinearSearch3 (a : Array Int) (P : Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) : Nat :=\n  let rec loop (n : Nat) : Nat :=\n    if n < a.size then\n      if P (a[n]!) then n else loop (n + 1)\n    else\n      0\n  loop 0\n\n@[reducible, simp]\ndef LinearSearch3_postcond (a : Array Int) (P : Int -> Bool) (result: Nat) (h_precond : LinearSearch3_precond (a) (P)) :=\n  result < a.size ∧ P (a[result]!) ∧ (∀ k, k < result → ¬ P (a[k]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LinearSearch3_spec_satisfied (a: Array Int) (P: Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) :\n    LinearSearch3_postcond (a) (P) (LinearSearch3 (a) (P) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_70", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining the first index in an array where a given condition holds true. The goal is to identify the position of the first element that meets a specified criterion, ensuring that no preceding element does.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of elements (for testing purposes, you can assume it is an array of integers).  \n• P: A predicate function on the elements (represented as a string for test cases, e.g., \"fun x => x > 5\"). It is assumed that at least one element in the array satisfies P.\n\n-----Output-----  \nThe output is a natural number (Nat) which represents the index of the first element in the array that satisfies the predicate P.  \n• The index returned is less than the size of the array.  \n• The element at the returned index satisfies P.  \n• All elements before the returned index do not satisfy P.\n\n-----Note-----  \nIt is assumed that the array contains at least one element that satisfies P. In cases where this precondition does not hold, the behavior of the function is not guaranteed by the specification.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LinearSearch3_spec_satisfied (a: Array Int) (P: Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) :\n    LinearSearch3_postcond (a) (P) (LinearSearch3 (a) (P) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LinearSearch3_precond (a : Array Int) (P : Int -> Bool) : Prop :=\n  ∃ i, i < a.size ∧ P (a[i]!)\n\ndef LinearSearch3 (a : Array Int) (P : Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) : Nat :=\n  let rec loop (n : Nat) : Nat :=\n    if n < a.size then\n      if P (a[n]!) then n else loop (n + 1)\n    else\n      0\n  loop 0\n\n@[reducible, simp]\ndef LinearSearch3_postcond (a : Array Int) (P : Int -> Bool) (result: Nat) (h_precond : LinearSearch3_precond (a) (P)) :=\n  result < a.size ∧ P (a[result]!) ∧ (∀ k, k < result → ¬ P (a[k]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LinearSearch3_spec_satisfied (a: Array Int) (P: Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) :\n    LinearSearch3_postcond (a) (P) (LinearSearch3 (a) (P) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_70"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical. \n\n-----Input-----  \nThe input consists of:  \n• str1: A list of characters.  \n• str2: A list of characters.\n\n-----Output-----  \nThe output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:  \n• Its length is less than or equal to the length of each input list.  \n• It is exactly the prefix of both str1 and str2.  \n• It is empty if the first characters of the inputs differ or if one of the lists is empty.\n\n-----Note-----  \nIt is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestCommonPrefix_spec_satisfied (str1: List Char) (str2: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :\n    LongestCommonPrefix_postcond (str1) (str2) (LongestCommonPrefix (str1) (str2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LongestCommonPrefix_precond (str1 : List Char) (str2 : List Char) : Prop :=\n  True\n\ndef LongestCommonPrefix (str1 : List Char) (str2 : List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) : List Char :=\n  let minLength := Nat.min str1.length str2.length\n  let rec aux (idx : Nat) (acc : List Char) : List Char :=\n    if idx < minLength then\n      match str1[idx]?, str2[idx]? with\n      | some c1, some c2 =>\n          if c1 ≠ c2 then acc\n          else aux (idx + 1) (acc ++ [c1])\n      | _, _ => acc\n    else acc\n  aux 0 []\n\n@[reducible, simp]\ndef LongestCommonPrefix_postcond (str1 : List Char) (str2 : List Char) (result: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :=\n  (result.length ≤ str1.length) ∧ (result = str1.take result.length) ∧\n  (result.length ≤ str2.length) ∧ (result = str2.take result.length) ∧\n  (result.length = str1.length ∨ result.length = str2.length ∨\n    (str1[result.length]? ≠ str2[result.length]?))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestCommonPrefix_spec_satisfied (str1: List Char) (str2: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :\n    LongestCommonPrefix_postcond (str1) (str2) (LongestCommonPrefix (str1) (str2) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_71", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical. \n\n-----Input-----  \nThe input consists of:  \n• str1: A list of characters.  \n• str2: A list of characters.\n\n-----Output-----  \nThe output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:  \n• Its length is less than or equal to the length of each input list.  \n• It is exactly the prefix of both str1 and str2.  \n• It is empty if the first characters of the inputs differ or if one of the lists is empty.\n\n-----Note-----  \nIt is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem LongestCommonPrefix_spec_satisfied (str1: List Char) (str2: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :\n    LongestCommonPrefix_postcond (str1) (str2) (LongestCommonPrefix (str1) (str2) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef LongestCommonPrefix_precond (str1 : List Char) (str2 : List Char) : Prop :=\n  True\n\ndef LongestCommonPrefix (str1 : List Char) (str2 : List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) : List Char :=\n  let minLength := Nat.min str1.length str2.length\n  let rec aux (idx : Nat) (acc : List Char) : List Char :=\n    if idx < minLength then\n      match str1[idx]?, str2[idx]? with\n      | some c1, some c2 =>\n          if c1 ≠ c2 then acc\n          else aux (idx + 1) (acc ++ [c1])\n      | _, _ => acc\n    else acc\n  aux 0 []\n\n@[reducible, simp]\ndef LongestCommonPrefix_postcond (str1 : List Char) (str2 : List Char) (result: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :=\n  (result.length ≤ str1.length) ∧ (result = str1.take result.length) ∧\n  (result.length ≤ str2.length) ∧ (result = str2.take result.length) ∧\n  (result.length = str1.length ∨ result.length = str2.length ∨\n    (str1[result.length]? ≠ str2[result.length]?))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem LongestCommonPrefix_spec_satisfied (str1: List Char) (str2: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :\n    LongestCommonPrefix_postcond (str1) (str2) (LongestCommonPrefix (str1) (str2) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_71"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe problem asks you to construct a new list by adding an extra number to the end of an existing list of numbers. The focus is on understanding what the final list should look like when a given number is included as the last element.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• b: An integer to be appended to the array.\n\n-----Output-----  \nThe output is an array of integers which represents the original array with the element b added at the end. That is, the output array’s list representation equals a.toList concatenated with [b].\n\n-----Note-----  \nThere are no special preconditions; the method is expected to work correctly for any array of integers and any integer b.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem append_spec_satisfied (a: Array Int) (b: Int) (h_precond : append_precond (a) (b)) :\n    append_postcond (a) (b) (append (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef append_precond (a : Array Int) (b : Int) : Prop :=\n  True\n\ndef copy (a : Array Int) (i : Nat) (acc : Array Int) : Array Int :=\n  if i < a.size then\n    copy a (i + 1) (acc.push (a[i]!))\n  else\n    acc\n\ndef append (a : Array Int) (b : Int) (h_precond : append_precond (a) (b)) : Array Int :=\n  let c_initial := copy a 0 (Array.empty)\n  let c_full := c_initial.push b\n  c_full\n\n@[reducible, simp]\ndef append_postcond (a : Array Int) (b : Int) (result: Array Int) (h_precond : append_precond (a) (b)) :=\n  (List.range' 0 a.size |>.all (fun i => result[i]! = a[i]!)) ∧\n  result[a.size]! = b ∧\n  result.size = a.size + 1\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem append_spec_satisfied (a: Array Int) (b: Int) (h_precond : append_precond (a) (b)) :\n    append_postcond (a) (b) (append (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_72", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe problem asks you to construct a new list by adding an extra number to the end of an existing list of numbers. The focus is on understanding what the final list should look like when a given number is included as the last element.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• b: An integer to be appended to the array.\n\n-----Output-----  \nThe output is an array of integers which represents the original array with the element b added at the end. That is, the output array’s list representation equals a.toList concatenated with [b].\n\n-----Note-----  \nThere are no special preconditions; the method is expected to work correctly for any array of integers and any integer b.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem append_spec_satisfied (a: Array Int) (b: Int) (h_precond : append_precond (a) (b)) :\n    append_postcond (a) (b) (append (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef append_precond (a : Array Int) (b : Int) : Prop :=\n  True\n\ndef copy (a : Array Int) (i : Nat) (acc : Array Int) : Array Int :=\n  if i < a.size then\n    copy a (i + 1) (acc.push (a[i]!))\n  else\n    acc\n\ndef append (a : Array Int) (b : Int) (h_precond : append_precond (a) (b)) : Array Int :=\n  let c_initial := copy a 0 (Array.empty)\n  let c_full := c_initial.push b\n  c_full\n\n@[reducible, simp]\ndef append_postcond (a : Array Int) (b : Int) (result: Array Int) (h_precond : append_precond (a) (b)) :=\n  (List.range' 0 a.size |>.all (fun i => result[i]! = a[i]!)) ∧\n  result[a.size]! = b ∧\n  result.size = a.size + 1\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem append_spec_satisfied (a: Array Int) (b: Int) (h_precond : append_precond (a) (b)) :\n    append_postcond (a) (b) (append (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_72"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nDetermine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.\n\n-----Input-----  \nThe input consists of:  \n• s: A string that is to be matched.  \n• p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.\n\n-----Output-----  \nThe output is a Boolean value:  \n• Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.  \n• Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.\n\n-----Note-----  \nIt is assumed that both strings provided have the same length.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Match_spec_satisfied (s: String) (p: String) (h_precond : Match_precond (s) (p)) :\n    Match_postcond (s) (p) (Match (s) (p) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Match_precond (s : String) (p : String) : Prop :=\n  s.toList.length = p.toList.length\n\ndef Match (s : String) (p : String) (h_precond : Match_precond (s) (p)) : Bool :=\n  let sList := s.toList\n  let pList := p.toList\n  let rec loop (i : Nat) : Bool :=\n    if i < sList.length then\n      if (sList[i]! ≠ pList[i]!) ∧ (pList[i]! ≠ '?') then false\n      else loop (i + 1)\n    else true\n  loop 0\n\n@[reducible, simp]\ndef Match_postcond (s : String) (p : String) (result: Bool) (h_precond : Match_precond (s) (p)) :=\n  (result = true ↔ ∀ n : Nat, n < s.toList.length → ((s.toList[n]! = p.toList[n]!) ∨ (p.toList[n]! = '?')))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Match_spec_satisfied (s: String) (p: String) (h_precond : Match_precond (s) (p)) :\n    Match_postcond (s) (p) (Match (s) (p) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_73", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nDetermine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.\n\n-----Input-----  \nThe input consists of:  \n• s: A string that is to be matched.  \n• p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.\n\n-----Output-----  \nThe output is a Boolean value:  \n• Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.  \n• Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.\n\n-----Note-----  \nIt is assumed that both strings provided have the same length.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Match_spec_satisfied (s: String) (p: String) (h_precond : Match_precond (s) (p)) :\n    Match_postcond (s) (p) (Match (s) (p) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Match_precond (s : String) (p : String) : Prop :=\n  s.toList.length = p.toList.length\n\ndef Match (s : String) (p : String) (h_precond : Match_precond (s) (p)) : Bool :=\n  let sList := s.toList\n  let pList := p.toList\n  let rec loop (i : Nat) : Bool :=\n    if i < sList.length then\n      if (sList[i]! ≠ pList[i]!) ∧ (pList[i]! ≠ '?') then false\n      else loop (i + 1)\n    else true\n  loop 0\n\n@[reducible, simp]\ndef Match_postcond (s : String) (p : String) (result: Bool) (h_precond : Match_precond (s) (p)) :=\n  (result = true ↔ ∀ n : Nat, n < s.toList.length → ((s.toList[n]! = p.toList[n]!) ∨ (p.toList[n]! = '?')))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Match_spec_satisfied (s: String) (p: String) (h_precond : Match_precond (s) (p)) :\n    Match_postcond (s) (p) (Match (s) (p) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_73"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves identifying the maximum value in a non-empty array of integers. The objective is to determine which element in the array is greater than or equal to every other element, ensuring that the selected value is one of the elements in the array.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers. It is assumed that the array is non-empty (i.e., its size is at least 1).\n\n-----Output-----  \nThe output is an integer that represents the maximum element in the array. This value is guaranteed to satisfy the following:  \n• It is greater than or equal to every element in the array.  \n• It is exactly equal to one of the elements in the array.\n\n-----Note-----  \nIt is assumed that the provided array is non-empty. In cases where the array is empty, the function's behavior is not defined.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxArray_spec_satisfied (a: Array Int) (h_precond : maxArray_precond (a)) :\n    maxArray_postcond (a) (maxArray (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxArray_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef maxArray_aux (a : Array Int) (index : Nat) (current : Int) : Int :=\n  if index < a.size then\n    let new_current := if current > a[index]! then current else a[index]!\n    maxArray_aux a (index + 1) new_current\n  else\n    current\n\ndef maxArray (a : Array Int) (h_precond : maxArray_precond (a)) : Int :=\n  maxArray_aux a 1 a[0]!\n\n@[reducible, simp]\ndef maxArray_postcond (a : Array Int) (result: Int) (h_precond : maxArray_precond (a)) :=\n  (∀ (k : Nat), k < a.size → result >= a[k]!) ∧ (∃ (k : Nat), k < a.size ∧ result = a[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxArray_spec_satisfied (a: Array Int) (h_precond : maxArray_precond (a)) :\n    maxArray_postcond (a) (maxArray (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_74", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves identifying the maximum value in a non-empty array of integers. The objective is to determine which element in the array is greater than or equal to every other element, ensuring that the selected value is one of the elements in the array.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers. It is assumed that the array is non-empty (i.e., its size is at least 1).\n\n-----Output-----  \nThe output is an integer that represents the maximum element in the array. This value is guaranteed to satisfy the following:  \n• It is greater than or equal to every element in the array.  \n• It is exactly equal to one of the elements in the array.\n\n-----Note-----  \nIt is assumed that the provided array is non-empty. In cases where the array is empty, the function's behavior is not defined.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem maxArray_spec_satisfied (a: Array Int) (h_precond : maxArray_precond (a)) :\n    maxArray_postcond (a) (maxArray (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef maxArray_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef maxArray_aux (a : Array Int) (index : Nat) (current : Int) : Int :=\n  if index < a.size then\n    let new_current := if current > a[index]! then current else a[index]!\n    maxArray_aux a (index + 1) new_current\n  else\n    current\n\ndef maxArray (a : Array Int) (h_precond : maxArray_precond (a)) : Int :=\n  maxArray_aux a 1 a[0]!\n\n@[reducible, simp]\ndef maxArray_postcond (a : Array Int) (result: Int) (h_precond : maxArray_precond (a)) :=\n  (∀ (k : Nat), k < a.size → result >= a[k]!) ∧ (∃ (k : Nat), k < a.size ∧ result = a[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem maxArray_spec_satisfied (a: Array Int) (h_precond : maxArray_precond (a)) :\n    maxArray_postcond (a) (maxArray (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_74"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves finding the minimum element in a non-empty array of integers. The goal is to identify and return the smallest number present in the array.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers (the array is assumed to be non-empty).\n\n-----Output-----  \nThe output is an integer that:  \n• Is the smallest element from the input array.  \n• Satisfies the property that it is less than or equal to every element in the array and is exactly equal to at least one element of the array.\n\n-----Note-----  \nIt is assumed that the input array contains at least one element. The implementation uses a helper function (loop) to recursively compare elements and determine the minimum value.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minArray_spec_satisfied (a: Array Int) (h_precond : minArray_precond (a)) :\n    minArray_postcond (a) (minArray (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef minArray_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef loop (a : Array Int) (i : Nat) (currentMin : Int) : Int :=\n  if i < a.size then\n    let newMin := if currentMin > a[i]! then a[i]! else currentMin\n    loop a (i + 1) newMin\n  else\n    currentMin\n\ndef minArray (a : Array Int) (h_precond : minArray_precond (a)) : Int :=\n  loop a 1 (a[0]!)\n\n@[reducible, simp]\ndef minArray_postcond (a : Array Int) (result: Int) (h_precond : minArray_precond (a)) :=\n  (∀ i : Nat, i < a.size → result <= a[i]!) ∧ (∃ i : Nat, i < a.size ∧ result = a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minArray_spec_satisfied (a: Array Int) (h_precond : minArray_precond (a)) :\n    minArray_postcond (a) (minArray (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_75", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves finding the minimum element in a non-empty array of integers. The goal is to identify and return the smallest number present in the array.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers (the array is assumed to be non-empty).\n\n-----Output-----  \nThe output is an integer that:  \n• Is the smallest element from the input array.  \n• Satisfies the property that it is less than or equal to every element in the array and is exactly equal to at least one element of the array.\n\n-----Note-----  \nIt is assumed that the input array contains at least one element. The implementation uses a helper function (loop) to recursively compare elements and determine the minimum value.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem minArray_spec_satisfied (a: Array Int) (h_precond : minArray_precond (a)) :\n    minArray_postcond (a) (minArray (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef minArray_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef loop (a : Array Int) (i : Nat) (currentMin : Int) : Int :=\n  if i < a.size then\n    let newMin := if currentMin > a[i]! then a[i]! else currentMin\n    loop a (i + 1) newMin\n  else\n    currentMin\n\ndef minArray (a : Array Int) (h_precond : minArray_precond (a)) : Int :=\n  loop a 1 (a[0]!)\n\n@[reducible, simp]\ndef minArray_postcond (a : Array Int) (result: Int) (h_precond : minArray_precond (a)) :=\n  (∀ i : Nat, i < a.size → result <= a[i]!) ∧ (∃ i : Nat, i < a.size ∧ result = a[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem minArray_spec_satisfied (a: Array Int) (h_precond : minArray_precond (a)) :\n    minArray_postcond (a) (minArray (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_75"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires determining the smaller of two integers. Given two input numbers, the goal is to compare them and return the one that is less than or equal to the other.\n\n-----Input-----  \nThe input consists of two integers:  \n• x: The first integer.  \n• y: The second integer.\n\n-----Output-----  \nThe output is an integer representing the minimum of the two input integers:  \n• Returns x if x is less than or equal to y.  \n• Returns y if x is greater than y.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef myMin_precond (x : Int) (y : Int) : Prop :=\n  True\n\ndef myMin (x : Int) (y : Int) (h_precond : myMin_precond (x) (y)) : Int :=\n  if x < y then x else y\n\n@[reducible, simp]\ndef myMin_postcond (x : Int) (y : Int) (result: Int) (h_precond : myMin_precond (x) (y)) :=\n  (x ≤ y → result = x) ∧ (x > y → result = y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n  unfold myMin_postcond myMin\n  simp\n  have h_left : (x ≤ y → y ≤ x → y = x) := by\n    intro h₁ h₂\n    exact Int.le_antisymm h₂ h₁\n  have h_right : (y < x → x < y → x = y) := by\n    intro h₁ h₂\n    have h_contr : False := Int.lt_irrefl x (Int.lt_trans h₂ h₁)\n    contradiction\n  exact ⟨h_left, h_right⟩"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_76", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires determining the smaller of two integers. Given two input numbers, the goal is to compare them and return the one that is less than or equal to the other.\n\n-----Input-----  \nThe input consists of two integers:  \n• x: The first integer.  \n• y: The second integer.\n\n-----Output-----  \nThe output is an integer representing the minimum of the two input integers:  \n• Returns x if x is less than or equal to y.  \n• Returns y if x is greater than y.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef myMin_precond (x : Int) (y : Int) : Prop :=\n  True\n\ndef myMin (x : Int) (y : Int) (h_precond : myMin_precond (x) (y)) : Int :=\n  if x < y then x else y\n\n@[reducible, simp]\ndef myMin_postcond (x : Int) (y : Int) (result: Int) (h_precond : myMin_precond (x) (y)) :=\n  (x ≤ y → result = x) ∧ (x > y → result = y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n```", "ground_truth": "theorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n  unfold myMin_postcond myMin\n  simp\n  have h_left : (x ≤ y → y ≤ x → y = x) := by\n    intro h₁ h₂\n    exact Int.le_antisymm h₂ h₁\n  have h_right : (y < x → x < y → x = y) := by\n    intro h₁ h₂\n    have h_contr : False := Int.lt_irrefl x (Int.lt_trans h₂ h₁)\n    contradiction\n  exact ⟨h_left, h_right⟩", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_76"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves updating an element within a 2-dimensional array. The goal is to modify only a specific inner array by changing one of its elements to a new value while keeping every other element and all other inner arrays unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of arrays of natural numbers.  \n• index1: A natural number representing the index in the outer array identifying which inner array to modify (0-indexed).  \n• index2: A natural number representing the index within the selected inner array that should be updated (0-indexed).  \n• val: A natural number which is the new value to set at the specified inner index.\n\n-----Output-----  \nThe output is an array of arrays of natural numbers that:  \n• Has the same overall structure as the input.  \n• Contains all original inner arrays unchanged except for the inner array at position index1.  \n• In the modified inner array, only the element at index2 is replaced with val, while all other elements remain the same.\n\n-----Note-----  \nIt is assumed that index1 is a valid index for the outer array and that index2 is a valid index within the corresponding inner array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem modify_array_element_spec_satisfied (arr: Array (Array Nat)) (index1: Nat) (index2: Nat) (val: Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :\n    modify_array_element_postcond (arr) (index1) (index2) (val) (modify_array_element (arr) (index1) (index2) (val) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef modify_array_element_precond (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) : Prop :=\n  index1 < arr.size ∧\n  index2 < (arr[index1]!).size\n\ndef updateInner (a : Array Nat) (idx val : Nat) : Array Nat :=\n  a.set! idx val\n\ndef modify_array_element (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) : Array (Array Nat) :=\n  let inner := arr[index1]!\n  let inner' := updateInner inner index2 val\n  arr.set! index1 inner'\n\n@[reducible, simp]\ndef modify_array_element_postcond (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) (result: Array (Array Nat)) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :=\n  (∀ i, i < arr.size → i ≠ index1 → result[i]! = arr[i]!) ∧\n  (∀ j, j < (arr[index1]!).size → j ≠ index2 → (result[index1]!)[j]! = (arr[index1]!)[j]!) ∧\n  ((result[index1]!)[index2]! = val)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem modify_array_element_spec_satisfied (arr: Array (Array Nat)) (index1: Nat) (index2: Nat) (val: Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :\n    modify_array_element_postcond (arr) (index1) (index2) (val) (modify_array_element (arr) (index1) (index2) (val) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_77", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves updating an element within a 2-dimensional array. The goal is to modify only a specific inner array by changing one of its elements to a new value while keeping every other element and all other inner arrays unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of arrays of natural numbers.  \n• index1: A natural number representing the index in the outer array identifying which inner array to modify (0-indexed).  \n• index2: A natural number representing the index within the selected inner array that should be updated (0-indexed).  \n• val: A natural number which is the new value to set at the specified inner index.\n\n-----Output-----  \nThe output is an array of arrays of natural numbers that:  \n• Has the same overall structure as the input.  \n• Contains all original inner arrays unchanged except for the inner array at position index1.  \n• In the modified inner array, only the element at index2 is replaced with val, while all other elements remain the same.\n\n-----Note-----  \nIt is assumed that index1 is a valid index for the outer array and that index2 is a valid index within the corresponding inner array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem modify_array_element_spec_satisfied (arr: Array (Array Nat)) (index1: Nat) (index2: Nat) (val: Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :\n    modify_array_element_postcond (arr) (index1) (index2) (val) (modify_array_element (arr) (index1) (index2) (val) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef modify_array_element_precond (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) : Prop :=\n  index1 < arr.size ∧\n  index2 < (arr[index1]!).size\n\ndef updateInner (a : Array Nat) (idx val : Nat) : Array Nat :=\n  a.set! idx val\n\ndef modify_array_element (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) : Array (Array Nat) :=\n  let inner := arr[index1]!\n  let inner' := updateInner inner index2 val\n  arr.set! index1 inner'\n\n@[reducible, simp]\ndef modify_array_element_postcond (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) (result: Array (Array Nat)) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :=\n  (∀ i, i < arr.size → i ≠ index1 → result[i]! = arr[i]!) ∧\n  (∀ j, j < (arr[index1]!).size → j ≠ index2 → (result[index1]!)[j]! = (arr[index1]!)[j]!) ∧\n  ((result[index1]!)[index2]! = val)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem modify_array_element_spec_satisfied (arr: Array (Array Nat)) (index1: Nat) (index2: Nat) (val: Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :\n    modify_array_element_postcond (arr) (index1) (index2) (val) (modify_array_element (arr) (index1) (index2) (val) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_77"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nGiven two integers, the task is to compute two output values: one being the sum of the integers and the other being their difference.\n\n-----Input-----  \nThe input consists of two integers:  \n• x: An integer.  \n• y: An integer.\n\n-----Output-----  \nThe output is a tuple of two integers:  \n• The first element is x + y.  \n• The second element is x - y.\n\n-----Note-----  \nIt is assumed that x and y are valid integers. There are no additional constraints on the inputs.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef MultipleReturns_precond (x : Int) (y : Int) : Prop :=\n  True\n\ndef MultipleReturns (x : Int) (y : Int) (h_precond : MultipleReturns_precond (x) (y)) : (Int × Int) :=\n  let more := x + y\n  let less := x - y\n  (more, less)\n\n@[reducible, simp]\ndef MultipleReturns_postcond (x : Int) (y : Int) (result: (Int × Int)) (h_precond : MultipleReturns_precond (x) (y)) :=\n  result.1 = x + y ∧ result.2 + y = x\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n  unfold MultipleReturns_postcond MultipleReturns\n  simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_78", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nGiven two integers, the task is to compute two output values: one being the sum of the integers and the other being their difference.\n\n-----Input-----  \nThe input consists of two integers:  \n• x: An integer.  \n• y: An integer.\n\n-----Output-----  \nThe output is a tuple of two integers:  \n• The first element is x + y.  \n• The second element is x - y.\n\n-----Note-----  \nIt is assumed that x and y are valid integers. There are no additional constraints on the inputs.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef MultipleReturns_precond (x : Int) (y : Int) : Prop :=\n  True\n\ndef MultipleReturns (x : Int) (y : Int) (h_precond : MultipleReturns_precond (x) (y)) : (Int × Int) :=\n  let more := x + y\n  let less := x - y\n  (more, less)\n\n@[reducible, simp]\ndef MultipleReturns_postcond (x : Int) (y : Int) (result: (Int × Int)) (h_precond : MultipleReturns_precond (x) (y)) :=\n  result.1 = x + y ∧ result.2 + y = x\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n```", "ground_truth": "theorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n  unfold MultipleReturns_postcond MultipleReturns\n  simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_78"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven a nonempty array of integers and a valid index x (with 1 ≤ x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (assumed to be nonempty).\n• x: A natural number (Nat) such that 1 ≤ x < a.size.\n\n-----Output-----\nThe output is a pair (m, p) where:\n• m is the maximum value among the first x elements of the array.\n• p is an index in the array, with x ≤ p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size − 1.\n\n-----Note-----\nIt is assumed that the array a is nonempty and that the parameter x meets the precondition 1 ≤ x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem onlineMax_spec_satisfied (a: Array Int) (x: Nat) (h_precond : onlineMax_precond (a) (x)) :\n    onlineMax_postcond (a) (x) (onlineMax (a) (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef onlineMax_precond (a : Array Int) (x : Nat) : Prop :=\n  a.size > 0 ∧ x < a.size\n\ndef findBest (a : Array Int) (x : Nat) (i : Nat) (best : Int) : Int :=\n  if i < x then\n    let newBest := if a[i]! > best then a[i]! else best\n    findBest a x (i + 1) newBest\n  else best\n\ndef findP (a : Array Int) (x : Nat) (m : Int) (i : Nat) : Nat :=\n  if i < a.size then\n    if a[i]! > m then i else findP a x m (i + 1)\n  else a.size - 1\n\ndef onlineMax (a : Array Int) (x : Nat) (h_precond : onlineMax_precond (a) (x)) : Int × Nat :=\n  let best := a[0]!\n  let m := findBest a x 1 best;\n  let p := findP a x m x;\n  (m, p)\n\n@[reducible, simp]\ndef onlineMax_postcond (a : Array Int) (x : Nat) (result: Int × Nat) (h_precond : onlineMax_precond (a) (x)) :=\n  let (m, p) := result;\n  (x ≤ p ∧ p < a.size) ∧\n  (∀ i, i < x → a[i]! ≤ m) ∧\n  (∃ i, i < x ∧ a[i]! = m) ∧\n  ((p < a.size - 1) → (∀ i, i < p → a[i]! < a[p]!)) ∧\n  ((∀ i, x ≤ i → i < a.size → a[i]! ≤ m) → p = a.size - 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem onlineMax_spec_satisfied (a: Array Int) (x: Nat) (h_precond : onlineMax_precond (a) (x)) :\n    onlineMax_postcond (a) (x) (onlineMax (a) (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_79", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nGiven a nonempty array of integers and a valid index x (with 1 ≤ x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (assumed to be nonempty).\n• x: A natural number (Nat) such that 1 ≤ x < a.size.\n\n-----Output-----\nThe output is a pair (m, p) where:\n• m is the maximum value among the first x elements of the array.\n• p is an index in the array, with x ≤ p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size − 1.\n\n-----Note-----\nIt is assumed that the array a is nonempty and that the parameter x meets the precondition 1 ≤ x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem onlineMax_spec_satisfied (a: Array Int) (x: Nat) (h_precond : onlineMax_precond (a) (x)) :\n    onlineMax_postcond (a) (x) (onlineMax (a) (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef onlineMax_precond (a : Array Int) (x : Nat) : Prop :=\n  a.size > 0 ∧ x < a.size\n\ndef findBest (a : Array Int) (x : Nat) (i : Nat) (best : Int) : Int :=\n  if i < x then\n    let newBest := if a[i]! > best then a[i]! else best\n    findBest a x (i + 1) newBest\n  else best\n\ndef findP (a : Array Int) (x : Nat) (m : Int) (i : Nat) : Nat :=\n  if i < a.size then\n    if a[i]! > m then i else findP a x m (i + 1)\n  else a.size - 1\n\ndef onlineMax (a : Array Int) (x : Nat) (h_precond : onlineMax_precond (a) (x)) : Int × Nat :=\n  let best := a[0]!\n  let m := findBest a x 1 best;\n  let p := findP a x m x;\n  (m, p)\n\n@[reducible, simp]\ndef onlineMax_postcond (a : Array Int) (x : Nat) (result: Int × Nat) (h_precond : onlineMax_precond (a) (x)) :=\n  let (m, p) := result;\n  (x ≤ p ∧ p < a.size) ∧\n  (∀ i, i < x → a[i]! ≤ m) ∧\n  (∃ i, i < x ∧ a[i]! = m) ∧\n  ((p < a.size - 1) → (∀ i, i < p → a[i]! < a[p]!)) ∧\n  ((∀ i, x ≤ i → i < a.size → a[i]! ≤ m) → p = a.size - 1)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem onlineMax_spec_satisfied (a: Array Int) (x: Nat) (h_precond : onlineMax_precond (a) (x)) :\n    onlineMax_postcond (a) (x) (onlineMax (a) (x) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_79"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines the minimum of two integers. The method should return the smaller of the two numbers. When both numbers are equal, either one may be returned.\n\n-----Input-----\nThe input consists of two integers:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the smaller value between the input integers, ensuring that the result is less than or equal to both inputs.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef myMin_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef myMin (a : Int) (b : Int) (h_precond : myMin_precond (a) (b)) : Int :=\n  if a <= b then a else b\n\n@[reducible, simp]\ndef myMin_postcond (a : Int) (b : Int) (result: Int) (h_precond : myMin_precond (a) (b)) :=\n  (result ≤ a ∧ result ≤ b) ∧\n  (result = a ∨ result = b)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n  unfold myMin myMin_postcond\n  constructor\n  · split\n    case left.isTrue h =>\n      simp\n      exact h\n    case left.isFalse h =>\n      simp\n      rw [Int.not_le] at h\n      exact Int.le_of_lt h\n  · split <;> simp"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_8", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that determines the minimum of two integers. The method should return the smaller of the two numbers. When both numbers are equal, either one may be returned.\n\n-----Input-----\nThe input consists of two integers:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the smaller value between the input integers, ensuring that the result is less than or equal to both inputs.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef myMin_precond (a : Int) (b : Int) : Prop :=\n  True\n\ndef myMin (a : Int) (b : Int) (h_precond : myMin_precond (a) (b)) : Int :=\n  if a <= b then a else b\n\n@[reducible, simp]\ndef myMin_postcond (a : Int) (b : Int) (result: Int) (h_precond : myMin_precond (a) (b)) :=\n  (result ≤ a ∧ result ≤ b) ∧\n  (result = a ∨ result = b)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n```", "ground_truth": "theorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n  unfold myMin myMin_postcond\n  constructor\n  · split\n    case left.isTrue h =>\n      simp\n      exact h\n    case left.isFalse h =>\n      simp\n      rw [Int.not_le] at h\n      exact Int.le_of_lt h\n  · split <;> simp", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_8"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining whether a specified key appears exactly once in an array. The goal is to verify the uniqueness of the key's occurrence without prescribing any specific approach or implementation method.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• key: An integer representing the element whose occurrence is to be checked.\n\n-----Output-----  \nThe output is a Boolean value that:  \n• Is true if the key appears exactly once in the array.  \n• Is false otherwise.\n\n-----Note-----  \nThe function should correctly handle arrays with no occurrences of the key, multiple occurrences, and exactly one occurrence.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem only_once_spec_satisfied (a: Array Int) (key: Int) (h_precond : only_once_precond (a) (key)) :\n    only_once_postcond (a) (key) (only_once (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef only_once_precond (a : Array Int) (key : Int) : Prop :=\n  True\n\ndef only_once_loop {T : Type} [DecidableEq T] (a : Array T) (key : T) (i keyCount : Nat) : Bool :=\n  if i < a.size then\n    match a[i]? with\n    | some val =>\n        let newCount := if val = key then keyCount + 1 else keyCount\n        only_once_loop a key (i + 1) newCount\n    | none => keyCount == 1\n  else\n    keyCount == 1\n\ndef only_once (a : Array Int) (key : Int) (h_precond : only_once_precond (a) (key)) : Bool :=\n  only_once_loop a key 0 0\n\ndef count_occurrences {T : Type} [DecidableEq T] (a : Array T) (key : T) : Nat :=\n  a.foldl (fun cnt x => if x = key then cnt + 1 else cnt) 0\n\n@[reducible, simp]\ndef only_once_postcond (a : Array Int) (key : Int) (result: Bool) (h_precond : only_once_precond (a) (key)) :=\n  ((count_occurrences a key = 1) → result) ∧\n  ((count_occurrences a key ≠ 1) → ¬ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem only_once_spec_satisfied (a: Array Int) (key: Int) (h_precond : only_once_precond (a) (key)) :\n    only_once_postcond (a) (key) (only_once (a) (key) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_80", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves determining whether a specified key appears exactly once in an array. The goal is to verify the uniqueness of the key's occurrence without prescribing any specific approach or implementation method.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• key: An integer representing the element whose occurrence is to be checked.\n\n-----Output-----  \nThe output is a Boolean value that:  \n• Is true if the key appears exactly once in the array.  \n• Is false otherwise.\n\n-----Note-----  \nThe function should correctly handle arrays with no occurrences of the key, multiple occurrences, and exactly one occurrence.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem only_once_spec_satisfied (a: Array Int) (key: Int) (h_precond : only_once_precond (a) (key)) :\n    only_once_postcond (a) (key) (only_once (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef only_once_precond (a : Array Int) (key : Int) : Prop :=\n  True\n\ndef only_once_loop {T : Type} [DecidableEq T] (a : Array T) (key : T) (i keyCount : Nat) : Bool :=\n  if i < a.size then\n    match a[i]? with\n    | some val =>\n        let newCount := if val = key then keyCount + 1 else keyCount\n        only_once_loop a key (i + 1) newCount\n    | none => keyCount == 1\n  else\n    keyCount == 1\n\ndef only_once (a : Array Int) (key : Int) (h_precond : only_once_precond (a) (key)) : Bool :=\n  only_once_loop a key 0 0\n\ndef count_occurrences {T : Type} [DecidableEq T] (a : Array T) (key : T) : Nat :=\n  a.foldl (fun cnt x => if x = key then cnt + 1 else cnt) 0\n\n@[reducible, simp]\ndef only_once_postcond (a : Array Int) (key : Int) (result: Bool) (h_precond : only_once_precond (a) (key)) :=\n  ((count_occurrences a key = 1) → result) ∧\n  ((count_occurrences a key ≠ 1) → ¬ result)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem only_once_spec_satisfied (a: Array Int) (key: Int) (h_precond : only_once_precond (a) (key)) :\n    only_once_postcond (a) (key) (only_once (a) (key) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_80"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves performing integer division with remainder on natural numbers. Given two natural numbers, x (the dividend) and y (the divisor), the objective is to determine the quotient and remainder. When y is non-zero, the quotient and remainder should satisfy the condition that the dividend equals the divisor multiplied by the quotient plus the remainder, with the remainder being nonnegative and strictly less than y. In the case where y is zero, the result should indicate that no division is performed by returning x as the quotient and 0 as the remainder.\n\n-----Input-----  \nThe input consists of two natural numbers:  \n• x: A natural number representing the dividend.  \n• y: A natural number representing the divisor.\n\n-----Output-----  \nThe output is a pair of integers (r, q) where:  \n• If y ≠ 0, then q is the quotient and r is the remainder such that:  \n   - q * Int.ofNat y + r = Int.ofNat x  \n   - 0 ≤ r < Int.ofNat y  \n   - 0 ≤ q  \n• If y = 0, then the output is (Int.ofNat x, 0).\n\n-----Note-----  \nThe specification regarding the division properties applies only when y is non-zero. When y = 0, the function safely returns (x, 0) in its integer form.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef DivisionFunction_precond (x : Nat) (y : Nat) : Prop :=\n  True\n\ndef divMod (x y : Nat) : Int × Int :=\n  let q : Int := Int.ofNat (x / y)\n  let r : Int := Int.ofNat (x % y)\n  (r, q)\n\ndef DivisionFunction (x : Nat) (y : Nat) (h_precond : DivisionFunction_precond (x) (y)) : Int × Int :=\n  if y = 0 then (Int.ofNat x, 0) else divMod x y\n\n@[reducible, simp]\ndef DivisionFunction_postcond (x : Nat) (y : Nat) (result: Int × Int) (h_precond : DivisionFunction_precond (x) (y)) :=\n  let (r, q) := result;\n  (y = 0 → r = Int.ofNat x ∧ q = 0) ∧\n  (y ≠ 0 → (q * Int.ofNat y + r = Int.ofNat x) ∧ (0 ≤ r ∧ r < Int.ofNat y) ∧ (0 ≤ q))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n  unfold DivisionFunction_postcond DivisionFunction\n  simp\n  split\n  {\n    simp\n    intro h₁\n    contradiction\n  }\n  {\n\n    have h_left : (¬y = 0 →\n    (divMod x y).snd * ↑y + (divMod x y).fst = ↑x ∧\n      (0 ≤ (divMod x y).fst ∧ (divMod x y).fst < ↑y) ∧ 0 ≤ (divMod x y).snd) := by\n      intro h₁\n      have h₁_left : (divMod x y).snd * ↑y + (divMod x y).fst = ↑x := by\n        unfold divMod\n        simp\n        have h₁ := Int.ediv_add_emod' x y\n        apply h₁\n      have h₁_right : (0 ≤ (divMod x y).1 ∧ (divMod x y).1 < ↑y) ∧ 0 ≤ (divMod x y).2 := by\n        have h₂_left : (0 ≤ (divMod x y).1 ∧ (divMod x y).1 < ↑y) := by\n          have h₃_left : 0 ≤ (divMod x y).1 := by\n            unfold divMod\n            simp\n            rw [←Int.natCast_mod, ←Int.ofNat_eq_natCast]\n            have ha := Int.zero_le_ofNat (x % y)\n            apply ha\n          have h₃_right : (divMod x y).1 < ↑y := by\n            unfold divMod\n            simp\n            rw [←Int.natCast_mod]\n            have ha := @Int.natMod_lt x y h₁\n            rw [Int.natMod, ←Int.natCast_mod, Int.toNat_ofNat] at ha\n            rw [←Mathlib.Tactic.Zify.natCast_lt]\n            apply ha\n          exact ⟨h₃_left, h₃_right⟩\n\n        have h₂_right : 0 ≤ (divMod x y).2 := by\n          unfold divMod\n          simp\n          rw [←Int.natCast_div]\n          have ha := Int.natCast_nonneg (x / y)\n          apply ha\n        exact ⟨h₂_left, h₂_right⟩\n      exact ⟨h₁_left, h₁_right⟩\n    have h_right : (y = 0 → (divMod x y).fst = ↑x ∧ (divMod x y).snd = 0) := by\n      intro h₀\n      have h₁_left : (divMod x y).1 = ↑x := by\n        unfold divMod\n        simp\n        rw [←Int.natCast_mod, h₀, Nat.mod_zero]\n      have h₁_right : (divMod x y).snd = 0 := by\n        unfold divMod\n        simp\n        rw [←Int.natCast_div, h₀, Nat.div_zero, ←@Int.cast_id 0]\n        rfl\n      exact ⟨h₁_left, h₁_right⟩\n    constructor\n    · simp_all [h_left]\n    · simp_all [h_right]\n  }"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_81", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves performing integer division with remainder on natural numbers. Given two natural numbers, x (the dividend) and y (the divisor), the objective is to determine the quotient and remainder. When y is non-zero, the quotient and remainder should satisfy the condition that the dividend equals the divisor multiplied by the quotient plus the remainder, with the remainder being nonnegative and strictly less than y. In the case where y is zero, the result should indicate that no division is performed by returning x as the quotient and 0 as the remainder.\n\n-----Input-----  \nThe input consists of two natural numbers:  \n• x: A natural number representing the dividend.  \n• y: A natural number representing the divisor.\n\n-----Output-----  \nThe output is a pair of integers (r, q) where:  \n• If y ≠ 0, then q is the quotient and r is the remainder such that:  \n   - q * Int.ofNat y + r = Int.ofNat x  \n   - 0 ≤ r < Int.ofNat y  \n   - 0 ≤ q  \n• If y = 0, then the output is (Int.ofNat x, 0).\n\n-----Note-----  \nThe specification regarding the division properties applies only when y is non-zero. When y = 0, the function safely returns (x, 0) in its integer form.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef DivisionFunction_precond (x : Nat) (y : Nat) : Prop :=\n  True\n\ndef divMod (x y : Nat) : Int × Int :=\n  let q : Int := Int.ofNat (x / y)\n  let r : Int := Int.ofNat (x % y)\n  (r, q)\n\ndef DivisionFunction (x : Nat) (y : Nat) (h_precond : DivisionFunction_precond (x) (y)) : Int × Int :=\n  if y = 0 then (Int.ofNat x, 0) else divMod x y\n\n@[reducible, simp]\ndef DivisionFunction_postcond (x : Nat) (y : Nat) (result: Int × Int) (h_precond : DivisionFunction_precond (x) (y)) :=\n  let (r, q) := result;\n  (y = 0 → r = Int.ofNat x ∧ q = 0) ∧\n  (y ≠ 0 → (q * Int.ofNat y + r = Int.ofNat x) ∧ (0 ≤ r ∧ r < Int.ofNat y) ∧ (0 ≤ q))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n```", "ground_truth": "theorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n  unfold DivisionFunction_postcond DivisionFunction\n  simp\n  split\n  {\n    simp\n    intro h₁\n    contradiction\n  }\n  {\n\n    have h_left : (¬y = 0 →\n    (divMod x y).snd * ↑y + (divMod x y).fst = ↑x ∧\n      (0 ≤ (divMod x y).fst ∧ (divMod x y).fst < ↑y) ∧ 0 ≤ (divMod x y).snd) := by\n      intro h₁\n      have h₁_left : (divMod x y).snd * ↑y + (divMod x y).fst = ↑x := by\n        unfold divMod\n        simp\n        have h₁ := Int.ediv_add_emod' x y\n        apply h₁\n      have h₁_right : (0 ≤ (divMod x y).1 ∧ (divMod x y).1 < ↑y) ∧ 0 ≤ (divMod x y).2 := by\n        have h₂_left : (0 ≤ (divMod x y).1 ∧ (divMod x y).1 < ↑y) := by\n          have h₃_left : 0 ≤ (divMod x y).1 := by\n            unfold divMod\n            simp\n            rw [←Int.natCast_mod, ←Int.ofNat_eq_natCast]\n            have ha := Int.zero_le_ofNat (x % y)\n            apply ha\n          have h₃_right : (divMod x y).1 < ↑y := by\n            unfold divMod\n            simp\n            rw [←Int.natCast_mod]\n            have ha := @Int.natMod_lt x y h₁\n            rw [Int.natMod, ←Int.natCast_mod, Int.toNat_ofNat] at ha\n            rw [←Mathlib.Tactic.Zify.natCast_lt]\n            apply ha\n          exact ⟨h₃_left, h₃_right⟩\n\n        have h₂_right : 0 ≤ (divMod x y).2 := by\n          unfold divMod\n          simp\n          rw [←Int.natCast_div]\n          have ha := Int.natCast_nonneg (x / y)\n          apply ha\n        exact ⟨h₂_left, h₂_right⟩\n      exact ⟨h₁_left, h₁_right⟩\n    have h_right : (y = 0 → (divMod x y).fst = ↑x ∧ (divMod x y).snd = 0) := by\n      intro h₀\n      have h₁_left : (divMod x y).1 = ↑x := by\n        unfold divMod\n        simp\n        rw [←Int.natCast_mod, h₀, Nat.mod_zero]\n      have h₁_right : (divMod x y).snd = 0 := by\n        unfold divMod\n        simp\n        rw [←Int.natCast_div, h₀, Nat.div_zero, ←@Int.cast_id 0]\n        rfl\n      exact ⟨h₁_left, h₁_right⟩\n    constructor\n    · simp_all [h_left]\n    · simp_all [h_right]\n  }", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_81"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task is about processing an array of integers by producing a new array that excludes the first element. The objective is to define a clear behavior: if the array contains at least one element, return a modified array starting from the second element.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has a length equal to the original array's length minus one.  \n• Contains the same elements as the input array except for the first element.  \n• Satisfies the condition that for every index i in the output array, the element at position i is equal to the element at position i+1 in the input array.\n\n-----Note-----  \nIt is assumed that the input array is non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem remove_front_spec_satisfied (a: Array Int) (h_precond : remove_front_precond (a)) :\n    remove_front_postcond (a) (remove_front (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef remove_front_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef copyFrom (a : Array Int) (i : Nat) (acc : Array Int) : Array Int :=\n  if i < a.size then\n    copyFrom a (i + 1) (acc.push (a[i]!))\n  else\n    acc\n\ndef remove_front (a : Array Int) (h_precond : remove_front_precond (a)) : Array Int :=\n  if a.size > 0 then\n    let c := copyFrom a 1 (Array.mkEmpty (a.size - 1))\n    c\n  else\n    panic \"Precondition violation: array is empty\"\n\n@[reducible, simp]\ndef remove_front_postcond (a : Array Int) (result: Array Int) (h_precond : remove_front_precond (a)) :=\n  a.size > 0 ∧ result.size = a.size - 1 ∧ (∀ i : Nat, i < result.size → result[i]! = a[i + 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem remove_front_spec_satisfied (a: Array Int) (h_precond : remove_front_precond (a)) :\n    remove_front_postcond (a) (remove_front (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_82", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task is about processing an array of integers by producing a new array that excludes the first element. The objective is to define a clear behavior: if the array contains at least one element, return a modified array starting from the second element.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has a length equal to the original array's length minus one.  \n• Contains the same elements as the input array except for the first element.  \n• Satisfies the condition that for every index i in the output array, the element at position i is equal to the element at position i+1 in the input array.\n\n-----Note-----  \nIt is assumed that the input array is non-empty.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem remove_front_spec_satisfied (a: Array Int) (h_precond : remove_front_precond (a)) :\n    remove_front_postcond (a) (remove_front (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef remove_front_precond (a : Array Int) : Prop :=\n  a.size > 0\n\ndef copyFrom (a : Array Int) (i : Nat) (acc : Array Int) : Array Int :=\n  if i < a.size then\n    copyFrom a (i + 1) (acc.push (a[i]!))\n  else\n    acc\n\ndef remove_front (a : Array Int) (h_precond : remove_front_precond (a)) : Array Int :=\n  if a.size > 0 then\n    let c := copyFrom a 1 (Array.mkEmpty (a.size - 1))\n    c\n  else\n    panic \"Precondition violation: array is empty\"\n\n@[reducible, simp]\ndef remove_front_postcond (a : Array Int) (result: Array Int) (h_precond : remove_front_precond (a)) :=\n  a.size > 0 ∧ result.size = a.size - 1 ∧ (∀ i : Nat, i < result.size → result[i]! = a[i + 1]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem remove_front_spec_satisfied (a: Array Int) (h_precond : remove_front_precond (a)) :\n    remove_front_postcond (a) (remove_front (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_82"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves concatenating two arrays of integers by appending the second array to the end of the first array. The goal is to produce a new array that sequentially contains all elements from the first array followed by all elements from the second array.\n\n-----Input-----  \nThe input consists of two parameters:  \n• a: An Array of integers representing the first part of the concatenated array.  \n• b: An Array of integers representing the second part of the concatenated array.\n\n-----Output-----  \nThe output is an Array of integers that satisfies the following:  \n• The length of the output array is equal to the sum of the lengths of arrays a and b.  \n• The first part of the output array (indices 0 to a.size - 1) is identical to array a.  \n• The remaining part of the output array (indices a.size to a.size + b.size - 1) is identical to array b.\n\n-----Note-----  \nNo additional preconditions are required since the function uses the sizes of the input arrays to build the resulting array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem concat_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : concat_precond (a) (b)) :\n    concat_postcond (a) (b) (concat (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef concat_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef concat (a : Array Int) (b : Array Int) (h_precond : concat_precond (a) (b)) : Array Int :=\n  let n := a.size + b.size\n  let rec loop (i : Nat) (c : Array Int) : Array Int :=\n    if i < n then\n      let value := if i < a.size then a[i]! else b[i - a.size]!\n      loop (i + 1) (c.set! i value)\n    else\n      c\n  loop 0 (Array.mkArray n 0)\n\n@[reducible, simp]\ndef concat_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : concat_precond (a) (b)) :=\n  result.size = a.size + b.size\n    ∧ (∀ k, k < a.size → result[k]! = a[k]!)\n    ∧ (∀ k, k < b.size → result[k + a.size]! = b[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem concat_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : concat_precond (a) (b)) :\n    concat_postcond (a) (b) (concat (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_83", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves concatenating two arrays of integers by appending the second array to the end of the first array. The goal is to produce a new array that sequentially contains all elements from the first array followed by all elements from the second array.\n\n-----Input-----  \nThe input consists of two parameters:  \n• a: An Array of integers representing the first part of the concatenated array.  \n• b: An Array of integers representing the second part of the concatenated array.\n\n-----Output-----  \nThe output is an Array of integers that satisfies the following:  \n• The length of the output array is equal to the sum of the lengths of arrays a and b.  \n• The first part of the output array (indices 0 to a.size - 1) is identical to array a.  \n• The remaining part of the output array (indices a.size to a.size + b.size - 1) is identical to array b.\n\n-----Note-----  \nNo additional preconditions are required since the function uses the sizes of the input arrays to build the resulting array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem concat_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : concat_precond (a) (b)) :\n    concat_postcond (a) (b) (concat (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef concat_precond (a : Array Int) (b : Array Int) : Prop :=\n  True\n\ndef concat (a : Array Int) (b : Array Int) (h_precond : concat_precond (a) (b)) : Array Int :=\n  let n := a.size + b.size\n  let rec loop (i : Nat) (c : Array Int) : Array Int :=\n    if i < n then\n      let value := if i < a.size then a[i]! else b[i - a.size]!\n      loop (i + 1) (c.set! i value)\n    else\n      c\n  loop 0 (Array.mkArray n 0)\n\n@[reducible, simp]\ndef concat_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : concat_precond (a) (b)) :=\n  result.size = a.size + b.size\n    ∧ (∀ k, k < a.size → result[k]! = a[k]!)\n    ∧ (∀ k, k < b.size → result[k + a.size]! = b[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem concat_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : concat_precond (a) (b)) :\n    concat_postcond (a) (b) (concat (a) (b) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_83"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nYou are given an array of integers and a threshold value k. The problem is to create a new array where every element greater than k is replaced with -1 while every other element remains unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of integers.  \n• k: An integer used as the threshold for replacement.\n\n-----Output-----  \nThe output is an array of integers that satisfies the following conditions:  \n• For every index i, if arr[i] is greater than k, then the returned array at index i is -1.  \n• For every index i, if arr[i] is less than or equal to k, then the returned array at index i remains unchanged.\n\n-----Note-----  \nIt is assumed that the input array may be empty or non-empty, and that k can be any integer. There are no additional preconditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem replace_spec_satisfied (arr: Array Int) (k: Int) (h_precond : replace_precond (arr) (k)) :\n    replace_postcond (arr) (k) (replace (arr) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef replace_precond (arr : Array Int) (k : Int) : Prop :=\n  True\n\ndef replace_loop (oldArr : Array Int) (k : Int) : Nat → Array Int → Array Int\n| i, acc =>\n  if i < oldArr.size then\n    if (oldArr[i]!) > k then\n      replace_loop oldArr k (i+1) (acc.set! i (-1))\n    else\n      replace_loop oldArr k (i+1) acc\n  else\n    acc\n\ndef replace (arr : Array Int) (k : Int) (h_precond : replace_precond (arr) (k)) : Array Int :=\n  replace_loop arr k 0 arr\n\n@[reducible, simp]\ndef replace_postcond (arr : Array Int) (k : Int) (result: Array Int) (h_precond : replace_precond (arr) (k)) :=\n  (∀ i : Nat, i < arr.size → (arr[i]! > k → result[i]! = -1)) ∧\n  (∀ i : Nat, i < arr.size → (arr[i]! ≤ k → result[i]! = arr[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem replace_spec_satisfied (arr: Array Int) (k: Int) (h_precond : replace_precond (arr) (k)) :\n    replace_postcond (arr) (k) (replace (arr) (k) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_84", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nYou are given an array of integers and a threshold value k. The problem is to create a new array where every element greater than k is replaced with -1 while every other element remains unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of integers.  \n• k: An integer used as the threshold for replacement.\n\n-----Output-----  \nThe output is an array of integers that satisfies the following conditions:  \n• For every index i, if arr[i] is greater than k, then the returned array at index i is -1.  \n• For every index i, if arr[i] is less than or equal to k, then the returned array at index i remains unchanged.\n\n-----Note-----  \nIt is assumed that the input array may be empty or non-empty, and that k can be any integer. There are no additional preconditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem replace_spec_satisfied (arr: Array Int) (k: Int) (h_precond : replace_precond (arr) (k)) :\n    replace_postcond (arr) (k) (replace (arr) (k) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef replace_precond (arr : Array Int) (k : Int) : Prop :=\n  True\n\ndef replace_loop (oldArr : Array Int) (k : Int) : Nat → Array Int → Array Int\n| i, acc =>\n  if i < oldArr.size then\n    if (oldArr[i]!) > k then\n      replace_loop oldArr k (i+1) (acc.set! i (-1))\n    else\n      replace_loop oldArr k (i+1) acc\n  else\n    acc\n\ndef replace (arr : Array Int) (k : Int) (h_precond : replace_precond (arr) (k)) : Array Int :=\n  replace_loop arr k 0 arr\n\n@[reducible, simp]\ndef replace_postcond (arr : Array Int) (k : Int) (result: Array Int) (h_precond : replace_precond (arr) (k)) :=\n  (∀ i : Nat, i < arr.size → (arr[i]! > k → result[i]! = -1)) ∧\n  (∀ i : Nat, i < arr.size → (arr[i]! ≤ k → result[i]! = arr[i]!))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem replace_spec_satisfied (arr: Array Int) (k: Int) (h_precond : replace_precond (arr) (k)) :\n    replace_postcond (arr) (k) (replace (arr) (k) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_84"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem focuses on reversing an array of integers. The goal is to take an input array and produce a new array with the elements arranged in the reverse order.  \n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers, which may be empty, contain one element, or many elements.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same length as the input array.  \n• Contains the same elements as the input array, but in reverse order.  \n• For every valid index i in the input array, the output at index i is equal to the element at index (a.size - 1 - i) from the input array.\n\n-----Note-----  \nThere are no specific preconditions; the method should correctly handle any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem reverse_spec_satisfied (a: Array Int) (h_precond : reverse_precond (a)) :\n    reverse_postcond (a) (reverse (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef reverse_precond (a : Array Int) : Prop :=\n  True\n\ndef reverse_core (arr : Array Int) (i : Nat) : Array Int :=\n  if i < arr.size / 2 then\n    let j := arr.size - 1 - i\n    let temp := arr[i]!\n    let arr' := arr.set! i (arr[j]!)\n    let arr'' := arr'.set! j temp\n    reverse_core arr'' (i + 1)\n  else\n    arr\n\ndef reverse (a : Array Int) (h_precond : reverse_precond (a)) : Array Int :=\n  reverse_core a 0\n\n@[reducible, simp]\ndef reverse_postcond (a : Array Int) (result: Array Int) (h_precond : reverse_precond (a)) :=\n  (result.size = a.size) ∧ (∀ i : Nat, i < a.size → result[i]! = a[a.size - 1 - i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem reverse_spec_satisfied (a: Array Int) (h_precond : reverse_precond (a)) :\n    reverse_postcond (a) (reverse (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_85", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem focuses on reversing an array of integers. The goal is to take an input array and produce a new array with the elements arranged in the reverse order.  \n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers, which may be empty, contain one element, or many elements.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same length as the input array.  \n• Contains the same elements as the input array, but in reverse order.  \n• For every valid index i in the input array, the output at index i is equal to the element at index (a.size - 1 - i) from the input array.\n\n-----Note-----  \nThere are no specific preconditions; the method should correctly handle any array of integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem reverse_spec_satisfied (a: Array Int) (h_precond : reverse_precond (a)) :\n    reverse_postcond (a) (reverse (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef reverse_precond (a : Array Int) : Prop :=\n  True\n\ndef reverse_core (arr : Array Int) (i : Nat) : Array Int :=\n  if i < arr.size / 2 then\n    let j := arr.size - 1 - i\n    let temp := arr[i]!\n    let arr' := arr.set! i (arr[j]!)\n    let arr'' := arr'.set! j temp\n    reverse_core arr'' (i + 1)\n  else\n    arr\n\ndef reverse (a : Array Int) (h_precond : reverse_precond (a)) : Array Int :=\n  reverse_core a 0\n\n@[reducible, simp]\ndef reverse_postcond (a : Array Int) (result: Array Int) (h_precond : reverse_precond (a)) :=\n  (result.size = a.size) ∧ (∀ i : Nat, i < a.size → result[i]! = a[a.size - 1 - i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem reverse_spec_satisfied (a: Array Int) (h_precond : reverse_precond (a)) :\n    reverse_postcond (a) (reverse (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_85"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that rotates an array of integers to the left by a specified offset.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers (which may be empty or non-empty).  \n• offset: An integer representing the number of positions to rotate the array. The offset is assumed to be non-negative.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same length as the input array.  \n• For every valid index i, the output element at index i is equal to the input element at index ((i + offset) mod n), where n is the array size.\n\n-----Note-----  \nIf the array is empty, the method should return an empty array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem rotate_spec_satisfied (a: Array Int) (offset: Int) (h_precond : rotate_precond (a) (offset)) :\n    rotate_postcond (a) (offset) (rotate (a) (offset) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef rotate_precond (a : Array Int) (offset : Int) : Prop :=\n  offset ≥ 0\n\ndef rotateAux (a : Array Int) (offset : Int) (i : Nat) (len : Nat) (b : Array Int) : Array Int :=\n  if i < len then\n    let idx_int : Int := (Int.ofNat i + offset) % (Int.ofNat len)\n    let idx_int_adjusted := if idx_int < 0 then idx_int + Int.ofNat len else idx_int\n    let idx_nat : Nat := Int.toNat idx_int_adjusted\n    let new_b := b.set! i (a[idx_nat]!)\n    rotateAux a offset (i + 1) len new_b\n  else b\n\ndef rotate (a : Array Int) (offset : Int) (h_precond : rotate_precond (a) (offset)) : Array Int :=\n  let len := a.size\n  let default_val : Int := if len > 0 then a[0]! else 0\n  let b0 := Array.mkArray len default_val\n  rotateAux a offset 0 len b0\n\n@[reducible, simp]\ndef rotate_postcond (a : Array Int) (offset : Int) (result: Array Int) (h_precond : rotate_precond (a) (offset)) :=\n  result.size = a.size ∧\n  (∀ i : Nat, i < a.size →\n    result[i]! = a[Int.toNat ((Int.ofNat i + offset) % (Int.ofNat a.size))]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem rotate_spec_satisfied (a: Array Int) (offset: Int) (h_precond : rotate_precond (a) (offset)) :\n    rotate_postcond (a) (offset) (rotate (a) (offset) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_86", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires writing a Lean 4 method that rotates an array of integers to the left by a specified offset.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers (which may be empty or non-empty).  \n• offset: An integer representing the number of positions to rotate the array. The offset is assumed to be non-negative.\n\n-----Output-----  \nThe output is an array of integers that:  \n• Has the same length as the input array.  \n• For every valid index i, the output element at index i is equal to the input element at index ((i + offset) mod n), where n is the array size.\n\n-----Note-----  \nIf the array is empty, the method should return an empty array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem rotate_spec_satisfied (a: Array Int) (offset: Int) (h_precond : rotate_precond (a) (offset)) :\n    rotate_postcond (a) (offset) (rotate (a) (offset) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef rotate_precond (a : Array Int) (offset : Int) : Prop :=\n  offset ≥ 0\n\ndef rotateAux (a : Array Int) (offset : Int) (i : Nat) (len : Nat) (b : Array Int) : Array Int :=\n  if i < len then\n    let idx_int : Int := (Int.ofNat i + offset) % (Int.ofNat len)\n    let idx_int_adjusted := if idx_int < 0 then idx_int + Int.ofNat len else idx_int\n    let idx_nat : Nat := Int.toNat idx_int_adjusted\n    let new_b := b.set! i (a[idx_nat]!)\n    rotateAux a offset (i + 1) len new_b\n  else b\n\ndef rotate (a : Array Int) (offset : Int) (h_precond : rotate_precond (a) (offset)) : Array Int :=\n  let len := a.size\n  let default_val : Int := if len > 0 then a[0]! else 0\n  let b0 := Array.mkArray len default_val\n  rotateAux a offset 0 len b0\n\n@[reducible, simp]\ndef rotate_postcond (a : Array Int) (offset : Int) (result: Array Int) (h_precond : rotate_precond (a) (offset)) :=\n  result.size = a.size ∧\n  (∀ i : Nat, i < a.size →\n    result[i]! = a[Int.toNat ((Int.ofNat i + offset) % (Int.ofNat a.size))]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem rotate_spec_satisfied (a: Array Int) (offset: Int) (h_precond : rotate_precond (a) (offset)) :\n    rotate_postcond (a) (offset) (rotate (a) (offset) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_86"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers (Array Int).  \n\n-----Output-----  \nThe output is an array of integers that is:  \n• Sorted in non-decreasing order.  \n• A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.  \n\n-----Note-----  \nIt is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SelectionSort_spec_satisfied (a: Array Int) (h_precond : SelectionSort_precond (a)) :\n    SelectionSort_postcond (a) (SelectionSort (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SelectionSort_precond (a : Array Int) : Prop :=\n  True\n\ndef findMinIndexInRange (arr : Array Int) (start finish : Nat) : Nat :=\n  let indices := List.range (finish - start)\n  indices.foldl (fun minIdx i =>\n    let currIdx := start + i\n    if arr[currIdx]! < arr[minIdx]! then currIdx else minIdx\n  ) start\n\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  if i < a.size && j < a.size && i ≠ j then\n    let temp := a[i]!\n    let a' := a.set! i a[j]!\n    a'.set! j temp\n  else a\n\ndef SelectionSort (a : Array Int) (h_precond : SelectionSort_precond (a)) : Array Int :=\n  let indices := List.range a.size\n  indices.foldl (fun arr i =>\n    let minIdx := findMinIndexInRange arr i a.size\n    swap arr i minIdx\n  ) a\n\n@[reducible, simp]\ndef SelectionSort_postcond (a : Array Int) (result: Array Int) (h_precond : SelectionSort_precond (a)) :=\n  List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm a.toList result.toList\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SelectionSort_spec_satisfied (a: Array Int) (h_precond : SelectionSort_precond (a)) :\n    SelectionSort_postcond (a) (SelectionSort (a) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_87", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers (Array Int).  \n\n-----Output-----  \nThe output is an array of integers that is:  \n• Sorted in non-decreasing order.  \n• A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.  \n\n-----Note-----  \nIt is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SelectionSort_spec_satisfied (a: Array Int) (h_precond : SelectionSort_precond (a)) :\n    SelectionSort_postcond (a) (SelectionSort (a) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SelectionSort_precond (a : Array Int) : Prop :=\n  True\n\ndef findMinIndexInRange (arr : Array Int) (start finish : Nat) : Nat :=\n  let indices := List.range (finish - start)\n  indices.foldl (fun minIdx i =>\n    let currIdx := start + i\n    if arr[currIdx]! < arr[minIdx]! then currIdx else minIdx\n  ) start\n\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  if i < a.size && j < a.size && i ≠ j then\n    let temp := a[i]!\n    let a' := a.set! i a[j]!\n    a'.set! j temp\n  else a\n\ndef SelectionSort (a : Array Int) (h_precond : SelectionSort_precond (a)) : Array Int :=\n  let indices := List.range a.size\n  indices.foldl (fun arr i =>\n    let minIdx := findMinIndexInRange arr i a.size\n    swap arr i minIdx\n  ) a\n\n@[reducible, simp]\ndef SelectionSort_postcond (a : Array Int) (result: Array Int) (h_precond : SelectionSort_precond (a)) :=\n  List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm a.toList result.toList\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SelectionSort_spec_satisfied (a: Array Int) (h_precond : SelectionSort_precond (a)) :\n    SelectionSort_postcond (a) (SelectionSort (a) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_87"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves converting a list of integers into an array such that the array contains all the elements of the list in the exact same order. The objective is to ensure that the array has the same number of elements as the list and that each element in the array corresponds exactly to the element at the same position in the list.\n\n-----Input-----  \nThe input consists of:  \n• xs: A list of integer elements.  \n\n-----Output-----  \nThe output is an array of elements of type integer that:  \n• Has a size equal to the length of the input list xs.  \n• Contains all the elements from xs in the same order, ensuring that for every valid index i, the array element at i is equal to the list element at i.\n\n-----Note-----  \nThere are no additional preconditions; the method should work correctly for any list of elements.  \nA corresponding specification is provided stating that the array’s size equals the list’s length and that each element is preserved.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ToArray_spec_satisfied (xs: List Int) (h_precond : ToArray_precond (xs)) :\n    ToArray_postcond (xs) (ToArray (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef ToArray_precond (xs : List Int) : Prop :=\n  True\n\ndef ToArray (xs : List Int) (h_precond : ToArray_precond (xs)) : Array Int :=\n  xs.toArray\n\n@[reducible, simp]\ndef ToArray_postcond (xs : List Int) (result: Array Int) (h_precond : ToArray_precond (xs)) :=\n  result.size = xs.length ∧ ∀ (i : Nat), i < xs.length → result[i]! = xs[i]!\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ToArray_spec_satisfied (xs: List Int) (h_precond : ToArray_precond (xs)) :\n    ToArray_postcond (xs) (ToArray (xs) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_88", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves converting a list of integers into an array such that the array contains all the elements of the list in the exact same order. The objective is to ensure that the array has the same number of elements as the list and that each element in the array corresponds exactly to the element at the same position in the list.\n\n-----Input-----  \nThe input consists of:  \n• xs: A list of integer elements.  \n\n-----Output-----  \nThe output is an array of elements of type integer that:  \n• Has a size equal to the length of the input list xs.  \n• Contains all the elements from xs in the same order, ensuring that for every valid index i, the array element at i is equal to the list element at i.\n\n-----Note-----  \nThere are no additional preconditions; the method should work correctly for any list of elements.  \nA corresponding specification is provided stating that the array’s size equals the list’s length and that each element is preserved.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem ToArray_spec_satisfied (xs: List Int) (h_precond : ToArray_precond (xs)) :\n    ToArray_postcond (xs) (ToArray (xs) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef ToArray_precond (xs : List Int) : Prop :=\n  True\n\ndef ToArray (xs : List Int) (h_precond : ToArray_precond (xs)) : Array Int :=\n  xs.toArray\n\n@[reducible, simp]\ndef ToArray_postcond (xs : List Int) (result: Array Int) (h_precond : ToArray_precond (xs)) :=\n  result.size = xs.length ∧ ∀ (i : Nat), i < xs.length → result[i]! = xs[i]!\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem ToArray_spec_satisfied (xs: List Int) (h_precond : ToArray_precond (xs)) :\n    ToArray_postcond (xs) (ToArray (xs) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_88"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.\n\n-----Input-----  \nThe input consists of:  \n• s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.\n\n-----Output-----  \nThe output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.\n\n-----Note-----  \nNo additional preconditions are required. The method should correctly handle any list, including an empty list.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :\n    SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SetToSeq_precond (s : List Int) : Prop :=\n  True\n\ndef SetToSeq (s : List Int) (h_precond : SetToSeq_precond (s)) : List Int :=\n  s.foldl (fun acc x => if acc.contains x then acc else acc ++ [x]) []\n\n@[reducible, simp]\ndef SetToSeq_postcond (s : List Int) (result: List Int) (h_precond : SetToSeq_precond (s)) :=\n  result.all (fun a => a ∈ s) ∧ s.all (fun a => a ∈ result) ∧\n  result.all (fun a => result.count a = 1) ∧\n  List.Pairwise (fun a b => (result.idxOf a < result.idxOf b) → (s.idxOf a < s.idxOf b)) result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :\n    SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_89", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.\n\n-----Input-----  \nThe input consists of:  \n• s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.\n\n-----Output-----  \nThe output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.\n\n-----Note-----  \nNo additional preconditions are required. The method should correctly handle any list, including an empty list.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :\n    SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SetToSeq_precond (s : List Int) : Prop :=\n  True\n\ndef SetToSeq (s : List Int) (h_precond : SetToSeq_precond (s)) : List Int :=\n  s.foldl (fun acc x => if acc.contains x then acc else acc ++ [x]) []\n\n@[reducible, simp]\ndef SetToSeq_postcond (s : List Int) (result: List Int) (h_precond : SetToSeq_precond (s)) :=\n  result.all (fun a => a ∈ s) ∧ s.all (fun a => a ∈ result) ∧\n  result.all (fun a => result.count a = 1) ∧\n  List.Pairwise (fun a b => (result.idxOf a < result.idxOf b) → (s.idxOf a < s.idxOf b)) result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :\n    SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_89"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that checks whether two arrays of integers have any elements in common. In other words, the method should return true if there is at least one element that appears in both arrays, and false if no such element exists.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one common element between the two arrays.\nReturns false if there are no common elements shared by the arrays.\n\n-----Note-----\nBoth arrays are assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef hasCommonElement_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size > 0 ∧ b.size > 0\n\ndef hasCommonElement (a : Array Int) (b : Array Int) (h_precond : hasCommonElement_precond (a) (b)) : Bool :=\n  a.any fun x => b.any fun y => x = y\n\n@[reducible, simp]\ndef hasCommonElement_postcond (a : Array Int) (b : Array Int) (result: Bool) (h_precond : hasCommonElement_precond (a) (b)) :=\n  (∃ i j, i < a.size ∧ j < b.size ∧ a[i]! = b[j]!) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n  unfold hasCommonElement hasCommonElement_postcond\n  constructor\n  · intro h\n    rcases h with ⟨i, j, hi, hj, heq⟩\n    simp [Array.any_eq]\n    exists i\n    exists hi\n    exists j\n    exists hj\n    have heqa : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    have heqb : b[j]! = b[j] := by\n      exact getElem!_pos b j hj\n    rw [heqa, heqb] at heq\n    exact heq\n  · intro h\n    simp [Array.any_eq] at h\n    rcases h with ⟨i, hi, j, hj, heq⟩\n    exists i\n    exists j\n    simp [hi, hj]\n    have heqa : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    have heqb : b[j]! = b[j] := by\n      exact getElem!_pos b j hj\n    rw [heqa, heqb]\n    exact heq"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_9", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description----- \nThis task requires writing a Lean 4 method that checks whether two arrays of integers have any elements in common. In other words, the method should return true if there is at least one element that appears in both arrays, and false if no such element exists.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one common element between the two arrays.\nReturns false if there are no common elements shared by the arrays.\n\n-----Note-----\nBoth arrays are assumed to be non-null.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef hasCommonElement_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size > 0 ∧ b.size > 0\n\ndef hasCommonElement (a : Array Int) (b : Array Int) (h_precond : hasCommonElement_precond (a) (b)) : Bool :=\n  a.any fun x => b.any fun y => x = y\n\n@[reducible, simp]\ndef hasCommonElement_postcond (a : Array Int) (b : Array Int) (result: Bool) (h_precond : hasCommonElement_precond (a) (b)) :=\n  (∃ i j, i < a.size ∧ j < b.size ∧ a[i]! = b[j]!) ↔ result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n```", "ground_truth": "theorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n  unfold hasCommonElement hasCommonElement_postcond\n  constructor\n  · intro h\n    rcases h with ⟨i, j, hi, hj, heq⟩\n    simp [Array.any_eq]\n    exists i\n    exists hi\n    exists j\n    exists hj\n    have heqa : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    have heqb : b[j]! = b[j] := by\n      exact getElem!_pos b j hj\n    rw [heqa, heqb] at heq\n    exact heq\n  · intro h\n    simp [Array.any_eq] at h\n    rcases h with ⟨i, hi, j, hj, heq⟩\n    exists i\n    exists j\n    simp [hi, hj]\n    have heqa : a[i]! = a[i] := by\n      exact getElem!_pos a i hi\n    have heqb : b[j]! = b[j] := by\n      exact getElem!_pos b j hj\n    rw [heqa, heqb]\n    exact heq", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_9"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.\n\n-----Input-----  \nThe input consists of:  \n• a: A non-empty 2D array of integers (Array (Array Int)). The array is guaranteed to contain at least one element.\n• key: An integer value (Int) to search for in the array.\n\n-----Output-----  \nThe output is a pair of integers (Int × Int):  \n• If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.  \n• If the key is not found, the function returns (-1, -1).\n\n-----Note-----  \nIt is assumed that the input 2D array is sorted by rows and columns.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SlopeSearch_spec_satisfied (a: Array (Array Int)) (key: Int) (h_precond : SlopeSearch_precond (a) (key)) :\n    SlopeSearch_postcond (a) (key) (SlopeSearch (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef get2d (a : Array (Array Int)) (i j : Int) : Int :=\n  (a[Int.toNat i]!)[Int.toNat j]!\n\n@[reducible, simp]\ndef SlopeSearch_precond (a : Array (Array Int)) (key : Int) : Prop :=\n  List.Pairwise (·.size = ·.size) a.toList ∧\n  a.all (fun x => List.Pairwise (· ≤ ·) x.toList) ∧\n  (\n    a.size = 0 ∨ (\n      (List.range (a[0]!.size)).all (fun i =>\n        List.Pairwise (· ≤ ·) (a.map (fun x => x[i]!)).toList\n      )\n    )\n  )\n\ndef SlopeSearch (a : Array (Array Int)) (key : Int) (h_precond : SlopeSearch_precond (a) (key)) : (Int × Int) :=\n  let rows := a.size\n  let cols := if rows > 0 then (a[0]!).size else 0\n\n  let rec aux (m n : Int) (fuel : Nat) : (Int × Int) :=\n    if fuel = 0 then (-1, -1)\n    else if m ≥ Int.ofNat rows || n < 0 then (-1, -1)\n    else if get2d a m n = key then (m, n)\n    else if get2d a m n < key then\n      aux (m + 1) n (fuel - 1)\n    else\n      aux m (n - 1) (fuel - 1)\n\n  aux 0 (Int.ofNat (cols - 1)) (rows + cols)\n\n@[reducible, simp]\ndef SlopeSearch_postcond (a : Array (Array Int)) (key : Int) (result: (Int × Int)) (h_precond : SlopeSearch_precond (a) (key)) :=\n  let (m, n) := result;\n  (m ≥ 0 ∧ m < a.size ∧ n ≥ 0 ∧ n < (a[0]!).size ∧ get2d a m n = key) ∨\n  (m = -1 ∧ n = -1 ∧ a.all (fun x => x.all (fun e => e ≠ key)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SlopeSearch_spec_satisfied (a: Array (Array Int)) (key: Int) (h_precond : SlopeSearch_precond (a) (key)) :\n    SlopeSearch_postcond (a) (key) (SlopeSearch (a) (key) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_90", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThe task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.\n\n-----Input-----  \nThe input consists of:  \n• a: A non-empty 2D array of integers (Array (Array Int)). The array is guaranteed to contain at least one element.\n• key: An integer value (Int) to search for in the array.\n\n-----Output-----  \nThe output is a pair of integers (Int × Int):  \n• If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.  \n• If the key is not found, the function returns (-1, -1).\n\n-----Note-----  \nIt is assumed that the input 2D array is sorted by rows and columns.\n\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SlopeSearch_spec_satisfied (a: Array (Array Int)) (key: Int) (h_precond : SlopeSearch_precond (a) (key)) :\n    SlopeSearch_postcond (a) (key) (SlopeSearch (a) (key) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef get2d (a : Array (Array Int)) (i j : Int) : Int :=\n  (a[Int.toNat i]!)[Int.toNat j]!\n\n@[reducible, simp]\ndef SlopeSearch_precond (a : Array (Array Int)) (key : Int) : Prop :=\n  List.Pairwise (·.size = ·.size) a.toList ∧\n  a.all (fun x => List.Pairwise (· ≤ ·) x.toList) ∧\n  (\n    a.size = 0 ∨ (\n      (List.range (a[0]!.size)).all (fun i =>\n        List.Pairwise (· ≤ ·) (a.map (fun x => x[i]!)).toList\n      )\n    )\n  )\n\ndef SlopeSearch (a : Array (Array Int)) (key : Int) (h_precond : SlopeSearch_precond (a) (key)) : (Int × Int) :=\n  let rows := a.size\n  let cols := if rows > 0 then (a[0]!).size else 0\n\n  let rec aux (m n : Int) (fuel : Nat) : (Int × Int) :=\n    if fuel = 0 then (-1, -1)\n    else if m ≥ Int.ofNat rows || n < 0 then (-1, -1)\n    else if get2d a m n = key then (m, n)\n    else if get2d a m n < key then\n      aux (m + 1) n (fuel - 1)\n    else\n      aux m (n - 1) (fuel - 1)\n\n  aux 0 (Int.ofNat (cols - 1)) (rows + cols)\n\n@[reducible, simp]\ndef SlopeSearch_postcond (a : Array (Array Int)) (key : Int) (result: (Int × Int)) (h_precond : SlopeSearch_precond (a) (key)) :=\n  let (m, n) := result;\n  (m ≥ 0 ∧ m < a.size ∧ n ≥ 0 ∧ n < (a[0]!).size ∧ get2d a m n = key) ∨\n  (m = -1 ∧ n = -1 ∧ a.all (fun x => x.all (fun e => e ≠ key)))\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SlopeSearch_spec_satisfied (a: Array (Array Int)) (key: Int) (h_precond : SlopeSearch_precond (a) (key)) :\n    SlopeSearch_postcond (a) (key) (SlopeSearch (a) (key) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_90"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves creating a function that swaps two integer values. Given two integers, the function should return a pair where the first element is the second input value and the second element is the first input value.\n\n-----Input-----  \nThe input consists of two integers:  \n• X: An integer representing the first value.  \n• Y: An integer representing the second value.\n\n-----Output-----  \nThe output is a pair (Int × Int) that:  \n• Contains the original Y as the first element.  \n• Contains the original X as the second element.\n\n-----Note-----  \nThere are no additional preconditions. The function simply swaps the two input values.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Swap_precond (X : Int) (Y : Int) : Prop :=\n  True\n\ndef Swap (X : Int) (Y : Int) (h_precond : Swap_precond (X) (Y)) : Int × Int :=\n  let x := X\n  let y := Y\n  let tmp := x\n  let x := y\n  let y := tmp\n  (x, y)\n\n@[reducible, simp]\ndef Swap_postcond (X : Int) (Y : Int) (result: Int × Int) (h_precond : Swap_precond (X) (Y)) :=\n  result.fst = Y ∧ result.snd = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n  unfold Swap_postcond Swap\n  simp_all\n  exact fun a a_1 => a (id (Eq.symm a_1))"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_91", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves creating a function that swaps two integer values. Given two integers, the function should return a pair where the first element is the second input value and the second element is the first input value.\n\n-----Input-----  \nThe input consists of two integers:  \n• X: An integer representing the first value.  \n• Y: An integer representing the second value.\n\n-----Output-----  \nThe output is a pair (Int × Int) that:  \n• Contains the original Y as the first element.  \n• Contains the original X as the second element.\n\n-----Note-----  \nThere are no additional preconditions. The function simply swaps the two input values.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Swap_precond (X : Int) (Y : Int) : Prop :=\n  True\n\ndef Swap (X : Int) (Y : Int) (h_precond : Swap_precond (X) (Y)) : Int × Int :=\n  let x := X\n  let y := Y\n  let tmp := x\n  let x := y\n  let y := tmp\n  (x, y)\n\n@[reducible, simp]\ndef Swap_postcond (X : Int) (Y : Int) (result: Int × Int) (h_precond : Swap_precond (X) (Y)) :=\n  result.fst = Y ∧ result.snd = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n```", "ground_truth": "theorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n  unfold Swap_postcond Swap\n  simp_all\n  exact fun a a_1 => a (id (Eq.symm a_1))", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_91"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves swapping the values of two integers. Given two integers as inputs, the objective is to return the two numbers in reversed order.\n\n-----Input-----  \nThe input consists of two integers:  \n• X: The first integer.  \n• Y: The second integer.\n\n-----Output-----  \nThe output is a tuple of two integers (Int × Int) where:  \n• The first element is equal to Y.  \n• The second element is equal to X.\n\n-----Note-----  \nThere are no restrictions on the input values. The function must correctly swap the inputs regardless of whether they are positive, negative, or zero.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SwapArithmetic_precond (X : Int) (Y : Int) : Prop :=\n  True\n\ndef SwapArithmetic (X : Int) (Y : Int) (h_precond : SwapArithmetic_precond (X) (Y)) : (Int × Int) :=\n  let x1 := X\n  let y1 := Y\n  let x2 := y1 - x1\n  let y2 := y1 - x2\n  let x3 := y2 + x2\n  (x3, y2)\n\n@[reducible, simp]\ndef SwapArithmetic_postcond (X : Int) (Y : Int) (result: (Int × Int)) (h_precond : SwapArithmetic_precond (X) (Y)) :=\n  result.1 = Y ∧ result.2 = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n  unfold SwapArithmetic_postcond SwapArithmetic\n  simp\n  rw [Int.sub_sub_self]\n  simp_all\n  exact fun a a_1 => a (id (Eq.symm a_1))"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_92", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves swapping the values of two integers. Given two integers as inputs, the objective is to return the two numbers in reversed order.\n\n-----Input-----  \nThe input consists of two integers:  \n• X: The first integer.  \n• Y: The second integer.\n\n-----Output-----  \nThe output is a tuple of two integers (Int × Int) where:  \n• The first element is equal to Y.  \n• The second element is equal to X.\n\n-----Note-----  \nThere are no restrictions on the input values. The function must correctly swap the inputs regardless of whether they are positive, negative, or zero.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SwapArithmetic_precond (X : Int) (Y : Int) : Prop :=\n  True\n\ndef SwapArithmetic (X : Int) (Y : Int) (h_precond : SwapArithmetic_precond (X) (Y)) : (Int × Int) :=\n  let x1 := X\n  let y1 := Y\n  let x2 := y1 - x1\n  let y2 := y1 - x2\n  let x3 := y2 + x2\n  (x3, y2)\n\n@[reducible, simp]\ndef SwapArithmetic_postcond (X : Int) (Y : Int) (result: (Int × Int)) (h_precond : SwapArithmetic_precond (X) (Y)) :=\n  result.1 = Y ∧ result.2 = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n```", "ground_truth": "theorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n  unfold SwapArithmetic_postcond SwapArithmetic\n  simp\n  rw [Int.sub_sub_self]\n  simp_all\n  exact fun a a_1 => a (id (Eq.symm a_1))", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_92"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.\n\n-----Input-----  \nThe input consists of:  \n• X: A UInt8 value.  \n• Y: A UInt8 value.\n\n-----Output-----  \nThe output is a pair of UInt8 values (newX, newY) where:  \n• newX is equal to the original Y.  \n• newY is equal to the original X.\n\n-----Note-----  \nThere are no additional preconditions; the function is meant to work correctly for any pair of UInt8 values by leveraging bitwise xor operations.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SwapBitvectors_spec_satisfied (X: UInt8) (Y: UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :\n    SwapBitvectors_postcond (X) (Y) (SwapBitvectors (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SwapBitvectors_precond (X : UInt8) (Y : UInt8) : Prop :=\n  True\n\ndef SwapBitvectors (X : UInt8) (Y : UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) : UInt8 × UInt8 :=\n  let temp := X.xor Y\n  let newY := temp.xor Y\n  let newX := temp.xor newY\n  (newX, newY)\n\n@[reducible, simp]\ndef SwapBitvectors_postcond (X : UInt8) (Y : UInt8) (result: UInt8 × UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :=\n  result.fst = Y ∧ result.snd = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SwapBitvectors_spec_satisfied (X: UInt8) (Y: UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :\n    SwapBitvectors_postcond (X) (Y) (SwapBitvectors (X) (Y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_93", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.\n\n-----Input-----  \nThe input consists of:  \n• X: A UInt8 value.  \n• Y: A UInt8 value.\n\n-----Output-----  \nThe output is a pair of UInt8 values (newX, newY) where:  \n• newX is equal to the original Y.  \n• newY is equal to the original X.\n\n-----Note-----  \nThere are no additional preconditions; the function is meant to work correctly for any pair of UInt8 values by leveraging bitwise xor operations.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SwapBitvectors_spec_satisfied (X: UInt8) (Y: UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :\n    SwapBitvectors_postcond (X) (Y) (SwapBitvectors (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SwapBitvectors_precond (X : UInt8) (Y : UInt8) : Prop :=\n  True\n\ndef SwapBitvectors (X : UInt8) (Y : UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) : UInt8 × UInt8 :=\n  let temp := X.xor Y\n  let newY := temp.xor Y\n  let newX := temp.xor newY\n  (newX, newY)\n\n@[reducible, simp]\ndef SwapBitvectors_postcond (X : UInt8) (Y : UInt8) (result: UInt8 × UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :=\n  result.fst = Y ∧ result.snd = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SwapBitvectors_spec_satisfied (X: UInt8) (Y: UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :\n    SwapBitvectors_postcond (X) (Y) (SwapBitvectors (X) (Y) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_93"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.\n\n-----Input-----\nThe input consists of:\n• s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).\n\n-----Output-----\nThe output is an array of the same type as the input:\n• The output array has the same size as the input array.\n• Each element in the output array is identical to the corresponding element in the input array.\n\n-----Note-----\nThere are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem iter_copy_spec_satisfied (s: Array Int) (h_precond : iter_copy_precond (s)) :\n    iter_copy_postcond (s) (iter_copy (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef iter_copy_precond (s : Array Int) : Prop :=\n  True\n\ndef iter_copy (s : Array Int) (h_precond : iter_copy_precond (s)) : Array Int :=\n  let rec loop (i : Nat) (acc : Array Int) : Array Int :=\n    if i < s.size then\n      match s[i]? with\n      | some val => loop (i + 1) (acc.push val)\n      | none => acc  -- This case shouldn't happen when i < s.size\n    else\n      acc\n  loop 0 Array.empty\n\n@[reducible, simp]\ndef iter_copy_postcond (s : Array Int) (result: Array Int) (h_precond : iter_copy_precond (s)) :=\n  (s.size = result.size) ∧ (∀ i : Nat, i < s.size → s[i]! = result[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem iter_copy_spec_satisfied (s: Array Int) (h_precond : iter_copy_precond (s)) :\n    iter_copy_postcond (s) (iter_copy (s) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": null}, "extra_info": {"language": "Lean", "example_name": "verina_basic_94", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.\n\n-----Input-----\nThe input consists of:\n• s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).\n\n-----Output-----\nThe output is an array of the same type as the input:\n• The output array has the same size as the input array.\n• Each element in the output array is identical to the corresponding element in the input array.\n\n-----Note-----\nThere are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem iter_copy_spec_satisfied (s: Array Int) (h_precond : iter_copy_precond (s)) :\n    iter_copy_postcond (s) (iter_copy (s) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef iter_copy_precond (s : Array Int) : Prop :=\n  True\n\ndef iter_copy (s : Array Int) (h_precond : iter_copy_precond (s)) : Array Int :=\n  let rec loop (i : Nat) (acc : Array Int) : Array Int :=\n    if i < s.size then\n      match s[i]? with\n      | some val => loop (i + 1) (acc.push val)\n      | none => acc  -- This case shouldn't happen when i < s.size\n    else\n      acc\n  loop 0 Array.empty\n\n@[reducible, simp]\ndef iter_copy_postcond (s : Array Int) (result: Array Int) (h_precond : iter_copy_precond (s)) :=\n  (s.size = result.size) ∧ (∀ i : Nat, i < s.size → s[i]! = result[i]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem iter_copy_spec_satisfied (s: Array Int) (h_precond : iter_copy_precond (s)) :\n    iter_copy_postcond (s) (iter_copy (s) h_precond) h_precond := by\n```", "ground_truth": null, "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_94"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of integers.  \n• i: An integer representing the first index (0-indexed) whose element is to be swapped.  \n• j: An integer representing the second index (0-indexed) whose element is to be swapped.\n\n-----Output-----  \nThe output is an array of integers which:  \n• Has the same size as the input array.  \n• Contains the element originally at index i in position j and the element originally at index j in position i.  \n• Leaves all other elements unchanged.\n\n-----Note-----  \nIt is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., Int.toNat i and Int.toNat j are less than arr.size).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef swap_precond (arr : Array Int) (i : Int) (j : Int) : Prop :=\n  i ≥ 0 ∧\n  j ≥ 0 ∧\n  Int.toNat i < arr.size ∧\n  Int.toNat j < arr.size\n\ndef swap (arr : Array Int) (i : Int) (j : Int) (h_precond : swap_precond (arr) (i) (j)) : Array Int :=\n  let i_nat := Int.toNat i\n  let j_nat := Int.toNat j\n  let arr1 := arr.set! i_nat (arr[j_nat]!)\n  let arr2 := arr1.set! j_nat (arr[i_nat]!)\n  arr2\n\n@[reducible, simp]\ndef swap_postcond (arr : Array Int) (i : Int) (j : Int) (result: Array Int) (h_precond : swap_precond (arr) (i) (j)) :=\n  (result[Int.toNat i]! = arr[Int.toNat j]!) ∧\n  (result[Int.toNat j]! = arr[Int.toNat i]!) ∧\n  (∀ (k : Nat), k < arr.size → k ≠ Int.toNat i → k ≠ Int.toNat j → result[k]! = arr[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n  unfold swap_postcond swap\n  unfold swap_precond at h_precond\n  obtain ⟨h₁, h₂, h₃, h₄⟩ := h_precond\n\n  apply And.intro\n  . simp\n    by_cases h_eq : (i = j)\n    . rw [h_eq]\n      rw [Array.getElem!_eq_getD]\n      rw [Array.setIfInBounds]\n      simp [h₄]\n    . rw [Array.setIfInBounds_comm]\n      let arr₁ := arr.setIfInBounds j.toNat arr[i.toNat]!\n      have ha₁ : arr₁ = arr.setIfInBounds j.toNat arr[i.toNat]! := rfl\n      let arr_j := arr[j.toNat]!\n      have hi : arr_j = arr[j.toNat]! := rfl\n      rw [←ha₁, ←hi]\n      have h₃' : i.toNat < (arr₁.setIfInBounds i.toNat arr_j).size := by\n        rw [ha₁]\n        unfold Array.setIfInBounds\n        split\n        . simp\n          split\n          . simp\n            exact h₃\n          . simp\n            exact h₃\n        . split\n          . simp\n            exact h₃\n          . simp\n            exact h₃\n      rw [Array.getElem!_eq_getD]\n      unfold Array.getD\n      split\n      . simp\n      . simp\n      intro h\n      have h_contr : i = j := by\n        rw [← Int.toNat_of_nonneg h₁, ← Int.toNat_of_nonneg h₂]\n        rw [h]\n      contradiction\n  . apply And.intro\n    . simp\n      by_cases h_eq : (i = j)\n      . rw [h_eq]\n        rw [Array.getElem!_eq_getD]\n        rw [Array.setIfInBounds]\n        simp [h₄]\n      . let arr₁ := arr.setIfInBounds i.toNat arr[j.toNat]!\n        have ha₁ : arr₁ = arr.setIfInBounds i.toNat arr[j.toNat]! := rfl\n        let arr_i := arr[i.toNat]!\n        have hi : arr_i = arr[i.toNat]! := rfl\n        rw [←ha₁, ←hi]\n        have h₃' : j.toNat < (arr₁.setIfInBounds j.toNat arr_i).size := by\n          rw [ha₁]\n          unfold Array.setIfInBounds\n          split\n          . simp\n            split\n            . simp\n              exact h₄\n            . simp\n              exact h₄\n          . split\n            . simp\n              exact h₄\n            . simp\n              exact h₄\n        rw [Array.getElem!_eq_getD]\n        unfold Array.getD\n        split\n        . simp\n        . rename_i h\n          contradiction\n    . simp\n      intro k hk hki hkj\n      let arr₁ := (arr.setIfInBounds i.toNat arr[j.toNat]!)\n      let harr₁ : arr₁ = (arr.setIfInBounds i.toNat arr[j.toNat]!) := rfl\n      rw [←harr₁]\n      have h₁ : arr₁[k]! = arr[k]! := by\n        rw [Array.getElem!_eq_getD]\n        rw [Array.getD]\n        simp\n        split\n        . rw [Array.getElem_setIfInBounds_ne arr arr[j.toNat]! hk]\n          rw [Array.getElem!_eq_getD]\n          rw [Array.getD]\n          simp\n          split\n          . rfl\n          . rfl\n          apply ne_comm.mp\n          exact hki\n        . rename_i h_contr\n          rw [harr₁] at h_contr\n          simp only [Array.size_setIfInBounds] at h_contr\n          contradiction\n      rw [Array.getElem!_eq_getD]\n      rw [Array.getD]\n      simp\n      split\n      . rw [Array.getElem_setIfInBounds_ne arr₁ arr[i.toNat]!]\n        rw [←h₁]\n        rw [Array.getElem!_eq_getD]\n        rw [Array.getD]\n        simp\n        split\n        . simp\n        . simp\n        rename_i h\n        exact h\n        rw [ne_comm]\n        exact hkj\n      . rename_i h_contr\n        have h : arr.size = arr₁.size := by\n          rw [harr₁]\n          simp\n        rw [←h] at h_contr\n        contradiction"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_95", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n• arr: An array of integers.  \n• i: An integer representing the first index (0-indexed) whose element is to be swapped.  \n• j: An integer representing the second index (0-indexed) whose element is to be swapped.\n\n-----Output-----  \nThe output is an array of integers which:  \n• Has the same size as the input array.  \n• Contains the element originally at index i in position j and the element originally at index j in position i.  \n• Leaves all other elements unchanged.\n\n-----Note-----  \nIt is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., Int.toNat i and Int.toNat j are less than arr.size).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef swap_precond (arr : Array Int) (i : Int) (j : Int) : Prop :=\n  i ≥ 0 ∧\n  j ≥ 0 ∧\n  Int.toNat i < arr.size ∧\n  Int.toNat j < arr.size\n\ndef swap (arr : Array Int) (i : Int) (j : Int) (h_precond : swap_precond (arr) (i) (j)) : Array Int :=\n  let i_nat := Int.toNat i\n  let j_nat := Int.toNat j\n  let arr1 := arr.set! i_nat (arr[j_nat]!)\n  let arr2 := arr1.set! j_nat (arr[i_nat]!)\n  arr2\n\n@[reducible, simp]\ndef swap_postcond (arr : Array Int) (i : Int) (j : Int) (result: Array Int) (h_precond : swap_precond (arr) (i) (j)) :=\n  (result[Int.toNat i]! = arr[Int.toNat j]!) ∧\n  (result[Int.toNat j]! = arr[Int.toNat i]!) ∧\n  (∀ (k : Nat), k < arr.size → k ≠ Int.toNat i → k ≠ Int.toNat j → result[k]! = arr[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n```", "ground_truth": "theorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n  unfold swap_postcond swap\n  unfold swap_precond at h_precond\n  obtain ⟨h₁, h₂, h₃, h₄⟩ := h_precond\n\n  apply And.intro\n  . simp\n    by_cases h_eq : (i = j)\n    . rw [h_eq]\n      rw [Array.getElem!_eq_getD]\n      rw [Array.setIfInBounds]\n      simp [h₄]\n    . rw [Array.setIfInBounds_comm]\n      let arr₁ := arr.setIfInBounds j.toNat arr[i.toNat]!\n      have ha₁ : arr₁ = arr.setIfInBounds j.toNat arr[i.toNat]! := rfl\n      let arr_j := arr[j.toNat]!\n      have hi : arr_j = arr[j.toNat]! := rfl\n      rw [←ha₁, ←hi]\n      have h₃' : i.toNat < (arr₁.setIfInBounds i.toNat arr_j).size := by\n        rw [ha₁]\n        unfold Array.setIfInBounds\n        split\n        . simp\n          split\n          . simp\n            exact h₃\n          . simp\n            exact h₃\n        . split\n          . simp\n            exact h₃\n          . simp\n            exact h₃\n      rw [Array.getElem!_eq_getD]\n      unfold Array.getD\n      split\n      . simp\n      . simp\n      intro h\n      have h_contr : i = j := by\n        rw [← Int.toNat_of_nonneg h₁, ← Int.toNat_of_nonneg h₂]\n        rw [h]\n      contradiction\n  . apply And.intro\n    . simp\n      by_cases h_eq : (i = j)\n      . rw [h_eq]\n        rw [Array.getElem!_eq_getD]\n        rw [Array.setIfInBounds]\n        simp [h₄]\n      . let arr₁ := arr.setIfInBounds i.toNat arr[j.toNat]!\n        have ha₁ : arr₁ = arr.setIfInBounds i.toNat arr[j.toNat]! := rfl\n        let arr_i := arr[i.toNat]!\n        have hi : arr_i = arr[i.toNat]! := rfl\n        rw [←ha₁, ←hi]\n        have h₃' : j.toNat < (arr₁.setIfInBounds j.toNat arr_i).size := by\n          rw [ha₁]\n          unfold Array.setIfInBounds\n          split\n          . simp\n            split\n            . simp\n              exact h₄\n            . simp\n              exact h₄\n          . split\n            . simp\n              exact h₄\n            . simp\n              exact h₄\n        rw [Array.getElem!_eq_getD]\n        unfold Array.getD\n        split\n        . simp\n        . rename_i h\n          contradiction\n    . simp\n      intro k hk hki hkj\n      let arr₁ := (arr.setIfInBounds i.toNat arr[j.toNat]!)\n      let harr₁ : arr₁ = (arr.setIfInBounds i.toNat arr[j.toNat]!) := rfl\n      rw [←harr₁]\n      have h₁ : arr₁[k]! = arr[k]! := by\n        rw [Array.getElem!_eq_getD]\n        rw [Array.getD]\n        simp\n        split\n        . rw [Array.getElem_setIfInBounds_ne arr arr[j.toNat]! hk]\n          rw [Array.getElem!_eq_getD]\n          rw [Array.getD]\n          simp\n          split\n          . rfl\n          . rfl\n          apply ne_comm.mp\n          exact hki\n        . rename_i h_contr\n          rw [harr₁] at h_contr\n          simp only [Array.size_setIfInBounds] at h_contr\n          contradiction\n      rw [Array.getElem!_eq_getD]\n      rw [Array.getD]\n      simp\n      split\n      . rw [Array.getElem_setIfInBounds_ne arr₁ arr[i.toNat]!]\n        rw [←h₁]\n        rw [Array.getElem!_eq_getD]\n        rw [Array.getD]\n        simp\n        split\n        . simp\n        . simp\n        rename_i h\n        exact h\n        rw [ne_comm]\n        exact hkj\n      . rename_i h_contr\n        have h : arr.size = arr₁.size := by\n          rw [harr₁]\n          simp\n        rw [←h] at h_contr\n        contradiction", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_95"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires swapping two integer values. Given two integers as input, the objective is to produce an output where their order is reversed: the first element of the output corresponds to the second input and the second element corresponds to the first input.\n\n-----Input-----  \nThe input consists of two integers:  \n• X: An integer value.  \n• Y: Another integer value.\n\n-----Output-----  \nThe output is a tuple (Int × Int) where:  \n• The first element is equal to Y.  \n• The second element is equal to X.\n\n-----Note-----  \nThere are no additional preconditions for this task. The function simply returns a swapped tuple of its two input integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SwapSimultaneous_precond (X : Int) (Y : Int) : Prop :=\n  True\n\ndef SwapSimultaneous (X : Int) (Y : Int) (h_precond : SwapSimultaneous_precond (X) (Y)) : Int × Int :=\n  (Y, X)\n\n@[reducible, simp]\ndef SwapSimultaneous_postcond (X : Int) (Y : Int) (result: Int × Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :=\n  result.1 = Y ∧ result.2 = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n  unfold SwapSimultaneous_postcond SwapSimultaneous\n  simp_all\n  exact fun a a_1 => a (id (Eq.symm a_1))"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_96", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires swapping two integer values. Given two integers as input, the objective is to produce an output where their order is reversed: the first element of the output corresponds to the second input and the second element corresponds to the first input.\n\n-----Input-----  \nThe input consists of two integers:  \n• X: An integer value.  \n• Y: Another integer value.\n\n-----Output-----  \nThe output is a tuple (Int × Int) where:  \n• The first element is equal to Y.  \n• The second element is equal to X.\n\n-----Note-----  \nThere are no additional preconditions for this task. The function simply returns a swapped tuple of its two input integers.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef SwapSimultaneous_precond (X : Int) (Y : Int) : Prop :=\n  True\n\ndef SwapSimultaneous (X : Int) (Y : Int) (h_precond : SwapSimultaneous_precond (X) (Y)) : Int × Int :=\n  (Y, X)\n\n@[reducible, simp]\ndef SwapSimultaneous_postcond (X : Int) (Y : Int) (result: Int × Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :=\n  result.1 = Y ∧ result.2 = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n```", "ground_truth": "theorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n  unfold SwapSimultaneous_postcond SwapSimultaneous\n  simp_all\n  exact fun a a_1 => a (id (Eq.symm a_1))", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_96"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves updating an array of integers such that the element at a specified index is set to 60 while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• j: A natural number representing the index (0-indexed) to update. It is assumed that j is a valid index (j < a.size).\n\n-----Output-----  \nThe output is an array of integers where:  \n• The element at index j is set to 60.  \n• All other elements remain the same as in the input array.\n\n-----Note-----  \nIt is assumed that j is a valid index (0 ≤ j < a.size).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef TestArrayElements_precond (a : Array Int) (j : Nat) : Prop :=\n  j < a.size\n\ndef TestArrayElements (a : Array Int) (j : Nat) (h_precond : TestArrayElements_precond (a) (j)) : Array Int :=\n  a.set! j 60\n\n@[reducible, simp]\ndef TestArrayElements_postcond (a : Array Int) (j : Nat) (result: Array Int) (h_precond : TestArrayElements_precond (a) (j)) :=\n  (result[j]! = 60) ∧ (∀ k, k < a.size → k ≠ j → result[k]! = a[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n  unfold TestArrayElements_postcond TestArrayElements\n  unfold TestArrayElements_precond at h_precond\n  apply And.intro\n  . rw [Array.getElem!_eq_getD, Array.getD]\n    simp\n    exact h_precond\n  . intro k\n    intro hk hxk\n    simp [Array.getElem!_eq_getD, Array.getD]\n    split\n    . rw [Array.getElem_setIfInBounds]\n      split\n      . rename_i h h₁\n        rw [eq_comm] at h₁\n        contradiction\n      . rfl\n    . rw [Array.getElem_setIfInBounds]\n      split\n      . rename_i h h₁\n        rw [eq_comm] at h₁\n        contradiction\n      . rfl"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_97", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task involves updating an array of integers such that the element at a specified index is set to 60 while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n• a: An array of integers.  \n• j: A natural number representing the index (0-indexed) to update. It is assumed that j is a valid index (j < a.size).\n\n-----Output-----  \nThe output is an array of integers where:  \n• The element at index j is set to 60.  \n• All other elements remain the same as in the input array.\n\n-----Note-----  \nIt is assumed that j is a valid index (0 ≤ j < a.size).\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef TestArrayElements_precond (a : Array Int) (j : Nat) : Prop :=\n  j < a.size\n\ndef TestArrayElements (a : Array Int) (j : Nat) (h_precond : TestArrayElements_precond (a) (j)) : Array Int :=\n  a.set! j 60\n\n@[reducible, simp]\ndef TestArrayElements_postcond (a : Array Int) (j : Nat) (result: Array Int) (h_precond : TestArrayElements_precond (a) (j)) :=\n  (result[j]! = 60) ∧ (∀ k, k < a.size → k ≠ j → result[k]! = a[k]!)\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n```", "ground_truth": "theorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n  unfold TestArrayElements_postcond TestArrayElements\n  unfold TestArrayElements_precond at h_precond\n  apply And.intro\n  . rw [Array.getElem!_eq_getD, Array.getD]\n    simp\n    exact h_precond\n  . intro k\n    intro hk hxk\n    simp [Array.getElem!_eq_getD, Array.getD]\n    split\n    . rw [Array.getElem_setIfInBounds]\n      split\n      . rename_i h h₁\n        rw [eq_comm] at h₁\n        contradiction\n      . rfl\n    . rw [Array.getElem_setIfInBounds]\n      split\n      . rename_i h h₁\n        rw [eq_comm] at h₁\n        contradiction\n      . rfl", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_97"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves computing three times a given integer. Given an integer, the goal is to produce a value that is exactly three times its value.\n\n-----Input-----\nThe input consists of a single integer:\nx: An integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the input integer and 3.\n\n-----Note-----\nThere are no additional preconditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  x * 3\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  simp +arith"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_98", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----\nThis task involves computing three times a given integer. Given an integer, the goal is to produce a value that is exactly three times its value.\n\n-----Input-----\nThe input consists of a single integer:\nx: An integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the input integer and 3.\n\n-----Note-----\nThere are no additional preconditions.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\n\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  x * 3\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  simp +arith", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_98"}}}}
{"data_source": "Verina", "prompt": [{"role": "user", "content": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires computing three times the given integer. The goal is to determine the product of the input integer and 3.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is an integer that represents three times the input value.\n\n-----Note-----  \nThe implementation uses two different branches based on the value of x (i.e., x < 18 or x ≥ 18), but both branches guarantee that the result equals 3*x.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  if x < 18 then\n    let a := 2 * x\n    let b := 4 * x\n    (a + b) / 2\n  else\n    let y := 2 * x\n    x + y\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```"}], "ability": "programming", "reward_model": {"style": "execution", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  simp\n  split_ifs with h₁\n  . rw [←Int.add_mul]\n    simp\n    have h : (6: ℤ) = 3 * 2 := by simp\n    rw [h, Int.mul_comm, Int.mul_ediv_assoc, Int.mul_ediv_assoc]\n    simp\n    rw [Int.mul_comm]\n    rfl\n    simp\n  . rw (occs := [1]) [←Int.one_mul x]\n    rw [←Int.add_mul]\n    simp +arith"}, "extra_info": {"language": "Lean", "example_name": "verina_basic_99", "prompt": "I need to solve the following task in Lean 4: \n```\n-----Description-----  \nThis task requires computing three times the given integer. The goal is to determine the product of the input integer and 3.\n\n-----Input-----  \nThe input consists of:  \n• x: An integer.\n\n-----Output-----  \nThe output is an integer that represents three times the input value.\n\n-----Note-----  \nThe implementation uses two different branches based on the value of x (i.e., x < 18 or x ≥ 18), but both branches guarantee that the result equals 3*x.\n```\n#####\n\n More formally, I need to prove the following theorem in Lean 4: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```\n#####\n\nThe file context in which I'm writing the proof is \n```\nimport Mathlib\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True\n\ndef Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  if x < 18 then\n    let a := 2 * x\n    let b := 4 * x\n    (a + b) / 2\n  else\n    let y := 2 * x\n    x + y\n\n@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\n\n```\n#####\n\nI need ALL code to be in Lean 4. I cannot have ANY code written in Lean 3 whatsoever. DO NOT use Lean 3 syntax or features. Start your proof with: \n```\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n```", "ground_truth": "theorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  unfold Triple_postcond Triple\n  simp\n  split_ifs with h₁\n  . rw [←Int.add_mul]\n    simp\n    have h : (6: ℤ) = 3 * 2 := by simp\n    rw [h, Int.mul_comm, Int.mul_ediv_assoc, Int.mul_ediv_assoc]\n    simp\n    rw [Int.mul_comm]\n    rfl\n    simp\n  . rw (occs := [1]) [←Int.one_mul x]\n    rw [←Int.add_mul]\n    simp +arith", "need_tools_kwargs": true, "tools_kwargs": {"tools/execute_fstar": {"example_name": "verina_basic_99"}}}}
